[{"path":"index.html","id":"üdvözöljük","chapter":"Üdvözöljük","heading":"Üdvözöljük","text":"Ez honlap az Adatkezelés és egyváltozós elemzések c. könyv elektronikus változatát mutatja . nyomtatásban megjelent könyvhöz képest számos bővítést tartalmaz:függelék fejezetei, például kitűzött feladatok megoldásai itt jelennek meg,az R grafikus lehetőségeit tartalmazó fejezet bővebb hagyományos grafika résszel.teljes könyv, az adatbázisok és az R kódok megtalálhatók következő címen.könyvet Máth János lektorálta, és Friss Kinga illusztrálta.","code":""},{"path":"eloszo.html","id":"eloszo","chapter":"Előszó","heading":"Előszó","text":"Kedves Olvasó!Köszönjük, hogy bizalmat szavaz könyvünknek, és az R megismeréséhez ezt az utat választja. Az első lépésektől komplett adatelemzési feladatok megoldásáig vezetjük az Olvasót, és főként kezdő vagy újrakezdő felhasználókhoz szólunk. Utunk során áttekintjük az adatfeldolgozás minden lépését: az adatok beolvasását, előkészítését, elemzését és az eredmények publikálását .Könyvünk összesen 11 fejezetet tartalmaz. Az egyes fejezeteket alkotó alfejezeteket három különböző ikon egyikével jelöltük meg, amelyek jelzőtáblaként szolgálnak az R megismerésének útján. Az egyes ikonok jelentése következő:\nEgy hegy. Az így jelölt fejezet az R alaptudás része, megismerése feltétlenül javasolt. könyvben megfogalmazott célok ezen fejezetek megismerésével elérhetők, azaz komplett adatelemzéseket hajthatunk végre csupán ezek végig olvasásával .\n\nKét hegy. Kiegészítő tudást tartalmazó fejezetek. Újabb eszközök megismerését teszik lehetővé, és/vagy hozzájárulnak az egy hegy fejezetek mélyebb megértéséhez.\n\nHárom hegy. Az R ismeretek további részletezése, meglévő eszközök finomabb kezelése, vagy további beállítási lehetőségek olvashatók ezekben fejezetekben. Elképzelhető, hogy ritkábban felmerülő problémák megoldásához kapunk itt segítséget.\nfejezetek hármas tagolása azt célt szolgálja, hogy minél hamarabb örömet és sikert okozhasson az R használata, ugyanakkor további olvasással részletesebb ismeretek utáni vágyunkat kielégíthessük. Könyvünk olvasását tehát az 1. fejezet egy hegy alfejezetével (1.1 Elindulás) érdemes kezdeni, ott kapunk ajánlást folytatásra. további fejezetek olvasási sorrendje teljes mértékben az elvégzendő feladattól, tudásunktól és kíváncsiságunktól függ.fejezetek végén összefoglaljuk tanultakat. Megismételjük legfontosabb fogalmakat és felsoroljuk megismert függvényeket.\nÖsszefoglalás. Miről szólt az előszó? könyv 11 fejezetet tartalmaz, az alfejezeteket három különböző ikon egyikével jelöltük: egy hegy, két hegy vagy három hegy.\nAz R tanulmányozása kitartást és némi időt igényel. Nagyon fontos szerepet kap gyakorlás, ezért minden fejezet végén találunk feladatokat.\nFeladatok. fejezet végi feladatok megoldásával jelentősen hozzájárulunk magabiztos R tudás megszerzéséhez. Találunk szórakoztató és érdekes feladatokat .\nÖrömmel fogadjuk Olvasóink észrevételeit az abari.kalman@gmail.com címen.","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik","chapter":"1 Itt kezdődik","heading":"1 Itt kezdődik","text":"","code":""},{"path":"itt-kezdodik.html","id":"Itt-kezdodik-1-szint","chapter":"1 Itt kezdődik","heading":"1.1 Elindulás","text":"\nEbben fejezetben:\n\nbemutatunk egy konkrét adatelemzési példát,\n\náttekintjük könyv tartalmát,\n\nlehetőséget adunk az előzetes R ismeretek felmérésére,\n\nés segítünk megfelelő fejezet kiválasztására folytatáshoz.\nKönyvünk elsődleges célja az R bemutatása kezdő felhasználók számára, de minden bizonnyal azok találni fognak hasznos részeket, akik már rendelkeznek R ismeretekkel. Bevezetést nyújtunk az R által lefedett három nagy terület mindegyikébe: az adatkezelésbe, grafikus megjelenítésbe és az adatelemzésbe . leírtak megértéséhez statisztikai alapismereteken túl semmilyen előzetes tudás nem szükséges.egy konkrét adatelemzési példa segítségével bemutatjuk, hogy mit nyújt e könyv az Olvasó számára. bevezető példa megoldása során az előismeretekkel rendelkező Olvasó saját R tudását felmérheti, és ezzel egyben segítséget kaphat tudásához és céljaihoz legjobban illeszkedő fejezet kiválasztására, amellyel tovább folytathatja az olvasást.Bevezető példa: Két tanítási módszer összehasonlítása\nEgy 2020-kutatásunkban (Csapó, Csernoch, Abari 2020) 7. osztályos tanulóknak Excel ismereteket oktattunk két különböző megközelítésben. Az egyik csoportban hagyományos, míg másikban modern (Sprego) tanítási módszert használtunk. tanulási időszak az Excel ismeretek felmérésével zárult. Az összegyűjtött adatok az excel_2020.xlsx állományban állnak rendelkezésre.\nNézzük az adatelemzés lépéseit és egyben könyvünk felépítését!2. fejezet: Mi az R?\nbevezető példa megoldását R-ben fogjuk elvégezni (és nem más eszközben, mint például az SPSS, jamovi, JASP, SAS stb.). Érdemes tehát ismerni az R céljait és lehetőségeit, jó ha van egy összképünk használt statisztikai programcsomagról. Ezt az áttekintést nyújtja 2 fejezet.3. fejezet: Az R telepítése.\nAz adatelemzés konkrét lépéseinek elvégzéséhez telepített Alap R és RStudio szükséges. Ha ezek nem állnak rendelkezésre, vagy még nem találkoztunk ezekkel az eszközökkel, akkor 3. fejezet nekünk szól.4. fejezet: Munka az R-ben.\nAz adatelemzés végrehajtásához az RStudio-t ajánljuk, és azon belül pedig projektek használatát szorgalmazzuk. 4. fejezetben megismerjük az RStudio legalapvetőbb funkcióit, parancsállományok létrehozását és futtatását.fenti előzmények után elkezdhetjük bevezető példa megoldását:indítsuk el az RStudio-t,hozzunk létre egy új projektet,hozzunk létre egy új RMarkdown állományt,helyezzük el lentebb szereplő R parancsokat az RMarkdown állomány egyes csonkjaiban.5. fejezet: Az R nyelv.\nAz R parancsok létrehozásának vannak szabályai, amelyeket munka során kell tartanunk. Ismernünk kell jó néhány függvényt, és általában el kell tudnunk igazodni az R nyelvben. Az 5. fejezet ezért kulcsfontosságú, tanulmányozzuk alaposan, és lehetőleg minden kitűzött feladatát oldjuk meg.6. fejezet: Beolvasás\nAz adatelemzés első lépése az adatállomány beolvasása. Adataink változatos formában állhatnak rendelkezésre, 6. fejezetben ezek beolvasására kapunk receptet.bevezető példa megoldásához az RMarkdown állomány egyik csonkját bővítsük lenti sorokkal.7. fejezet: Adatkezelés\nstatisztikai elemzés elkezdése előtt számos adatkezelési tevékenységre lehet szükség. Ezt sokszor rendkívül időigényes folyamatot 7. fejezetben részletezzük.bevezető példa megoldásához az RMarkdown állomány egyik csonkját bővítsük lenti sorokkal. Az adatkezelés legtöbbször beolvasott állomány jellemzőinek lekérésével kezdődik.karakteres vagy numerikus vektorok faktorrá konvertálása az egyik leggyakoribb előkészítő parancs.táblázatok és ábrák megfelelő megjelenéséhez, végezzük el faktorszintek sorrendbe állítását.8. fejezet: Mutatók és táblázatok.\nHa az adatainkat már megfelelő formába hoztuk, akkor továbbléphetünk az elemzés felé. 8. fejezet leíró statisztikai elemzésekből mutatók és táblázatok létrehozását mutatja .felmérés eredményeinek statisztikai mutatóit íratjuk ki két tanítási módszert használó csoportban.9. fejezet: Grafika.\ngrafikus megjelenítés leíró statisztikai elemzés része. 9. fejezetben részletesebben olvashatunk publikációkész ábrák létrehozásáról.numerikus változók esetén használt egyik elterjedt ábrázolási formát, dobozdiagramot használjuk két tanítási csoport eredményének grafikus összehasonlítására.10. fejezet: Hipotézisvizsgálatok.\nstatisztikai hipotézisvizsgálat minden adatelemzés központi része, gyűjtött adatokból populációra nézve következtetést vonhatunk le. 10. fejezetben leggyakoribb egyváltozós elemzéseket mutatjuk .Mann-Whitney-próbát hajtunk végre két tanítási módszer eredményességének összehasonlítására.11. fejezet: Publikálás.\nAz adatelemzési folyamat utolsó lépése, az elemzés eredményének publikációkész formába alakítása. 11. fejezetben megismerjük azokat legegyszerűbb folyamatokat, amelyekkel többnyire formanyelvtől függetlenül, publikációkész eredményközlést végezhetünk.bevezető példában kapott eredmények publikálását végezzük el. korábban használt psych::describeBy() függvény hívását úgy módosítjuk, hogy az bármely formanyelven (PDF, HTML, Docx) megfelelő eredményt adjon. Ehhez mindössze egészítsük ki következő sorokkal leíró statisztikai elemzést, majd Knit nyomógomb segítségével fordítsuk le az RMarkdown állományt. leírü statisztikai mutatók máris táblázatos, könnyen áttekinthető formában jelennek meg.Publikációnk szerves része magyarázó ábra. korábban rajzolt dobozdiagramunkat csinosítsuk ki következő sorok R csonkba helyezésével. ggsave() függvény háttértárra rögzítésről gondoskodik.bevezető példa megoldásához természetesen hipotézisvizsgálat szöveges értékelés hozzátartozik, de ezt az alfejezet végén szereplő egyik kitűzött feladatra halasztjuk. hangsúly könyv vázlatos tartalomjegyzékének bemutatásán volt, részletesebb, de felsorolásszerű tartalomjegyzéket következő két alfejezetben találunk.","code":"\n# install.packages(\"rio\")                         # rio csomag telepítése\nlibrary(rio)                                      # rio csomag betöltése\nfelmeres <- import(file = \"adat/excel_2020.xlsx\") # beolvasás\nstr(felmeres)              # dataframe szerkezete\nnames(felmeres)            # változónevek  \nunique(felmeres$modszer)   # különböző értékek - osztaly\nfelmeres$modszer <- factor(felmeres$modszer)\nfelmeres$modszer <- factor(felmeres$modszer, levels=c(\"modern\", \"hagyományos\"))\n# install.packages(\"psych\") # psych csomag telepítése\npsych::describeBy(x = felmeres$eredmeny, group = felmeres$modszer, mat=T)\n#>     item      group1 vars  n      mean        sd    median   trimmed       mad\n#> X11    1      modern    1 13 0.6541958 0.1968892 0.6621212 0.6568871 0.2044191\n#> X12    2 hagyományos    1 13 0.3800117 0.1272075 0.3628788 0.3913912 0.1190573\n#>            min       max     range       skew  kurtosis         se\n#> X11 0.32575758 0.9530303 0.6272727 -0.2885768 -1.189491 0.05460724\n#> X12 0.08333333 0.5515152 0.4681818 -0.6434813 -0.114030 0.03528102\nlibrary(ggplot2)\nggplot(data = felmeres, mapping = aes(x=modszer, y=eredmeny)) + geom_boxplot()\nwilcox.test(eredmeny~modszer, data=felmeres)\n#> \n#>  Wilcoxon rank sum exact test\n#> \n#> data:  eredmeny by modszer\n#> W = 145, p-value = 0.001248\n#> alternative hypothesis: true location shift is not equal to 0\noptions(OutDec = \",\")  # a tizdesjel beállítása\nst <- psych::describeBy(x = felmeres$eredmeny, \n                                 group = felmeres$modszer, \n                                 mat=T, digits = 3)\nknitr::kable(t(st), align = c(\"c\", \"c\"))\nlibrary(ggplot2)\np1 <- ggplot(data = felmeres, mapping = aes(x=modszer, y=eredmeny)) + \n  geom_boxplot() + \n  labs(x=NULL, y=\"Eredmény (%)\", \n       title=\"7. osztályos tanulók Excel eredménye\", \n       subtitle = \"Két tanulási módszer összehasonlítása\") + \n  scale_y_continuous(labels = scales::percent) + theme_bw()\nggsave(filename = \"output/kep/dd.png\", plot = p1)\np1"},{"path":"itt-kezdodik.html","id":"itt-kezdodik-1-summary","chapter":"1 Itt kezdődik","heading":"1.1.1 Összefoglalás","text":"\nEbben az alfejezetben egy adatelemzési példát oldottunk meg, melynek segítségével illusztrálni tudtuk további fejezetek tartalmát. 2. fejezetben áttekintést adunk az R-ről, 3.-ban az Alap R és RStudio telepítését, 4.-ben az RStudio használatát mutatjuk . Az 5. fejezetben kellő részletességgel ismertetjük az R nyelvet. további fejezetekben az adatelemzés szokásos lépéseit vesszük sorra, 6. fejezetben beolvasást, 7. fejezetben az adatok előkészítését, 8. és 9. fejezetben leíró statisztikai műveleteket mutatjuk . 10. fejezet az egyváltozós hipotézisvizsgálatoké, az utolsó, 11. fejezet az eredmények publikálását foglalja össze.\n","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-1-exercise","chapter":"1 Itt kezdődik","heading":"1.1.2 Feladatok","text":"\nMilyen online vagy nyomtat könyvek segítik az R elsajátítását? Próbáljuk összegyűjteni magyar nyelvű könyveket !\n\nTérképezzük fel az online videókurzusokat az R tanulásához!\n\nbevezető példa (Két tanítási módszer összehasonlítása) megoldásában hipotézisvizsgálat alapján adjunk szöveges értékelést!\nfenti feladatok megoldása","code":""},{"path":"itt-kezdodik.html","id":"a-könyv-felépítése","chapter":"1 Itt kezdődik","heading":"1.2 A könyv felépítése","text":"\nEbben fejezetben:\n\nbemutatjuk könyv részletes felépítését,\n\nezzel tovább segítjük választást folytatáshoz.\nkönyv 11 fejezetből áll, és fejezetenként 3 vagy több alfejezetből. röviden bemutatjuk az egyes alfejezetek tartalmát.","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-2-summary","chapter":"1 Itt kezdődik","heading":"1.2.1 Összefoglalás","text":"\nEbben részben röviden bemutattuk könyv összes alfejezetét. későbbiekben térképként használhatja az Olvasó az itt ismertetett táblázatot.\n","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-2-exercise","chapter":"1 Itt kezdődik","heading":"1.2.2 Feladatok","text":"Az adatfeldolgozás 4 lépése következő: (1) adatok beolvasása, (2) adatok előkészítése elemzésre, (3) adatok elemzése és (4) az eredmények publikálása. könyv mely fejezetei tartoznak az adatfeldolgozás fenti lépéseihez?Az R-rel való munka általunk javasolt módja: RStudio-ban, projektmódban, R vagy RMarkdown állományokat szerkesztünk és hajtunk végre. Mely fejezetekben találunk hasznos információkat az R ezen használatával kapcsolatban?","code":""},{"path":"itt-kezdodik.html","id":"próbák-listája","chapter":"1 Itt kezdődik","heading":"1.3 Próbák listája","text":"\nEbben fejezetben:\n\náttekintést adunk az egy- és kétváltozós hipotézisvizsgálatokról.\n10. fejezetben bemutatjuk az egy- és kétváltozós hipotézisvizsgálatok végrehajtását. Ebben fejezetben felsoroljuk legfontosabb próbákat, összesen öt táblázatban soroljuk fel őket:egy mintát vizsgáló próbák (1.1 táblázat),páros mintát vizsgáló próbák (1.2 táblázat),két független mintát vizsgáló próbák (1.3 táblázat),több összetartozó mintát vizsgáló próbák (1.4 táblázat),több független mintát vizsgáló próbák (1.5 táblázat).táblázatokban megadjuk, hogy vizsgálatnak mi célja, vagyis populációbeli változó(k) melyik paraméterére vonatkoznak próbák, várható értékre, mediánra, varianciára vagy valószínűségre. 10. fejezetben foglalkozunk az eloszlásvizsgálatok közül normalitást ellenőrző próbákkal , így 1.1 táblázat ezeket számba veszi.TÁBLÁZAT 1.1:  Egy minta vizsgálataTÁBLÁZAT 1.2:  Páros minta vizsgálataTÁBLÁZAT 1.3:  Két független minta vizsgálataTÁBLÁZAT 1.4:  Több összetartozó minta vizsgálataTÁBLÁZAT 1.5:  Több független minta vizsgálata","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-3-summary","chapter":"1 Itt kezdődik","heading":"1.3.1 Összefoglalás","text":"\nEbben részben rövid áttekintést adtunk könyv 10. fejezetében sorra kerülő statisztikai próbákról. Megneveztük próbákat, R parancsokkal szemléltettük használatukat, valamint jeleztük céljukat. táblázatok áttekintésével képet kaphatunk arról, hogy későbbiekben milyen jellegű statisztikai következtetéseket tudunk levonni az R használatával.\n","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-3-exercise","chapter":"1 Itt kezdődik","heading":"1.3.2 Feladatok","text":"Minden statisztikai próba esetében négy dolgot érdemes tudni: (1) statisztikai próba neve, (2) null- és ellenhipotézise, (3) alkalmazási feltételei, és (4) próba végrehajtásának módja valamely statisztikai programcsomagban. 10. fejezetben statisztikai próbák végrehajtását természetesen R-beli eszközökkel mutatjuk . Ismerjük fenti táblázatokban megnevezett próbák null- és ellenhipotézisét, valamint az alkalmazási feltételeit? Próbáljuk ezeket felidézni! Hol találunk ezekről információt?Mely próbák maradtak ki ebből könyvből? Hol találunk ezek R-beli végrehajtására példát?\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r","chapter":"2 Mi az R?","heading":"2 Mi az R?","text":"","code":""},{"path":"mi-az-r.html","id":"az-r-bemutatása","chapter":"2 Mi az R?","heading":"2.1 Az R bemutatása","text":"\nEbben fejezetben:\n\nmegismerjük az R jellemzőit,\n\nmegtudjuk, hogy melyek parancssoros interfész előnyei,\n\nmegismerjük az Alap R fogalmát,\n\nkörülhatároljuk az R nyelv, az Alap R és csomag fogalmát.\n","code":""},{"path":"mi-az-r.html","id":"az-r-jellemzői","chapter":"2 Mi az R?","heading":"2.1.1 Az R jellemzői","text":"Az R egy magas szintű programozási nyelv és környezet, amelynek legfontosabb felhasználása az adatelemzés és az ahhoz kapcsolódó grafikus megjelenítés. Három alapvető jellemzője kiemeli többi statisztikai programcsomag közül: (1) az R ingyenesen telepíthető és használható; (2) az R nyílt forrású, így bárki hozzájárulhat az R fejlesztéséhez, azaz létrehozhat új csomagokat, és ezzel kiegészítheti az R tudását; és (3) az R felhasználók rendkívül aktív és befogadó online közösséget alkotnak, szinte minden felmerülő kérdésünkre hamar választ kaphatunk.Álljon itt egy bővített lista azokról jellemzőkről, amelyek vonzóvá tehetik számunkra az R statisztikai programcsomagot.Az R szabad szoftver, bárki ingyenesen letöltheti és használhatja. Ez egyfelől megkönnyíti az oktatási intézmények, tanszékek és oktatók munkáját, hiszen nincs szükség kereskedelmi programok licenszeléséből adódó pénzügyi vagy más természetű nehézségek kezelésére. Másrészt hallgatók statisztika kurzusok során tanultakat otthon vagy később munkájukban felhasználhatják.Az R platform-független, azaz Windows, Linux és macOS környezetben használható. Nem kell lemondanunk kedvenc operációs rendszerünkről, ha az R-t szeretnénk használni.Az R egy teljes értékű programozási nyelv, nem csak egy statisztikai programcsomag önmagában.Az R statisztikai módszerek szinte végtelen választékát kínálja. R-ben felhasználható statisztikai eljárásokat statisztikusok fejlesztik folyamatosan és csomagok formájában teszik elérhetővé. Valószínű, hogy egy új statisztikai módszer leghamarabb az R-ben válik elérhetővé.Az R rendkívül gazdag grafikus lehetőségekkel rendelkezik.statisztikai szakirodalomban és az egyetemi oktatók körében egyre elterjedtebb az R, mint közös (statisztikai program)nyelv használata. Ha valamilyen statisztikai problémára keressük megoldást, vagy csak konzultálunk egy statisztikussal, az R ismerete (akár csak olvasási szinten) rendkívüli előnyt jelenthet.Az R igen jól dokumentált, beépített súgón kívül számos könyv és leírás érhető el.Az R parancssoros interfésszel rendelkezik, amely számos előnnyel jár. Egyrészt szkript állományok létrehozása és végrehajtása statisztikai elemzések megismételhetőségét biztosítják, másrészt ez az oktatók és hallgatók könnyebb kommunikációját lehetővé teszi.Az R az adatelemzés eredményének sokszínű publikálását biztosítja. Az RMarkdown formanyelv segítségével HTML, PDF és Word dokumentumot, illetve prezentációs diákat vagy akár kész cikkeket hozhatunk létre. Shiny csomag interaktív Webes alkalmazások építését teszi lehetővé.Mára az R használata szinte egyet jelent az ingyenesen elérhető RStudio használatával, amely egy kényelmes integrált fejlesztői környezetet biztosít parancsállományok létrehozásához.Érdemes bepillantani az R árnyékosabb oldalába . Az R egyik gyengesége, hogy nagy adatbázisok kezeléséhez erős hardverre van szüksége, de legtöbb felhasználás során ez semmilyen problémát nem okoz. másik gyengeség, hogy az R elsajátításához nem kevés idő és kitartás szükséges. Jelen könyv éppen ezt folyamatot kívánja megkönnyíteni és lerövidíteni.","code":""},{"path":"mi-az-r.html","id":"a-r-parancssoros","chapter":"2 Mi az R?","heading":"2.1.2 A R parancssoros","text":"Az R alapvető használata során parancsokat gépelünk és hajtunk végre. Ez lényegesen eltér ma megszokott felhasználói programok világától, ahol egy grafikus felhasználói felületen egérrel vagy az ujjunkkal mutogatjuk el kívánt tevékenységet. Az R egészen más megközelítést vall, használata kezdeti lépésektől nagyfokú figyelmet és pontosságot követel. parancsokban kell gondolkodnunk, ám ezt végig áthatja tudom mit csinálok elv, így némi idő elteltével érezni fogjuk, hogy az R megszelídül, már nem köt bele minden “szavunkba,” egyre több dologra tudjuk rávenni, és végül egy rendkívül értékes társsá válik. Jelen könyv ezen az úton szeretné végigvezetni az Olvasót.Már tanulás elején szeretnénk tisztázni, hogy az R elsajátításához nem szükséges programozói alaptudás. Az R felhasználók többsége egyáltalán nem programozó, és mindennapi adatelemző munka sem igényli az R nyelv programozói fokú ismeretét. Természetesen, ha rendelkezünk ilyen irányú előtanulmányokkal tanulási folyamat néhány szakasza lerövidíthető, de könyvünk elsősorban azok számra íródott, akik programozási nyelvekkel korábban nem találkoztak, és nem vágynak az R ilyen mélységű ismeretére. Az R nyelv elsajátítása során bevezetjük azokat az egyszerű fogalmakat, amelyeket nem nélkülözhetők az adatelemzés során, azonban az R programozásához más szakkönyveket javaslunk olvasásra.","code":""},{"path":"mi-az-r.html","id":"mi-valójában-az-r","chapter":"2 Mi az R?","heading":"2.1.3 Mi valójában az R?","text":"Az R nyelv fejlesztője az R Core Team. Az R nyelv egy rendkívül népszerű szkriptnyelv, több millióan használják világszerte. Elsősorban adatelemzésre, adatmodellezésre és grafikus megjelenítésre, vagyis arra, amit ma adattudományok (data science) alatt értünk. Azonban az R nyelv önmagában nem szoftver, hanem egy rendkívül rugalmas szkriptnyelv, amely például előírja, hogy milyen szintaktikai szabályok mentén fogalmazhatjuk meg az utasításainkat. Ahhoz, hogy az R nyelvet használni tudjuk, vagyis, hogy számítógép valóban végre hajtsa szintaktikailag helyes utasításinkat, szükség van egy szoftveres környezetre, egy olyan futtató rendszerre, amely kódunkat értelmezi és végrehajtja.Az R környezet három fő összetevőt tartalmaz: (1) egy konzolt, ahová parancsainkat begépelhetjük; (2) parancsok végrehajtásáért felelős R interpretert; (3) csomagokokat. konzol és az interpreter biztosítja az R nyelven írt parancsok tényleges végrehajtását. Így tudunk adatokat beolvasni, átlagot számolni, varianciaelemzést futtatni, vagy publikációkész ábrákat létrehozni. csomagok adatokat és függvényeket tartalmaznak, például MASS csomag 88 adatobjektumot és 78 függvényt tartalmaz. függvények valamilyen tevékenységet hajtanak végre, és valójában ezeket csomag-függvényeket használjuk fel konzolban, ha bármilyen tevékenységet szeretnénk végrehajtani (például adatokat beolvasni, átlagot számolni stb.). könyv írásának időpontjában kb. 17000 csomag volt érhető el az R-hez. Csomagok 3 csoportját különböztetjük meg: standard csomagok (14 db), ajánlott csomagok (15 db) és egyéb csomagok (kb. 17000 db). standard csomagok fejlesztője az R Core Team. standard csomagok: base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils. Az ajánlott csomagok: KernSmooth, MASS, Matrix, boot, class, cluster, codetools, foreign, lattice, mgcv, nlme, nnet, rpart, spatial, survival. Az ajánlot csomagok közül foreign és az nlme fejlesztője az R Core Team, többit más felhasználók fejlesztették, például már említett MASS csomag fejlesztője Brian Ripley. Csomagot bárki szabadon fejleszthet és terjeszthet, az egyéb csomagok csoportját akár mi gyarapíthatjuk.R környezet már igazi szoftver, terjesztésének koordinálását az R Foundation végzi CRAN infrastruktúráján keresztül. Ez biztosítja, hogy számítógépünkre telepíthessük az R környezetet. Ezt CRAN-ról elérhető R futtatási környezetet Alap R-nek nevezzük. Fő komponensei már említett konzol parancsok begépelésére, az R értelmező begépelt parancsok végrehajtására és csomagok közül standard és ajánlott csomagok. Az Alap R telepítése után már tudunk R parancsokat végrehajtani, és nagyon sok adatelemzési probléma megoldására nyílik módunk, sőt azt mondhatjuk, hogy tetszőleges problémát megoldhatunk kisebb-nagyobb erőfeszítéssel, mert az R egy teljes értékű nyelv. Azonban sokszor érdemesebb az egyéb csomagok közül választani, hiszen könnyen elképzelhető, hogy számtalan csomag között találunk olyat, amely segítségünkre lehet speciális feladataink megoldása során. Valószínű, hogy létezik olyan csomago és benne olyan függvény, amely adatkezelési, adatelemzési, grafikai vagy publikálási feladatunkat jelentősen megkönnyíti. Az egyéb csomagok csoportjába tartozó csomagok forrása több tárhely lehet, ezek közül legjelentősebb az R Foundation által karbantartott CRAN (kb. 15000 csomaggal), Bioconductor (1741 csomaggal) és GitHub.Az R tehát egyszerre több dolgot jelent. Az R egyrészt egy magas szintű programozási nyelv, hamarosan megtanuljuk, hogyan írjunk ezen nyelven értelmes utasításokat. Másrészt nyelv körüli környezetet jelenti, amely magába foglalja konzolt, parancsaink értelmezésért felelős R interpretert, valamint azokat csomagokat, amelyekkel az R tudása kiegészíthető.","code":""},{"path":"mi-az-r.html","id":"mi-az-r-1-summary","chapter":"2 Mi az R?","heading":"2.1.4 Összefoglalás","text":"\nMinden statisztikai programcsomag, így az R , alapvetően számításigényes statisztikai eljárások kézi végrehajtásától kímél meg minket. Az R nagyon gazdag adatmanipulációs és grafikus funkciókban , támogatja reprodukálható adatelemzés végrehajtását. Az R ingyenes, többplatformos és egyik legfontosabb jellemzője, hogy parancsok útján bírhatjuk működésre. Az Alap R biztosítja konzolt parancsok begépelésére, az R interpretert parancsok tényleges végrehajtására, és jónéhány csomagba szervezett eljárást az adatelemzési feladatok elvégzéséhez. Az Alap R mindössze néhány tucat csomagot tartalmaz, standard csomagokokat és az ajánlott csomagokat, de több tízezer további csomaggal bővíthetjük az R tudását. Az adatelemzési munka során egy R környezet vesz minket körül, amely az R nyelven megírt parancsok értelmezésére és végrehajtására képes Alap R-ből, és az ún. egyéb csomagokból áll.\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r-1-exercise","chapter":"2 Mi az R?","heading":"2.1.5 Feladatok","text":"Keressünk weboldalakat, amelyek az R előnyeit és hátrányait listázzák!Keressük meg, hogy az R optimális futtatásához, milyen hardver követelmények szükségesek!Nézzünk utána, hogy ma kb. hány csomag érhető el az R-hez? Keressünk ábrát, amely bemutatja, hogy az évek során hány csomag volt elérhető az R-hez?Hol áll az R népszerűsége többi programozási nyelvhez, illetve statisztikai programcsomaghoz képest?Milyen ingyenesen elérhető, grafikus felhasználói felülettel rendelkező statisztikai programcsomagok építenek az R-re?Említettük, hogy az adatelmezési munka nem igényli az R programozói fokú ismeretét, de soroljunk fel néhány könyvet, amelyből az R programozása megtanulható!","code":""},{"path":"mi-az-r.html","id":"a-modern-r","chapter":"2 Mi az R?","heading":"2.2 A modern R","text":"\nEbben fejezetben:\n\nmegismerjük Tidyverse R fogalmát,\n\nmegtudjuk mit értünk modern R alatt.\n2014-es év az R nyelv életében meghatározó változást hozott. Egyrészt megjelent magrittr csomagban pipe operátor (%>%), amellyel olvashatóbb kódok írására nyílt lehetőség1, másrészt pipe operátorra alapozva Hadley Wickham bemutatta dplyr és tidyr csomagokat. Ezzel az R funkcionális2 oldalát úgy erősítették meg3, hogy sokszoros egymásba ágyazás során kiküszöbölték kerekzárójelek írásának problémáját. Az ebben szellemben készült csomagok listája bővült az idők folyamán, és Tidyverse nevet kapta ez csomaggyűjtemény. Jelenleg következő csomagok alkotják: ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats. Ezek csomagok nem egyszerűen új funkciókkal ruházzák fel az Alap R tudását, mint általában az egyéb csomagok. Tidyverse csomagjai konzisztens módon együttműködnek, és egy új megközelítést hoznak az adatelemzési folyamatok végrehajtásában és kódok írásában. Rövidebb idő alatt hozhatunk létre könnyebben karbantartható kódokat, és műveleteink végrehajtása rendszerint gyorsabb. Amikor ebben megközelítésben hozzuk létre és hajtjuk végre utasításainkat, akkor azt mondjuk hogy Tidyverse R-t használjuk. Tidyverse R nem helyettesíti az Alap R-t, és csak bizonyos feladatokra használható. Lássunk tisztán, amit elvégezhetünk Tidyverse R-ben, azt az Alap R-ben meg tudnánk tenni, de valószínűleg több gépeléssel, lassabb és rosszabbul karbantartható kóddal.Eddig láttuk, hogy az R használatához szükséges az Alap R telepítése, majd speciális problémánknak megfelelően kiegészíthetjük az R tudását úgy, hogy telepítünk egyet vagy többet az egyéb csomagok kategóriájából. Választhatjuk akár Tidyverse csomagjait telepítésre, ugyanis így lehetőségünk nyílik Tidyverse R használatára. Utasításaink megfogalmazásának ma ez legmodernebb módja.modern R alatt lényegében azokat funkciókat értjük, amelyek Tidyverse gyűjteményben található csomagokhoz kötődnek. Ezekkel csomagokkal, gyorsabb, olvashatóbb és könnyebben karbantartható kódokat hozhatunk létre. Tidyverse használata tehát erősen javasolt, de ebben könyvben “hagyományos,” Tidyverse R előtti lehetőségeket bemutatjuk.","code":""},{"path":"mi-az-r.html","id":"mi-az-r-2-summary","chapter":"2 Mi az R?","heading":"2.2.1 Összefoglalás","text":"\nTidyverse R egy csomaggyűjtemény az egyéb csomagok csoportjából, amely újabb szemléletű R parancsok írására ad lehetőséget. Az így készült kódjaink rendszerint gyorsabban futnak és könnyebben karbantarthatók. modern R Tidyverse R csomagjaival kiegészített Alap R, de legfőképp egy új lehetőség parancsaink megfogalmazására.\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r-2-exercise","chapter":"2 Mi az R?","heading":"2.2.2 Feladatok","text":"Ki Hadley Wickham?Honnan származik pipe operátor neve?","code":""},{"path":"mi-az-r.html","id":"múlt-és-jelen","chapter":"2 Mi az R?","heading":"2.3 Múlt és jelen","text":"\nEbben fejezetben:\n\nmegismerjük az R rövid történetét és annak szereplőit,\n\nmajd egy szubjektív listával segítjük az R tanulását,\n\nilletve megismerjük az R alaptudás elemeit.\n","code":""},{"path":"mi-az-r.html","id":"szereplők-és-fogalmak","chapter":"2 Mi az R?","heading":"2.3.1 Szereplők és fogalmak","text":"Érdemes néhány szereplőt és fogalmat tisztázni az R világán belül. Az R nyelvet 1992-ben kezdte fejleszteni Ross Ihaka és Robert Gentleman, 1997-től pedig egy nagyobb csapat, az R Development Core Team vezeti fejlesztést (rövidebben R Core Team). Ettől az évtől az R hivatalosan GNU projekt része. Az R Core Team tagjai 2002-ben létrehozták R Foundation Statistical Computing (rövidebben R Foundation) közhasznú, nonprofit szervezetet, amelynek célja (1) az R folyamatos fejlesztésének biztosítása, és ehhez kapcsolódóan nyílt forráskódú számítógépes statisztikai innovációk támogatása, (2) az R fejlesztői közösség (R Core Team) hivatalos hangjaként felhasználók, intézmények és üzleti vállalkozások számára kommunikáció biztosítása, és (3) az R program és dokumentációk szerzői jogainak kezelése. szervezet rendszeresen konferenciákat, találkozókat szervez, referált folyóiratot, kézikönyveket és technikai leírásokat ad ki, valamint fenntart egy számítógépes infrastruktúrát (ez CRAN, amely levelező listákat, FTP- és Webszervereket üzemeltet). Az R Foundation hivatalos oldala – egyben az R hivatalos oldala – https://www.r-project.org/. Az R Foundation (és más önkéntesek) által üzemeltetett számítógépes hálózat neve CRAN (Comprehensive R Archive Network), amely szabad hozzáférést nyújt az R legfrissebb verziójához, az R kiterjesztéseihez (csomagokhoz) és részletes dokumentációkhoz. CRAN fő számítógépe Ausztriában található https://CRAN.R-project.org/, azonban nagyon sok naponta frissülő tükörszerver érhető el világszerte.","code":""},{"path":"mi-az-r.html","id":"alapelvek","chapter":"2 Mi az R?","heading":"2.3.2 Alapelvek","text":"Az R elsődleges célja, hasonlóan más statisztikai programcsomagokhoz, statisztikai adatelemzés, amelyet négy lépésre bonthatunk:adatok beolvasása,adatok előkészítése elemzésre,adatelemzés,eredmények publikálása.Az R mára fenti 4 tevékenység elvégzését teljes körűen támogatja. könyv célja ezek bemutatása. Mielőtt elkezdjük ezt az izgalmas utat – az R tanulmányozását – néhány alapelvet szeretnék megemlíteni, ami segíthet minket az utazásunk során:Magabiztosság - Az R nagyon nagy, így teljes megismerése nem lehet célunk. Mindig lesz valaki, aki az R egyik vagy másik részét jobban, vagy kevésbé ismeri nálunk. Ez természetes, ezen soha ne csodálkozzunk. Az eltérő ismeretek azonban az R speciális területeire vonatkoznak, az R alaptudás (2.3.3 fejezet) minden R-ben jártas felhasználó számára közös. E könyv célja ennek az alaptudásnak az átadása, melynek birtokában már kellő magabiztossággal vághatunk neki az R azon részeinek elsajátításába, amelyek az éppen elénk kerülő speciális feladat megoldásához szükségesek. Hisszük, hogy e könyv elolvasásával, mind az R alaptudás, mind kellő magabiztosság elérhetővé válik számunkra.Gyakorlás - Az R alaptudásának megszerzése némi időbe telik, ez tagadhatatlan. motiváció megtartásához viszonylag jól kell éreznünk magunkat tanulás és gyakorlás során. könyvben ezért minden fejezet végén találunk megoldandó feladatokat, amelyek között szórakoztató, érdekes és kihívást jelentő gyakorlatok szerepelnek.Svájci bicska - R nagyon sokféle statisztikai és nem-statisztikai probléma megoldására képes, sőt ugyanarra problémára nagyon sok különböző eszközt kínál. Ha elsőre nem legszebb, legoptimálisabb megoldás jut az eszünkbe, ne csüggedjünk, ez legtöbb esetben nem jelent gondot. Azon se csodálkozzunk, ha korábban megoldott problémánkra idővel újab és újabb megoldási lehetőségeket találunk.","code":""},{"path":"mi-az-r.html","id":"Ralaptudas","chapter":"2 Mi az R?","heading":"2.3.3 Az R alaptudás","text":"Melyek az R-ben való munkavégzéshez nélkülözhetetlen alapismeretek? Meggyőződésünk, ha lentebb felsorolt témakörökkel tisztában vagyunk, akkor már magabiztos R tudással rendelkezünk, és bármilyen további R témakör könnyen elsajátítható lesz. Ezekre az ismeretekre úgy gondolhatunk, mint egy ablakra, amelyen keresztül az R szinte végtelen lehetőségeinek tárháza nyílik meg előttünk. Később visszatérhetünk ehhez listához, és ellenőrizhetjük, hány elemet tudunk már kipipálni.Az R alaptudás elemei:Az R környezet alapszintű ismerete\n\naz Alap R, az RStudio és csomagok telepítése\n\nprojektek használata és R parancsok futtatása az RStudio-ban\n\naz Alap R, az RStudio és csomagok telepítése\nprojektek használata és R parancsok futtatása az RStudio-banAz R nyelv alapszintű ismerete\n\nkonstansok írása\n\nobjektumok kezelése\n\negyszerű adattípusok\n\nalapvető operátorok\n\nkifejezés fogalma\n\nfüggvényhívás lehetőségei\n\nösszetett adattípusok,\n\nvektoraritmetika szabályai\n\nkonstansok írása\nobjektumok kezelése\negyszerű adattípusok\nalapvető operátorok\nkifejezés fogalma\nfüggvényhívás lehetőségei\nösszetett adattípusok,\nvektoraritmetika szabályaiAz alapvető függvények ismerete\n\ncsomagkezelő függvények\n\nmunkaterület függvényei\n\nmatematikai függvények\n\ninput/output függvények\n\nindexelés, szűrés, rendezés\n\ninformáció kérés az objektumokról\n\negyszerű típuskonverzió\n\ntranszformáció\n\nismétlő és összesítő függvények\n\nhagyományos grafika néhány eleme\n\nggplot2 alapszintű ismerete\n\ncsomagkezelő függvények\nmunkaterület függvényei\nmatematikai függvények\ninput/output függvények\nindexelés, szűrés, rendezés\ninformáció kérés az objektumokról\negyszerű típuskonverzió\ntranszformáció\nismétlő és összesítő függvények\nhagyományos grafika néhány eleme\nggplot2 alapszintű ismereteEgyéb ismeretek\n\nszövegszerkesztési és állománykezelési ismeretek\n\ntagolt szöveges állomány fogalma\n\nreprodukálható kutatás az RMarkdown segítségével\n\nszövegszerkesztési és állománykezelési ismeretek\ntagolt szöveges állomány fogalma\nreprodukálható kutatás az RMarkdown segítségével","code":""},{"path":"mi-az-r.html","id":"mi-az-r-3-summary","chapter":"2 Mi az R?","heading":"2.3.4 Összefoglalás","text":"\nAz R fejlesztését Ross Ihaka és Robert Gentleman kezdte, majd 1997-től egy nagyobb csapat, az R Development Core Team vezeti fejlesztést. Az R Core Team tagjai 2002-ben létrehozták R Foundation Statistical Computing közhasznú, nonprofit szervezetet, amelynek fő célja az R folyamatos fejlesztésének biztosítása. szervezet fenntart egy CRAN nevű számítógépes hálózatot, amely szabad hozzáférést biztosít az R legfrissebb verziójához, csomagokhoz és részletes dokumentációkhoz.\nAz R alaptudás megszerzése elegendő magabiztosságot fog nyújtani az adatelemzési munka során, azonban vegyük figyelembe, hogy ezt csak kellő gyakorlással érhetjük el. Az R sokféle megoldást biztosít ugyanarra problémára, legyen az statisztikai vagy bármilyen más jellegű probléma.\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r-3-exercise","chapter":"2 Mi az R?","heading":"2.3.5 Feladatok","text":"Keressünk olyan statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet?Keressünk olyan nem-statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet?Nézzük át néhány online elérhető R könyvet, és hasonlítsuk össze az R alaptudás egyes elemeivel! Melyek az átfedő részek, és hol vannak különbségek?","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese","chapter":"3 Az R telepítése","heading":"3 Az R telepítése","text":"","code":""},{"path":"az-r-telepitese.html","id":"a-fő-komponensek-telepítése","chapter":"3 Az R telepítése","heading":"3.1 A fő komponensek telepítése","text":"\nEbben fejezetben:\n\nmegismerjük az Alap R, az RStudio és csomagok telepítését.\nkorábbi fejezetekben megismertük az R világának néhány fogalmát és szereplőjét. Tudjuk, hogy az R nyelv használatához megfelelő szoftveres környezetre van szükség, amely magába foglalja az Alap R-t és az egyéb csomagok kategóriájából esetlegesen telepített csomagokat . Az R már ezen eszközök birtokában teljes körűen használható, azonban egy újabb ingyenes eszköz, az RStudio, kényelmessé és hatékonnyá teszi az adatelemzési munkát.Könyvünk legfontosabb gondolata: ma akkor tudjuk legjobban kihasználni az R lehetőségeit, és ezzel egyidőben legkényelmesebb módon elvégezni az adatelemzési feladatunkat, ha (1) az Rstudio-t használjuk, (2) projekt üzemmódban dolgozunk, és (3) RMarkdown állományokban rögzítjük az R parancsainkat. Ezt szemléletet következetesen képviseljük az egyes fejezetekben, és későbbiekben részletesebben bemutatjuk, hogyan tudjuk mindezt megvalósítani.R kényelmes használatához legelső lépés szoftveres környezet egyes elemeinek telepítése. Három fő komponens telepítésére lesz szükségünk:Alap R, amely tartalmazza konzolt, az R interpretert, illetve standard csomagokokat és az ajánlott csomagokat,RStudio, amely egy új konzollal “eltakarja” az Alap R-t, és kényelmesebb hozzáférést biztosít az Alap R interpreteréhez és csomagjaihoz.Csomagok, amelyek az egyéb csomagok nagy halmazából származnak, és telepítésükkel újabb és újabb képességekkel ruházzuk fel az Alap R-t.","code":""},{"path":"az-r-telepitese.html","id":"az-alap-r-telepítése","chapter":"3 Az R telepítése","heading":"3.1.1 Az Alap R telepítése","text":"Az Alap R telepítéséhez látogassunk el az R hivatalos letöltő oldalára: https://cran.r-project.org/. Az operációs rendszerünknek megfelelő link kiválasztásával folytassuk navigálást.Windows felhasználók Download R Windows linken, majd base linken kattintva jutnak el telepítőprogram linkjéhez: Download R X.X.X Windows. sikeres letöltés után indítsuk el telepítőt, és az alapértelmezetten felajánlott opciók nyugtázásával végezzük el telepítést. telepítést lehetőleg olyan Windows felhasználó alatt végezzük el, amelynek neve sem ékezetes karaktert, sem szóközt, sem egyéb írásjelet nem tartalmaz.macOS felhasználók Download R (Mac) OS X linken kattintva jutnak telepítőhöz: R-X.X.X.pkg. letöltés után indítsuk el telepítőt, és Next gombok segítségével végezzük el telepítést.Linux felhasználók az aktuális R verzió telepítéséhez Download R Linux linken keresztül jutnak el, ahol megfelelő disztribúció (Debian, Redhat, Suse, Ubuntu) kiválasztása után konkrét információkat kapnak telepítésről.","code":""},{"path":"az-r-telepitese.html","id":"az-rstudio-telepítése","chapter":"3 Az R telepítése","heading":"3.1.2 Az RStudio telepítése","text":"Az RStudio telepítéséhez az operációs rendszerünknek megfelelő telepítőt kell letöltenünk https://www.rstudio.com/products/rstudio/download/ oldalról. Az RStudio Desktop (Open Source License) változatára lesz szükségünk, töltsük le és telepítsük ezt számítógépünkre. telepítés során fogadjuk el az alapértelmezett opciókat. Az RStudio automatikusan megtalálja és használja korábban telepített Alap R példányunkat, így későbbiekben elegendő lesz az RStudio-t használni, azon keresztül elérhetjük az Alap R minden funkcióját.","code":""},{"path":"az-r-telepitese.html","id":"Csomagoktelepitese","chapter":"3 Az R telepítése","heading":"3.1.3 Csomagok telepítése","text":"csomagok telepítésére az Alap R vagy az RStudio elindítása után van módunk. Érdemes telepítéseket az RStudio-ból végezni. csomag fellelési helye alapján, három különböző tárhelyről mutatjuk csomagok telepítését. Látni fogjuk, hogy csomagok telepítéséhez R parancsokat fogunk használni. Ha még nem vagyunk jártasak R parancsok futtatásban, akkor 4.1 fejezet fellapozásával segítséget kaphatunk lenti parancsok kipróbálásához, de úgy eljárhatunk, hogy kihagyjuk ennek résznek az áttekintését, és később térünk vissza, amikor valóban felmerül az igény csomagok telepítésére.Az R csomagok hivatalos helye CRAN (Comprehensive R Archive Network). CRAN számítógépei tárolják nyílt forráskódú R nyelv és környezet különböző verzióinak kódjait és dokumentációit, így az összes R csomag forráskódját . Egy bírálási folyamat után bármely felhasználó csomagja CRAN-ból elérhető lehet.Az Alap R vagy az RStudio elindítása után az install.packages() függvénnyel tölthetünk le és telepíthetünk csomagot CRAN-ról. Tetszőleges csomag telepítéséhez írjuk csomag nevét idézőjelekben függvény argumentumába:psych csomagot, amely pszichológia kutatások adatainak elemzéséhez nyújt segítséget, például így telepíthetjük:csomagok másik fontos forrása Bioconductor, ahol alaposan tesztelt és igen jól dokumentált bioinformatikai témájú csomagokat találunk. Az innen elérhető csomagokat – például DESeq2 csomagot az RNS-szekvenálási elemzésekhez – következő parancsokkal telepíthetjük:csomagok harmadik fő forrása GitHub. felhasználók saját fejlesztésű csomagjaikat rendszerint először GitHub-keresztül teszik elérhetővé. Ha ezeket csomagokat szeretnénk kipróbálni, akkor felhasználó és csomag nevének birtokában következő parancsot kell kiadnunk:Például GitHub-ról telepíthető emo csomag segítségvel hangulatjeleket szúrhatunk az RMarkdown állományainkba. Ezzel sorral telepíthetjük csomagot:Fontos tudnunk, hogy csomagok telepítésére egy számítógépen egy adott R verzión belül csak egyszer van szükség. telepítő parancsainkat azonban érdemes megőrizni, hogy ha szükséges, akkor egy új R verzióban könnyen tudjuk telepíteni korábban használt csomagjainkat. Nagyon fontos, hogy telepítő parancsok futtatása után, tegyük azokat megjegyzésbe, vagyis írjunk előjük kettőskereszt (#) karaktert (részletesebb információkat megjegyzésekről 5.1.3 fejezetben olvashatunk). Ezzel tudjuk megvédeni ezeket telepítő parancsokat az újbóli, véletlen, felesleges végrehajtástól. Ennek megfelelően telepítő parancsainkat ilyen formában kell őriznünk:Vegyük figyelmbe, hogy egy csomag telepítése során más, egyéb csomagok telepítése automatikusan megtörténhet, tehát egy helyett valójában több csomag felkerülhet gépünkre. Az előfordulhat, hogy egy csomag telepítése csak akkor lesz sikeres, ha más csomagok frissítését engedélyezzük az adott csomag telepítése során. Végül előfordulhat olyan eset , amikor egy csomag telepítése valamilyen oknál fogva meghiúsul. Erról minden esetben hibaüzenet tájékoztat minket, és ez szinte minden esetben jó kiindulásul szolgál hibát okozó körülmény elhárításában. legtöbbször egy másik csomag hiánya okozza sikertelen telepítést, ezért olvassuk ki hibaüzenetből hiányolt csomag nevét, és először ennek telepítését végezzük el.","code":"install.packages(\"csomag_neve\")\ninstall.packages(\"psych\")        # psych csomag telepítése\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(\"DESeq2\")devtools::install_github(\"felhasznalo_neve/csomag_neve\")\ndevtools::install_github(\"hadley/emo\")\n# install.packages(\"psych\")        # psych csomag telepítése\n# if (!requireNamespace(\"BiocManager\", quietly = TRUE))\n#     install.packages(\"BiocManager\")\n# BiocManager::install(\"DESeq2\")\n# devtools::install_github(\"hadley/emo\")"},{"path":"az-r-telepitese.html","id":"az-r-telepitese-1-summary","chapter":"3 Az R telepítése","heading":"3.1.4 Összefoglalás","text":"\nAz R kényelmes használatához először telepítsük az operációs rendszerünknek megfelelő Alap R, majd az RStudio legújabb verzióját. Az R képességeit csomagok segítségével bővíthetjük, ehhez legtöbbször az install.packages() parancsot használjuk.\n","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese-1-exercise","chapter":"3 Az R telepítése","heading":"3.1.5 Feladatok","text":"Melyik az R legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest?Melyik az RStudio legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest?Hogyan deríthető ki, hogy egy csomagban (például MASS) csomagban, hány adatobjektum, és hány függvény található?","code":""},{"path":"az-r-telepitese.html","id":"a-tidyverse-r-telepítése","chapter":"3 Az R telepítése","heading":"3.2 A Tidyverse R telepítése","text":"\nEbben fejezetben:\n\nmegismerjük Tidyverse R telepítését.\nTidyverse R az R meglévő funkcióinak új szemléletű használatát jelenti. modern R jelenleg egyet jelent Tidyverse R-rel, az ebben szemléleteben készült parancsaink gyorsak, jól olvashatók és könnyen módosíthatók. Tidyverse R funkciói összesen 8 csomagba (ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats) vannak szétosztva, mindegyik csomag egy-egy témakört fed le. fenti csomagok telepítése egyetlen gyűjtőcsomag tidyverse nevű csomag telepítésével elvégezhető:Tidyverse R telepítését követően csomagokban lévő függvények használatához Tidyverse R betöltésére szükség van. Hívjuk meg library() függvényt, amely ebben az esetben igen részletes tájékoztatást ad az újonnan elérhető csomagokról.Tidyverse R csomagjait jelenleg intenzíven fejlesztik, így gyakran jelenik meg újabb és újabb verzió. Érdemes ellenőrizni, hogy Tidyverse R csomagjai közül legfrissebbeket használjuk-e. Ehhez tidyverse csomag tidyverse_update() függvényét használjuk.Például fenti esetben 3 csomag frissítését javasolja tidyverse_update() függvény, és segítséget ad telepítőparancs listázásával.","code":"\ninstall.packages(\"tidyverse\") # a Tidyverse R telepítése\nlibrary(tidyverse)\n#> -- Attaching packages ----------------------------- tidyverse 1.3.0 --\n#> <U+221A> ggplot2 3.3.0     <U+221A> purrr   0.3.3\n#> <U+221A> tibble  3.0.0     <U+221A> dplyr   0.8.5\n#> <U+221A> tidyr   1.0.2     <U+221A> stringr 1.4.0\n#> <U+221A> readr   1.3.1     <U+221A> forcats 0.5.0\n#> -- Conflicts -------------------------------- tidyverse_conflicts() --\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()\ntidyverse::tidyverse_update()\n#> The following packages are out of date:\n#> \n#> * lubridate (1.7.4 -> 1.7.8)\n#> * purrr     (0.3.3 -> 0.3.4)\n#> * xml2      (1.2.5 -> 1.3.1)\n#> \n#> Start a clean R session then run:\n#> install.packages(c(\"lubridate\", \"purrr\", \"xml2\"))"},{"path":"az-r-telepitese.html","id":"az-r-telepitese-2-summary","chapter":"3 Az R telepítése","heading":"3.2.1 Összefoglalás","text":"\nTidyverse R használatához elegendő telepítenünk tidyverse csomagot, amely többi 8 csomag telepítését automatikusan elvégzi. telepítést install.packages(“tidyverse”) paranccsal végezzük. Időnként ellenőrizzük tidyverse::tidyverse_update() segítségével, hogy legfrissebb változatát használjuk-e Tidyverse R-t alkotó csomagoknak.\n","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese-2-exercise","chapter":"3 Az R telepítése","heading":"3.2.2 Feladatok","text":"Keressünk rá Tidyverse R csomagjaira, és próbáljuk kideríteni az egyes csomagok fő célját, alkalmazási területeit!Derítsük ki, hogy az R Core Team vagy Hadley Wickham több R csomag szerzője!","code":""},{"path":"az-r-telepitese.html","id":"az-r-frissítése","chapter":"3 Az R telepítése","heading":"3.3 Az R frissítése","text":"\nEbben fejezetben:\n\nbemutatjuk az Alap R, az RStudio és csomagok frissítését.\nR ideális használata során az RStudio-ban dolgozunk, és így érjük el az Alap R és az egyes csomagok szolgáltatásait. mai napig mindhárom komponenst intenzíven fejlesztik, újabb és újabb funkciókat építenek , és az esetleges hibákat rendre javítják frissebb változatokban. Az Alap R évente kb. négyszer frissül, az RStudio háromszor, és érdemes időnként azt ellenőrizni, hogy gyakran használt csomagjainkból nincs-e frissebb példány.","code":""},{"path":"az-r-telepitese.html","id":"az-alap-r-frissítése","chapter":"3 Az R telepítése","heading":"3.3.1 Az Alap R frissítése","text":"telepített Alap R verzióját az R.version.string végrehajtásával ellenőrizhetjük. Amennyiben az R hivatalos oldalán találunk frissebb példányt, akkor legalább két módszer segítségével frissíthetjük az Alap R-t. Megjegyezzük, hogy az Alap R sikeres frissítése után az RStudio automatikusan az új példányt fogja használni.1. módszer: csak Windows alatt. Windows operációs rendszer alatt rendelkezésre áll az installr csomag, amelynek pontosan az feladata, hogy kényelmesen telepíthessük számítógépünkre az R legfrissebb verzióját. Az installr régebbi verzióban lévő csomagokat az új változatba átmozgatja, és ott azok frissítését elvégzi. következő parancsok futtatására van szükség.2. módszer: általános út. Az Alap R frissítésének másik módja, hogy telepítünk egy új példányt régi R mellé. Azaz korábban látott módon letöltjük és telepítjük az Alap R legújabb változatát, pontosan úgy, mintha még nem lenne gépünkön működő R. Ez az új verzió azonban félkarú óriás mindaddig, amíg régi R verzióban használt összes csomagot nem telepítjük újra az új verzióban . Ezt magunk egyesével megtehetjük, ha korábban összegyűjtöttük csomagtelepítő parancsainkat, legyen szó akár akár CRAN, Bioconductor vagy GitHub oldaláról származó csomagokról. Ha ezek nem állnak rendelkezésre, akkor az Alap R frissítésének általános útját három lépésben foglalhatjuk össze.Indítsuk el az RStudio-t még az új R verzió telepítése előtt, és futtassuk le következő sorokat. futtatás eredménye egy bináris állomány (csomagok.rds), amely régi R összes telepített csomagjának nevét és más információkat tartalmaz. Lépjünk ki az RStudio-ból.Telepítsük az Alap R új verzióját.Telepítsük az Alap R új verzióját.Indítsuk el az RStudio-t és futtassuk le lenti sorokat. folyamat több percig eltarthat. Az RStudio már az új R verziót használja, így csomagok az új R tudását egészítik ki.Indítsuk el az RStudio-t és futtassuk le lenti sorokat. folyamat több percig eltarthat. Az RStudio már az új R verziót használja, így csomagok az új R tudását egészítik ki.Megjegyezzük, hogy fenti 2. módszer segítségével csak CRAN csomagjait tudjuk telepíteni, Bioconductor és GitHub oldalakról származó csomagok telepítését magunknak kell megismételni.","code":"\n# install.packages(\"installr\") # az installr csomag telepítése\nlibrary(installr)              # az installr csomag betöltése\nupdateR()                      # az Alap R és a csomagok frissítése\ntelepitett.csomagok <- installed.packages(priority=\"NA\")\nsaveRDS(object = telepitett.csomagok, file = \"csomagok.rds\")\ntelepitett.csomagok <- readRDS(file = \"csomagok.rds\")\ninstall.packages(pkgs=telepitett.csomagok[,1])"},{"path":"az-r-telepitese.html","id":"az-rstudio-frissítése","chapter":"3 Az R telepítése","heading":"3.3.2 Az RStudio frissítése","text":"telepített RStudio példányunk verziószámát Help / RStudio menüpont segítségével, vagy az rstudioapi::versionInfo() parancs futtatásával ellenőrizhetjük. Frissebb verzió létezéséről Help / Check Updates menüpont ad tájékoztatást. Amennyiben találunk újabb verziót az RStudio hivatalos honlapján, töltsük le az operációs rendszerünknek megfelelő változatot és indítsuk el telepítőt. Szerencsére régi RStudio beállításait örökli az új példány.","code":""},{"path":"az-r-telepitese.html","id":"csomagok-frissítése","chapter":"3 Az R telepítése","heading":"3.3.3 Csomagok frissítése","text":"korábban telepített csomagokat az RStudio Tools/Check Package Updates menüpontjával frissíthetjük. frissíthető csomagok megjelennek egy dialógus dobozban, jelöljük ki az összes csomagot és indítsuk el telepítési folyamatot. következő R parancs végrehajtásával frissíthetjük csomagjainkat.","code":"\nupdate.packages(ask=FALSE) "},{"path":"az-r-telepitese.html","id":"az-r-telepitese-3-summary","chapter":"3 Az R telepítése","heading":"3.3.4 Összefoglalás","text":"\nAz Alap R, az RStudio és az egyes csomagok időről-időre megújulnak, érdemes évente legalább egy-két alkalommal elvégezni ezek frissítését. Az Alap R frissítése lényegében egy új verzió telepítését jelenti, régi R továbbra elérhető marad. Az RStudio frissítése után csak az új verziót használhatjuk. Az Alap R és az RStudio friss verziója hivatalos honlapokról szerezhető . csomagok frissítéséhez használjuk update.packages(ask=FALSE) parancsot.\n","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese-3-exercise","chapter":"3 Az R telepítése","heading":"3.3.5 Feladatok","text":"Az RStudio Tools/Check Package Updates menüpontjával tájékozódjunk telepített csomagjaink állapotáról. Végezzük el szükséges frissítéseket!","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben","chapter":"4 Munka az R-ben","heading":"4 Munka az R-ben","text":"","code":""},{"path":"munka-az-r-ben.html","id":"AzRStudiohasznalata","chapter":"4 Munka az R-ben","heading":"4.1 Az RStudio használata","text":"\nEbben fejezetben:\n\nmegismerjük az RStudio jellemzőit és felépítését,\n\nkonzolos és parancsállományos használat különbségeit,\n\nparancsállományok és az RMarkdown állományok lehetőségeit,\n\nprojekt fogalmát és használatát,\n\nés az RStudio billenytűparancsait.\nMiután minden szükséges szoftverkomponenst feltelepítettünk, hogyan tudjuk működésre bírni az R-t? Tegyük fel, hogy van egy nagyon egyszerű adatfeldolgozási problémánk, szeretnénk megtudni Csillagok háborúja c. film karaktereinek átlagos testmagasságát. Ha rátalálunk egy alkalmas adatbázisra, amely tartalmazza szereplők testmagasságait, akkor még két konkrét adatelemzési lépés vár ránk: (1) az adatbázis megnyitása, (2) az átlagos testmagasság meghatározása. Korábban láttuk, hogy az R parancssoros, tehát fenti két lépést R parancsok formájában kell megfogalmaznunk. Kérdés, hová írjuk parancsainkat, hogyan hajthatjuk őket végre, és végül, milyen parancsokkal érhetjük el célunkat. Ebben fejeztben az első két kérdésre fókuszálunk, hová írhatjuk parancsainkat és hogyan tudjuk azokat hatékonyan végrehajtani.Máris megválaszoljuk kérdéseket. Korábban láttuk, hogy az Alap R telepítésével elérhetővé válik konzol, ahová parancsainkat begépelve, majd ENTER-t ütve utasításokat tudunk végrehajtani. Az RStudio telepítésével kapunk egy konzolt, amelynek működése megegyezik az Alap R konzoljával: ide gépelhetünk parancsokat, és ENTER-rel végrehajthatjuk őket. konzol azonban nem legkényelmesebb módja az R parancsok végrehajtására. Érdemes szöveges állományba gyűjteni az adatfeldolgozáshoz kapcsolódó R parancsainkat, és azokat egyesével, többet egyszere, vagy akár az összeset elküldeni konzolba végrehjatásra. Ezeknek szöveges állományoknak két fajtáját ismerjük meg ebben könyvben: parancsállományokat és az RMarkdown állományokat (11. fejezetben az RMarkdown állományokról többet olvashatunk). parancsállományok és az RMarkdown állományok létrehozásához legtöbb segítséget az RStudio nyújtja: parancsok begépelését drámaian leegyszerűsíti, és egyben számos más kényelmi funkciót ajánl. Hová írjuk tehát az R parancsainkat? Az RStudio parancsállományaiba vagy RMarkdown állományaiba. Kezdjük fejezetet az RStudio lehetőségeinek megismerésével!","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-jellemzői","chapter":"4 Munka az R-ben","heading":"4.1.1 Az RStudio jellemzői","text":"Fontos tisztázni, az RStudio használatához feltétlenül szükség van telepített Alap R-re, nélküle nem tudunk R parancsokat futtatni. Jó gyakorlat, ha az RStudio telepítése előtt telepítjük fel az Alap R-t, de fordított sorrend sem okoz problémát. Sőt, ha az Alap R egy új verzióját telepítjük fel, akkor korábban telepített RStudio már az új verziójú R futtató környezetét fogja használni. Az RStudio tudása tehát végrehajtható R parancsok tekintetében megegyezik az Alap R tudásával, hiszen minden utasítás, amelynek végrehajtását az RStudio-ban kezdeményezzük, végső soron az Alap R-rel telepített interpreterhez kerül, és végrehajtásáért ő felel. Az RStudio elsősorban parancsok írását könnyíti meg, segítségével parancsok létrehozásához kapunk rendkívüli segítséget.Megjegyezzük, hogy az RStudio egy üzleti vállalkozás neve egyben, amely többféle terméket fejleszt. Ezek egyike az RStudio-nak nevezett integrált fejlesztőkörnyezet, kimondottan az R programozási nyelv számára. Foglaljuk össze, hogy melyek az RStudio erősségei.Parancsok írásának könnyítése. Az R parancsok begépelését számos eszköz segíti, például kódkiegészítés, szintaxisnak megfelelő kódszínezés és tippek megjelenítése.Integrált környezetben, egy felületen látjuk munka során szükséges összes komponenst. Az adatelemzési munka nem merül ki parancsok begépelésében és végrehajtásában. Az R parancsokat jelentő forráskódon kívül kezelnünk kell az outputot, ami lehet szöveges és ábra jellegű , valamint el kell igazodnunk memóriában tárolt adatok között . Sokszor súgót meg kell jelenítenünk, és információval kell rendelkeznünk telepített csomagokról . Az RStudio nagy előnye, hogy mindezt egyetlen integrált felületen láthatjuk és ezen keresztül vezérelhetjük.Projektek használata. Az RStudio támogatja projektek használatát , amellyel az adott adatfeldolgozási folyamat összetevőit – az adatállományokat, parancsállományokat, RMarkdown állományokat, képállományokat és dokumentációkat –, egyetlen könyvtárba foghatjuk össze, és forráskódból relatívan hivatkozhatunk ezekre az állományokra.Publikálás támogatása. Az RMarkdown segítségével kényelmesen és reprodukálható módon hozhatunk létre például PDF, HTML és Word formanyelvű dokumentumokat, vagy PDF, HTML és PowerPoint bemutatókat.További lehetőségek. Az RStudio támogatja Shiny Webes alkalmazások fejlesztését, de saját csomagok létrehozásához kapunk segítséget. Az RStudio támogatja Git verziókezelő használatát .Az RStudio fenti lehetőségeinek bemutatása külön könyvet igényelne, de mindennapi munkához szükséges ismereteket bemutatjuk.","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-felépítése","chapter":"4 Munka az R-ben","heading":"4.1.2 Az RStudio felépítése","text":"Az RStudio indítása után egy több panelból álló alkalmazást látunk. Első indításnál három részre van osztva az alkalmazás, vagyis három panel látható, de tipikus használat során négy panelünk van. Válasszuk ki először File / New file / New R Script menüpontot, amely egy új parancsállomány létrehozását kezdeményezi. E lépés után már biztosan négy-paneles, 4.1 ábrán látható elrendezést kapjuk. Az ábran megneveztük az egyes részeket, két bal oldali panel Forrás és Konzol, jobb oldaliak Környezet és az Ábra. Figyeljük meg, hogy panelek tetején fülek láthatók, így az egyes paneleken különböző lapokat tudunk kiválasztanai, egy panel tehát több lapot tartalmazhat. panelek szélessége és magassága állítható, egyrészt az elválasztó sávokat az egér segítségével mozgathatjuk, másrészt panelek méretező gombjain (az egyes panelek jobb felső sarkában) kattinthatunk. méretezés során eltűnhetnek panelek, de sávok mozgatásával vagy View / Panes / Show Panes menüponttal láthatóvá tehetjük az összes panelt.\nÁBRA 4.1: Az RStudio tipikus képernyőképe\nlegtöbb időt Forrás nevű bal felső panelben töltjük, mert alapértelmezetten itt jelennek meg parancsállományok és az RMarkdown állományok lapjai. Az R parancsainkat tehát ide írjuk. Az RStudio első indításánál ez panel üres, de további indításoknál korábban szerkesztett, de nem zárt lapok automatikusan megnyílnak. Itt helyeztünk el korábban egy parancsállomány lapot File / New file / New R Script segítségével. Ez lap egy egyszerű szövegszerkesztő. Győződjünk meg erről, próbáljuk ki, mert jövőben ebben szövegszerkesztőben töltjük legtöbb időt! fejezet végi kitűzött feladatok között rákérdezünk szövegszerkesztési ismeretekre. Oldjuk meg azt feladatot, majd térjünk vissza ide!bal alsó panel Konzol nevet viseli, vagyis ez az RStudio konzolja, melynek használata és célja megegyezik az Alap R konzoljával. Vagyis begépelhetünk parancsokat, és az ENTER-rel végrehajtjuk őket. Azonban konzol mindössze egysoros szövegszerkesztési lehetőséget kínál, lényegében egyszerre egy parancs begépelésére és végrehajtására van lehetőségünk. Ez lényegesen eltér Forrás panel parancsállomány vagy RMarkdown lapján lévő teljes értékű szövegszerkesztőtől, ahol több sor begépelésére és végrehajtására van lehetőségünk. konzol azonban mégis központi szerepet kap, mert alapesetben az R csak konzolba kerülő parancsokat tudja végrehajtani. parancsállományok és RMarkdown állományok R parancsait valahogyan át kell ide irányítani, úgy mintha ide gépeltük volna őket. De konzol nem csak parancsainkat, azaz az inputot, hanem azok eredményét, az outputot tartalmazza.két jobb oldali panel többfunkciós. jobb felső, Környezet panelben jelennek meg munka során létrehozott objektumok nevei (Environment lap), valamint parancsok története (History lap). Az Environment lapon megjelenő adatbázis nevén kattintva Forrás panelben egy külön lapon megjelenik az adatbázis tartalma, így kapjuk az ún. adatbázis lapot. jobb alsó Ábra panel tartalmazza súgót (Help lap), munka során rajzolt ábráinkat (Plot lap), csomagjaink listáját (Packages lap) és munkakönyvtárunk állományait, könyvtárait (Files lap). két jobb oldali panel elnevezés önkényes volt, hiszen az Environment és Plot csak egy-egy lap neve ezeken többfunkciós paneleken.","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-beállításai","chapter":"4 Munka az R-ben","heading":"4.1.3 Az RStudio beállításai","text":"Mielőtt elkezdjük munkát az RStudio-ban feltétlenül végezzünk el néhány beállítást. Az RStudio működését az Tools / Global Options menüpont alatt módosíthatjuk.UTF-8 kódolás beállítása. fenti menüpont kiválasztása után bal oldali listából Code, majd fenti opciók közül Saving opciót válasszuk. 4.2 ábrán látható módon, érjük el, hogy Default text encoding alatt az UTF-8 legyen kiválasztva. Fontos, hogy minden szöveges állományunk UTF-8 kódolású legyen.\nÁBRA 4.2: Az UTF-8 beállítása az RStudio-ban\nmunkaterület automatikus mentésének tiltása. bal oldalon General menüpont kiválasztása után Basic opció alatt vegyük ki pipát Restore .RData workspace startup elől, valamint Save workspace .RData exit választót állítsuk Never-re (4.3 ábra). Az RStudio projekt szemléletű használata mellett erre mentési funkcióra nincs szükség.\nÁBRA 4.3: munkaterület automatikus mentésének tiltása az RStudio-ban\nAz output megjelenítésének tiltása az RMarkdown lapon. bal oldalon az RMarkdown menüpont kiválasztása után vegyük ki pipát Show output inline R Markdown documents elől (4.4 ábra). Ez beállítás gördülékenyebb szerkesztést biztosít az RMarkdown lapokon.\nÁBRA 4.4: Az output megjelenítésének tiltása az RMarkdown lapon\nOpcionális lehetőségként panelek tartalmán változtathatunk Tools / Global Options / Pane Layout menüpontban. Az RStudio színösszeállításán az Appearance menüpont Editor theme beállításával változtathatunk.","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-konzola","chapter":"4 Munka az R-ben","heading":"4.1.4 Az RStudio konzola","text":"Az RStudio konzola Konzol panel egyik lapján található (4.1 ábra). konzol az RStudio kulcsfontosságú része, korábban láttuk, hogy minden R parancsot végrehajtás előtt ide kell irányítani. Végrehajtása után szöveges eredmények itt jelennek meg, és hibaüzeneteket itt olvashatjuk. Láthatjuk tehát, hogy konzol figyelmünk középpontjában áll munka során.Közvetlenül azonban nagyon ritkán gépelünk parancsot konzolba, erre Forrás panel parancsállomány vagy RMarkdown lapját fogjuk használni. Ebben részben mégis konzolt mutatjuk , ugyanis meghatározó szerepe miatt értenünk kell működését.konzol működése nagyon egyszerű: (1) egysoros parancsokat gépelünk > prompt után, (2) ENTER-t nyomunk, (3) az R interpreter értelmezi és végrehajtja begépelt parancsot, és (4) megjelenik az eredmény. Ezt követően egy újabb sor begépelésére van lehetőségünk, ENTER után annak az értelmezése következhet, majd az eredmény megjelenítése jön, és így tovább.Próbáljuk ki mi konzolt! Bátran gépeljünk parancsokat. Például citation() parancs outputja fontos lehet az R-el végzett munkáink publikálásánál, hiszen megmutatja hogyan hivatkozhatunk az R statisztikai programra, vagy valamelyik csomagjára.Fontos információ az Alap R és az RStudio pontos verziószáma, ezt információt az R.Version() és RStudio.Version() függvény szolgáltatja. Gépelésnél vigyázzunk kis- és nagybetűk helyes bevitelére, mert az R megkülönbözteti ezeket.konzol lehetőségeinek szisztematikus megismerését folytassuk egy egyszerű paranccsal:konzolban megjelent az eredmény, ahogy ezt az összes eddigi parancsunk esetében láthattuk. Azonban nem minden parancs után jelenik meg output konzolban. Például következő parancsnak nincs eredménysora konzolban, de ez messze nem jelenti azt, hogy nem történt semmi (történt: létrehoztunk egy objektumot).Sőt, az előfordulhat, hogy az R nem talált valamit rendben parancsban. Ekkor természetesen nem hajtja/hajthatja végre begépelt sort, helyette hibát jelez.válasz fenti “parancsra” az Error: unexpected symbol \"Ez nem\" hibaüzenet lesz. Alapvető szabály, ha válaszban megjelenik az Error szócska, akkor parancsunkat valamilyen ok miatt nem tudta végrehajtani az R értelmező, és az Error utáni részből tájékozódhatunk hiba okáról. Minden más esetben sikeres volt végrehajtás.Hosszabb, bonyolult parancsok gépelésénél gyakran előfordul, hogy valamiért nem sikerül “teljessé” tenni begépelt parancsot, valami még hiányzik belőle (például egy záró kerek zárójel). Ezt az R értelmező észreveszi és az ENTER megnyomása után egy + folytatás prompt megjelenítésével jelzi ezt számunkra. + prompt után van lehetőségünk hiányzó részek pótlására, majd ha készen vagyunk az ENTER billentyűvel az összes eddig még végre nem hajtott sort elküldhetjük az értelmezőnek.Gépeljük következő parancsot, három egymás utáni sorba, ENTER-ekkel elválasztva.paste(\"Ez már\", kerüljön az első sorba, majd nyomjunk ENTER-t. Az R nem hajtja végre sort, de erre nyilvánvalóan hibás, befejezetlen parancsra hibaüzenetet sem jelenít meg. Helyette felajánlja parancs folytatását, befejezését egy új sorba, amely már + prompttal kezdődik. második sorba gépeljük az \"jó\" karaktersorozatot, nyomjuk meg az ENTER-t. Sajnos még ez sem tette teljessé parancsunkat, így további folytatásra van lehetőségünk + után harmadik sorban. Ide gépeljük hiányzó ) részt, és üssünk ENTER-t. parancsunk teljessé vált, megkapjuk az eredményt konzolban, pontosan úgy, mintha három sort egyetlen sorba gépeltük volna.Legyünk nagyon óvatosak konzol folytatás prompt funkciójával. Ha például az R nem találja parancs hiányzó részét, akkor konzol ezen kényelmi funkciója oda vezethet, hogy folyamatosan + promptot kapjuk az ENTER megnyomása után. Ezt helyzetet hivatott megoldani az ESC billentyű, mellyel megszakíthatjuk az értelmező parancsfeldolgozási kísérletét. Az ESC megnyomása után visszakapjuk > prompttal kezdődő (üres) sort, vagyis tiszta lappal, új, lehetőség szerint teljes parancs gépelésébe kezdhetünk. parancssorba mindig teljes parancsot gépeljünk, amint megjelenik + folytatás prompt, azonnal szakítsuk meg az ESC megnyomásával az értelmezési folyamatot.Az R konzolos használatát két funkció valóban kényelmesebbé teszi. Egyrészt korábban végrehajtott parancsainkat visszahívhatjuk, lapozhatunk bennük előre, hátra. Erre FEL/LE NYÍL billentyűkkel van lehetőségünk. Ezt history-nak nevezzük, vagyis parancsok történetének. Természetesen az így visszahívott parancsot tetszőleges módon átszerkeszthetjük: navigálhatunk sorban előre hátra, beszúrhatunk/törölhetünk karaktereket vagy használhatjuk vágóasztal billentyűparancsait. visszahívott és módosított parancsot az ENTER segítségével újra végrehajthatjuk, és ehhez még sor végére sem kell szövegkurzort pozícionálni, az sorban tetszőleges helyen állhat, az R mégis teljes sort fogja értelmezni.másik kényelmi lehetőség TAB billentyű használata, amellyel az elkezdett, még nem fejezett sorokat egészíthetjük ki. Ha egy sort többféleképpen kiegészíthet az R, akkor egy listát kapunk lehetőségekről, amelyet továbbgépeléssel szűkíthetünk, ha pedig csak egyetlen szóba jöhető befejezése van begépelt karaktereknek, akkor TAB megnyomása után ezzel résszel kiegészül az elkezdett sorunk. Így nemcsak egyszerűen gépelést, illetve időt takaríthatunk meg, hanem például tájékozódhatunk korábban létrehozott objektumok nevéről vagy az elérhető függvények névéről és paramétereiről .Az objektum, függvények és az egyéb ebben fejezetben homályosan hagyott fogalmak definícióit könyv későbbi részeiben részletesen tárgyaljuk.","code":"> citation()\n> citation(package = \"ggplot2\")> R.Version()       \n> RStudio.Version()> 1+2\n[1] 3> x <- 3> Ez nem lesz jó.> paste(\"Ez már\",\n+        \"jó\"\n+       )\n[1] \"Ez már jó\""},{"path":"munka-az-r-ben.html","id":"parancsállományok","chapter":"4 Munka az R-ben","heading":"4.1.5 Parancsállományok","text":"Láthattuk, hogy konzolba egyszerre csak egy parancsot gépelhetünk , úgy gondolhatunk konzolra, mint egy egysoros szövegszerkesztőre. Begépelünk egy sort és végrehajtjuk az ENTER-rel. problémáink többsége viszont nem oldható meg egyetlen paranccsal, csak több tízzel vagy százzal, ezért ez az interaktív, konzolos használat nem alkalmas hosszabb elemzésre.Parancsainkat begépelhetjük egy .R kiterjesztésű, egyszerű, formázás nélküli szöveges állományba . Az ilyen szöveges állományt parancsállománynak vagy szkriptállománynak nevezzük. Ilyen szöveges állományok létrehozására tetszőleges szövegszerkesztő alkalmas, de természetesen mi az RStudio segítségével fogjuk ezeket elkészíteni, ugyanis itt kapjuk legnagyobb segítséget parancsok gépeléséhez, majd végrehajtásához. Forrás panel tartalmazza parancsállomány lapokat, létrehozásuk korábban látott File / New file / New R Script menüponttal történik. Parancsállományok mentésére és már létező megnyitására van lehetőségünk megfelelő menüpont kiválasztásával (File / Save és File / Open File).parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, hiszen konzol egysoros szövegszerkesztője helyett egy szinte végtelen sok parancssor begépelésére alkalmas szövegszerkesztő áll rendelkezésünkre. Mint minden szövegszerkesztőben, különböző billentyűparancsok és vágóasztal itt megkönnyíti szerkesztés folyamatát. Az ENTER jelentése parancsállományos környezetben szövegszerkesztőkben megszokott újsor beszúrása, ami lényegesen különbözik konzolos használat parancsvégrehajtási funkciójától. parancsaink interaktív végrehajtásáért az RStudio-ban Code/Run selected line(s) menüponttal, vagy még gyakrabban Ctrl+Enter billentyűkombinációval van lehetőségünk. Ezekkel módszerekkel tudjuk parancsainkat konzolba irányítani és végrehajtani. De nézzük meg ezt gyakorlatban!","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-rstudio-ban","chapter":"4 Munka az R-ben","heading":"4.1.6 Munka az RStudio-ban","text":"Kezdjük munkát! Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljünk néhány sort. Figyeljük meg, hogy milyen sokat segít az RStudio lenti sorok begépelésében. Az értékadás (<-) operátort az Alt+- billentyűkombináció segítségével vigyük .szövegkurzorral álljunk az első sorra, és hajtsuk végre Ctrl+Enter billentyűparancsot. Láthatjuk, hogy (1) sor átkerül konzolba, (2) az RStudio végrehajtja sort és az eredményt konzolban megjeleníti, és (3) szövegkurzor lejjebb lép következő végrehajtható sorra. Egy újabb Ctrl+Enter így már ezt sort hatja végre, és így tovább. Ha sorok végrahajtása közben hibaüzenetet kapunk (Error), ne essünk kétségbe, hibaüzenet munka része. Nézzük át figyelmesen begépelt sorainkat, javítsuk őket, és futassuk újra az összes sort, fentről lefelé Ctrl+Enter-ek segítségével.parancsok végrehajtása során láthatjuk mennyire kényelmes, integrált környezetben találtuk magunkat. Az x <- mean(1:100) hatására az Environment lapon megjelent az x objektum neve és értéke. Plot lapon láthatunk egy ábrát, amit plot(1:10) rajzolt meg, és ?mean Help lapon mutatja meg mean() átlagszámoló függvény beépített súgóját.Mentsük el parancsállományunkat File / Save vagy Ctrl+S segítségével. Korábban létrehozott parancsállományokat File / Open menüponttal nyithatunk meg.soronkénti végrehajtás mellett nagyon gyakori kijelölt szövegrészek végrehajtása, amit szintén Ctrl+Enter-rel tudunk kezdeményezni. kijelölt rész lehet több sor, teljes parancsállomány, vagy valamelyik sor egy része. Ez utóbbi próbáljuk ki úgy, hogy parancsállomány első sorában csak az 1+2 részt jelöljük ki, és ezt hajtsuk végre Ctrl+Enter segítségével. Az eredmény konzolban 3 lesz. teljes szkriptállomány végrehajtásához jelöljük ki Ctrl+segítségével parancsállomány összes sorát, és nyomjuk meg Ctrl+Enter-t. konzolban tudjuk ellenőrizni, hogy minden sort újra végrehajtottunk.","code":"\n1+23\ngetwd()          # munkakönyvtár kiírása\nx <- mean(1:100)\nplot(1:10)\n?mean\ncat(\"- Vége -\\n\")"},{"path":"munka-az-r-ben.html","id":"rmarkdown-állományok","chapter":"4 Munka az R-ben","heading":"4.1.7 RMarkdown állományok","text":"Láttuk, hogy az R parancsok összegyűjtésére és végrehajtására .R kiterjesztésű parancsállományok kiváló megoldást nyújtanak. Emlékezzünk vissza fejezet eleji példára, amelyben Csillagok háborúja c. film karaktereinek átlagos testmagasságát kerestük. Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljük megoldást jelentő sorokat.Látható, hogy feladat tényleges megoldását jelentő két R parancs mellett megjegyzéseket becsempésztünk, hogy később tudjuk, ki, mikor és miért készítette ezt parancsállományt (# utáni részeket sor végéig az R figyelmen kívül hagyja; részletesebb információkat megjegyzésekről 5.1.3 fejezetben olvashatunk). Futtassuk sorokat Ctrl+Enter segítségével, fussuk át kiszámolt átlagos testmagasságokat az output mean oszlopában, majd mentsük el szkriptállományt Ctrl+S-sel starwars.R néven. Később, napok, hetek vagy hónapok múlva, újra megnyithatjuk starwars.R állományunkat (File / Open), és újra lefuttathatjuk mini-elemzésünket. Ezzel fejezet eleji adatelemzési feladatunkat megoldottuk. Lehet ezt ennél jobban csinálni? Igen!Az R parancsainkat olyan .Rmd kiterjesztésű, egyszerű, szöveges állományokban öszegyűjthetjük, amelyek többet nyújtanak, mint parancsállományok, de szerkezetük kicsit kötöttebb. Az ilyen szöveges állományok az RMarkdown állományok. Miben nyújtanak többet: ahogyan 11. fejezetben részletesen áttekintjük, az RMarkdown állományok az eredmények publikálásához, például HTML, PDF vagy Word formanyelvű állományok létrehozásához szükségesek. Hozzunk létre az RStudio-ban File / New File / R Markdown menüponttal egy új RMarkdown állományt. megjelenő dialógusdobozban töltsük ki Title és Author mezőket, azaz adjunk címet és szerzőt dokumentumhoz, majd kattintsunk az OK gombon. Forrás panelen megjelenik egy új RMarkdown lap, amely egy alapértelmezett tartalommal jön létre, és nem üresen, mint parancsállományok esetében. Említettük, hogy az RMarkdown állományok szerkezete kötöttebb, ez az alapértelmezett tartalom az eligazodásban segít minket. Érjük el, hogy az új RMarkdown ezeket sorokat tartalmazza (szerző neve sajátunk legyen):Minden RMarkdown állomány egy fejléccel kezdődik, amelyet --- karakterek határolnak. természetes nyelvű szöveget szabadon fejléc alatti részben bárhová írhatjuk, az R parancsokat azonban ún. R csonkokban kell elhelyeznünk, amelyeket speciális kezdő és záró sorok határolnak. 11. fejezetben részletesebben olvashatunk ezekről. elégedjünk meg annyival, egy RMarkdown állományban tetszőlegesen sok R csonkot elhelyezhetünk, és egy R csonk tetszőlegesen sok R parancsot tartalmazhat. Egy R csonkon belül parancsok végrehajtása ugyanúgy Ctrl+Enter-rel történik, mint parancsállományok esetében. Próbáljuk ki! begépelt RMarkdown állományunk második csonkjában lévő két R parancsot hajtsuk végre két Ctrl+Enter segítségével. mini-elemzés eredménye ismét konzolban látható.Hogyan foglalhatnánk össze parancsállományok és az RMarkdown állományok közötti különbséget? 4.1 táblázatban láthatjuk, hogy mindkét állományban összesen három különböző tartalmat szoktunk rögzíteni: (1) fejlécinformációt arról, hogy mi az elemzés célja, ki és mikor készítette az állományt, (2) magyarázó, természetes nyelvű szöveget (pl. magyar vagy angol nyelven), és (3) az R parancsokat. Az R parancsokat szabadon írhatjuk parancsállományokba, viszont fejlécinformációt és magyarázó szövegeket megjegyzésbe kell tenni. Az RMarkdown állományokba magyarázó, természetes nyelvű szövegek írhatók szabadon, míg az R parancsokat csonkokba, fejlécinformációt pedig kötött módon, az állomány elejére kell írnunk.TÁBLÁZAT 4.1:  parancsállomány és az RMarkdown állomány összehasonlításaValóban annyiban áll különbség két állománytípus között, hogy máshová és máshogyan írjuk az R parancsokat és az egyéb magyarázó/fejléc szövegeinket? Nem. 11. fejezetben részletesen bemutatjuk, hogy az RMardown állományok ereje abban van, hogy egy fordítási folyamat (knit-elés) során, olyan PDF, HTML vagy Word állományt tudunk előállítani, amely magyarázó/fejléc szövegeken, és az R parancsokon kívül, az R parancsok outputját tartalmazza, legyen az szöveges vagy ábra jellegű output.","code":"\n# A Csillagok háborúja c. film karaktereinek átlagos testmagassága\n# Abari Kálmán\n# 2020. 06. 23.\n\n# Adatok beolvasása és az átlagok kiírása\n# install.packages(\"dplyr\")      # a dplyr csomag telepítése\ndata(starwars, package=\"dplyr\")  # adatbázis beolvasása csomagból\npsych::describeBy(starwars$height, starwars$species, fast=T, mat=T)---\ntitle: \"A Csillagok háborúja c. film karaktereinek átlagos testmagassága\"\nauthor: \"Abari Kálmán\"\ndate: '2020. 06. 23 '\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\nAdatok beolvasása és az átlagok kiírása\n\n```{r}\n# install.packages(\"dplyr\")      # a dplyr csomag telepítése\ndata(starwars, package=\"dplyr\")  # adatbázis beolvasása csomagból\npsych::describeBy(starwars$height, starwars$species, fast=T, mat=T)\n```"},{"path":"munka-az-r-ben.html","id":"projektek-használata","chapter":"4 Munka az R-ben","heading":"4.1.8 Projektek használata","text":"Mostanra nagyon közel kerültünk az általunk ajánlott adatelemzési munkaformához, ugyanis már tudunk az RStudio-n belül parancsállományokat és RMarkdown állományokat használni. Még egy összetevő azonban kulcsfontosságú kényelmes munkához: az RStudio-ban minden esetben projektet kell használnunk.Az RStudio lehetőséget ad, hogy minden egyes adatfeldolgozási feladatunkhoz egy projektet rendeljünk. Egy RStudio projekt minimálisan egy projekt könyvtárat és az ebben lévő lévő .Rproj kiterjesztésű projektállományt jelenti. Ezeket következő módszerrel hozhatjuk létre. Először kattintsunk File / New Project menüponton. Válasszuk ki New Directory opciót (4.5 ábra), majd New Project nyomógombon kattintsunk (4.6 ábra).\nÁBRA 4.5: RStudio projekt létrehozása: 1. lépés\nDirectory name szöveges mezőbe projektünk nevét határozhatjuk meg, ami egyben az új projektünk könyvtárneve lesz. Adjuk meg itt az elso_projekt nevet. Create project subdirectory mezőben azt szülő könyvtárat határozhatjuk meg, ahová projekt könyvtárunkat el szeretnénk helyezni. projekt létrehozását Create Project nyomógombbal fejezhetjük .\nÁBRA 4.6: RStudio projekt létrehozása: 2. lépés\nKét nagyon fontos dolog történt fentiek hatására. Egyrészt számítógépünkön létrejött az elso_projekt projektkönyvtár, és benne az elso_projekt.Rproj projektállomány, márészt az RStudio ún. projekt üzemmódba került, azaz az elso_projekt lett az aktív projekt. Az RStudio-ban egyszerre egy projekt lehet aktív, de elképzelhető, hogy egyetlen projekt sem aktív. Az RStudio felületén jobb felső sarokban tájékozódhatunk, ahol az elso_project feliratot látjuk, de amennyiben nincs aktív projektünk, akkor Project: (none) feliratot olvashatjuk. Kerüljük projekt nélküli állapotot.\nÁBRA 4.7: RStudio projekt létrehozása: 3. lépés\nMinden adatfeldolgozási feladathoz – még legkisebbhez – hozzunk létre projektet. Minden állományt, amely feladathoz tartozik projektkönyvtáron belül helyezzük el. Milyen állományok jöhetnek szóba: például parancsállományok, RMarkdown állományok, adatállományok, képállományok, dokumentációk és hivatkozásokat tartalmazó állományok. Érdemes ezeket rendezetten, ha szükséges, alkönyvtárakba szétosztva tárolni. Jó gyakorlat lehet, hogy parancsállományokat és az RMarkdown állományokat közvetlenül projektkönyvtárban (ez az elso_projekt), az adatállományokat egy adat alkönyvtárban projektkönyvtáron belül (elso_projekt/adat) tároljuk, képállományok és dokumentációk helye pedig lehet az elso_project/kep, illetve elso_projekt/doku alkönyvtár.Válthatunk egy másik projektre (File / Open Project), de zárhatjuk az aktív projektet (File / Close project). Később újra megnyithatjuk ezt File / Open Project segítségével. megnyitás során természetesen az .Rproj kiterjesztésű projektállományt kell kiválasztanunk.Ritkábban az előfordulhat, hogy az adatfeldolgozási folyamatunkkal kapcsolatos állományok összegyűjtését korábban elkezdtük, és csak később szeretnénk ezt könyvtárat egyben RStudio projektkönyvtárként felhasználni.\nÁBRA 4.8: RStudio projekt létrehozása: létező könyvtár megadása\nKorábban létrehozott könyvtárból szintén File / New Project menüpont segítségével hozhatunk létre RSudio projektkönyvtárat. Itt azonban az Existing Directory opciót kell kiválasztani (4.5 ábra). Ezt követően ennek létező könyvtárnak az elérési útját kell megadnunk az 4.8 ábrán látható beviteli mezőben.Végül foglaljuk össze, milyen előnyökkel jár projekt használata:logikailag egy adatfeldolgozási folyamathoz tartozó állományainkat fizikailag együtt tudjuk tartani.Projekt üzemmódban az RStudio az aktuális könyvtárat projektkönyvtárra állítja, így relatív hivatkozást használhatunk kódunkban, amely projekt hordozhatóságát biztosítja különböző számítógépek között.","code":""},{"path":"munka-az-r-ben.html","id":"billenytűparancsok","chapter":"4 Munka az R-ben","heading":"4.1.9 Billenytűparancsok","text":"Az RStudio legfontosabb billentyűparancsa Ctrl+Enter, amely parancsot konzolba küldi végrehajtásra. Van még néhány további billentyűparancs, amelyet érdemes felsorolni, hiszen ezek használatával gyorsítani, egyszerűsíteni tudjuk munkánkat.Ctrl+Shift+N: új parancsállomány létrehozása,Ctrl+S: parancsállomány mentése,Ctrl+W: lap bezárása Forrás panelen,Ctrl+Tab / Ctrl+Shift+Tab: aktív lap léptetése előre és hátra Forrás panelen,Ctrl+F: szöveg keresése és cseréje,Tab: kód kiegészítése,Ctrl+Shift+C: kijelölt sorok - vagy kikommentelése,Ctrl+Alt+Fel / Le (és Shift+Jobbra / Balra): kurzor magasságának állítása (és az oszlopszélesség beállítása) több sor szerkesztésére,Esc: Konzol panelen kilépés folytatás promptból, Forrás panelen kilépés többsoros szerkesztésből,Alt+Fel / Le: sor mozgatása fel vagy le,Alt+Shift+K: billentyűparancsok módosítása,Alt+-: értékadó operátor (<-) beszúrása,Ctrl+Shift+M: pipe operátor (%>%) beszúrása,Ctrl+Enter: az aktuális sor vagy kijelölt rész futtatása,Ctrl+Alt+R: teljes parancsállomány futtatása,Ctrl+Shift+P: kurzor feletti csonkok parancsainak futtatása,Ctrl++ / Ctrl+-: betűméret nagyítása vagy kicsinyítése.Ha valamelyik kombináció nem működik számítógépünkön, akkor Tools / Modify Keyboard Shortcuts menüpont alatt új billentyűparancsot adhatunk az ott felsorolt funkciókhoz.","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-1-summary","chapter":"4 Munka az R-ben","heading":"4.1.10 Összefoglalás","text":"\nAz adatelemzési munka során az RStudio -t használjuk projekt üzemmódban, miközben RMarkdown állományba gyűjtjük az elemző R parancsokat és az egyéb magyarázó/fejléc szövegeket. Ebben fejezetben ezt tételmondatot töltöttük meg tartalommal. Megismertük az RStudio integrált környezetét. Forrás panel lehetséges lapjai parancsállomány, az RMarkdown állomány és az adatbázis. Konzol panel legfontosabb lapja konzol, amely központi szerepet játszik munka során, hiszen Ctrl+Enter-rel végrehajtott R parancsok eredménye és az esetleges hibaüzenetek itt jelennek meg. munka során .R kiterjesztésű parancsállományok kiválóan alkamasak hosszabb elemzések R parancsainak tárolására, de ha publikáláshoz segítséget szeretnénk kapni, akkor inkábba kötöttebb szerkezetű, .Rmd kiterjesztésű RMarkdown állományba rögzítsük parancsainkat. Az RStudio rutinszerű használatához billentyűparancsok ismerete hozzátartozik. projektszemlélet az adatelemzéssel kapcsolatos állományok egybentartásáról, és hordozhatóság biztosításáról szól.\n","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-1-exercise","chapter":"4 Munka az R-ben","heading":"4.1.11 Feladatok","text":"Bizonyosudjunk meg róla, hogy az alapvető szövegszerkesztési ismeretek birtokában vagyunk. Ismerjük az Insert billentyű funkcióját? Találjunk legalább 8 módszert, amely kizárólag billentyű segítségével mozgatja szövegkurzort! szövegkijelölésnek milyen billentyűparancsait ismerjük? Milyen karaktertörlési lehetőségeket ismerünk? Ismerjük mindhárom vágóasztal-művelet billentyűparancsát?Az RStudio mellett milyen más intergrált fejlesztőeszközök léteznek az R-hez?Az Appearance menüpont Editor theme beállításával változtassunk az RStudio színösszeállításán. Keressük meg legjobban hozzánk illőt! Vegyük figyelembe, hogy hosszútávon minél sötétebb háttér jó választás.","code":""},{"path":"munka-az-r-ben.html","id":"segítség-az-r-használatához","chapter":"4 Munka az R-ben","heading":"4.2 Segítség az R használatához","text":"\nEbben fejezetben:\n\nmegismerjük az R hivatalos dokumentációit,\n\naz ún. cheet-sheet-ek forrását,\n\nés parancssorból elérhető súgó parancsokat.\nAz R használatához számos segítséget találunk az Interneten, telepített Alap R-ben és az RStudio-ban egyaránt. Az online segítségek közül elsősorban http://cran.r-project.org címen olvasható R dokumentációkat emeljük ki, ahol több tucat, elsősorban angol nyelvű leírást találunk az R megismeréséhez. bal oldali Documentation / Manuals menüpont alatt találjuk például az R hivatalos bevezető dokumentumát (Introduction R), melynek tanulmányozása rendkívül nagy lépést jelenthet az R alaptudás megszerzéséhez. Az említett menüpont alatt találjuk még contributed documentation linket , amely számos rövidebb, és hosszabb dokumentációt tartalmaz, angol és más nyelveken. Itt találjuk Solymosi Norbert nagyszerű magyar nyelvű R R bevezetőjét .Az R népszerűségének köszönhetően, nagyon sok további dokumentációt, tutoriált és példát találhatunk, ha az internetes keresőkhöz fordulunk. fejezet végi egyik kitűzött feladatban összeállíthatjuk saját listánkat.Rendkívül népszerűek ma az ún. cheat-sheet-ek, amelyek néhány PDF oldalon sok ábrával, és lényeg kiemelésével mutatják egy-egy témakör legfontosabb tudnivalóit. Az RStudio Help / Cheetsheets menüjéből, vagy közvetlenü https://www.rstudio.com/resources/cheatsheets/ címről számos R téma cheet-sheet-je olvashatjuk.tekintsük át azokat súgókat, amelyek az R parancssorából indíthatók. Az R megismerését kezdhetjük aparanccsal, ahol számos, az R nyelvet részletesen tárgyaló dokumentum közül választhatunk.Ha csak egyetlen függvénnyel kapcsolatban szeretnénk segítséget kérni, akkor használhatjuk beépített súgórendszer parancsait. Adjuk ki avagy rövidebbparancsot, ha t.test() függvényről szeretnénk részletes leírását kapni. ?függvénynév lehetőség, minden függvény esetében rendelkezésre áll súgó kikérésére. Abban az esetben, ha nem ismerjük teljesen függvény nevét, használhatjuk aparancsot, ekkor az összes olyan függvényt kilistázhatjuk, amelynek nevében vagy leírásában test karaktersorozat előfordul.Hasznos lehet továbbá find() parancs, amely elárulja, hogy az illető függvény melyik már betöltött csomagban foglal helyet.fenti példából kiolvasható, hogy az aov() függvény stats csomagban található.Ugyancsak betöltött csomagokban végez keresést az apropos() függvény, amellyel lehetőség van parancssorból elérhető függvények vagy objektumok nevében keresni.Tovább segítheti az egyes függvények használatának elsajátítását az example() parancs, amely az egyes függvények használatára mutat példát.Utolsó lehetőségként ejtsünk szót demo() függvényről, amellyel olyan beépített szkripteket futtathatunk, amelyek az R tudását, erejét hivatottak demonstrálni. Próbáljuk ki következő parancsokat.","code":"\nhelp.start()\nhelp(t.test)\n ?t.test\nhelp.search(\"test\")\nfind(\"aov\")\n#> [1] \"package:stats\"\napropos(\"aov\")\n#> [1] \"aov\"         \"eff.aovlist\" \"summary.aov\"\nexample(t.test)\ndemo(graphics)\ndemo(persp)\ndemo(plotmath)\ndemo(Hershey)"},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-2-summary","chapter":"4 Munka az R-ben","heading":"4.2.1 Összefoglalás","text":"\nAz RStudio parancsok gépelését számos módon könnyíti meg, de ha egy függvényről részletesebb leírást szeretnénk olvasni, akkor ?függvénynév parancsot használjuk. Egy-egy témakör gyors megismeréséhez cheet-sheet-eket ajánljuk, amelyek az RStudio Help / Cheetsheets menüjéből elérhetők. Az R hivatalos honlapján hosszabb leírásokat találunk.\n","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-2-exercise","chapter":"4 Munka az R-ben","heading":"4.2.2 Feladatok","text":"Keressünk magyar nyelvű leírásokat az R-hez!közösségi médiában melyek az R legfontosabb fórumai?Hogyan indíthatjuk el egy csomag beépített súgóját? Ismerjük meg így fun csomagot!","code":""},{"path":"munka-az-r-ben.html","id":"az-alap-r-használata","chapter":"4 Munka az R-ben","heading":"4.3 Az Alap R használata","text":"\nEbben fejezetben:\n\nmegtanuljuk az Alap R-ben konzol,\n\nés parancsállományok használatát,\n\naz R Commander kezelését,\n\nvalamint kötegelt feldolgozás módszereit.\nAmennyiben nagygépes környezetben dolgozunk, vagy valamilyen oknál fogva az RStudio-t nem tudjuk használni, akkor az Alap R lehet az egyetlen lehetőség R parancsok futtatására. Ebben az esetben sajnos le kell mondanunk parancsok kényelmes bevitelét és végrehajtását támogató interaktív eszközökről, de természetesen az R teljes ereje, összes függvénye továbbra rendelkezésünkre áll. Ebben részben az Alap R lehetőségeit tekintjük át.Az Alap R elindítása az adott platformon megfelelő bináris állomány futtatását jelenti.Windows operációs rendszerekben az R indítása többnyire az Asztalon lévő R ikon segítségével lehetséges. Ez az RGui.exe grafikus felhasználói felülettel rendelkező alkalmazást indítja, amelynek legfontosabb része külön ablakban (R Console) megjelenő konzol (4.9 ábra).MacOs környezetben indítsuk el az R.app alkalmazást, amely egyetlen konzolt tartalmaz.Linux környezetben az R parancssori futtatásával szintén egy konzolt kapunk.","code":""},{"path":"munka-az-r-ben.html","id":"a-konzol-használata","chapter":"4 Munka az R-ben","heading":"4.3.1 A konzol használata","text":"konzol az Alap R környezet központi része mindegyik platformon. konzol működése lényegében megegyezik korábban megismert RStudio-s konzol működésével: egysoros parancsokat gépelünk prompt (>) után, ENTER-t nyomunk, majd az R interpreter értelmezi és végrehajtja begépelt parancsot, és megjelenik az eredmény. 4.9 ábrán Windows környezetben használható RGui alkalmazás látható, miután konzolba két parancsot gépeltünk és hajtottunk végre.\nÁBRA 4.9: RGui alkalmazás konzollal Windows környezetben\nAz RStudio konzolának minden korábban említett alapfunkciója az Alap R konzolában elérhető, tudjuk használni parancsok történetét, kódkiegészítést TAB billentyűvel, és folytatás prompt (+) megjelenik befejezetlen sorok esetén. Windows alatt futó RGui azonban ismeri parancsállományokat .","code":""},{"path":"munka-az-r-ben.html","id":"parancsállományok-az-rgui-ban","chapter":"4 Munka az R-ben","heading":"4.3.2 Parancsállományok az RGui-ban","text":"Az RGui Windows-os Alap R része, és ahogyan láthattuk, egy nagyon egyszerü grafikus környezet, amelynek központjában konzol található (R Console ablak 4.9 ábrán). Az RGui nagyszerű tulajdonsága, hogy támogatja parancsállományok használatát. Az RGui-ban találunk menüpontokat (File/New script, File/Open script és File/Save), amelyekkel létrehozhatunk, megnyithatunk, és elmenthetünk parancsállományokat. Tudjuk, hogy parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, de fontos műveletként jelenik meg az átirányítás, amely szövegszerkesztőben összegyűjtött parancsokat vezeti át konzolba. Az RGui-ban ez Ctrl+R billentyűkombinációval lehetséges – ez gyakorlatilag az Rstudio-beli Ctrl+Enter –, de az Edit/Run line selection vagy az Edit/Run menüpontok rendelkezésre állnak. soronkénti végrehajtás mellett itt lehetőség van kijelölt szövegrészek végrehajtására, de több sort, teljes parancsállományt, vagy valamelyik sor egy részét elküldhetjük konzolba Ctrl+R segítségével.","code":""},{"path":"munka-az-r-ben.html","id":"r-commander","chapter":"4 Munka az R-ben","heading":"4.3.3 R Commander","text":"Eddig az R használatának két lényegesen eltérő módját mutattuk : konzolos használatot és parancsállományos használatot (az RMarkdown állományok használatát ez utóbbi csoportba sorolhatjuk). Láttuk, hogy konzol az RStudio és az Alap R központi része, de az RStudio és az RGui parancsállományos használatot támogatja. Mindegyik fenti használati mód parancsok gépelésével jár együtt.Azonban létezik egy harmadik, az eddigiektől lényegesen eltérő módja az R használatának. Parancsok gépelése nélkül, csupán egérkattintássokkal végezhetünk statisztikai elemzést. Az R erre alkalmas beépített eszközét R Commander-nek nevezik, de külső eszközök képesek az R parancssoros lényét elfedni előlünk. Ilyen külső eszköz például jamovi és JASP. Mindhárom felsorolt eszközben közös, hogy grafikus felhasználói felületen mozgunk, és egérkattintással, menüben való navigálással, vezérlőelemek (rádiógombok, jelölőnégyzetek, listák, nyomógombok, beviteli mezők) használatával magyarázzuk el kívánt tevékenységet.továbbiakban az R Commander lehetőségeit tekintjük át röviden. Az R Commander az Rcmdr nevű csomagban foglal helyet, így használatához ezt csomagot telepítenünk kell. Ezt követően library() függvény segítségével tudjuk elindítani az R Commander-t:Az indítás után egy külön R Commander ablak jelenik meg (4.10 ábra), melynek felépítése fentről lefelé következő: (1) gazdag menürendszer, (2) eszköztár az aktuális adatbázis (Adattábla) mezővel és az Adattábla megtekintése gombokkal, (3) parancsállomány vagy RMarkdown lapok, (4) output számára fenntartott szöveges mező, és (5) az üzenetek helye. Megjegyezzük, hogy 4.10 ábrán látható R Commander-t az Alap R-ből indítottuk. Amennyiben RStudio-ból adjuk ki library(Rcmdr) parancsot, akkor 4. és az 5. elem, azaz az output és az üzenetek rész nem lesz látható, mert az RStudio konzola ezeket magába integrálja.\nÁBRA 4.10: Az R Commander induló ablaka\nkilépést az R Commander-ből File / Kilépés menüpont segítségével kezdeményezhetjük. Kilépés után az R Commander újraindításához következő parancsokat kell használnunk.Az R Commander lényegét legkönyebben úgy tudjuk szemléltetni, ha egérkattintásokkal megoldjuk Csillagok háborúja c. filmmel kapcsolatos adatelemzési feladatunkat. Első lépésként töltsük dplyr csomagot az Eszközök / Csomag(ok) betöltése menüponttal. Keressük meg listában dplyr csomagnevet és kattintsunk az OK gombon. Ezt követően olvassuk starwars adatbázist ebből csomagból, az Adatok / Csomagban lévő adatok / Adattábla beolvasása betöltött csomagból menüpont segítségével. Kattintsunk duplán dplyr csomagneven, majd jobb oldali listában szintén duplán starwars adatbázison, majd az OK gombbal fejezzük műveletet. Figyeljük meg, hogy az R szkript és R Markdown lapok tartalmazni fogják az egérrel elmutogatott tevékenységeinknek megfelelő R parancsokat, illetve az output és üzenetek részben ezek végrehajtásáról értesítést kapunk.Még egy rendkívül fontos dolog történt dplyr csomag starwars adatbázisának beolvasása után. Az eszköztárban az Adattábla részben már nem Nincs aktív adattábla szöveg szerepel, hanem starwars adatbázis neve. Azt kell megjegyeznünk az R Commander használata során, hogy mindig van egy kitüntetett, aktív adattáblánk, és minden további tevékenység, amit menüpontok segítségével el tudunk érni, az erre kitüntetett, aktív adattáblára vonatkozik. Az aktív adattáblát le lehet cserélni. Amennyiben nyitnánk egy másik adatbázist, akkor starwars feliratú gombon kattintva, egy listából kiválaszthatnánk, hogy melyik adatbázisunk legyen az R Commander-ben aktív.Folytassuk az adatelemzést az Elemzések / Összegzések / Numerikus változók összegzése menüpont kiválasztásával. megjelenő dialógusdobozból válasszuk ki height változót, az Összegzés csoportonként gombon kattintva pedig species változót. Az OK gombok megnyomása után az output részben látjuk az elemzés eredményét.Az R Commander nagyon hatékony eszköz gyors elemzések, egyszerű adatbetekintések elvégzésére. Számos menüpontot kínál az adatok beolvasásához, előkészítéséhez és az elemzéséhez. Ráadásul az egyes menüpontokban elmutogatott tevékenységek R parancsait szorgalmasan gyűjti, így azokat File / Szkript mentése vagy File / R Markdown mentése kiválasztásával, el tudjuk menteni magunk számára. Az R Commander vagy jamovi és JASP ismerete nagyban hozzájárul hatékony adatelemzéshez.Végül megemlítjük, hogy az R Commander tudása kibővíthető beépülő modulok (plugin-ek) segítségével. Ezek új menüpontokat, dialógusdobozokat és természetesen új függvényeket tartalmaznak. beépülő modulok csomagok formájában érhetők el. Például az Easy R beépülő modul telepítéséhez az RcmdrPlugin.EZR csomagra van szükség.Telepítés után beépülő modul betöltésére szükség van, csak így tudjuk az új funkciókat elérni. Ezt az Eszközök / Rcmdr plugin(ok) betöltése menüpontban tehetjük meg. Az R Commander újraindulása után, már az új menüszerkezetet fogjuk látni. Az R Commander hivatalos oldalán teljes listát kapunk az elérhető beépülő modulokból.","code":"\n# install.packages(\"Rcmdr\")  # R Commander telepítése\nlibrary(Rcmdr)               # R Commander indítása\n# ha véletlenül bezártuk az R Commander-t\ndetach(package:Rcmdr)\nlibrary(Rcmdr)\n# beépülő modul telepítése \ninstall.packages(\"RcmdrPlugin.EZR\")"},{"path":"munka-az-r-ben.html","id":"kötegelt-futtatás","chapter":"4 Munka az R-ben","heading":"4.3.4 Kötegelt futtatás","text":"Ha felidézzük az eddig tanultakat az R használati módjairól, akkor világos, hogy mindegyik az interaktív használathoz kötődik. Egy tipikus adatelemzési munka során pontosan erre van szükség, kezdeményezzük egy művelet végrehatását és várjuk az eredményt. Újabb művelet, újabb output. Ezt fajta interaktív használatot láttuk konzolban, parancsállományok és RMarkdown állományok esetén, és az R Commander-ben . Azonban az interaktív használat mellett beszélünk ún. kötegelt feldolgozásról . Ez azt jelenti, hogy egy parancsállomány összes sorát egyetlen lépésben hatjuk végre. Nem vagyunk kíváncsiak soronkénti eredményekre, teljes szkriptállomány futtatása ad olyan eredményt, amelyre nekünk éppen szükségünk van. Kötegelt futtatásra source() függvényt használhatjuk, valamint az Alap R egy külső alkalmazását, az Rscript programot.Tegyük fel, hogy egy netflix.R parancsállományban összegyűjtöttük az összes olyan R sort, amely egyetlen ábra létrehozásához szükséges. Ez az ábra meglehetősen összetett, mert az egyes években megjelent filmek és sorozatok számát tartalmazza, és viszonylag sok adatelőkészítési műveletet előzte meg. Ezek nem mindig izgalmasak számunkra, annál inkább maga az ábra, amelynek létrehozása netflix.R egyetlen célja.következő sort az Alap R vagy az RStudio konzolába/parancsállományába, vagy az RStudio RMarkdown állományába elhelyezhetjük. source() függvény netflix.R minden sorát végrehajtja és reményeink szerint előállítja kívánt ábrát.source() függvény kicsit másként közelít parancsainkhoz, mint amit megszoktunk az interaktív konzolos és parancsállományos használat során. source() először teljes állományban ellenőrzi parancsok szintaktikai helyességét, és csak akkor kezdi el az első majd az azt követő parancsok végrehajtásához, ha mindent rendben talált.Másik lehetőség parancsállomány kötegelt futtatására, az RScript program, amely ugyanúgy az Alap R része, mint konzol vagy az interpreter. Az operációs rendszer parancssorából kell kiadnunk következő parancsot:fenti sor hatására ugyanúgy létrejön kívánt ábra, de az output.txt-ben megkapjuk futás közben keletkező egyéb outputokat .Kötegelt feldolgozásra viszonylag ritkán van szükségünk, akkor többnyire nagygépes környezetben. Az interaktív használat legtöbb adatelemzési munka során elegendő rugalmasságot ad.","code":"\nsource(\"netflix.R\", echo = T)Rscript --vanilla netflix.R > output.txt"},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-3-summary","chapter":"4 Munka az R-ben","heading":"4.3.5 Összefoglalás","text":"\nAmennyiben az RStudio használatára nincs lehetőségünk, akkor az Alap R eszközeivel kiválóan megoldhatjuk adatelemzési feladatainkat. konzol és az RGui parancsállományai interaktív parancsvégrehajtást biztosítanak, source() függvény és az RScript alkalmazás pedig .R kiterjesztésű parancsállományok kötegelt feldolgozását segítik. Az R Commander parancsok gépelése nélkül teszi lehetővé elemzések végrehajtását, mindössze megfelelő menüpontot kell kiválasztani, majd dialógusdobozan elvégezni szükséges beállításokat. Érdemes kipróbálni jamovi és JASP statisztikai programokat .\n","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-3-exercise","chapter":"4 Munka az R-ben","heading":"4.3.6 Feladatok","text":"Foglaljuk össze az R használati módjait! Soroljuk fel mind négy lehetőséget!Hasonlítsuk össze parancsállományok használatát RGui-ban és RStudio-ban!Hasonlítsuk össze parancsállományok és az RMarkdown használatát R Commander-ben és RStudio-ban!Töltsük le és telepítsük az ingyenesen elérhető jamovi és JASP statisztikai programokat, majd nyissuk meg beépített adatbázisait, és végezzünk néhány egyszerűbb elemzést! Ha elakadunk, keressünk videó tutoriált az eszközök használatáról. Melyik eszköz tetszik jobban? Miben hasonlítanak és miben térnek el?","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv","chapter":"5 Az R nyelv","heading":"5 Az R nyelv","text":"Az előző fejezetekben megismertük az R környezetet, az Alap R, az RStudio és csomagok telepítését, megtanultuk projektek, parancsállományok és RMarkdown állományok létrehozását. Tudjuk, különböző környezetekben eltérő módszerekkel hajthatjuk végre az R parancsokat: konzolban az ENTER, Windows-os RGui-ban Ctrl+R, míg az RStudio-ban Ctrl+Enter billentyűkombinációt kell használnunk. parancsok végrehajtása közben érdemes észben tartani, ha folytatás prompt (+) feltűnik, akkor kattintsunk bele konzolba, és nyomjuk meg az Esc billentyűt, így tudunk kilépni befejezetlen sor szerkesztésébőlA fejezet példáinak kipróbáláshoz hozzunk létre egy gyakorlas nevű új projektet az RStudio-ban (File / New Project), majd készítsünk egy gyakorlas.Rmd RMarkdown állományt (File / New File / R Markdown) és egy gyakorlas.R parancsállományt (File / New File / R Script). fejezet példáit felváltva gépeljük az RMarkdown állomány R csonkjaiba, illetve parancsállomány tetszőleges soraiba. fejezet további részében az R nyelvre koncentrálunk, arra, hogy mit írunk, és nem arra, hogy hová írjuk parancsokat.","code":""},{"path":"az-r-nyelv.html","id":"adatobjektumok","chapter":"5 Az R nyelv","heading":"5.1 Adatobjektumok","text":"Ebben fejezetben:áttekintjük az egyszerű számolási lehetőségek R-ben,bevezetjük az aritmetikai operátor és kifejezés fogalmát,megismerjük az objektum létrehozását és elnevezését,több parancs elhelyezését egy sorban,és megjegyzések használatát.Az R nyelv megismerését számadatok írásával kezdjük. Az adatelemzés során számszerű adatok kezelése leggyakoribb, hiszen méréssel és számlálással ilyen jellegű adatokhoz jutunk. Számszerű adat testmagasságunk cm-ben kifejezve, az IQ-teszten elért pontszámunk, vagy testvéreink és Facebook ismerőseink száma .","code":""},{"path":"az-r-nyelv.html","id":"számolás-az-r-ben","chapter":"5 Az R nyelv","heading":"5.1.1 Számolás az R-ben","text":"Kezdjük számszerű adatok megismerését egy egyszerű sor begépelésével.Végrehajtás után konzolban láthatjuk az összeadás eredményét, 4-et. Az eredmény előtt egy szögletes zárójelben lévő sorszámot láthatunk ([1]), amely bonyolultabb outputokban segít eligazodni. Később az 5.3.3.2 fejezetben visszatérünk [1] értelmezésére.Látjuk, ebben az esetben az R úgy viselkedik, mint egy számológép. parancssorba gépelt algebrai kifejezés értékét kiszámolja és képernyőn megjeleníti. Természetesen az összeadáson túl más műveletet használhatunk.fenti példából látható, hogy az R követi műveletek elvégzésének matematikában megszokott sorrendjét. Azaz szorzás műveletre (*) hamarabb sor kerül, ennek eredménye 12. Ezt követi az összeadás (+), már 4 és 12 között. Ennek az összeadás műveletnek az eredménye 16, ami egyben kifejezés értéke , tehát ez jelenik meg konzolban.Természetesen matematikában megszokott módon változtathatunk műveletek végrehajtásának alapértelmezett sorrendjén, azaz használhatunk kerek zárójeleket. Ezeket az R megszokott módon értelmezi: zárójelben szereplő műveletek végrehajtását előreveszi.fenti példában az összeadás művelet lesz az első, amelynek az eredménye 10. Ezt követi szorzás, így kapjuk kifejezés értékeként 20-.Ezeket matematikában megszokott algebrai kifejezéseket, az R-ben egyszerűen kifejezésnek vagy – utalva arra, hogy kifejezés értéke szám – aritmetikai kifejezésnek nevezünk. Az eddigiek alapján az aritmetikai kifejezések tehát következő nyelvi elemeket tartalmazhatják:számok, amelyeket numerikus konstansoknak nevezünk,műveleti jelek, amelyeket aritmetikai operátoroknak nevezünk,és kerekzárójelek.fentiek alapján összetettebb aritmetikai kifejezéseket megformálhatunk. Az R minden esetben kiszámolja kifejezések értékét – azaz kiértékeli kifejezést –, és kapott értéket megjeleníti konzolban.Az aritmetikai kifejezések használata során ne felejtkezzünk el műveletek alapértelmezett végrehajtási sorrendjéről. műveletek megjelenítését az operátorok végzik, melyeknek fontos tulajdonsága, hogy mennyire szorosan kötik magukhoz az adatokat (vagy más néven az operandusokat). Az operátorok ezen fonos tulajdonságát precedenciának nevezzük. Az R-ben használható aritmetikai operátorokat precedenciájuk csökkenő sorrendjében az ?? táblázat tartalmazza.Például hatványozás és az előjel operátor precedenciája eltér egymástól, hatványozás nagyobb precedenciájú, azaz szorosabban köti magához az adatokat, így végrehajtása megelőzi az előjel operátort. Ha nem vagyunk elég óvatosak, és plusz zárójelek segítségével nem biztosítjuk kívánt végrehajtási sorrendet, akkor nem kívánt eredményhez juthatunk. lenti példában láthatjuk, hogy zárójelek nélkül nagyobb precedenciájú hatványozás az elsőként végrehajtott művelet.Eddig láthattuk, hogy kifejezéseinket operátorok, numerikus konstansok és zárójelek segítségével építettük fel. Ezek kifejezések két alkotójukban általánosíthatók:általánosítható kifejezés adat része, amelyet eddig numerikus konstansok képviseltek (ezekből lesznek az objektumok),általánosíthatő kifejezés művelet része, amelyet eddig az operátorok jelenítettek meg (ezek lesznek függvények).Az adatrész általánosítása tehát az adatobjektum (vagy röviden objektum), műveleteké pedig függvényobjektum (vagy röviden függvény). Ezeket tekintjük át következőkben.","code":"\n2+2 \n#> [1] 4\n4+6*2\n#> [1] 16\n(4+6)*2\n#> [1] 20\n4^2-3*2+1\n#> [1] 11\n(104-20)/6-4*7*10/(5**2-5)\n#> [1] 0\n-2^2    # először hatványozás, majd előjel\n#> [1] -4\n(-2)^2  # először előjel, majd hatványozás\n#> [1] 4"},{"path":"az-r-nyelv.html","id":"objektumok","chapter":"5 Az R nyelv","heading":"5.1.2 Objektumok","text":"Ha egy kifejezés értéket nem egyszerűen képernyőn szeretnénk megjeleníteni, hanem azt később fel szeretnénk használni, akkor objektumot4 kell létrehoznunk. Az objektumok révén memóriába rögzíthetünk tetszőleges értékeket, később pedig elővehetjük és felhasználhatjuk ezeket az értékeket.\nTudjuk, ha lenti aritmetikai kifejezést parancssorba írjuk, az R miután kiértékelte kifejezést, kifejezés értékét megjeleníti konzolban. Ez az érték azonban megjelenítés után rögtön el vész, többször nem használhatjuk fel.Ha létrehozunk egy x nevű objektumot, akkor ezt az értéket további kifejezésekben szerepeltethetjük. Minden olyan helyen, ahol eddig számok jelentek meg kifejezésekben, oda ez az x objektumnév beírható.fenti sor végrehajtása után írhatjuk következőket, hiszen kifejezések kiértékelése során az x objektum memóriában tárolt értékével fog számolni az R.Minden objektumnak van neve és tartozik hozzá memóriában egy terület, ahol kérdéses érték tárolásra kerül. Esetünkben az objektum neve x, hozzá tartozó memóriaterületen pedig 97 értéket tárolja az R. Az objektum leegyszerűsítve tehát egy név-érték pár, ahol nevet és memóriában eltárolandó értéket mi magunk választjuk meg.Az objektumok kezeléséhez 3 művelet kapcsolódik:objektum létrehozása,objektum értékének lekérdezése,és az objektum értékének megváltoztatása.","code":"\n1157/13+2^3 \n#> [1] 97\nx <- 1157/13+2^3 \nx+2       # mintha 97+2 lenne\n#> [1] 99\n2*x^3+5   # 2*97^3+5\n#> [1] 1825351"},{"path":"az-r-nyelv.html","id":"objektumok-létrehozása","chapter":"5 Az R nyelv","heading":"5.1.2.1 Objektumok létrehozása","text":"Objektumot értékadással hozhatunk létre. Az értékadás tartalmaz egy értékadás operátort, melynek alakja <- (balra nyíl), vagyis egy kisebb jel és egy mínusz előjel egymás után írva szóköz nélkül5.Az értékadás általános alakja:Ahol lehet továbbiakban ezt balra nyíl alakú értékadó operátort használjuk az értékadás során, és nem szintén legális egyenlőségjelet (=). balra nyíl írását az RStudio az Alt+- segítségével támogatja, így bevitele nem okozhat nehézséget. Az egyenlőségjelet megtartjuk függvényargumentumok elnevezésére. Az egyszerűség kedvéért balra nyíl előtt lévő objektumnevet az értékadás bal oldalának, az utána lévő kifejezést az értékadás jobb oldalának nevezzük.Ha olyan objektumnevet szerepeltetünk az értékadásban, amely még nem létezik, akkor az R létrehoz egy ilyen nevű új objektumot, és hozzá tartozó memóriaterületen pedig az értékadás jobb oldalán lévő kifejezés kiértékelése után kapott értéket tárolja el.fenti sor végrehajtása után konzolban nem jelenik meg eredmény, mégis egy nagyon fontos dolog történik, létrejön az nevű objektum, amelynek értéke 3 lesz mindaddig, amig ezen nem változtatunk. munkánk során létrehozott objektumok memória egy speciális területére, munkaterületre (workspace) kerülnek.Ha az értékadásban használt objektum már létezik, akkor jobb oldali kifejezés kiértékelése után kapott értékkel felülírja bal oldali objektumhoz tartozó memóriaterületet. Ezzel módszerrel tehát korábban létrehozott objektum értékét módosíthatjuk.már létező objektum értékét könnyen megváltoztathatjuk.","code":"objektumnév <- kifejezés    # értékadó utasítás\na <- 1+2    # objektum létrehozása\na <- 10/3   # objektum értékének megváltoztatása"},{"path":"az-r-nyelv.html","id":"objektumok-értékének-lekérdezése","chapter":"5 Az R nyelv","heading":"5.1.2.2 Objektumok értékének lekérdezése","text":"Az objektum memóriában tárolt értékét le kérdezhetjük. legegyszerűbb mód erre, ha az objektum nevét parancssorba írjuk és végrehajtjuk sort, máris megkapjuk az objektum memóriában tárolt értékét.Objektumok tetszőleges kifejezésben megjelenhetnek, akár egy értékadás jobb oldalán lévő kifejezésben . kifejezések kiértékelésében az objektum memóriában tárolt értékével vesz részt.fenti sorokból kiolvasható, hogy immár az objektum értéke 14.","code":"\na     # vajon mi az objektum értéke?\n#> [1] 3.333333\na*3              # a kifejezés értéke konzolba kerül\n#> [1] 10\na <- 4 + a * 3   # megváltozik az objektum értéke, nincs output\na                # megtudjuk az objektum értékét\n#> [1] 14"},{"path":"az-r-nyelv.html","id":"objektumelnevezes","chapter":"5 Az R nyelv","heading":"5.1.2.3 Objektumok elnevezése","text":"Az objektumok elnevezésére eddig egyetlen betűt (karaktert) használtunk, de ez elég ritka eset munka során. Helyes gyakorlat, ha az objektum neve utal az objektum tartalmára, céljára. Ha például testmagasságot tárolunk el egy objektumban, akkor írhatjuk következőt:fenti sor létrehozza munkaterületen magassag nevű objektumot 179 értékkel.Az objektumok elnevezésérebetűket,számjegyeket,pont (.) és az aláhúzás (_) szimbólumokat használhatjuk.Az objektum neve csak betűvel vagy ponttal kezdődhet, számjeggyel vagy aláhúzással nem. Továbbá név nem lehet az R-ben már lefoglalt kulcsszó, mint például , function vagy TRUE (kulcsszavak listáját ?Reserved paranccsal ismerhetjük meg). Hagyományosan pont karaktert használjuk az objektumnevekben tagolásra (például magassag.peter Péter magasságának tárolására). Az R magyar ékezetes karakterek használatát megengedi az objektumnevekben, de csakúgy mint az állományok és könyvtárak elnevezésében, érdemes ezek használatát mellőzni.Az objektumoknak érdemes “beszédes” nevet választani, még ha ennek az ára némi extra gépelés . Tudjuk, Tab billentyű segíti gépelést az RStudio-ban.Az R kis- és nagybetű érzékeny, vagyis az x és X különböző objektumoknak számítanak. Például következőparancs után asor hibát jelez (Error: object 'Pulzus.atlag' found), azaz Pulzus.atlag objektumot nem találja az R. Minden olyan esetben, ha nem létező objektumra hivatkozunk, fenti hibaüzenet jelenik meg konzolban.Amennyiben gondoskodunk nagy P-vel kezdődő objektumról , akkor lehetőségünk van hibaüzenet nélkül mindkét objektum értékének kiíratására.gyakorlatban kerüljük el az olyan helyzeteket, amikor két objektumnév csak kis- nagybetűk használatában tér el.fenti példában egy további apró újdonság szerepelt. Ha egy parancssorban több utasítást szeretnénk elhelyezni, akkor ezeket pontosvesszővel (;) kell elválasztanunk. pontosvesszővel elválasztott utasításokat az R értelmező egymás után, balról jobbra haladva hajtja végre, mintha külön sorba írtuk volna őket. lenti sor 3 kifejezést (parancsot) tartalmaz pontosvesszővel elválasztva, mindegyik eredménye külön-külön jelenik meg konzolban, mintha 3 különböző sorba írtuk volna őket.","code":"\nmagassag <- 179\npulzus.atlag <- 72\nPulzus.atlag\n#> Error: object 'Pulzus.atlag' not found\nPulzus.atlag <- 69           # új objektumot hozunk létre\nPulzus.atlag; pulzus.atlag   # két parancs egy sorban\n#> [1] 69\n#> [1] 72\n1+2; 3+4; 5+6     # három kifejezés egy sorban\n#> [1] 3\n#> [1] 7\n#> [1] 11"},{"path":"az-r-nyelv.html","id":"MegjegyzesazRben","chapter":"5 Az R nyelv","heading":"5.1.3 Megjegyzések az R-ben","text":"Nagyon sok példában láttunk már magyar nyelvű, magyarázó, értelmező szövegrészeket az R parancsok körül. Ezek az R megjegyzések. Megjegyzést az R-ben kettőskereszt (#) karakter használatával vezetünk . Az R értelmező kettőskereszttől sor végéig tartó részt figyelmen kívül hagyja. Itt helyezhetjük el paranccsal kapcsolatos magyarázatainkat magunk vagy kódot később olvasók számára. Teljes sorokat, vagy sorok végét tudjuk így kivonni végrehajtás alól.Nem kizárólag magyarázó szövegek kerülhetnek megjegyzésbe, sokszor R parancsok végrehajtását akadályozzuk meg ezzel módszerrel. Úgy kerülhetjük el egy parancs végrehajtását, hogy nem kell kitörölnünk parancsállományból vagy az RMarkdown állományból, egyszerűen csak megjegyzésbe kell tennünk őket. Emlékezzünk vissza, hogy az 3.1.3 fejezetben csomagok telepítésért felelős parancsok esetében kifezetten javasoltuk megjegyzések használatát:Végül megemlítjük, hogy az RStuio-ban egyszerre több kijelölt sort tudunk megjegyzésbe tenni, vagy onnan kivenni Ctrl+Shift+c segítségével.","code":"\n# Érdekes tény, ha a 153 számjegyeit köbre emeljük, \n#   majd összeadjuk őket, pontosan 153-at kapunk\n1^3+5^3+3^3       # hatványozás a ^ operátorral\n#> [1] 153\n1**3+5**3+3**3    # hatványozás a ** operátorral\n#> [1] 153\n# xkcd: Randall Munroe webképregényei\n# install.packages(\"RXKCD\")\nlibrary(RXKCD)             # csomag betöltése       \nsearchXKCD(\"Star Wars\")    # keresés címben vagy leírásban\ngetXKCD(1769)              # webképregény megjelenítése"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-1-summary","chapter":"5 Az R nyelv","heading":"5.1.4 Összefoglalás","text":"\nEgyszerű kifejezéseket építhetünk numerikus konstansok (számok), operátorok és kerekzárójelek segítségével. legfontosabb matematikai operátorok négy alapművelet és hatványozás. kifejezés kiértékelése balról jobbra sorrendben történik, de ezt felülírja kerekzárójelek használata és az operátorok precedenciája. Egy kifejezés értékét eltárolhatjuk memória speciális területén, munkamemóriában. Ehhez az értékeadó operátorral létre kell hoznunk egy új objektumot. Az objektum egy név-érték páros. Az objektum létrehozása után az objektum neve tetszőleges kifejezés adat részében szerepelhet. Több parancsot pontosvesszővel (;) írhatunk egy sorba. Megjegyzéseket kettőskereszt (#) segítségével helyezthetünk el.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-1-exercise","chapter":"5 Az R nyelv","heading":"5.1.5 Feladatok","text":"Gondoljuk át, mi lehet következő algebrai kifejezés eredménye, majd ellenőrizzük R-ben : \\(8/2(2+2)\\).Gondoljuk át, hogy .342e1 név miért nem lehet érvényes objektumnév? Próbáljuk ki make.names(\".342e1\") parancsot, majd tanulmányozzuk ?make.names leírást!Magyarázzuk meg make.names(c(\"\", \"\", \"\")) és make.names(c(\"\", \"\", \"\"), unique = T) parancsok közötti különbséget!Gondoljuk át, hogy egy parancsállomány mely pontjain érdemes feltétlenül megjegyzéseket használni!Jelentősen segíthetjük navigációt az RStudio parancsállományaiban, ha bizonyos megjegyzések végére ezt írjuk: ---- (négy mínusz jel). Hogyan használhatjuk ezt lehetőséget az RStudio-ban, és milyen előnyei vannak?Az RStudio-ban parancsállomány (.R) szerkesztése közben próbáljuk ki Ctrl+Shift+R billentyűparancsot, és hozzá kapcsolódó Shift+Alt+J billentyűparancsot . Mi jelentése az Alt+L, Shift+Alt+L, Alt+O és Shift+Alt+O billentyűparancsoknak? megismert funkciók hogyan válthatók ki RMarkdown (.Rmd) állomány szerkesztése közben?","code":""},{"path":"az-r-nyelv.html","id":"függvények","chapter":"5 Az R nyelv","heading":"5.2 Függvények","text":"Ebben fejezetben:áttekintjük függvényhívás lehetőségeit nevesített argumentumokkal, az alapértelmezésekkel és az argumentumok sorrendjének megváltoztatásával,megismerjük legfontosabb matematikai függvényeket,és pontosítjuk kifejezés fogalmát.Az aritmetikai kifejezéseinkben használható operátorok nem teszik lehetővé minden matematikai művelet elvégzését. Mit tegyünk ha 2 négyzetgyökét szeretnénk kiszámolni? négyzetgyökvonás operátor nem létezik az R-ben, de ebben speciális esetben hatványozás operátor segítségével elérhetjük célunkat.Az R azonban más lehetőséget biztosít négyzetgyök kiszámítására és ez az sqrt() függvény.függvények valamilyen utasítássorozatot hajtanak végre és számítás eredményét szolgáltatják. Esetünkben az sqrt() függvény egy szám (pozitív) négyzetgyökét számolja ki, annak számnak négyzetgyökét, amely kerek zárójelek között szerepel. Tehát az R paraméterben megadott 2 értékre meghívja az sqrt() függvényt, ami visszatér 2 négyzetgyökével.","code":"\n2^0.5\n#> [1] 1.414214\nsqrt(2)\n#> [1] 1.414214"},{"path":"az-r-nyelv.html","id":"a-függvényhívás-szabályai","chapter":"5 Az R nyelv","heading":"5.2.1 A függvényhívás szabályai","text":"függvényhívás általános alakja:függvény neve ugyanazoknak szabályoknak engedelmeskedik, amelyeket az objektumok nevénél megtárgyaltunk (lévén függvény egy objektum). függvény neve után kerek zárójelben következnek függvény argumentumai, amelyek függvény utasításainak bemenő paraméterei. függvény bemenő paraméterek alapján az utasításainak megfelelően egy visszatérési értéket fog szolgáltatni.Egy függvény különböző hívásainál az előforduló argumentumok száma és azok sorrendje igen változatos képet mutathat. Elöljáróban elmondhatjuk, hogy függvények argumentumai alapértelmezett értékkel rendelkezhetnek, így ezek az argumentumok elhagyhatók. Továbbá, függvények argumentumai névvel rendelkeznek, amelyeket ha függvény hívásánál felhasználjuk, az argumentumok sorrendje tetszőleges lehet.Először tekintsük át az R alapvető matematikai függvényeit (?? táblázat). Nézzük meg részletesebben log() függvényt. Ha kikérjük súgóját ?log parancs begépelésével, akkor megtudhatjuk, hogy ez legáltalánosabb logaritmus függvény, tetszőleges alap esetén hívható. Számunkra legfontosabb súgónak az sora, amely logaritmus függvény használatát mutatja: log(x, base=exp(1)).Ebből kiolvasható, hogy log() függvénynek 2 argumentuma (más néven paramétere) van. Az elsőt x-nek, másodikat base-nek nevezik. második paraméter alapértelmezett értékkel rendelkezik, tehát ez paraméter hívásnál elhagyható, míg az x= argumentum megadása kötelező. base= paraméter értéke könnyen kideríthető azparancsból. Ezt az irracionális számot matematikában e-vel jelöljük, és Euler-féle számnak nevezzük. Ha nem határozzuk meg második paramétert, akkor log() függvény természetes alappal (base=exp(1)) számítja ki az x logaritmusát.Ezek alapján 2 természetes alapú logaritmusát afüggvényhívás adja meg. Azt megtehetjük, hogy felhasználjuk hívásnál az argumentum nevét (x), és egy egyenlőségjel (=) felhasználásával ezt 2 elé szúrjuk .fenti sor természetesen ugyanúgy 2 természetes alapú logaritmusát szolgáltatja, csak explicit módon közöltük, hogy az aktuális paraméterben szereplő 2-es értéket az x= nevű formális paraméternek feleltetjük meg. Ez felesleges gépelést jelentett és általában elmondhatjuk, hogy matematikai függvények esetében az oly gyakori x= argumentumnevet szokás szerint nem írjuk ki függvényhívás során.Hívjuk két argumentummal log() függvényt. 100 10-es alapú logaritmusát aparanccsal tudhatjuk meg. függvényhívásnál az x= formális argumentum 100, base= pedig 10 értéket kapja. Természetesen ezt hívásnál mi rögzíthetjük világosabb értelmezés kedvéért saját magunk számára avagy akárformában .Arra lehetőség van, hogy megcseréljük az aktuális paraméterek sorrendjét. legbiztonságosabb ekkor az összes paraméter nevesítése,de két argumentum esetén így egyértelmű hozzárendelés:Ha az argumentumok nevesítése nélkül cseréljük fel az aktuális paramétereket, akkor természetesen nem várt eredményt kapunk, mert 10 100-alapú logaritmusa lesz az eredmény.Kényelmi lehetőség az aktuális paraméterek elnevezésénél, hogy rövidítéseket használhatunk, addig csonkolhatjuk az argumentum nevét, amíg az argumentumok egyértelműen azonosíthatók maradnak. Így példában akár b=-vel helyettesíthetjük base= argumentumnevet:Mint korábban említettük, az x= argumentum nem rendelkezik alapértelmezett értékkel, így paraméter nélkül nem hívható log() függvény.fenti hibaüzenethez hasonlót láthatunk, ha egy függvényt nem megfelelő számú paraméterrel hívunk.Eddig függvények aktuális paramétereiként csak numerikus konstansokat használtunk, pedig valójában tetszőleges kifejezéseket megadhatunk. függvény hívása előtt ezek kiértékelődnek és hívás során ezek az értékek rendelődnek formális paraméterekhez.fenti példa következő numerikus konstansokkal történő hívásoknak felel meg:függvények sokféle csoportja létezik az R-ben, látott matematikai függvények osztálya csak egy sok közül. következő fejezetekben függvények más csoportjait megismerjük.","code":"függvénynév(argNév1=arg1, argNév2=arg2, ..., argNévN=argN)\nexp(1)    #  Euler-féle szám, a természetes logaritmus alapja \n#> [1] 2.718282\nlog(2)    # 2 természetes alapú logaritmusa\n#> [1] 0.6931472\nlog(x=2)   # 2 természetes alapú logaritmusa\n#> [1] 0.6931472\nlog(100, 10)        # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(100, base=10)    # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(x=100, base=10)  # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(base=10, x=100)  # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(base=10, 100); log(10, x=100)  # 100 10-es alapú logaritmusa 2x\n#> [1] 2\n#> [1] 2\nlog(10, 100)  # 10 100-as alapú logaritmusa\n#> [1] 0.5\nlog(b=10, 100)   # 100 10-es alapú logaritmusa\n#> [1] 2\nlog()\n#> Error: argument \"x\" is missing, with no default\nalap <- 10; log(exp(1)); log(exp(4), base=alap); log(2*exp(2), b=alap/2)\n#> [1] 1\n#> [1] 1.737178\n#> [1] 1.673346\nlog(2.718282); log(54.59815, base=10); log(14.77811, base=5)\n#> [1] 1\n#> [1] 1.737178\n#> [1] 1.673346"},{"path":"az-r-nyelv.html","id":"a-kifejezés-fogalma","chapter":"5 Az R nyelv","heading":"5.2.2 A kifejezés fogalma","text":"Elérkezett az idő, hogy kifejezés fogalmát pontosíthassuk: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerekzárójelekkel helyesen összefűzött sorozata kifejezés.Az R nyelv parancsai, vagy más néven utasításai lényegében kifejezések. Az R nyelvben egy parancs végrehajtása lényegében egy kifejezés kiértékelését jelenti, és legtöbb esetben kifejezés értékének megjelenítését konzolban.munka során az R értelmező az utasítások egymás utáni kiértékelését végzi. Az utasításokat újsor karakter vagy pontosvessző választhatja el. szintaktikailag helyes utasítások kiértékelése mindig egy értéket eredményez, ez lesz az utasítás értéke. Még akkor rendelkezik értékkel az utasításunk, ha az nem jelenik meg parancssorban, például az értékadó utasítás értéke jobb oldali kifejezés értéke. Ezért írhatjuk következő parancsot:Amennyiben egy értékadás, mint kifejezés értékét szeretnénk megjeleníteni konzolban, akkor tegyük kerekzárójelbe teljes sort:kifejezés fogalmának gyakorlásához nézzünk egy példát. másodfokú egyenlet megoldóképlete segítségével oldjuk meg az \\(x^{2}–5x+4=0\\) egyenletet. Gépeljük következő sorokat:fenti hat sor mindegyike egy-egy kifejezés. Az első három sorban lévő kifejezéseknek nincs outputja konzolban, céljuk új objektumok létrehozása, és maguk kifejezések csupán értékadó operátort, objektumnevet és konstanst tartalmaznak. negyedik sor kifejezése szintén output nélkül hajtódik végre, és itt új objektum jön létre, kifejezés több összetevőt tartalmaz: objektumneveket, függvényhívást, matematikai operátorokat és konstansokat. Az ötödik és hatodik sorban lévő kifejezések értékei kiértékelés után megjelennek az outputban, és objektumnevekből, matematikai operátorokból, kerekzárójelekből és konstansokból épülnek fel.","code":"\ny <- x <- 10\nx; y\n#> [1] 10\n#> [1] 10\n(x <- 20)\n#> [1] 20\negyutthato.a <- 1\negyutthato.b <- -5\negyutthato.c <- 4\nD <- sqrt(egyutthato.b^2-4*egyutthato.a*egyutthato.c) # diszkrimináns\n(-egyutthato.b+D)/(2*egyutthato.a)   # 1. gyök\n#> [1] 4\n(-egyutthato.b-D)/(2*egyutthato.a)   # 2. gyök\n#> [1] 1"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-2-summary","chapter":"5 Az R nyelv","heading":"5.2.3 Összefoglalás","text":"\nfüggvényobjektumok (vagy röviden függvények) előre definiált utasítások sorozatát hajtják végre, és egy visszatérési értéket szolgáltatnak. visszatérési érték meghatározását függvény bemenő paraméterei, az argumentumok befolyásolják. Minden argumentumnak van neve, és opcionálisan rendelkezhetnek alapértelmezett értékkel . Az R-rel való munka nem más, mint kifejezések létrehozása és végrehajtása, vagyis kiértékelése. kifejezés fogalma: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerekzárójelekkel helyesen összefűzött sorozata kifejezés. kifejezések kiértékelése során az eredmény megjelenhet konzolban, de látható output nélkül végbemehet kifejezés végrehajtása.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-2-exercise","chapter":"5 Az R nyelv","heading":"5.2.4 Feladatok","text":"Tekintsük át az ?? táblázat utolsó oszlopában szereplő R függvényeket. Próbáljuk megjósolni függvények visszatérési értékét. Végezzünk ellenőrzést: gépeljük , és hajtsuk végre matematikai függvényeket! Egészítsük ki begépelt matematikai függvényeket az argumentumok nevével, mindegyik argumentumnak adjunk nevet az ?? táblázat első oszlopa alapján!Az előző feladatban matematikai függvények gépelése során milyen RStudio kényelmi funkciókat fedeztünk fel. Soroljunk fel legalább hármat!Az aranymetszés arányait tartalmazó épületek, képzőművészeti alkotások máig nagy esztétikai értékkel bírnak. Határozzuk meg ezt az arányt \\(\\phi=\\frac{1+\\sqrt{5}}{2}\\)\nképlet segítségével! Egy /4-es oldalra kb. 47 sort írhatunk 12-es betűmérettel, és kb. 35 sort 16-os betűmérettel. Egy üres lap hanyadik sorába írnánk címet 12-es és 16-os betűméret esetén? Próbáljuk ki mindezt egy szövegszerkesztőben !trigonometrikus függvények argumentumában radinánban kell megadni szög értékét, és nem fokban. Ezt figyelembe véve határozzuk meg 0, 30, 45, 60, 90 és 180 fok szinuszát, koszinuszát és tangensét!","code":""},{"path":"az-r-nyelv.html","id":"adatszerkezetek","chapter":"5 Az R nyelv","heading":"5.3 Adatszerkezetek","text":"Ebben fejezetben:áttekintjük numerikus, karakteres és logikai konstansok írását,vektor, mátrix, faktor, lista, és adattábla adatszerkezeteket,ezek kezelését, indexelését, tesztelését és konvertálását.Kezdünk egyre mélyebre ásni az R nyelvben. Megismertük már az adatobjektum, függvény és kifejezés fogalmát. Ezek birtokában már bátran belevághatunk könyvünk kulcsfontosságú fejezetébe, az adatszerkezetek tanulmányozásába. Legyünk alaposak az itt szereplő témakörök áttekintésében, és lehetőleg oldjunk meg minden kitűzött feladatot. Később ez sokszorosan megtérül.Minden statisztikai programcsomag adatokkal dolgozik. Az R-ben nevekkel ellátott objektumokban tároljuk ezeket az adatokat. Lényegében minden tevékenység ezen objektumok létrehozása, módosítása és lekérdezése köré csoportosítható. Ezeket műveleteket az R-ben az operátorok és függvények képviselik. Láttuk, adatokból (objektumokból), operátorokból és függvényekből kifejezéseket építünk, és hajtunk végre – így foglalható össze minden egyes tevékenység az R-ben.Ebben fejezetben kifejezések adat részére összpontosítunk, hiszen minden adatelemzési munka kiinduló pontja maga az adat. Eddig csak számszerű (numerikus) adatokkal találkoztunk, és azok közül csak az egész számok leírására fókuszáltunk. Adatfeldolgozási folyamatainkban mért adatok azonban numerikus mellett karakteres formában előfordulnak, valamint az R-ben egy harmadik adattípus, logikai fontos szerepet kap. Összefoglalva, három R alaptípus lesz fontos számunkra az adatfeldolgozás során:numerikus típus, amely lehet double vagy integer, attól függően, hogy tizedestörteket vagy egész számokat szeretnénk tárolni,karakteres típus, amelyek nem egyetlen karaktert, hanem egy karaktersorozatot vagy más néven sztringet jelentenek,logikai típus, amely az adatszerkezetek manipulációja során jut nagyon fontos szerephez.továbbiakban megismerjük, hogyan adhatjuk meg az R számára fenti típusokba tartozó értékeket, illetve ezek felhasználásával, hogyan tudunk bonyolultabb adatszerkezeteket, összetett típusokat létrehozni.","code":""},{"path":"az-r-nyelv.html","id":"konstansok","chapter":"5 Az R nyelv","heading":"5.3.1 Konstansok","text":"Mért adatokat közvetlenül az R-konstansok segítségével írhatunk . konstansok olyan objektumoknak tekinthetők, amelyeknek nincs nevük, csak értékük, és azt nem tudjuk megváltoztatni. Ha Péter 18 éves, akkor azt 18 leírásával közölhetjük az R-rel, és ez nem jelenthet mást (nem lehet más az értéke), mint 18. már említett három egyszerű típusnak megfelelően tekintsük át numerikus, karakteres és logikai konstansokat.","code":""},{"path":"az-r-nyelv.html","id":"numerikus-konstansok","chapter":"5 Az R nyelv","heading":"5.3.1.1 Numerikus konstansok","text":"numerikus konstansok többféle alakban megjelenhetnek az R-ben. Az integer szóval az egész számok tárolását végző konstansra hivatkozunk, double konstansok pedig törtrészt tartalmazhatnak, de ez nem kötelező. Ha nem érdekes, hogy szám integer vagy double, akkor egyszerűen numerikus (R-ben numeric) elnevezést használjuk.Az ?? táblázatban látható, hogy integer értékek írásához szükséges az L utótag használata, egyébként double-ként kezeli az R számot, még akkor ha nem adtunk meg törtrészt.Fontos szabály, hogy tizedesvessző alakja az R-ben pont. nulla egészrészű tizedestörtek esetében az értéktelen nullát elhagyhatjuk.Használhatunk az R-ben exponenciális alakú és hexadecimális (16-os számrendszerű) számokat .Az exponenciális alakú számokat e vagy E karakter vágja ketté, egy bal oldali és egy jobb oldali részre. Az exponenciális alakú szám értéke: bal oldali rész szorozva 10 annyiadik hatványával, mint amennyi jobb oldali rész. Érdemes időt szentelni az exponenciális alakú számok értelmezésére, mert az R outputokban gyakran előfordulnak: szám előjelét bal oldali rész előjele dönti el, viszont nagyságrendjét jobb oldali szám nagyságrendje és előjele együtt határozza meg.Az exponenciális alakú számok nagy előnye, hogy nagyon kis, illetve nagyon nagy számok nagyságát jobban meg tudjuk ítélni, és persze az ilyen alakú számok leírásánál helyet megtakarítunk.Az R automatikusan exponenciális alakra vált túl kicsi vagy túl nagy számok konzolbeli megjelenítésénél. Ezt viselkedést az R egyik globális opciójának beállításával tudjuk némileg szabályozni. globális opciókat az options() függvénnyel tudjuk állítani az R-ben (?options), amelyben scipen= paramétert kell megadnunk. Minél nagyobb pozitív értéket adunk meg, annál jobban törekszik az R számok fix alakú megjelenítésére, negatív érték megadásánál pedig ugyanez igaz az exponenciális alakra.16-os számrendszerű számok írásához 0-9 és kis -f vagy nagy -F betűket használhatjuk fel. hexadecimális számokat 0x vagy 0X előtag vezeti .Aritmetikai műveleteinkben rendszerint double típusú számokat, 10-es számrendszerben és fix (nem exponenciális) alakban használunk. De ettől bármikor eltérhetünk:számok megjelenését konzolban még egy globális opció befolyásolja. digits megszabja, hány értékes jegyre pontosan jelenjenek meg számaink konzolban. Lehetséges értékei az 1-22 tartományba esnek, alapértelmezés szerint 7 az értéke. beállított érték csak egy ajánlás az R számára, és főképp tizedestörtek esetén okozhat meglepetést, ha túl kicsire állítjuk digits értékét.Természetesen objektumokat létrehozhatunk numerikus értékek tárolására, ahogyan korábban már láttuk. Az objektum típusa konstans típusával fog megegyezni:","code":"\n0.04; .04; -.04 # utóbbi egy negatív szám, a nulla egészrész megadása nélkül\n#> [1] 0.04\n#> [1] 0.04\n#> [1] -0.04\n12e3; 12E+3; 12e-3; 0xa2e; 0Xa2e\n#> [1] 12000\n#> [1] 12000\n#> [1] 0.012\n#> [1] 2606\n#> [1] 2606\n0.0000000000000000000000000016726         # proton tömege (kg)\n#> [1] 1.6726e-27\n0.00000000000000000000000000000091093822  # elektron tömege (kg)\n#> [1] 9.109382e-31\n100000000        # ennyi fele kell figyelni egy diáknak (százmillió)\n#> [1] 1e+08\n5970000000000000000000000                 # A Föld tömege (kg)\n#> [1] 5.97e+24\noptions(scipen= 0)       # az alapértelmezés\n0.0000001                # túl kicsi: exponenciális lesz\n#> [1] 1e-07\n123                      # marad fix alakú \n#> [1] 123\n100000000                # túl nagy: exponenciális lesz\n#> [1] 1e+08\noptions(scipen=-8); 0.0000001; 123; 100000000 # exponenciális lesz mind\n#> [1] 1e-07\n#> [1] 1.23e+02\n#> [1] 1e+08\noptions(scipen= 8); 0.0000001; 123; 100000000 # fix lesz mind\n#> [1] 0.0000001\n#> [1] 123\n#> [1] 100000000\noptions(scipen= 0)       # az alapértelmezés visszaállítása\n12L + -3.04 + 3.4e2 + -0x1af  # számok 4 különböző formában\n#> [1] -82.04\noptions(digits = 1); 12.36\n#> [1] 12\noptions(digits = 2); 12.36\n#> [1] 12\noptions(digits = 3); 12.36\n#> [1] 12.4\noptions(digits = 4); 12.36\n#> [1] 12.36\noptions(digits = 7)        # alapértelmezés visszaállítása\npeter.magassaga <- 181                                  # double objektum\npeter.sulya     <- 72L                                  # integer objektum\npeter.bmi       <- peter.sulya /(peter.magassaga/100)^2 # double objektum"},{"path":"az-r-nyelv.html","id":"karakteres-konstansok","chapter":"5 Az R nyelv","heading":"5.3.1.2 Karakteres konstansok","text":"Az R-ben karakteres konstans (vagy más néven sztring vagy karaktersorozat) speciális karakterekkel határolt, tetszőleges karaktereket tartalmazó sorozat. karakteres konstans tehát nem egyetlen karaktert jelent tipikusan, hanem többet. Három módszerrel adhatunk meg karakteres konstanst:Karakteres konstansok készítésekor tetszőleges karaktersorozatunkat dupla (\") vagy egyszeres (') idézőjellel kell körbevennünk, de az R 4.0.0-ás verziójától az r\"(tetszőleges_karaktersorozat)\" forma elérhetővé vált. Láthatjuk, hogy az R dupla idézőjelet részesíti előnyben az output megjelenítése során.Egy karakteres konstans tetszőleges karaktert (betűt, számjegyet, írásjeleket, szóközt stb.) tartalmazhat, egyedül azt határolójelet kell elkerülnünk, amelyet az illető karakteres konstans létrehozásánál használtuk.karakteres konstansok tartalmazhatnak ún. escape szekvenciákat, olyan backslash jellel (\\, fordított perjel) kezdődő karaktersorozatokat, amelyeket speciálisan értelmez az R. legfontosabb escape szekvenciákat és jelentésüket az ?? táblázat tartalmazza.Természetesen, karakteres objektumokat létrehozhatunk.Karakteres operátor az R-ben nincs, de számos karakterkezelő függvény segíti sztringek kezelését (?? táblázat).","code":"\n\"Látni távol kis falucska tornyát.\"\n#> [1] \"Látni távol kis falucska tornyát.\"\n'Látni távol kis falucska tornyát.'\n#> [1] \"Látni távol kis falucska tornyát.\"\nr\"(Látni távol kis falucska tornyát.)\"\n#> [1] \"Látni távol kis falucska tornyát.\"\nnev <- 'Zsolt'; foglalkozas <- \"festő\"; lakohely <- r\"(Érd)\"\nnev; foglalkozas; lakohely\n#> [1] \"Zsolt\"\n#> [1] \"festő\"\n#> [1] \"Érd\""},{"path":"az-r-nyelv.html","id":"logikai-konstansok","chapter":"5 Az R nyelv","heading":"5.3.1.3 Logikai konstansok","text":"Az eddigiekben megismert numerikus és karakteres konstansok nagyon sokfélék lehetnek, de ugyanígy numerikus és karakteres objektumokhoz nagyon sok lehetséges numerikus és karakteres érték rendelhető. logikai adattípus ezektől lényegesen egyszerűbb típus, mivel összesen két érték tárolására van módunk. Ez logikai igaz és logikai hamis érték, amelyek az R nyelvben TRUE és FALSE logikai értékeket jelentik. Az R logikai értékek írását T és F globális változók bevezetésével segíti, ezek induló értéke TRUE és FALSE logikai érték.Ezeket logikai konstansokat értékadásban szerepeltethetjük, így logikai objektumokat hozhatunk létre.Logikai értékeket vagy objektumokat relációs operátorok segítségével létrehozhatunk (?? táblázat).Numerikus és karakteres adatok lehetnek relációs operátorok bemenő adatai. Numerikus adatok esetén számok nagysága, karakteres adatok esetén az ábécében elfoglalt hely és sztringek hossza (lexikografikus sorrend) alapján végzi az R az összehasonlítást. sztringek lexikografikus összehasonlítása, magyar területi beállítások esetén, magyar ékezetes karaktereket helyesen kezeli.logikai értékkel visszatérő kifejezéseket (egyszerű) logikai kifejezéseknek nevezzük. Ezekből az egyszerű logikai kifejezésekből logikai operátorok segítségével összetett logikai kifejezéseket hozhatunk létre (?? táblázat).","code":"\nfiu <- TRUE; van.kocsija <- FALSE; hazas <- T\nfiu; van.kocsija; hazas\n#> [1] TRUE\n#> [1] FALSE\n#> [1] TRUE"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-3-1-summary","chapter":"5 Az R nyelv","heading":"5.3.1.4 Részösszefoglalás","text":"\nAz adatfeldolgozás során többnyire számokkal és szövegekkel dolgozunk. Az R numerikus és karakteres adatok írásának szabályait pontosan rögzíti. Numerikus konstansok írása matematikában megszokott módon történik (például 12, -24, 12e+3, 0xabc3), azonban fontos megjegyeznünk, hogy tizedestörtek esetében pontot kell használnunk az egész és törtrész elválasztására (például 12.34, -0.04, 3.12e+12). Karakteres konstansok esetében következő formákat használhatjuk: “tetszőleges karakterek”, ‘tetszőleges karakterek’, és r”(tetszőleges karakterek)“. logikai konstansok az adatmanipuláció során nyújtanak segítséget, két leheséges értékük logikai igaz és hamis: TRUE, FALSE vagy rövidebben T, F.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-3-1-exercise","chapter":"5 Az R nyelv","heading":"5.3.1.5 Feladatok","text":"Mi hasonlóság következő három numerikus konstans között: 0xabc, 2748, .2748e4.Az R öt előre definiált konstassal rendelkezik (?Constants). Írassuk ki ezek értékeit, állapítsuk meg típusukat!Az aranymetszés arányszámát (\\(\\phi=\\frac{1+\\sqrt{5}}{2}\\)) írassuk konzolba legalább 8 tizedes pontossággal!Az r\"(tetszőleges karakterek)\" formájú karakteres konstans megadásnak több válozata létezik, soroljunk fel még legalább öt lehetőséget (?Quotes)! Milyen előnyökkel rendelkezik ez megadási forma az idézőjelek és fordított perjel tekintetében?Helyezzünk el idézőjeleket karakteres konstansokban, mindhárom megadási forma mellett!Próbáljuk ki az ?? táblázat karakterkezelő függvényeit! Gépeljük az utolsó oszlopban lévő példákat, és vizsgáljuk meg függvények visszatérési értékét.Próbáljuk ki az ?? táblázat relációs operátorait! Gépeljük példákat és ellenőrizzük az eredményeket.logikai operátorok működéséről teljes képet kaphatunk az ?? táblázatból. Próbáljuk ki ezeket parancsokat !","code":""},{"path":"az-r-nyelv.html","id":"adatszerkezetek-áttekintése","chapter":"5 Az R nyelv","heading":"5.3.2 Adatszerkezetek áttekintése","text":"Az előző fejezetben láttuk, hogy az R-ben leírható értékek alapvetően 4 típusba sorolhatók. Ezek double, az integer, karakteres és logikai alaptípusok. Ezen értékek felhasználásával nagyon egyszerűen tudunk objektumokat létrehozni. Ezek az objektumok, mindjárt látjuk, az R legalapvetőbb adatszerkezetének, vektornak az egyelemű változatai.fenti objektumok típusa rendre double, integer, karakteres és logikai. Ezt könnyen ellenőrizhetjük typeof() vagy class() függvényekkel. typeof() az objektum alaptípusát adja meg, class() pedig inkább az R objektum-orientált lehetőségeihez kapcsolódó függvény, de fenti objektumok esetében nagyon hasonló eredményt szolgáltat, és későbbiek során sokat fogjuk használni. Egyedül double objektumokok esetén tér el visszatérési értéke, class() ugyanis ekkor numeric outputot adja.Az adatelemzési problémáink megoldásához egyszerre több adatérték feldolgozására van szükséges. Mivel az R nyelvet statisztikai adatfeldolgozásra tervezték, így nem csodálkozhatunk azon, ha több értéket el tudunk tárolni egymás utáni memóriahelyeken fenti 4 alaptípusból (double, integer, karakteres és logikai). Ezt többféleképp megtehetjük, például egy vagy több dimenzió mentén, illetve keverhetjük típusokat vagy ragaszkodhatunk az azonos típusba tartozó értékek egymásutánjához. Ennek megfelelően több különböző R adatszerkezettel kell számolnunk. Ebben fejezetben az R leggyakrabban használt adatszerkezetit tekintjük át. felsoroljuk és jellemezzük őket:vektor - Azonos alaptípusú értékeket egymás után sorolunk fel, egy dimenzó mentén.mátrix - Azonos alaptípusú értékekből egy kétdimenziós szerkezetet hozunk létre, amelynek vannak sorai és oszlopai.faktor - Integer értékeket egymás után teszünk, egy dimenzió mentén, de megadjuk, hogy melyik szám milyen címkét jelöl.lista - Tetszőleges típusú objektumokat egymás után sorolunk fel, egy dimenzió mentén.adattábla - Tetszőleges típusú, de azonos elemszámú objektumokat egymás után sorolunk fel. Tipikusan azonos hosszúságú vektorokat vagy faktorokat teszünk egymás mellé, és így egy kétdimenziós szerkezetet kapunk, amelynek vannak sorai és oszlopai.Az 5.1 ábra összefoglalja az adatszerkezetek fenti tulajdonságait. Beszélünk numerikus (double vagy integer), karakteres és logikai vektorokról, melyek egydimenziósak és homogének, azaz azonos típusú adatokat tartalmaznak. Ugyanez igaz mátrixokra, csak két dimenzióban, sorokkal és oszlopokkal. faktor egy integer vektor (azaz egydimenziós és homogén), azonban külön nyilvántartást vezet arról, hogy az egyes integer értékeknek milyen címke felel meg. Az adattábla lesz legfontosabb adatszerkezet számunkra: kétdimenziós, de oszlopai homogének, hiszen ezek vektorok (numerikus, karakteres vagy logikai) vagy faktorok lehetnek. lista legszabadabb adatszerkezet, egydimenziós, de elemei bármilyen adtszerkezethez tartozhatnak. Például az 5.1 ábrán egy 8 elemű lista jelenik meg, amelynek első eleme egy numerikus vektor, utolsó eleme pedig egy adattábla.\nÁBRA 5.1: Az R legfontosabb adatszerkezetei\nAz ?? táblázatban más szempontból mutatjuk az adatszerkezeteket: példát mutatunk adott típusú (adatszerkezetű) objektumok létrehozására, és közöljük, hogy typeof() és class() milyen outputot szolgáltat az így létrehozott objektumok esetében.következő alfejezetekben részletesen áttekintjük vektor, mátrix, faktor, lista és az adattábla adatszerkezeteket, ugyanis ezek töltik legfontosabb szerepet az adatelemzések során. Mindegyik esetben megvizsgáljuk:hogyan hozhatjuk létre az adott adatszerkezetű objektumot,hogyan tesztelhetjük, hogy az adott típusú objektumról van-e szó,hogyan konvertálhatunk más adatszerkezetekből ilyen típusú objektumot,milyen műveletekben vehet részt,hogya érhetjük el az objektum részeit, azaz hogyan indexelhetjük az objektumokat.","code":"\nobj.double     <- 12.03\nobj.integer    <- 12L\nobj.karakteres <- \"Péter\"\nobj.logikai    <- TRUE\ntypeof(obj.double);     class(obj.double)\n#> [1] \"double\"\n#> [1] \"numeric\"\ntypeof(obj.integer);    class(obj.integer)\n#> [1] \"integer\"\n#> [1] \"integer\"\ntypeof(obj.karakteres); class(obj.karakteres)\n#> [1] \"character\"\n#> [1] \"character\"\ntypeof(obj.logikai);    class(obj.logikai)\n#> [1] \"logical\"\n#> [1] \"logical\""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-4-summary","chapter":"5 Az R nyelv","heading":"5.3.2.1 Részösszefoglalás","text":"\nkülönböző típusú konstansokat objektumok létrehozására használhatjuk fel. statisztikában egy objektumok értéke több konstas egymásutánja. legegyszerűbb adatszerkezet az R-ben vektor, amelyben tetszőlegesen sok, azonos típusú értéket helyezhetünk el egy dimenzió mentén. faktor és lista egydimenziós, míg mátrix és az adattábla kétdimenziós. faktor integer vektor, amelyben számoknak címkéket feleltetünk meg. lista elemi tetszőleges típusúak lehetnek. mátrix ugyanúgy homogén, minta vektor és faktor. Az adattábla felfogható azonos elemszámú vektorok/faktorok listájának.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-4-exercise","chapter":"5 Az R nyelv","heading":"5.3.2.2 Feladatok","text":"Próbáljuk ki az ?? táblázatban szereplő példákat. Hozzuk létre különböző típusú objektumokat és vizsgáljuk meg typeof() és class() függvényekkel az objektumok típusát.","code":""},{"path":"az-r-nyelv.html","id":"vektor","chapter":"5 Az R nyelv","heading":"5.3.3 Vektor","text":"Az R legalapvetőbb adatszerkezete vektor. vektort egymás melletti (vagy alatti) cellákban tárolt értékek sorozataként képzelhetjük el (5.1 ábra), mely értékek mindegyike azonos típusú. Így azt mondhatjuk, hogy vektor azonos típusú (egynemű, homogén) adatok egydimenziós együttese. vektor fontos jellemzője, hogy homogén, tehát vektort alkotó értékek vagy kizárólag integer, vagy kizárólag double, vagy kizárólag karakteres, vagy kizárólag logikai típusúak lehetnek.","code":""},{"path":"az-r-nyelv.html","id":"vektor-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.3.1 Vektor létrehozása","text":"Vektort legegyszerűbben c() függvénnyel hozhatunk létre, az argumentumlistában egymás felsoroljuk vektort alkotó értékeket. Double vektort hozhatunk létre például, ha paraméterben numerikus konstansokat sorolunk fel:v.d objektum egy 4 elemű double vektor. Az első eleme 2, második eleme 4, harmadik 6 és negyedik egyben utolsó eleme 8. vektor elemei szóközökkel elválasztva jelennek meg konzolban.Karakteres vektort hasonlóan hozhatunk létre, v.k vektor 3 elemű lesz.Egy logikai vektor csak logikai konstansokat tartalmazhat (TRUE vagy FALSE, illetve T és F rövidebb változatot használhatjuk):v.d, v.k és v.l objektum egy-egy példa az R különböző típusú vektoraira. Az objektumok fontos jellemzője az objektum hossza, ami vektorok esetén vektort alkotó elemek számát jelenti. Ezt length() függvénnyel kérdezhetjük le.vektor hosszát létrehozása után módosíthatjuk, szintén length() függvényt használjuk, de az értékadás bal oldalán.v.l logikai vektor már 5 elemű lesz:Mivel nem adtuk meg 4. és 5. elemét, így az NA lesz, ami hiányzó érték jele az R-ben. Az NA minden vektornak eleme lehet, vektor típusától függetlenül.Térjünk vissza vektorok létrehozásához. c() függvény paraméterébe természetesen konstansok helyett tetszőleges kifejezéseket írhatunk:vektorok esetében homogenitás központi szerepet játszik. Az R abban az esetben sem fog különböző típusú elemekből vektort létrehozni, ha ezeket egyetlen c() függvényhívásban szerepeltetjük. Ekkor automatikus típuskonverzió történik. Nézzük ezeknek az eseteit:Amennyiben karakteres konstans szerepel az elemek között, vektor karakteres típusú lesz. Ha numerikus és logikai értéket sorolunk fel, akkor vektor numerikus lesz, azzal kiegészítéssel, hogy TRUE logikai érték 1-re, FALSE pedig 0-ra konvertálódik.További lehetőség c() függvény használata során, hogy paraméterben vektort szerepeltethetünk. Ekkor ezek az elemek szerepelni fognak az eredményvektorban:fenti példában létrehozott uj.v 13 elemű numerikus vektor összerakásához felhasználtunk két 3 elemű vektort és egy kételemű vektort .Vektorok létrehozása során még egy érdekes lehetőségről érdemes szót ejteni. c() függvényben vektor egyes elemeit elnevezhetjük, és ezek nevek az outputban meg fognak jelenni. Az elemek elnevezéséhez írjünk egy nevet és egy egyenlőségjelet az argumentumként használt elem elé. Ha név nem egyetlen szó (vagyis tartalmaz szóközt), akkor karakterkonstansok megadásánál látott három módszer valamelyikét használhatjuk (tehát dupla és szimpla idézőjeleket és az r\"()\" konstrukciót), vagy backtick (`) szimbólumot. Ezzel módszerrel például naponta tanulással töltött időnket úgy rögzíthetjük, hogy az output “beszédesebb” lesz, több információt tartalmaz.vektorelemek nevei lekérdezhetők names() függvénnyel. Amennyiben értékeadás bal oldalán szerepeltetjük, vektor elemneveit módosítani tudjuk.","code":"\nv.d <- c(2, 4, 6, 8); v.d  # numerikus (double) vektor létrehozása\n#> [1] 2 4 6 8\nv.k <- c(\"erős\", 'közepes', \"gyenge\"); v.k # karakteres vektor létrehozása\n#> [1] \"erős\"    \"közepes\" \"gyenge\"\nv.l <- c(TRUE, FALSE, T); v.l  # logikai vektor létrehozása\n#> [1]  TRUE FALSE  TRUE\nlength(v.d); length(v.k); length(v.l)  # vektor hossza\n#> [1] 4\n#> [1] 3\n#> [1] 3\nlength(v.l) <- 5  # vektor hosszának módosítása\nv.l\n#> [1]  TRUE FALSE  TRUE    NA    NA\nv.i <- c(12L, NA, 15L)  # 3 elemű integer vektor; a 2. eleme nem ismert\nszamok <- c(1, (2+3)*4, 1/4, .5^3);        szamok\n#> [1]  1.000 20.000  0.250  0.125\nnevek  <- c(\"Péter\", paste0('Zso', \"lt\")); nevek\n#> [1] \"Péter\" \"Zsolt\"\niteletek <- c(T, 1<2, 2==3);               iteletek\n#> [1]  TRUE  TRUE FALSE\neset.1 <- c(2,4,\"6\",8);    eset.1\n#> [1] \"2\" \"4\" \"6\" \"8\"\neset.2 <- c(T, FALSE,\"6\"); eset.2\n#> [1] \"TRUE\"  \"FALSE\" \"6\"\neset.3 <- c(T, FALSE, 3);  eset.3\n#> [1] 1 0 3\nregi.v.1 <- c(1, 2, 3)\nregi.v.2 <- c(7, 8, 9)\nuj.v <- c(0, regi.v.1, 4, 5, 6, regi.v.2, 10, c(11, 12)); uj.v\n#>  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12tan.ido <- c(Hétfő=35, Kedd=95); tan.ido\n#> Hétfő  Kedd \n#>    35    95\ntan.ido <- c(Hétfő=35, \"Kedd délelőtt\"=50, `Kedd délután`=45); tan.ido\n#>         Hétfő Kedd délelőtt  Kedd délután \n#>            35            50            45\nnames(tan.ido)                         # elemnevek lekérdezése\n#> [1] \"Hétfő\"         \"Kedd délelőtt\" \"Kedd délután\"\nnames(tan.ido) <- c(\"H\", \"K.1\", \"K.2\") # elemnevek módosítása\ntan.ido\n#>   H K.1 K.2 \n#>  35  50  45"},{"path":"az-r-nyelv.html","id":"szabalyosvektorokalfejezet","chapter":"5 Az R nyelv","heading":"5.3.3.2 Szabályos vektorok létrehozása","text":"Ha egy vektor elemi szabályos rendben követik egymást, akkor szabályos vektorokról beszélünk. Ilyen lehet például következő három numerikus vektor és két karakteres vektor.Szabályos numerikus vektorokat hozhatunk létre kettőspont (:) operátorral vagy seq() függvénnyel. Az így létrehozott vektorok ugyanis valamilyen számtani sorozat egymást követő elemei, vagyis az egymás mellett lévő elemek különbsége állandó.legegyszerűbb vektorlétrehozási mód kettőspont (:) operátor, ahol az egymást követő elemek távolsága 1 vagy -1. Általános alakja: start:stop.Látható, hogy az így létrehozott vektorok lehetnek csökkenő vagy növekvő rendezettségűek, valamint tört értékeket használhatunk operandusként. sorozat nem feltétlenül kettőspont utáni értékig tart, mindössze annyi igaz, hogy sorozat vége stop értéknél mindig kisebb egyenlő (vagy nagyobb egyenlő, csökkenő sorozat esetén).Hosszabb numerikus vektorokat könnyűszerrel létrehozhatunk. 101:140 parancs hatására 40 elemet hozunk létre. Hosszabb vektorok outputjában könnyebben el tudunk igazodni sorok elején lévő [x] konstrukció segítségével: minden sorban sor első eleme vektor x. eleme. lenti otputban szereplő [17] például azt mutatja, hogy sor elején lévő 117 40 elemű vektor 17. eleme.seq() függvény nagyobb szabadságot ad numerikus sorozatok generálására. Legegyszerűbb használata esetén kettőspont (:) operátort kapjuk vissza:seq() függvény használatához négy argumentum nevét és jelentését kell megtanulnunk: = sorozat első elemét határozza meg, = az utolsó elemet, = lépésközt és length.= létrehozandó vektor elemeinek számát. négy paraméterből három megadása már egyértelműen azonosítja kívánt vektort:seq_along() függvénnyel szintén tudunk 1-től induló, 1-es lépésközű sorozatot alkotni, amelynek utolsó értéke, paraméterben megadott vektor elemszáma.Tetszőleges típusú vektor létrehozására használhatjuk rep() függvényt, amely egy létező vektor értékeit ismétli meg. rep() első paramétere az ismétlendő vektor, times= pedig az ismétlések számát adja meg.fenti példában mindenhol háromszor ismételtük meg az első paramétert, méghozzá úgy, hogy az R egymás után sorolta fel őket.Egy vektor ismétlésének van egy másik esete , amikor az elemeit sorban egyenként véve végezzük el az ismétlést. Ekkor nem times= paramétert, hanem az = argumentumot kell használnunk függvény hívásánál.Látjuk, hogy egyelemű vektorok ismétlése esetén nincs különbség times= és az = paraméterek használata között.Utolsó esetként elemenként szeretnénk ismételni, de eltérő ismétlésszámmal. Ekkor times= paraméterben bemenő vektor elemszámával azonos hosszú vektort kell megadni. Ez vektor tartalmazza az elemek ismétlés számát.Végezetül bemutatjuk, hogy az = és az egyelemű értékkel rendelkező times= egyszerre alkalmazható. Ekkor előszőr helyben ismétlés (=), majd az így kapott vektor teljes ismétlése következik (times=).Szabályos karakteres vektor létrehozására használhatjuk paste0() függvényt. Egy előtaghoz (például f.) hozzáfűzhetünk 10 különböző számot, amely így egy 10 elemű karakteres vektort eredményez.collapse= argumentum használatával, akár egyetlen karakteres értékbe összeolvaszthatjuk fenti elemeket. Az argumentumban az összevonásnál használt elválasztó karaktert adjuk meg.Az eddigiek összefoglalásaként nézzünk példát különbüző típusú és elemhosszú vektorok létrehozására.","code":"\nc(1, 2, 3, 4, 5); c(1, 3, 5, 7); c(1, 1, 1, 2, 2, 2)\nc(\"férfi\", \"nő\", \"férfi\", \"nő\"); c(\"f.1\", \"f.2\", \"f.3\")\n1:10\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n10:1\n#>  [1] 10  9  8  7  6  5  4  3  2  1\n-1.5:5\n#> [1] -1.5 -0.5  0.5  1.5  2.5  3.5  4.5\n10.5:3\n#> [1] 10.5  9.5  8.5  7.5  6.5  5.5  4.5  3.5\n101:140\n#>  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116\n#> [17] 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132\n#> [33] 133 134 135 136 137 138 139 140\nseq(1, 10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nseq(from=1, to=10, by=2)\n#> [1] 1 3 5 7 9\nseq(from=1, to=10, length.out=5)\n#> [1]  1.00  3.25  5.50  7.75 10.00\nseq(to=10, by=1.3, length.out=5)\n#> [1]  4.8  6.1  7.4  8.7 10.0\nseq(from=1, by=1.3, length.out=5)\n#> [1] 1.0 2.3 3.6 4.9 6.2\nx <- c(\"Hétfő\", \"Kedd\", \"Szerda\"); y <- 11:20\nseq_along(x)\n#> [1] 1 2 3\nseq_along(y)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nrep(2, times=3)\n#> [1] 2 2 2\nrep(c(2, 0, -2), times=3)\n#> [1]  2  0 -2  2  0 -2  2  0 -2\nrep(\"nap\", times=3)\n#> [1] \"nap\" \"nap\" \"nap\"\nrep(c(F, T, T), times=3)\n#> [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\nrep(2, each=3)\n#> [1] 2 2 2\nrep(c(2, 0, -2), each=3)\n#> [1]  2  2  2  0  0  0 -2 -2 -2\nrep(\"nap\", each=3)\n#> [1] \"nap\" \"nap\" \"nap\"\nrep(c(F,T,T), each=3)\n#> [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\nrep(c(2, 3, 4), times=c(1, 2, 3))\n#> [1] 2 3 3 4 4 4\nrep(c(\"nap\", \"part\"), times=c(2, 3))\n#> [1] \"nap\"  \"nap\"  \"part\" \"part\" \"part\"\nrep(c(T, F, T), times=c(2, 3, 4))\n#> [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nrep(1:5, each=2, times=3)\n#>  [1] 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5\npaste0(\"f.\", 1:10)\n#>  [1] \"f.1\"  \"f.2\"  \"f.3\"  \"f.4\"  \"f.5\"  \"f.6\"  \"f.7\"  \"f.8\"  \"f.9\"  \"f.10\"\npaste0(\"f.\", 1:10, collapse = \"_\")\n#> [1] \"f.1_f.2_f.3_f.4_f.5_f.6_f.7_f.8_f.9_f.10\"\ny <- 12L                        # y 1 elemű integer vektor\ny <- 12                         # y 1 elemű double\ny <- \"Bízz magadban!\"           # y 1 elemű karakteres\ny <- TRUE                       # y 1 elemű logikai\ny <- c(23.8, -5)                # y 2 elemű double\ny <- c(\"H\", \"K\")                # y 2 elemű karakteres\ny <- c(T, FALSE)                # y 2 elemű logikai\ny <- c(1, 2, 3, 4, 5)           # y 5 elemű double\ny <- 1:5                        # y 5 elemű integer\ny <- seq(from=9, to=100, by=2)  # y 46 elemű double\ny <- rep(c(\"H\", \"K\"), times=10) # y 20 elemű karakteres\nz <- seq_along(y)               # z 20 elemű integer\ny <- paste0(\"év.\", 2001:2020)   # y 20 elemű karakteres"},{"path":"az-r-nyelv.html","id":"a-vektoraritmetika-szabályai","chapter":"5 Az R nyelv","heading":"5.3.3.3 A vektoraritmetika szabályai","text":"Amint az előzőekben láttuk, az R rendszer legalapvetőbb adattárolási szerkezete vektor. Az R egyik legnagyszerűbb tulajdonsága pedig az, ahogyan vektorokkal műveleteket végezhetünk. Korábban már láttuk, hogyan tudunk összeadni két számot az R-ben. Próbáljunk meg összeadni két 2 elemű vektort:két fenti vektort parancssorban hoztuk létre c() függvénnyel. Az összeadás eredménye egy 2 elemű vektor. Az eredményvektor az 1+3 és 2+4 műveletek alapján jött létre, vagyis az összeadás operandusaiban szereplő vektor azonos sorszámú elemeire hajtotta végre kijelölt műveletet az R.Két vektor összeadásánál természetesen használhatunk objektumneveket :Itt az eredményvektor 3 elemű, és komponensenkénti műveletvégrehajtás szabályainak megfelelően az 1+2, 2+3 és 3+4 összeadások eredménye lesz 3 új elem.Az összeadás műveletet tetszőleges operátorral felcserélhetjük, használhatjuk az összes aritmetikai, relációs és logikai operátort.fenti műveletek közül hatványozás végrehajtása tűnhet kicsit szokatlannak, itt ugyanis egy 3 elemű vektort, mint alapot egy 3 elemű másik vektorra, mint kitevőre emeljük. Ha azonban komponensenkénti végrehajtás szabályát észben tartjuk, akkor világos, hogy az eredményvektor az 1^2, 2^3 és 3^4 eredménye.\nkomponensenkénti végrehajtás szabálya logikai operátorokra érvényes.vektorok közötti műveletek legegyszerűbb esetét tekintettük át eddig, azaz azonos elemszámú vektorokat adtunk össze vagy vontunk ki egymásból. Ha az operátor két oldalán lévő vektorok elemszáma eltér, akkor az általános szabály az, hogy rövidebbik vektort az R megismétli mindaddig, míg hosszabbik vektor elemszámát el nem éri. Ha rövidebbik vektort nem egész számszor megismételve kapjuk hosszabb vektor hosszát, akkor figyelmeztetést kapunk az R-től, melyben erre tényre felhívja figyelmünket, de kijelölt műveletet az R ennek ellenére végrehajtja.fenti példában egy 2 elemű és egy 1 elemű vektort adunk össze. rövidebb vektort még egyszer megismételve már az c(5, 5) vektort kapjuk, így kijelölt összeadás minden fennakadás nélkül végrehajtható. Az eredményvektor az 1+5 és 2+5 összeadások eredménye lesz.egy 2 elemű és egy 3 elemű vektort adunk össze.rövidebbik vektort még egyszer megismételve c(1, 2, 1, 2) vektort kapjuk, de mivel nincs szükség minden elemére, ezért figyelmeztető üzenetet kapunk. Az eredményvektor az 1+3, 2+4 és 1+5 összeadások eredménye lesz. következő példában már nincs figyelmeztetés, hiszen rövidebb vektort egész számszor, pontosan kétszer kellett megismételni koordinátánkénti műveletvégrehajtáshoz.Foglaljuk össze vektoraritmetka szabályait: azonos elemszámú vektorok között az azonos pozícióban lévő vektorelemek között hajtódik végre kijelölt művelet (vagyis koordinátánkénti végrehajtás történik), különböző elemszámú vektorok esetében pedig először rövidebbik vektor ismétléssel kiegészül hosszabbik vektor hosszára, és ezt követi koordintánkénti végrehajtás.Az operátorokon túl az ?? táblázatban szereplő matematikai függvények támogatják vektor paramétert. Ekkor nem egyetlen értékkel térnek vissza, hanem bemenő vektor minden elemére kiszámolt függvényértékek vektorával.","code":"\nc(1, 2) + c(3, 4)\n#> [1] 4 6\nx <- c(1, 2, 3); y <- c(2, 3, 4)\nx + y\n#> [1] 3 5 7\nc(1,2) - c(2,3)\n#> [1] -1 -1\nx <- c(1, 2, 3); y <- c(2, 3, 4)\nx-y\n#> [1] -1 -1 -1\nx*y\n#> [1]  2  6 12\nx/y\n#> [1] 0.5000000 0.6666667 0.7500000\nx^y\n#> [1]  1  8 81\nx==y\n#> [1] FALSE FALSE FALSE\nx<y\n#> [1] TRUE TRUE TRUE\n!c(T, T, F, F)\n#> [1] FALSE FALSE  TRUE  TRUE\nc(T, T, F, F) & c(T, F, T, F)\n#> [1]  TRUE FALSE FALSE FALSE\nc(T, T, F, F) | c(T, F, T, F)\n#> [1]  TRUE  TRUE  TRUE FALSE\nc(1, 2)+5\n#> [1] 6 7\nc(1, 2) + c(3, 4, 5)\n#> Warning in c(1, 2) + c(3, 4, 5) :\n#>   longer object length is not a multiple of shorter object length\n#> [1] 4 6 6\nc(1, 2)+c(3, 4, 5, 6)\n#> [1] 4 6 6 8\nsqrt(c(4, 9, 16))              # 3 szám négyzetgyöke\n#> [1] 2 3 4\nlog(x=c(1, 10, 100), base=10)  # 3 szám 10-es alapú logaritmusa\n#> [1] 0 1 2\nx <- 1.3:10; round(x)          # 9 szám egészre kerekítve \n#> [1] 1 2 3 4 5 6 7 8 9"},{"path":"az-r-nyelv.html","id":"függvények-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.4 Függvények vektorokkal","text":"Az előző fejezetben láttuk, hogy matematikai függvények vektor argumentumot elfogadnak, és vektor minden elemére kiszámolják függvényértéket. Míg log(x=16, base=2) függvényhívás matematikában megszokot módon egyetlen bemenő értékhez (16) egyetlen kimenő éréket szolgáltat (4), addig az R lehetőségeit jobban kihasználó log(x = c(1, 2, 4, 8, 16), base=2) függvényhívás négy bemenő értékből (c(1, 2, 4, 8, 16)) négy kimenő érték c(0, 1, 2, 3, 4) állít elő. függvények és vektorok kapcsolatának azonban van egy másik aspektusa, amely szorosan kötődik statisztikai műveletek végrehajtásához.Az R-ben számos függvény olyan vektort vár az argumentumában, amely nem egy elemet, hanem tipikusan több tizet vagy százat tartalmaz. Ezeket függvényeket vektor alapú függvényeknek nevezzük, és az R statisztikai mutatókat számoló függvényei ebbe csoportba tartoznak. vektor alapú függvényekre az jellemző, hogy bemenő vektor elemeivel egy előre definiált műveletsorozatot hajtanak végre, például összadják vektor elemeit, kiszámolják az elemek átlagát vagy szórását, és visszatérési értékként ezt az összeget, átlagot vagy szórást szolgáltatja. legfontosabb vektor alapú függvényeket az ?? táblázat tartalmazza.","code":""},{"path":"az-r-nyelv.html","id":"típusok-kezelése","chapter":"5 Az R nyelv","heading":"5.3.3.5 Típusok kezelése","text":"Minden R vektor típusa négy alaptípus egyike lehet: double, integer, karakteres vagy logikai. Korábban láttuk, hogy class() és typeof() függvények pontos tájékoztatást adnak vektorok típusáról. Létezik azonban egy függvénycsalád, amellyel megvizsgálhatjuk, hogy egy tetszőleges objektum az adott típushoz tartozik-e. Ez az .*() függvénycsalád, amelynek eleme az .double(), .integer(), .logical() ésis.character() függvény. Nézzünk egy példát használatukra.Láttuk korábban, hogy logikai értékek esetében, ha szükséges, automatikus típuskonverzió történik numerikus típusra (TRUE - 1, FALSE - 0). Sok esetben azonban explicit típuskonverzióra van szükség, amit az .*() függvénycsaláddal hajthatunk végre. Vektorok esetében használhatjuk az .double(), .integer(), .logical() vagy .character() függvényeket. Nézzünk ezekre néhány példát.","code":"\nx.d <- c(3.5, 4.1, 9.2)  # új objektum - double vektor\nis.double(x.d)           # x.d vajon double?\n#> [1] TRUE\nis.integer(x.d)          # x.d vajon integer?\n#> [1] FALSE\nis.character(x.d)        # x.d vajon karakteres?  \n#> [1] FALSE\nis.logical(x.d)          # x.d vajon logikai?\n#> [1] FALSE\nas.double(c(T, F))              # logikai vektorból double \n#> [1] 1 0\nas.integer(c(\"2.9\", \"a\", \"3\"))  # karakteres vektorból integer\n#> [1]  2 NA  3\nas.character(1:5)               # integer vektorból karakteres           \n#> [1] \"1\" \"2\" \"3\" \"4\" \"5\"\nas.logical(0:3)                 # integer vektorból logikai\n#> [1] FALSE  TRUE  TRUE  TRUE"},{"path":"az-r-nyelv.html","id":"az-na-hiányzó-érték","chapter":"5 Az R nyelv","heading":"5.3.3.6 Az NA hiányzó érték","text":"Korábbi példáinkban már felbukkant hiányzó érték, amelyet az R-ben az NA jelöl. Az adatelemzési munkánkat végigkísérik hiányzó adatok. Első lépésként azt jegyezzük meg, hogy az NA hiányzó érték tetszőleges típusú vektorban lehet elem.Egy NA érték jelenlétét vektorban az .na() függvénnyel tudjuk kimutatni. Az .na() argumentuma tetszőleges vektor lehet, visszatérési értéke pedig bemenő vektor elemszámával megegyező logikai vektor. visszatérő logikai vektor csak abban pozícióban tartalmaz TRUE értéket, ahol bemenő vektorban hiányzó adatot találunk.Hiányzó értékeket tartalmazó vektor esetén néhány vektor alapú függvény meglepő eredményt adhat. statisztikai mutatókat számoló függvények rendre NA-val térnek vissza, ha bemenő vektorban van hiányzó érték.Ha kíváncsiak vagyunk az NA értéken kívüli elemek átlagára, akkor egy második paramétert szerepeltetnünk kell mean() függvényben, és minden más statisztikai mutatót számoló függvényben. Az na.rm= argumentum TRUE értéke biztosítja, hogy az átlag számítása során hiányzó értékeket figyelmen kívül hagyjuk.","code":"\nx <- c(2, NA, 4); x              # NA numerikus vektorban\n#> [1]  2 NA  4\nx <- c(NA, \"erős\", \"gyenge\"); x  # NA karakteres vektorban\n#> [1] NA       \"erős\"   \"gyenge\"\nx <- c(T, NA, NA); x             # NA logikai vektorban\n#> [1] TRUE   NA   NA\nx <- c(1, NA, 3, 4, NA)    # két NA numerikus vektorban\nis.na(x)                   # két TRUE a logikai vektorban\n#> [1] FALSE  TRUE FALSE FALSE  TRUE\nmean(c(1:10,NA))\n#> [1] NA\nmean(c(1:10,NA), na.rm=T)\n#> [1] 5.5"},{"path":"az-r-nyelv.html","id":"az-inf-és-a-nan","chapter":"5 Az R nyelv","heading":"5.3.3.7 Az Inf és a NaN","text":"Az R-ben numerikus műveletek eredménye – matematikai értelmezéstől sokszor eltérően – vezethet pozitív vagy negatív végtelen eredményre. Ezeket az Inf és -Inf szimbólumok jelölik, amelyeket különböző kifejezésekben akár mi felhasználhatunk.Néhány esetben numerikus kifejezések eredménye nem értelmezhető számként, ezt az R-ben NaN (“Number”) jelöli. Ilyen kifejezések például:Egy kifejezés véges vagy végtelen voltát az .finite() vagy .infinite() függvényekkel tesztelhetjük. NaN értékre az .nan() függvénnyel kérdezhetünk rá. Figyeljük meg, NaN értékre, mind az .nan(), mind az .na() függvény TRUE értéket ad.","code":"\n1/0               \n#> [1] Inf\nlog(0)\n#> [1] -Inf\nexp(Inf)\n#> [1] Inf\nmean(c(1,2,Inf))\n#> [1] Inf\n0/0\n#> [1] NaN\nInf-Inf\n#> [1] NaN\nInf/Inf\n#> [1] NaN\nx <- c(1, NA, NaN, Inf, -Inf)\nis.na(x)\n#> [1] FALSE  TRUE  TRUE FALSE FALSE\nis.nan(x)\n#> [1] FALSE FALSE  TRUE FALSE FALSE\nis.infinite(x)\n#> [1] FALSE FALSE FALSE  TRUE  TRUE\nis.finite(x)\n#> [1]  TRUE FALSE FALSE FALSE FALSE"},{"path":"az-r-nyelv.html","id":"vektor-indexelése","chapter":"5 Az R nyelv","heading":"5.3.3.8 Vektor indexelése","text":"Fontos részhez érkeztünk, érdemes kicsit lassítanunk. Már nagyon sok mindent megtanultunk vektorokról: egy vektorban egy dimenzió mentén azonos típusú értékeket sorolhatunk fel, amellyel vektoraritmetika szabályai szerint műveleteket tudunk végezni. Például hozzunk létre egy 10 elemű vektort, növeljük meg minden egyes vektorelem értékét 1-gyel.fenti sorok hatására konzolban egy 10 elemű vektor elemei jelennek meg, minden elem 1-gyel nagyobb, mint az x adott eleme. Egyetlen összeadás (+) operátor segítségével valójában 10 összeadás végrehajtását írtuk elő. Vegyük észre, hogy maga az x vektor nem módosult, továbbra az eredeti 11:20 elemeket tartalmazza. Egy objektum ugyanis addig őrzi az értékét, amíg értékadó operátor segítségével felül nem írjük.Tekintsük következő sorokat.Az y vektor 10 elemű, 11:20 értékekkel hoztuk létre. második sorban azonban megváltoztatjuk az y értékét, mert újra az értékadás bal oldalán szerepel az y objektum. Az y új értéke az értékadás jobb oldalán szereplő kifejezés értéke lesz, azaz y+1 összeadás eredménye, ami nem más mint 12:21. Az y értékének megjelenítésével ellenőrizhetjük, hogy valóban 12:21 elemek kerülnek konzolba.fenti példában y minden értékét megváltoztattuk. Az eredeti 11:20 helyett az új érték 12:21. Az y vektor minden egyes eleme megváltozott, például ahol 11 volt, ott 12 van, ahol 12 volt ott 13. Ha szükség van az eredeti és az új y értékekre akkor kicsit módosítanunk kell az eddigi sorokon.z vektor 10 elemű, 11:20 kezdőértéke, és jól látható, hogy fenti sorok hatására ez nem változik meg, hiszen z újra már nem jelenik meg értékadás bal oldalán. Értékadás jobb oldalán viszont felbukkan, második sorban z.uj objektum létrehozásához használtuk fel z értékét. Az z és z.uj objektumok értékének kiírásával ellenőrizhetjük, hogy z továbbra biztonságosan tárolja 11.20 értékeket, de z.uj-ban kívánt 12:21 módosított értékek megtalálhatók. további munkafázisokban így az eredeti és módosított értékek elérhetők lesznek, ami újdonság, mert az előző példákban ez lehetőség nem volt elérhető. Az x objektumot használó példában csak az eredeti, az y vektoros példában csak módosított értékeket tudnánk későbbiekben használni.Összefoglalva az eddigieket, két tanulságot vonhatunk le. Egyfelől, vektorműveleteknek csak akkor lesz “maradandó” hatása, ha objektumban őrizzük számítás eredményét, azaz értékadást használunk. Ez az objektum lehet kindulásként használt erdeti objektum (y <- y + 1), de biztonságosabb ha új objektumot hozunk létre az új értékek számára (z.uj <- z + 1), mert így az eredeti értékeket jövőben tudjuk használni. Másfelől, ezek példák ráirányítják figyelmet vektoraritmetika egy nagyszerű jellemzőjére: vektorműveletek megadása független vektor hosszától, nem lesz bonyolultabb egy vektorművelet, például az x+1 összeadás ha x nem 10 elemű, hanem mondjuk 100 hosszú. Az összeadás művelet parancsa 100 elemű vektor esetén csupán x+1, azonban háttérben nem 10, hanem 100 összeadás történik. Akár 10, akár 100 elemű az x, az összes elemre az x segítségével hivatkozhatunk, és az x+1 összeadás az x összes eleméhez hozzáad 1-et. De mit tegyünk, ha nincs szükségem x összes elemére, vagy nem szeretném x összes elemét megnövelni 1-gyel, csak néhányat. Ekkor indexelést kell használnunk.Az adatfeldolgozás során gyakori, hogy vektor egyes elemeit külön-külön szeretnénk elérni, lekérdezni vagy módosítani. vektor egy tetszőleges részét, egy vagy több elemét az indexelés művelettel érhetjük el, melynek eredménye szintén vektor lesz. Az index operátor jele szögletes zárójel ([]) az R-ben, amit vektor neve után kell írnunk. Vektorok indexelésének általános alakja:Az indexvektor lehet numerikus, karakteres és logikai vektor . Nézzük ezeket sorban.","code":"\nx <- 11:20         # x integer vektor létrehozása\nx + 1              # kiíratjuk az 1-gyel megnövelt értékeket (x nem változik)\n#>  [1] 12 13 14 15 16 17 18 19 20 21\nx                  # x értékének kiírása\n#>  [1] 11 12 13 14 15 16 17 18 19 20\ny <- 11:20         # y integer vektor létrehozása\ny <- y + 1         # megnöveljük 1-gyel y értékeit (y megváltozik)\ny                  # y értékének kiírása \n#>  [1] 12 13 14 15 16 17 18 19 20 21\nz    <- 11:20         # z integer vektor létrehozása\nz.uj <- z + 1         # z.uj double vektor létrehozása (z nem változik)\nz                     # z értékének kiírása\n#>  [1] 11 12 13 14 15 16 17 18 19 20\nz.uj                  # z.uj értékének kiírása\n#>  [1] 12 13 14 15 16 17 18 19 20 21vektor[indexvektor]        # az eredmény egy vektor"},{"path":"az-r-nyelv.html","id":"indexelés-numerikus-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.8.1 Indexelés numerikus vektorokkal","text":"Kezdjük egy 10 elemű x vektor létrehozásával.Megfigyelhetjük, hogy az x vektor 1. eleme 11, 2. 12, az utolsó, 10. pedig éppen 20. Ebben felsorolásban az elemek sorszámai (1., 2., 10.) pontosan vektor indexeit jelentik. vektor indexelése tehát 1-gyel kezdődik, ez az 1. elem indexe, 2. elem indexe 2, az utolsó elemé pedig 10. Ha az index operátorba egy ilyen egyszerű sorszámot írunk, akkor vektor adott indexű elemét érhetjük el.Nem csak lekérdezhetjük, hanem az értékadó operátor segítségével módosíthatjuk valamelyik elemet.Itt először második elemet 100-ra cseréljük, majd harmadikat második kétszeresére. változást ellenőrizhetjük konzolban. Ha az x vektort az elemszámánál nagyobb indexszel próbáljuk elérni, akkor NA értéket kapunk:Vektorokat azonban nem csak egy elemű indexvektorokkal indexelhetünk, hanem két vagy több elemű numerikus vektorokat használhatunk. Ebben az esetben az indexvektorban felsorolt sorszámoknak megfelelő indexű elemeket érhetjük el.fenti példákban látható, hogy az indexelés során létrejött vektorok elemszáma az indexvektor elemszámával egyenlő. Egy indexet akár többször felsorolhatunk, és tetszőleges sorrend megengedett. szöglegetes zárójelben lévő indexvektort helyben elkészíthetjük c() és seq() függvénnyel (vagy bármilyen más vektorlétrehozó függvénnyel), vagy kettőspont (:) operátorral, de korábban létrehozott objektumot használhatunk indexelésre (x[y]).Az indexelés során több vektorelemet egy lépésben tudunk módosítani. Az indexelt elemek kaphatnak azonos vagy különböző értéket. Itt vektoraritmetikai szabályai kezdenek működni.fenti példában az x vektor három-három elemét módosítjuk az egyes értékadások során. Az értékadó operátor (<-) engedelmeskedik vektoraritmetika szabályainak, azaz az értékadás bal és jobb oldalán szereplő vektorokat tekinthetjük két olyan vektornak, amelyek között műveletet szeretnénk végrehajtani. Az első értékadásban azonos elemszámú két vektor, koordintánkénti értékadás azonnal megtörténik (x[c(1, 2, 3)] <- c(110, 120, 130)). másik két értékadásban különbözik két vektor elemszáma, így először ismétléssel kiegészül jobb oldali, rövidebbik vektor, majd ezután következhet koordinátánkénti végrehajtás.Egy vektor indexe mindig egész szám, de az R megengedi, hogy tört értékeket tartalmazó indexvektort szerepeltessünk az index operátorban, ekkor az egész részét veszi az indexeknek, egyszerűen csonkolja őket.Negatív értékeket tartalmazó numerikus vektorral indexelhetünk, ekkor negatív előjellel megadott sorszámokon kívül az összes többi elemet tudjuk elérni vagy módosítani.","code":"\nx <- 11:20; x\n#>  [1] 11 12 13 14 15 16 17 18 19 20\nx[1]     # x vektor 1. eleme\n#> [1] 11\nx[2]     # x vektor 2. eleme\n#> [1] 12\nx[10]    # x vektor 10. eleme\n#> [1] 20\nx[2] <- 100       # x 2. elemének módosítása\nx[3] <- 2*x[2]    # x 3. elemének módosítása\nx\n#>  [1]  11 100 200  14  15  16  17  18  19  20\nx[11]     # x csak 10 elemű, a 11. nem létező elem\n#> [1] NA\nx <- 11:20 \nx[c(1, 3, 5)]               # x vektor 1., 3. és 5. eleme\n#> [1] 11 13 15\nx[c(3, 5, 3, 1)]            # x vektor 3., 5. 3. és 1. eleme\n#> [1] 13 15 13 11\nx[3:6]                      # x vektor 3., 4., 5., és 6. eleme\n#> [1] 13 14 15 16\ny <- c(3,7)\nx[y]                        # x vektor 3. és 7. eleme\n#> [1] 13 17\nx[seq(from=2, to=10, by=2)] # x vektor páros indexű elemei  \n#> [1] 12 14 16 18 20\nx <- 11:20           \nx[c(1, 2, 3)] <- c(110, 120, 130) # x 1., 2. és 3. elemét módosítjuk\nx[c(4, 5, 6)] <- 0                # x 4., 5. és 6. elemét módosítjuk\nx[c(7, 8, 9)] <- c(170, 180)      # x 7., 8. és 9. elemét módosítjuk\nx\n#>  [1] 110 120 130   0   0   0 170 180 170  20\nx <- 11:20\nx[2.3]       # x 2. eleme\n#> [1] 12\nx[2.8]       # x 2. eleme\n#> [1] 12\nx <- 11:15\nx[-3]                         # minden x elem, kivéve a 3.\n#> [1] 11 12 14 15\nx[-c(1, 5)]                   # minden x elem, kivéve az 1. és az 5.\n#> [1] 12 13 14\nx[-(1:3)]                     # minden x elem, kivéve az első 3\n#> [1] 14 15\nx[-2] <- 0                    # minden x elem módosul, kivéve a 2.      \nx\n#> [1]  0 12  0  0  0"},{"path":"az-r-nyelv.html","id":"indexelés-karaketeres-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.8.2 Indexelés karaketeres vektorokkal","text":"Amennyiben egy vektor elemei rendelkeznek névvel, akkor karakteres indexvektorokat használhatunk az indexeléshez. Ez meglehetősen nagy könnyebbséget jelent, ugyanis nem kell ismernünk kívánt elem pozícióját, azaz indexét, elegendő fejben tartanunk az elem nevét. Vegyük példaként tanulók matematika versenyen elért pontszámait tartalmazó vektort.Látható, hogy kívánt elem eléréséhez, például Bori matematika teljesítményéhez nem kell ismernünk Bori pontszámának pozícióját, elegendő névre emlékeznünk.","code":"\nx <- c('Peti'=35, 'Bori'=37, 'Éva'=33)\nx[\"Bori\"]                              # x \"Bori\" nevű eleme\n#> Bori \n#>   37\nx[c(\"Peti\", \"Éva\")]                    # x \"Peti\" és \"Éva\" nevű eleme\n#> Peti  Éva \n#>   35   33\nx[c(\"Peti\", \"Éva\")] <- c(36, 34)       # x fenti 2 elemének módosítása\nx\n#> Peti Bori  Éva \n#>   36   37   34"},{"path":"az-r-nyelv.html","id":"indexelés-logikai-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.8.3 Indexelés logikai vektorokkal","text":"Vektorok indexeléséhez logikai vektorokat használhatunk. Első pillanatban kényelmetlennek, sőt feleslegesnek tűnik majd ez lehetőség, de következő fejezetben, vektorok szűrésénél, magunk meggyőződhetünk e módszer káprázatos erejérőlA logikai indexvektor működése nagyon egyszerű. Hossza az indexelenedő vektor hosszával egyenlő, és TRUE logikai értékkel jelezzük, hogy az adott pozíción lévő elemet el akarjuk érni, FALSE értékkel pedig azt, hogy nincs szükség arra az elemre.fenti példában TRUE szerepel az 1., 3. és 4. pozícióban, így az x vektor 1., 3. és 4. elemeit érhetjük el.Az indexelésre használt logikai vektor elemszáma kisebb lehet, mint az indexelt vektor hossza, ekkor az R az indexvektor ismétlésével kapja meg kívánt hosszt.c(T, F) vektor két elemű, az indexelendő x viszont 5 hosszú, így az R ismétléssel előállítja c(T, F, T, F, T) öt elemű vektort, és ezt használja az x indexeléséhez. Ha csupa TRUE értékű vektorral indexelünk, akkor az x vektor összes elemét megkapjuk, ha pedig csupa FALSE értékkel, akkor az üres vektort kapjuk. Az integer(0) az üres integer vektort jelöli.logikai vektorral indexelt vektorelemeket ugyanúgy módosíthatjuk, mint korábban numerikus és karakteres indexvektorok esetén.","code":"\nx <- 11:15\nx[c(T, F, T, T, F)]    # x vektor 1., 3., és 4. eleme    \n#> [1] 11 13 14\nx <- 11:15\nx[c(T, F)]      # x vektor 1., 3. és 5. eleme\n#> [1] 11 13 15\nx[T]            # x vektor összes eleme\n#> [1] 11 12 13 14 15\nx[F]            # x vektor egyik eleme sem\n#> integer(0)\nx <- 11:15\nx[c(T, F)] <- 0                    # x vektor 1., 3. és 5. elemét módosítjuk\nx[c(F, T, F, T, F)] <- c(120, 140) # x vektor 2. és 4. elemét módosítjuk\nx\n#> [1]   0 120   0 140   0"},{"path":"az-r-nyelv.html","id":"indexelesspecna","chapter":"5 Az R nyelv","heading":"5.3.3.8.4 Indexelés speciális értékekkel","text":"Az indexelésnek van néhány speciális esete, amelyet érdemes ismernünk. Vektorok indexelése során az indexoperátor üresen maradhat, ekkor vektor összes elemét elérhetjük, vagyis az x és x[] kifejezések ugyanazt az outputot adják.fenti példákból kiolvasható, hogy NaN és NA indexként való használata egyetlen NA-t, vagy az x hosszának megfelelő számú hiányzó értéket szolgáltat.Legyünk óvatosak, ha az indexvektor tartalmaz NA értéket, akkor az eredménybe azon pozíción szintén NA fog bekerülni.Kerüljük az értékadást NA-t tartalmazó indexvektor használata esetén. fenti példában az értékadás ugyan nem jelez hibát, és ellenőrizhetjük, hogy valóban megtörtént az első két vektorelem módosítása. Azonban az értékadás jobb oldalán több elemű vektor már nem engedélyezett, például az x[c(1, NA, 2)] <- c(100, 200) értékadás hibaüzenethez vezet. Összefoglalva, minden esetben ellenőrizzük, hogy az indexvektortunk tartalmaz-e NA hiányzó értéket.","code":"\nx <- 11:15\nx[]           # x minden eleme\n#> [1] 11 12 13 14 15\nx[NaN]        # egyetlen NA\n#> [1] NA\nx[NA]         # x elemszámának megfelelő NA   \n#> [1] NA NA NA NA NA\nx <- 11:15\nx[c(1, NA, 2)]          # x 1. eleme, NA, és x 2. eleme\n#> [1] 11 NA 12\nx[c(1, NA, 2)] <- 100   # x 1. és 2. elemének módosítása\nx\n#> [1] 100 100  13  14  15"},{"path":"az-r-nyelv.html","id":"vektor-szűrése","chapter":"5 Az R nyelv","heading":"5.3.3.9 Vektor szűrése","text":"Eddig vektorok elemeit pozíciójuk alapján értük el. Akár sorszámot, elemnevet vagy megfelelő pozícióban lévő logkai igaz/hamis értéket használtunk indexelésre, végső soron az számított, hogy az adott elem hol található vektorelemek egydimenziós sorában. Ebben fejezetben egy teljes más kiinduló pontot használni\nunk vektorelemek elérésére és ez vektor tartalma lesz, vagyis vektorelem konkrét értéke (és nem pozíciója).Bővítsük ki matematika pontszámokat tartalmazó vektorunkat, rögzítsük hat tanuló eredményét.Ha arra vagyunk kíváncsiak, hogy kik értek el 36 pontnál többet versenyen és milyen pontszámokkal, akkor rövid áttekintés után megadhatjuk választ, sőt pozíció alapján könnyen elvégezhetjük az alábbi indexeléseket .fenti sorok az eddigiekhez képest semmilyen újdonságot nem tartalmaznak, lényegében összefoglalják pozíció alapú indexelésről tanultakat. Felmerülhet bennünk kérdés, ha x nem hat elemű, hanem 60 vagy esetleg 600, akkor mennyi esélyünk lenne az indexelt kifejezések előállítására. Nem sok.Adódik azonban egy másik lehetőség, ami közvetlenül abból indul ki, hogy 36 pontnál nagyobb vektorelemeket keressük. Logikai művelettel ezt következőképp fogalmazhatjuk meg.Korábban láttuk, hogy ez művelet vektoraritmetikai szabályainak engedelmeskedve két lépésben értelmezhető: (1) mivel különböző elemhosszú két vektor, x hat elemű, 36 egy elemű, először jobb oldal hat elemű lesz (c(36, 36, 36, 36, 36, 36)), majd (2) koordinátánként relációs művelet végrehajtásra kerül, azaz x minden eleméről döntés születik, hogy nagyobb-e mint 36. relációs művelet eredménye egy hat elemű logikai vektor, amely pontosan ott TRUE, ahol az illető x elem nagyobb 36-nál, minden más helyen pedig FALSE. Esetünkben Bori és Ili elemeknél jelenik meg TRUE, vagyis 2. és 6. pozícióban. Vegyük észre, hogy ez pontosan az logikai vektor, mint amit mi hoztunk létre korábban pozíció alapú indexelés egyik példájaként (x[c(F, T, F, F, F, T)]).relációs művelet eredményét, mint logikai vektort kiválóan fel tudjuk használni az indexelésben 36 pontnál nagyobb vektorelemek eléréséhez.fenti sor az első példa szűrésre. szűrés lényegében logikai vektorral való indexelés, ahol logikai indexvektort egy olyan logikai kifejezés állítja elő, amely hivatkozik vektor tartalmára. definíciót értelmezve példára: logikai vektor, amely alapján az indexelés történik c(F, T, F, F, F, T), logikai kifejezés, amely ezt előállítja az x>36, vektor tartalmára pedig természetesen az x objektumnévvel utalunk logikai kifejezésen belül.szűrés nagyszerűen kezeli vektorhosszal kapcsolatban korábban felvetett problémánkat. Ha az x nem hat, hanem 60 vagy 600 elemű, akkor az x[x>36] végzi 36-nál nagyobb elemek leválogatását.Próbáljuk ki szűrést nagyobb elemszám esetén . Generáljunk 60 véletlen értékeket 0-40 értéktartományból, úgy mintha 60 tanuló matematika pontszáma állna rendelkezésre. sample() függvény az x= argumentumában megadott értékekből, size=-ban megadott darabszámnyit állít elő. replace=T argumentummal gondoskodunk arról, hogy egy érték többször szerpelhessen az eredményvektorban.pontszamok vektor 60 elemű, az első 10 értékét képenyőn láthatjuk. 36-nál nagyobb elemek megjelenítését szűréssel végeztük. Látható, hogy szűrés nem lett bonyolultabb vektor hosszának növekedésével.Más relációs operátorokat (?? táblázat) használhatunk szűrésben, sőt logikai operátorok (?? táblázat) segítségével tetszőleges természetes nyelven megfogalmazott feltételt át tudunk fordítani R logikai kifejezésbe. logikai operátorokat tartalmazó logikai kifejezésket összetett logikai kifejezéseknek nevezzük. Írassuk ki pontszámokat 36 és 39 között, majd 3 és 6 között, és végül mindezeket együtt.Időnként szükségünk lehet arra az információra, hogy vektorban melyik pozícióban vannak feltételnek eleget tevő vektorelemek. Erre feladatra () függvényt használhatjuk. () függvény bemenő paraméterként egy logikai vektort vár, visszatérési értéke pedig TRUE logikai értékek indexe lesz.Térjünk vissza matematika pontszámokhoz.Az outputokban nem látjuk tanulók pontszámát, tehát nem szűrés () célja, azoknak vektorelemeknek az indexét látjuk, amelyek az egyszerű vagy összetett logikai kifejezéseknek eleget tesznek.Végezetül tekintsük át szűrés és az értékadás kapcsolatát. Az adatelemzés során előfordulhat, hogy bizonyos feltételnek eleget tevő elemeket módosítani szeretnénk. Például, ha egy vektorban előzetesen hiányzó értékeket 99-cel jelöljük, akkor későbbi hibamentes elemzéshez NA-ra kell módosítanunk ezeket az értékekek.Az x így már helyes módon tartalmazza hiányzó értékeket. Ha esetleg később kiderül ezeknek az elemeknek tényleges értéke, akkor az NA-t kell helyettesítenünk új értékekkel. Vigyázzunk, az x == NA kifejezés helytelen hiányzó értékek tesztelésére, erre az .na() függvényt kell használnunk.Az x vektorban két hiányzó érték volt, így fenti értékadás jobb oldalán két elemű vektort használunk. Ha mindkét hiányzó értéket azonos számmal szeretnénk felülírni, akkor elegendő lenne x[.na(x)] <- 7 kifejezés .Korábban már említettük (5.3.3.8.4 alfejeztben, hogy kerüljük az értékadást NA-t tartalmazó indexvektor használata esetén. Azonban nem minden esetben tudunk kitérni az ilyen esetek elől. Növeljük meg hiányzó értékeket tartalmazó x vektor azon elemeit 1-gyel, amelyek 36-nál kisebbek! nyilvánvalónak látszó x[x < 36] <- x[x < 36] + 1 parancs helytelen, hibaüzenetet ad. Az értékadás mindkét oldalán szükséges az & !.na(x) hozzáfűzése meglévő logikai kifejezéshez.","code":"\nx <- c('Peti'=35, 'Bori'=37, 'Éva'=33, 'Pál'=21, 'Gergő'=34, 'Ili'=40)\nx\n#>  Peti  Bori   Éva   Pál Gergő   Ili \n#>    35    37    33    21    34    40\nx[c(2, 6)]               # indexelés numerikus vektorral\n#> Bori  Ili \n#>   37   40\nx[c(\"Bori\", \"Ili\")]      # indexelés karakteres vektorral\n#> Bori  Ili \n#>   37   40\nx[c(F, T, F, F, F, T)]   # indexelés logikai vektorral\n#> Bori  Ili \n#>   37   40\nx > 36        # relációs művelet, logikai vektort eredményez\n#>  Peti  Bori   Éva   Pál Gergő   Ili \n#> FALSE  TRUE FALSE FALSE FALSE  TRUE\nx[x > 36]       # x vektor szűrése (36-nál nagyobb elemek leválogatása)\n#> Bori  Ili \n#>   37   40\npontszamok <- sample(x = 0:40, size = 60, replace = T) # véletlen értékek\npontszamok[1:10]               # ponszamok vektor első 10 eleme\n#>  [1] 33 15 27 12  5 35  8  5  3 40\npontszamok[pontszamok > 36]    # pontszamok vektor szűrése\n#> [1] 40 40 37 37 40\npontszamok[pontszamok>=36 & pontszamok<=39]\n#> [1] 37 37\npontszamok[pontszamok>=3 & pontszamok<=6]\n#> [1] 5 5 3 3 5 4 5\npontszamok[(pontszamok>=36 & pontszamok<=39) | (pontszamok>=3 & pontszamok<=6)]\n#> [1]  5  5  3 37  3  5 37  4  5\nx <- c('Peti'=35, 'Bori'=37, 'Éva'=33, 'Pál'=21, 'Gergő'=34, 'Ili'=40)\nwhich(x > 36)         \n#> Bori  Ili \n#>    2    6\nwhich(36 <= x & x <= 39)\n#> Bori \n#>    2\nwhich(x == 21)\n#> Pál \n#>   4\nwhich(x != 21)\n#>  Peti  Bori   Éva Gergő   Ili \n#>     1     2     3     5     6\nx[is.na(x)] <- c(5, 7)    # hiányzó értékek módosítása\nx\n#>  Peti  Bori   Éva   Pál Gergő   Ili \n#>    35    37    33    21    34    40\nx <- c(33, NA, 32, 38, NA, 37)\nx[x < 36 & !is.na(x)] <- x[x < 36 & !is.na(x)] + 1"},{"path":"az-r-nyelv.html","id":"vektor-rendezése","chapter":"5 Az R nyelv","heading":"5.3.3.10 Vektor rendezése","text":"Egy vektor elemeit növekvő vagy csökkenő sorrendbe rendezhetjük. Az R-ben vektor elemeit sort() vagy az order() függvénnyel rendezhetjük.sort() függvény alapértelmezés szerint növekvő sorrendbe rendezi bemeneti vektort, ha azonban decreasing= paramétert TRUE-ra állítjuk, csökkenő rendezést kapunk. rev() függvénnyel, amely bementi vektor elemeit fordított sorrendben sorolja fel, szintén elérhetjük csökkenő rendezettséget.Ha sort() függvénnyel átrendezett vektort továbbiakban fel szeretnénk használni, akkor azt érdemes új objektumban tárolni (x.2 <- sort(x)).vektor rendezésének másik módja az order() függvényhez kapcsolódik. visszatérési érték ekkor egy numerikus indexvektor, amellyel bemenő vektort indexelve rendezett vektort kapunk.Az order() függvény esetében használhatjuk decreasing= paramétert, amellyel csökkenő sorrendbe rendezhetjük vektorunkat.numerikus vektorokon túl karakteres és logikai vektorokat sorba rendezhetjük sort() és order() függvényekkel.","code":"\nx <- c(1:5, 5:3)\nx\n#> [1] 1 2 3 4 5 5 4 3\nsort(x)               # x elemei növekvő sorrendben\n#> [1] 1 2 3 3 4 4 5 5\nsort(x, decreasing=T) # x elemei csökkenő sorrendben, vagy: rev(sort(x))\n#> [1] 5 5 4 4 3 3 2 1\nx <- c(1:5, 5:3)\norder(x)\n#> [1] 1 2 3 8 4 7 5 6\nx[order(x)]\n#> [1] 1 2 3 3 4 4 5 5\nx[order(x, decreasing=T)];\n#> [1] 5 5 4 4 3 3 2 1"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-5-summary","chapter":"5 Az R nyelv","heading":"5.3.3.11 Részösszefoglalás","text":"\nGratulálunk! Maratoni alfejezetünk végigolvasásával jelentős lépést tett meg az Olvasó magabiztos R ismeretek megszerzéséhez. vektor minden adatelemzési munka alapja, biztos kezelése kulcsfontosságú. Tetszőleges vektor létrehozásához c() függvényt használhatjuk, és az elemeket akár nevesíthetjük . Szabályos vektort seq(), seq_along() és rep() függvénnyel, vagy kettőspont (:) operátorral készíthetünk. Megbeszéltük vektorok közötti műveletek végrehajtásának fő szabályát: ismétléssel hozzuk azonos hosszra vektorokat ha szükséges, majd koordinátánként végezzük el kívánt műveletet. vektorokat támogatják matematikai függvények , minden vektorelemre meghívódik függvény. statisztikai függvények szintén vektort várnak, de többnyire egy értéket szolgáltatnak. vektorok típusának tesztelése az .(), konvertálása pedig az .() függvényekkel történik.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-5-exercise","chapter":"5 Az R nyelv","heading":"5.3.3.12 Feladatok","text":"Hozzuk létre következő numerikus vektort: 12, 14, 17.Hozzuk létre következő karakteres vektort: “Vác,” “Eger,” “Pécs.”Hozzuk létre következő logikai vektort: TRUE, FALSE, FALSE.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és különbség 1.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 102, az utolsó 8 és különbség -1.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és különbség 2.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, különbség 3 és vektor 25 elemű.Hozzuk létre azt numerikus vektort, amely 12 elemű, és minden elemének -2 az értéke!Hozzuk létre azt karakteres vektort, amely 7 elemű, és minden elemének “Péntek” az értéke!Hozzuk létre azt logikai vektort, amely 7 elemű, és minden elemének TRUE az értéke!Hozzuk létre azt numerikus vektort, amely 2, 3, 5 elemeket háromszor egymás után megismétli! Hány elemű az így létrejött vektor?Hozzuk létre azt numerikus vektort, amely 2, 3, 5 elemeket háromszor helyben megismétli! Hány elemű az így létrejött vektor?Hozzuk létre azt numerikus vektort, amely 2, 3, 5 elemeket helyben megismétli úgy, hogy 2-őt 4-szer, 3-5-ször és az 5-öt 7-szer ismétli meg! Hány elemű az így létrejött vektor?Szabályos vektorok létrehozásának van egy korábban még nem említett módja: sequence() függvény. Ismerjük meg súgóból ezt függvényt, és értelmezzük sequence(4) és sequence(c(4,5)) függvényhívásokat!Vektorok létrehozásának számos módját megismertük ebben fejezetben, de elemek megadása nélkül, vagy akár nulla hosszúsággal létrehozhatunk vektort. double(), integer(), character() és logical() függvények közvetlenül az adott típusnak megfelelő vektort hozzák létre. súgó tanulmányozásával állítsunk elő 0 és 10 elemű vektor objektumokat mind négy típus esetén.Próbáljuk ki az ?? táblázatban szereplő példákat.","code":""},{"path":"az-r-nyelv.html","id":"mátrix","chapter":"5 Az R nyelv","heading":"5.3.4 Mátrix","text":"mátrix adatszerkezet egyetlen lényeges dologban különbözik vektortól, mátrix kétdimenziós, sorokba és oszlopokba szervezi az elemeket, míg vektor egydimenziós (érdemes visszalapozni 5.1 ábrához). mátrix ugyanúgy homogén, mint vektor, ennek megfelelően beszélünk double, integer, karakteres és logikai mátrixokról.","code":""},{"path":"az-r-nyelv.html","id":"mátrix-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.4.1 Mátrix létrehozása","text":"Mátrix létrehozásához matrix() függvényt használjuk ki, amely egy kiinduló vektor elemeit használja fel mátrix feltöltéséhez. data= argumentumban kell megadnunk ezt vektort, majd az nrow= és/vagy ncol= argumentumokban közöljük sorok és oszlopok számát.fenti példában 20 elemű vektort 4 sorban rendezi el matrix() függvény, ennek megfelelően 5 oszlopos lesz az x mátrix. matrix() függvényben az ncol= paraméter használható.Az ncol=5 szerepeltetése nem jelent változást az előző példához képest, az x mátrix 4 sort és 5 oszlopot fog tartalmazni, rövidebben 4 \\(\\times\\) 5-ös. következő sorban az ncol=10 argumentum már egy 40 elemű mátrix létrehozását kezdeményezi, így az 1:20 vektor ismétlésével állnak elő szükséges elemek. (Figyelmeztetést kapunk, ha szükséges mátrixelemszám eléréséhez nem egész számszor kell ismételni kiinduló vektort, de mátrix ebben az esetben létre fog jönni.)fenti példában azt megfigyelhetjük, hogy 20 elemű vektorból oszlopfolytonosan jön létre mátrix, vagyis először az első oszlop töltődik fel vektorelemekkel, majd második, és így tovább. Ha sorfolytonosan szeretnénk bemenő vektor elemeiből mátrixot képezni, akkor byrow= paramétert igazra kell állítanunk.Mátrixot karakteres vagy logikai értékekből építhetünk.Az előző fejezetben láttuk, hogy vektorok elemeinek nevet adhatunk, így olvashatóbbá tehetjük rögzített adatainkat. matrix() függvény dimnames= argumentumában az egyes sorok és oszlopok elnevezéséről, valamint két dimenzió nevéről gondoskodhatunk.dimnames= argumentum dimenzió-, sor- és oszlopneveket listába rendezve várja. listákról 5.3.6 fejezetben olvashatunk. sor- és oszlopnevek megadásánál tartsuk az objektumok elnevezésével kapcsolatos szabályokat, azaz betűvel kezdjünk, kerüljük szóközt és egyéb írásjeleket, de tagolásra pontot használjuk.Létező mátrix esetén rownames() és colnames(x) függvényekkel tudjuk sor- és oszlopneveket lekérdezni, illetve módosítani.","code":"\nx <- matrix(data=1:20, nrow=4)        # 4x5-ös integer mátrix\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nx <- matrix(data=1:20, nrow=4, ncol=5)        # 4x5-ös integer mátrix\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nx <- matrix(data=1:20, nrow=4, ncol=10)       # 4x10-es integer mátrix\nx\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17    1    5    9   13    17\n#> [2,]    2    6   10   14   18    2    6   10   14    18\n#> [3,]    3    7   11   15   19    3    7   11   15    19\n#> [4,]    4    8   12   16   20    4    8   12   16    20\nx <- matrix(1:12, nrow=3, byrow=T)    # 3x4-es integer mátrix\nx\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    2    3    4\n#> [2,]    5    6    7    8\n#> [3,]    9   10   11   12\nmatrix(c(\"az\",\"egy\"), nrow=2, ncol=3, byrow=T) # 2x3-as karakteres mátrix\n#>      [,1]  [,2]  [,3] \n#> [1,] \"az\"  \"egy\" \"az\" \n#> [2,] \"egy\" \"az\"  \"egy\"\nmatrix(c(T,F,T), nrow=2, ncol=6, byrow=T)      # 2x6-os logikai mátrix   \n#>      [,1]  [,2] [,3] [,4]  [,5] [,6]\n#> [1,] TRUE FALSE TRUE TRUE FALSE TRUE\n#> [2,] TRUE FALSE TRUE TRUE FALSE TRUE\nx <- matrix(0, nrow = 2, ncol = 3, \n      dimnames = list('1. dim. neve'=c(\"sor.1\", \"sor.2\"),\n                      '2. dim. neve'=c(\"oszl.1\", \"oszl.2\", \"oszl.3\")))\nx\n#>             2. dim. neve\n#> 1. dim. neve oszl.1 oszl.2 oszl.3\n#>        sor.1      0      0      0\n#>        sor.2      0      0      0\nrownames(x)                           # sornevek lekérdezése\n#> [1] \"sor.1\" \"sor.2\"\ncolnames(x)                           # oszlopnevek lekérdezése\n#> [1] \"oszl.1\" \"oszl.2\" \"oszl.3\"\nrownames(x) <- c(\"eset.1\", \"eset.2\")  # sornevek módosítása\ncolnames(x) <- c(\"o.1\", \"o.2\", \"o.3\") # oszlopnevek módosítása\nx\n#>             2. dim. neve\n#> 1. dim. neve o.1 o.2 o.3\n#>       eset.1   0   0   0\n#>       eset.2   0   0   0"},{"path":"az-r-nyelv.html","id":"mátrix-indexelése","chapter":"5 Az R nyelv","heading":"5.3.4.2 Mátrix indexelése","text":"mátrixok indexelése nagyon hasonló vektorok indexeléséhez. Itt az index operátort ([]) kell használnunk, de két dimenzió miatt vesszővel választjuk el sorra és az oszlopra vonatkozó indexeket. Mátrix indexelésének általános alakja:sorinedexvektorra és az oszlopindexvektorra ugyanazok szabályok érvényesek, mint vektor esetén az indexvektorra. Használhatunk numerikus, karakteres és logikai egy vagy több elemű vektort, numerikus idexeknél negatív értéket, és természetesen el hagyhatjuk az egyes dimenziók indexvektorait. Nézzünk ezekre néhány példát.mátrix indexelése során kapott új adatszerkezetek elveszthetik kétdimenziós jellegüket és így mátrix helyett vektor lehet az indexelés eredménye. Ha ezt el akarjuk kerülni, használjuk drop=FALSE paramétert az indexben, ekkor minden esetben mátrix lesz az eredmény.Amennyiben mátrixunk sor- és oszlopnevekkel rendelkezik, akkor ezeket felhasználhatjuk az indexelés során.","code":"mátrix[sorindexvektor, oszlopindexvektor] # az eredmény egy mátrix vagy egy vektor\nx <- matrix(1:10, nrow=2, ncol=5, byrow=T)\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    6    7    8    9   10\nx[2, 3]                     # 1 elem elérése, vektor output\n#> [1] 8\nx[2, c(1,4)]                # 2 elem elérése, vektor\n#> [1] 6 9\nx[, c(1,4)]                 # 4 elem elérése, 2x2-es mátrix \n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    6    9\nx[, -c(1,4)]                # 6 elem elérése, 2x3-as mátrix\n#>      [,1] [,2] [,3]\n#> [1,]    2    3    5\n#> [2,]    7    8   10\nx[1, ]                      # 5 elem elérése, vektor\n#> [1] 1 2 3 4 5\nx[c(2, 1), c(T, F, T)]      # 6 elem elérése, 2x3-as mátrix\n#>      [,1] [,2] [,3]\n#> [1,]    6    8    9\n#> [2,]    1    3    4\nx[2, 3, drop=F]             # 1 elem elérése, 1x1-es mátrix output\n#>      [,1]\n#> [1,]    8\nx[2, c(1,4), drop=F]        # 2 elem elérése, 1x2-es mátrix \n#>      [,1] [,2]\n#> [1,]    6    9\nx[2, , drop=F]              # 5 elem elérése, 1x5-ös mátrix\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    6    7    8    9   10\nx[, 3, drop=F]              # 2 elem elérése, 2x1-es mátrix\n#>      [,1]\n#> [1,]    3\n#> [2,]    8\nx <- matrix(1:10, nrow=2, ncol=5, byrow=T)\nrownames(x) <- c(\"eset1\", \"eset2\")\ncolnames(x) <- paste0(\"sz.\", 1:5)\nx\n#>       sz.1 sz.2 sz.3 sz.4 sz.5\n#> eset1    1    2    3    4    5\n#> eset2    6    7    8    9   10\nx[\"eset1\", c(\"sz.2\", \"sz.1\")]     # 2 elem elérése, vektor output\n#> sz.2 sz.1 \n#>    2    1\nx[1:2, c(\"sz.2\", \"sz.1\")]         # 4 elem elérése, 2x2-es mátrix\n#>       sz.2 sz.1\n#> eset1    2    1\n#> eset2    7    6\nx[\"eset2\", paste0(\"sz.\", 1:3)]    # 3 elem elérése, vektor\n#> sz.1 sz.2 sz.3 \n#>    6    7    8\nx[\"eset1\", c(T,F), drop=F]        # 3 elem elérése, 1x3-as mátrix\n#>       sz.1 sz.3 sz.5\n#> eset1    1    3    5"},{"path":"az-r-nyelv.html","id":"számítások-a-mátrix-soraiban-és-oszlopaiban","chapter":"5 Az R nyelv","heading":"5.3.4.3 Számítások a mátrix soraiban és oszlopaiban","text":"Az előző részben említettük, ha üresen hagyjuk mátrix sor vagy oszlop pozícióját az indexelés során, akkor mátrix teljes oszlopára vagy sorára tudunk hivatkozni, vagyis alapesetben vektort kapunk. Az így kapott vektorokkal tetszőleges műveleteket hajthatunk végre. Hozzunk létre egy 3 \\(\\times\\) 4-es mátrixot, amely 3 tanuló átlagát tartalmazza 4 tantárgyból.Négy speciális függvénnyel az oszlopok és sorok összegét és átlagát számíthatjuk ki.Általánosabb megoldás, ha az apply() függvényt használjuk, amelyben mátrix soraira vagy oszlopaira vonatkozó függvényt mi határozzuk meg, így az összegzésen és az átlagszámításon kívül más függvényket elérhetünk. Az apply() első paramétere maga mátrix, második helyen pedig 1 vagy 2 áll, attól függően, hogy mátrix soraira (1) vagy oszlopaira (2) akarjuk harmadik paraméterben szereplő függvényt alkalmazni.","code":"\nx <- matrix(c(3.7, 5.3, 5.1, 4.2, 4.4, 3.8, 2.9, 4.2, 5.1, 4, 3, 5), \n            nrow=3, ncol=4, byrow=T, \n            dimnames = list(c(\"Pál\", \"Ili\", \"Éva\"),\n                            c(\"matek\", \"magyar\", \"angol\", \"ének\")))\nx\n#>     matek magyar angol ének\n#> Pál   3.7    5.3   5.1  4.2\n#> Ili   4.4    3.8   2.9  4.2\n#> Éva   5.1    4.0   3.0  5.0\nmean(x[1,])      # Pál féléves átlaga    \n#> [1] 4.575\nsd(x[,4])        # énekből a csoport átlaga \n#> [1] 0.4618802\nrowSums(x)      # sorösszegek, a tanulók jegyeinek összege\n#>  Pál  Ili  Éva \n#> 18.3 15.3 17.1\nrowMeans(x)     # sorátlagok, a tanulók félév végi átlaga\n#>   Pál   Ili   Éva \n#> 4.575 3.825 4.275\ncolSums(x)      # oszlopösszegek, a tantárgyak jegyeinek összege\n#>  matek magyar  angol   ének \n#>   13.2   13.1   11.0   13.4\ncolMeans(x)     # oszlopátlagok, a tantárgyak átlaga\n#>    matek   magyar    angol     ének \n#> 4.400000 4.366667 3.666667 4.466667\napply(x, 1, mean)    # sorátlagok, a tanulók félév végi átlaga\n#>   Pál   Ili   Éva \n#> 4.575 3.825 4.275\napply(x, 1, sd)      # soronkénti szórások\n#>       Pál       Ili       Éva \n#> 0.7544314 0.6652067 0.9844626\napply(x, 1, min)     # soronkénti minimumok\n#> Pál Ili Éva \n#> 3.7 2.9 3.0\napply(x, 2, mean)    # oszlopátlagok, a tantárgyak átlaga\n#>    matek   magyar    angol     ének \n#> 4.400000 4.366667 3.666667 4.466667\napply(x, 2, sd)      # oszloponkénti szórások\n#>     matek    magyar     angol      ének \n#> 0.7000000 0.8144528 1.2423097 0.4618802\napply(x, 2, min)     # oszloponkénti minimumok\n#>  matek magyar  angol   ének \n#>    3.7    3.8    2.9    4.2"},{"path":"az-r-nyelv.html","id":"sorok-és-oszlopok-kezelése","chapter":"5 Az R nyelv","heading":"5.3.4.4 Sorok és oszlopok kezelése","text":"Mátrixokat az rbind() és cbind() függvényekkel építhetünk.Vektor paraméterek esetén, felsorolt vektorok fogják alkotni az új mátrix oszlopait (cbind() esetén), illetve sorait (rbind() esetén), rövidebb vektor, ha van ilyen, ismétlődni fog.Új oszloppal vagy új sorral kiegészíthetjük már létező mátrixunkat.Tetszőleges pozícióba beszúrhatunk egy oszlopot vagy egy sort. Ehhez első lépésben létező x mátrixhoz hozzáillesztjük az új oszlopot vagy sort, majd indexeléssel átrendezzük az oszlopokat vagy sorokat.Hasznos lehetőség összesítő sorok vagy oszlopok mátrixhoz fűzése és elnevezése:sorok vagy oszlopok sorrendjét megcserélhetjük mátrixban, valamint ezek törlésére van lehetőségünk:","code":"\ncbind(1, 1:2, 1:4)    # mátrix létrehozása oszlopvektorokból\n#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    2    2\n#> [3,]    1    1    3\n#> [4,]    1    2    4\nrbind(1, 1:2, 1:4)    # mátrix létrehozása sorvektorokból\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    1    1    1\n#> [2,]    1    2    1    2\n#> [3,]    1    2    3    4\nx <- matrix(1:12, nrow=4, ncol=3); x\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]    4    8   12\ncbind(-3:0, x, 13:16)  # oszlopvektorok hozzáfűzése x elé és mögé\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   -3    1    5    9   13\n#> [2,]   -2    2    6   10   14\n#> [3,]   -1    3    7   11   15\n#> [4,]    0    4    8   12   16\nrbind(-1, x, 1)        # sorvektorok hozzáfűzése x fölé és alá      \n#>      [,1] [,2] [,3]\n#> [1,]   -1   -1   -1\n#> [2,]    1    5    9\n#> [3,]    2    6   10\n#> [4,]    3    7   11\n#> [5,]    4    8   12\n#> [6,]    1    1    1\ncbind(x, 13:16)[, c(1,2,4,3)]\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    5   13    9\n#> [2,]    2    6   14   10\n#> [3,]    3    7   15   11\n#> [4,]    4    8   16   12\nrbind(x, -1)[c(1, 2, 3, 5, 4),]\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]   -1   -1   -1\n#> [5,]    4    8   12\nx <- rbind(x,apply(x,2,mean))\nrownames(x) <- c(1:4,\"átlag\")\nx\n#>       [,1] [,2] [,3]\n#> 1      1.0  5.0  9.0\n#> 2      2.0  6.0 10.0\n#> 3      3.0  7.0 11.0\n#> 4      4.0  8.0 12.0\n#> átlag  2.5  6.5 10.5\nx <- matrix(1:12, nrow=4, ncol=3); x\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]    4    8   12\ny <- x[, c(2, 3, 1)]          # oszlopcsere\ny <- x[c(3, 2, 4, 1), ]       # sorcsere\ny <- x[, c(1, 3)]             # a 2. oszlop törlése\ny <- x[c(1, 3), ]             # az 2. és a 4. sor törlése"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-6-summary","chapter":"5 Az R nyelv","heading":"5.3.4.5 Részösszefoglalás","text":"\nmátrix homogén kétdimenziós adatszerkezet, és többnyire matrix() függvénnyel hozzuk létre. Indexelése [] operátorral történik, ahol sor- és oszlopindex megadásra van lehetőségünk.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-6-exercise","chapter":"5 Az R nyelv","heading":"5.3.4.6 Feladatok","text":"Hozzunk létre egy csupa 1-ből álló mátrixot, amelynek 3 sora és 2 oszlopa van!Hozzunk létre egy 3 \\(\\times\\) 4-es karakteres mátrixot, amely 12 különbüző keresztnevet tartalmaz!Hozzunk létre egy 3 \\(\\times\\) 4-es logikai mátrixot, amelynek 1. és 3. sora TURE 2. sora pedig FALSE értékeket tartalmaz!Mátrixok indexelésére olyan speciális indexmátrix használható, amelynek két oszlopa van, és az elérendő elemek sor- és oszlopkoordinátáit tartalmazza. Mutassunk példát erre mátrix[indexmátrix] alakú mátrixindexelésre!","code":""},{"path":"az-r-nyelv.html","id":"faktor","chapter":"5 Az R nyelv","heading":"5.3.5 Faktor","text":"faktor adattípus nagyon hasonló vektorhoz, ugyanis minden faktor egy speciális integer vektor, faktor tehát homogén és egydimenziós adatszerkezet. Faktorokat elsősorban kategorikus változók értékeinek tárolására használjuk, ilyen például személyek neme vagy iskolai végzettsége. faktor egy lényeges ponton több mint egy egyszerű integer vektor. faktor karbantart egy összerendelést az 1-gyel kezdődő numerikus egészek és faktor lehetséges karakteres értékei, címkék között (az 5.1 ábrán ezt egy piros kis téglalappal jelöltük). Egy faktorelem értéke csak ezekből címkékből kerülhet ki, ami nagy fokú védelmet jelent számunkra az adatkezelés során. Ha például létrehozunk egy faktort az (1-\"férfi\", 2-\"nő\") összerendeléssel, akkor egy faktorelem csak \"férfi\" vagy \"nő\" címkéket veheti fel, más értéket nem (az NA hiányzó érték termésetesen lehet faktorelem értéke). munka során mindig címkékkel találkozunk, háttérben lévő numerikus egészek csak ritkán kapnak szerepet.","code":""},{"path":"az-r-nyelv.html","id":"faktor-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.5.1 Faktor létrehozása","text":"faktorokat jellemzően karakteres vagy numerikus vektorokból hozzuk létre factor() függvény segítségével. faktor létrehozásánál mindig gondoskodjunk faktor lehetséges értékeinek, vagyis faktor címkéiknek megadásáról. címkéket néha (faktor)szinteknek (levels) nevezzük. Mivel kategorikus változóink lehetséges értékei többnyire ismertek az adatkezelés elején, faktorszintek felsorolása nem okozhat nehézséget. hozzunk létre egy faktort, amely öt személy nemét tartalmazza.Az x.f faktort az x karakteres vektorból hoztuk létre, így x.f ugyanúgy 5 hosszú, mint az x. Az x.f outputjában olvasható Levels: férfi nő rész azt közli velünk, hogy háttérben az 1 numerikus értéknek \"férfi\" címke, míg 2-nek \"nő\" címke felel meg. belső integer kódok feltárulnak az unclass(x.f) outputjában. szám-címke összerendelést magunk szabályozhatjuk, ha factor() függvény levels= argumentumában módosítunk sorrenden.fenti x.f faktor ugyanannak az 5 személynek nemét tartalmazza, de az összerendelést levels=c(\"nő\", \"férfi\") paraméterrel (1-\"nő\", 2-\"férfi\")-re változtattuk. Láthatjuk, címkék sorrendje faktor értékeitől független, mégis fontos szerepet kap majd táblázatok és ábrák megjelenítésénél, tehát érdemes rá odafigyelni.levels= argumentum szerepeltetése factor() függvényben sok kellemtlenségtől kímélhet meg minket. Ha elhagyjuk, akkor factor() függvény karakteres vektorban aktuálisan rendelkezésre álló értékekből konstruálja meg faktort. Nézzünk erre három esetet.Az első esetben faktor létrehozásához használt karakteres vektor megegyezik korábban látottakhoz, azaz helyesen tartalmazza mind \"férfi\", mind \"nő\" címkéket, így az x.f.1 faktor címkék lexikografikus rendezése alapján az (1-\"férfi\", 2-\"nő\") összerendeléssel jön létre. második esetben karakteres vektorunk elgépelés miatt egy \"Férfi\" címkét tartalmaz, ami az x.f.2 faktor szintjei között meg fog jelenni. harmadik esetben az okozza problémát, hogy 5 azonos nemű személy került mintába, így \"férfi\" címke egyáltalán nem jelenik meg az x.f.3 faktor szintjei között. Az x.f.2 és az x.f.3 faktorok tehát más-más okok miatt, de hibásan tartalmazzák faktorszinteket, és ez későbbi működést alapvetően befolyásolja. Az x.f.2 három különböző nemet ismer, az x.f.3 pedig mindössze egyet. fenti hibák levels= szerepeltetésével könnyen kiküszöbölhetők.fenti példákban látható, hogy \"Férfi\" címke helyére hiányzó érték került, az x.f.3 faktor pedig már \"férfi\" értéket fel tud venni jövőben.Numerikus vektorokból készíthetünk faktorokat. Például könnyebb rögzíthetőség miatt öt személy nemét numerikus vektorban hoztuk létre azzal szabállyal, hogy 0 jelentése nő, az 1 jelentése férfi. faktor létrehozása során ekkor levels= szerepe lehetséges numerikus értékek felsorolása lesz, és plusz paraméterként szereplő labels= segít faktorszintek beszédes elnevezésében. Az elnevezés levels=-ben lévő numerikus értékek sorrendjében történik, ezért nagyon fontos, hogy labels= címkéi kövessék ezt sorrendet.fenti példában látható, hogy levels= értékeinek sorrendje vezérli az elnevezést, 0 mindkét esetben \"nő\", az 1 \"férfi\" címkéhez fog vezetni. Az x.f.1 és x.f.2 faktorok mindössze háttérben lévő összerendelésben különböznek, első esetben az (1-\"nő\", 2-\"férfi\"), míg második esetben az (1-\"férfi\", 2-\"nő\") lesz faktorszintek sorrendje.","code":"\nx <- c(\"férfi\", \"férfi\", \"nő\", \"férfi\", \"nő\")  # karakteres vektor lérehozása\nx.f <- factor(x, levels=c(\"férfi\", \"nő\"))      # faktor létrehozása\nx.f                                            # faktor kiíratása\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: férfi nő\nunclass(x.f)                                   # integer kódok a háttérben\n#> [1] 1 1 2 1 2\n#> attr(,\"levels\")\n#> [1] \"férfi\" \"nő\"\nx.f <- factor(x, levels=c(\"nő\", \"férfi\"))      # faktor létrehozása\nx.f\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: nő férfi\n(x.f.1 <- factor(c(\"férfi\", \"férfi\", \"nő\", \"férfi\", \"nő\")))\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: férfi nő\n(x.f.2 <- factor(c(\"férfi\", \"Férfi\", \"nő\", \"férfi\", \"nő\")))\n#> [1] férfi Férfi nő    férfi nő   \n#> Levels: férfi Férfi nő\n(x.f.3 <- factor(c(\"nő\", \"nő\", \"nő\", \"nő\", \"nő\")))\n#> [1] nő nő nő nő nő\n#> Levels: nő\n(x.f.2 <- factor(c(\"férfi\", \"Férfi\", \"nő\", \"férfi\", \"nő\"),\n                 levels=c(\"férfi\", \"nő\")))   \n#> [1] férfi <NA>  nő    férfi nő   \n#> Levels: férfi nő\n(x.f.3 <- factor(c(\"nő\", \"nő\", \"nő\", \"nő\", \"nő\"),\n                 levels=c(\"férfi\", \"nő\")))\n#> [1] nő nő nő nő nő\n#> Levels: férfi nő\nx <- c(1, 1, 0, 1, 0)     # numerikus vektor létrehozása, 0-nő, 1-férfi\n(x.f.1 <- factor(x, levels=c(0, 1), \n                    labels=c(\"nő\", \"férfi\")))\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: nő férfi\n(x.f.2 <- factor(x, levels=c(1, 0), \n                    labels=c(\"férfi\", \"nő\")))\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: férfi nő"},{"path":"az-r-nyelv.html","id":"szabályos-faktor-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.5.2 Szabályos faktor létrehozása","text":"Ismétlést tartalmazó faktorokat gl() függvénnyel létrehozhatunk. Tipikusan szintek (n=) számát, az ismétlések számát (k=) és címkéket (labels=) szoktuk megadni.","code":"\n(x.f <- gl(n = 3, k = 2))\n#> [1] 1 1 2 2 3 3\n#> Levels: 1 2 3\n(x.f <- gl(n = 3, k = 2, labels=c(\"alap\", \"közép\", \"felső\")))\n#> [1] alap  alap  közép közép felső felső\n#> Levels: alap közép felső"},{"path":"az-r-nyelv.html","id":"faktor-indexelése-és-szűrése","chapter":"5 Az R nyelv","heading":"5.3.5.3 Faktor indexelése és szűrése","text":"Faktor indexelése [] operátorral történik. Indexvektorként numerikus, karakteres és logikai vektorokat használhatunk. Faktor indexelésének átalános alakja:Hozzunk létre egy faktort, amely hat személy dohányzási szokását tartalmazza (D-dohányzik, ND-nem dohányzik).Az indexelés eredménye minden esetben egy faktor lesz, amelynek szintjei alapesetben megegyeznek az eredeti faktor szintjeivel. drop=T argumentum nem használt címkéket eltávolítja faktorszintek közül. Logika kifejezéseket használhatunk az indexelés során, azaz szűrést végezhetünk, de vegyük figyelembe, hogy faktor esetén csak két relációs operátor használható, az egyenlő (==) és nem egyenlő (!=).Indexelt faktor természetesen érékadás bal oldalán szereplhet. faktor adatszerkezet megvéd minket az értékadások során, hiszen egy faktorelem csak faktorszintekben szereplő értékek egyikét veheti fel.Mivel \"nem dohányzik\" címke nem szerepel faktorszintek között, az x.f faktor 2. eleme NA lesz, egy figyelmeztető üzenet kíséretében.","code":"faktor[indexvektor]     # az eredmény egy faktor\n(x.f <- factor(c(\"D\", \"D\", \"ND\", \"D\", \"ND\", \"ND\"), levels = c(\"ND\", \"D\")))\n#> [1] D  D  ND D  ND ND\n#> Levels: ND D\nx.f[1]             # az x faktor 1. eleme (faktorszintek változatlanok)\n#> [1] D\n#> Levels: ND D\nx.f[1, drop=T]     # az x faktor 1. eleme (faktorszintek változtak)\n#> [1] D\n#> Levels: D\nx.f[1:3]           # az x faktor 1., 2. és 3. eleme\n#> [1] D  D  ND\n#> Levels: ND D\nx.f[c(T, F)]       # az x faktor 1, 3. és 5. eleme\n#> [1] D  ND ND\n#> Levels: ND D\nx.f[x.f == \"D\"]    # x szűrése (a dohányzók)\n#> [1] D D D\n#> Levels: ND D\nx.f[x.f != \"D\"]    # x szűrése (a nem dohányzók)\n#> [1] ND ND ND\n#> Levels: ND D\nx.f                        # az x.f faktor kiírása\n#> [1] D  D  ND D  ND ND\n#> Levels: ND D\nx.f[1] <- \"ND\"             # az x.f faktor 1. eleme legális értéket kap\nx.f[2] <- \"nem dohányzik\"  # az x.f faktor 2. eleme NA lesz\nx.f\n#> [1] ND   <NA> ND   D    ND   ND  \n#> Levels: ND D"},{"path":"az-r-nyelv.html","id":"faktorok-kezelése","chapter":"5 Az R nyelv","heading":"5.3.5.4 Faktorok kezelése","text":"faktorok kényelmes használatát két további függvény segíti. Az nlevels() függvénnyel faktorszintek számát ismerhetjük meg, levels() függvénnyel lekérdezhetők és módosíthatók faktorszintek. Nézzünk egy példát az iskolai végzettségel kapcsolatban. Összesen 7 személyről tudjuk, hogy alap-, közép- vagy felsőfokú végzettségű, de az egyszerűbb rögzítés miatt indulásként ezt az információt számokkal kódoltuk (1-alap, 2-közép, 3-felső).Az isk.vegz.f faktort az \"1\", \"2\" és \"3\" címkékkel hoztuk létre, de később levels() függvénnyel beszédesebb faktorszinteket hoztunk létre.","code":"\n# numerikus vektor létrehozása\nisk.vegz   <- c(1, 1, 2, 1, 3, 3, 2)\n# faktor létrehozása\nisk.vegz.f <- factor(isk.vegz, levels=c(\"1\", \"2\", \"3\")) \nisk.vegz.f                              # a faktor értéke\n#> [1] 1 1 2 1 3 3 2\n#> Levels: 1 2 3\nnlevels(isk.vegz.f)                     # a faktor szintjeinek száma\n#> [1] 3\nlevels(isk.vegz.f)                      # a faktor szintjei\n#> [1] \"1\" \"2\" \"3\"\n# a faktor szintjeinek módosítása\nlevels(isk.vegz.f) <- c(\"alap\", \"közép\", \"felső\") \nisk.vegz.f                              # a faktor értéke\n#> [1] alap  alap  közép alap  felső felső közép\n#> Levels: alap közép felső"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-7-summary","chapter":"5 Az R nyelv","heading":"5.3.5.5 Részösszefoglalás","text":"\nfaktor olyan integer vektor, amely az 1-től sorszámozott értékeihez egy-egy karakteres címkét rendel. Ezek címkék alkotják faktorelemek lehetséges értékeit, amelyeket másnéven faktorszinteknek neveznek. faktor létrehozásához factor() függvényt használjuk, és karakteres vektor konstansaiból vagy numerikus vektor címkeként kezelt számértékeiből jönnek létre faktor lehetséges értékei.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-7-exercise","chapter":"5 Az R nyelv","heading":"5.3.5.6 Feladatok","text":"Hozzuk létre azt karakteres vektort, amely férfi, nő karakteres konstansokat, úgy helyezi el egymás mellett, hogy 7 darab férfi érték után 13 db nő címke következik! Hány elemű az így létrejött vektor?Egy vizsgálatban az első 10 személy neme férfi, többi 8 neme nő volt. Hozzuk létre azt faktort, amely leírja neme változót!Egy vizsgálatban városi (“V”) és falusi (“F”) fiatalok vettek részt! megkérdezettek településtípusa rendre következő volt: F, F, V, F , V, V, V, F. Hozzuk létre azt faktort, amely leírja településtípus változót!Egy vizsgálatban dohányzási szokást egy kétértékű skálán mérték: 0-nem dohányzik; 1-dohányzik. megkérdezettek dohányzási szokása következő volt: 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0. Hozzuk létre azt faktort, amely leírja dohányzási szokás változót!","code":""},{"path":"az-r-nyelv.html","id":"listadefalf","chapter":"5 Az R nyelv","heading":"5.3.6 Lista","text":"Az eddig megismert vektor, mátrix és faktor adatszerkezet mindegyike homogén volt, csak azonos típusú értékek tárolására használhatjuk őket. lista típusú adatokban különböző adatszerkezetű elemeket felsorolhatunk, de sem típusra, sem méretre nincs korlátozás. Egy listaelem lehet vektor, mátrix, faktor, adattábla vagy akár egy másik lista (5.1 ábra). Látható, hogy lista az R legszabadabb adatszerkezete, egydimenziós, és célja logikailag összetartozó, de szerkezetileg különböző adatok tárolása.","code":""},{"path":"az-r-nyelv.html","id":"lista-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.6.1 Lista létrehozása","text":"list() függvénnyel hozhatunk létre legegyszerűbben listákat, itt vesszővel elválasztva kell megadnunk lista elemeit.fenti példában x egy 3 elemű lista, az első eleme egy 10 elemű numerikus vektor, második eleme egy 2 elemű karakteres vektor, harmadik eleme pedig egy 1 elemű logikai vektor. harmadik elemnek c nevet adtuk, de bármelyik elemet elnevezhettük volna ezzel módszerrel. Ha lista értékét megjelenítjük képernyőn, akkor listaelemek egymás alatt jelennek meg. Az első két esetben kettős szögletes zárójelben ([[]]) lévő sorszám azonosítja lista elemeit, harmadik esetben pedig listaelem általunk megadott neve dollárjel ($) után.listaelemek nevét names() függvénnyel kérdezhetjük le és állíthatjuk .","code":"\nx <- list(1:10, c(\"A\",\"B\"), c=T)    # 3 elemű lista\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> [[2]]\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] TRUE\nnames(x)                       # az x lista elemeinek neve\n#> [1] \"\"  \"\"  \"c\"\nnames(x)[c(1,2)] <- c(\"a\",\"b\") # az x 1. és 2. elemének elnevezése\nnames(x)\n#> [1] \"a\" \"b\" \"c\"\nx\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> $b\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] TRUE"},{"path":"az-r-nyelv.html","id":"lista-indexelése","chapter":"5 Az R nyelv","heading":"5.3.6.2 Lista indexelése","text":"Egy lista indexelése már megszokot [] indexoperátorral történik, amelyben továbbra lehetőségünk van numerikus, karakteres és logikai indexvektor megadására .[] operátorral kapott eredmény minden esetben lista, még akkor , ha lista egyetlen elemét érjük el. Nagyon fontos ettől megkülönböztetni [[]] operátor eredményét, amely lista valamelyik (egyetlen) elemével, annak az értékével tér vissza. Itt nincs mód több listaelem elérésére, és szokás szerint numerikus vagy karakteres értékkel indexelünk.[[]] operátor alkalmazása helyett rövidebb dollár ($) operátort használhatjuk azoknak listaelemeknek az elérésére, amelyeket korábban elneveztünk. lista nevét és az elem nevét fűzzük össze $ operátorral.Ha lista elemét valamelyik módszer segítségével elértük, akkor további indexelés segítségével az elem összetevőit lekérdezhetjük vagy módosíthatjuk.lista indexelésére tehát következő lehetőségek állnak rendelkezésre:","code":"\nx[1]           # az x lista 1. elemét tartalmazó 1 elemű lista\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx[c(2, 3)]     # az x lista 2. és 3. elemét tartalmazó 2 elemű lista\n#> $b\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] TRUE\nx[\"a\"]         # az x lista 1. elemét tartalmazó 1 elemű lista\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx[c(T, F, T)]  # az x lista 1. és 3. elemét tartalmazó 1 elemű lista\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> $c\n#> [1] TRUE\nx[[1]]     # az x lista 1. eleme\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx[[\"b\"]]   # az x lista 2. eleme\n#> [1] \"A\" \"B\"\nx[[3]]     # az x lista 3. eleme\n#> [1] TRUE\nx$a        # az x lista 1. eleme\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx$b        # az x lista 2. eleme\n#> [1] \"A\" \"B\"\nx$c        # az x lista 3. eleme\n#> [1] TRUE\nx[[\"a\"]][3:4]       # az x lista 1. elemének 3. és 4. eleme \n#> [1] 3 4\nx$a[4:5] <- 0       # az x lista 1. elemének 4. és 5. eleme 0 lesz\nx$c <- 1:2          # az x lista 3. elemének módosítása    \nx\n#> $a\n#>  [1]  1  2  3  0  0  6  7  8  9 10\n#> \n#> $b\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] 1 2lista[indexvektor]     # az eredmény egy lista\nlista[[index]]         # az eredmény a lista egy eleme\nlista$elemnév          # az eredmény a lista egy eleme  "},{"path":"az-r-nyelv.html","id":"művelet-a-listaelemekkel","chapter":"5 Az R nyelv","heading":"5.3.6.3 Művelet a listaelemekkel","text":"Egy lista mindem elemével az lapply() vagy az sapply() függvény segítségével hajthatunk végre műveletet.Az lapply() bemenő lista elemszámával egyező méretű listával tér vissza, melynek értékei az második paraméterben szereplő függvény visszatérési értékei. Az sapply() hasonlóan jár el, de visszatérési értéke egy vektor.","code":"\nlapply(X=x, FUN=length) # az x lista minden elemének a hossza egy listába\n#> $a\n#> [1] 10\n#> \n#> $b\n#> [1] 2\n#> \n#> $c\n#> [1] 2\nsapply(X=x, FUN=length) # az x lista minden elemének a hossza egy vektorba\n#>  a  b  c \n#> 10  2  2"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-8-summary","chapter":"5 Az R nyelv","heading":"5.3.6.4 Részösszefoglalás","text":"\nlista az R legszabadabb adatszerkezete, egydimenziós és inhomogén. Listát list() függvénnyel hozhatunk létre, melynek argumentumában tetszőleges adatszerkezetű objektumokat felsorolhatunk, ezek alkotják lista egyes elemeit. Lista indexelése [], [[]] és $ operátorokkal lehetséges.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-8-exercise","chapter":"5 Az R nyelv","heading":"5.3.6.5 Feladatok","text":"Hozzunk létre egy háromelemű listát TRUE, 12, és “Verseny” konstansokból!Hozzunk létre egy háromelemű listát TRUE, 12, és “Verseny” konstansokból, de gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve,” “indulok” és “leiras!”Hozzunk létre egy háromelemű listát TRUE, 12 és “Verseny” konstansokból, valamint az induló versenyzők végső pontszámaiból, amelyek rendre: 89, 78, 23, 67, 99, 69, 85, 77, 58, 72, 48, 81. Gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve,” “indulok,” “leiras” és “pontszam!”","code":""},{"path":"az-r-nyelv.html","id":"adattábla","chapter":"5 Az R nyelv","heading":"5.3.7 Adattábla","text":"Az adattábla (data frame) az R legfontosabb adatszerkezete, központi szerepet játszik az adatfeldolgozásban, lényegében minden statisztikai munka kiindulópontja. Inhomogén, kétdimenziós szerkezet, sorok és oszlopok alkotják, alapvetően azonos hosszúságú vektorokból és faktorokból épül fel (5.1 ábra). Az adattábla egyesíti mátrix és lista adatszerkezet előnyeit. Az adattábla kétdimenziós, mint mátrix, és inhomogén, mint lista. Ha mátrixként tekintünk az adattáblára, akkor sorokból és oszlopokból áll, ha listaként, akkor azonos hosszúságú (oszlop)vektorok/faktorok egydimenziós sorozata.","code":""},{"path":"az-r-nyelv.html","id":"adattábla-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.7.1 Adattábla létrehozása","text":"Adattáblát legegyszerűbben data.frame() függvénnyel hozhatunk létre, amely azonos hosszú vektorokat vagy faktorokat vár az argumentumában. data.frame() tehát listaszerűen konstruálja az adattáblát.fenti df adattáblát egy 3 elemű karakteres vektorból, és egy 3 elemű numerikus vektorból hoztuk létre. data.frame() függvénynek ezt két vektort adtuk meg, ennek megfelelően két oszlopa lesz az adattáblának. Mindkét vektor 3 elemű, így 3 sor lesz df-ben. Adattábálánk így 3 \\(\\times\\) 2-es. Mindkét argumentumokat elneveztük (nev, pont), ezekből oszlopnevek lesznek. Az oszlopok elnevezéséhez az objektumokneveknél használt szabályokat vegyük figyelembe (5.1.2.3 fejezet), és ne használjunk ékezetes karaktereket és szóközt. fenti outputból kiolvasható, hogy az adattábla sornevekkel rendelkezik, ezek automatikusan jönnek létre 1-től kezdődő sorszámmal.Ha data.frame() függvényben paraméterek hossza nem azonos, akkor rövidebb vektorok és faktorok ismétléssel kiegészülnek leghosszabb oszlop hosszára. Az ismétlés azonban csak egész számszor lehetséges, egyébként hibaüzenetet kapunk.példában egy 6 sorból és 3 oszlopból álló adattáblát készítettünk (df2 6 \\(\\times\\) 3-). data.frame() függvényben nem azonos tipus faktor és két numerikus vektor (x, y) hossza, így ismétléssel kapjuk meg fenti eredményt. Továbbá, ha elhagyjuk az argumentum nevét, akkor az oszlopnév megfelelő objektum neve alapján jön létre. Így kapta az első oszlop tipus nevet.","code":"\ndf <- data.frame(\n  nev  = c(\"Péter\", \"Éva\", \"Lajos\"),\n  pont = c(34, 32, 29)\n) \ndf      # adattábla kiírása\n#>     nev pont\n#> 1 Péter   34\n#> 2   Éva   32\n#> 3 Lajos   29\ntipus <- factor(c('A','B')); x <- 6:8; y <- 1:6\ndf2 <- data.frame(\n   tipus, \n   pont.1=x, \n   pont.2=y\n)\ndf2\n#>   tipus pont.1 pont.2\n#> 1     A      6      1\n#> 2     B      7      2\n#> 3     A      8      3\n#> 4     B      6      4\n#> 5     A      7      5\n#> 6     B      8      6"},{"path":"az-r-nyelv.html","id":"adattábla-felépítése","chapter":"5 Az R nyelv","heading":"5.3.7.2 Adattábla felépítése","text":"Adattábláink ritkán olyan kicsik, mint fenti df vagy df2. Sokszor több tucat sorból és oszlopból állnak, így az adattábla áttekintésére nem az adattáblát tároló objektum értékének képernyőre írása legszerencsésebb. Kényelmesebb, ha az RStudio adatbázis ablakában jelenítjük meg az adattábla tartalmát, amit Környezet panel megfelelő adatbázisnevén való kattintással és vagy View() parancssal kezdeményezhetünk. Próbáljuk ki View(df) és View(df2) függvényhívásokat.Hasznos információ szolgáltat az str() függvény , amely az adattábla szerkezetéről ad felvilágosítást.Láthatjuk, hogy df adattáblánk 3 sort (megfigyelést) és 2 oszlopot (változót) tartalmaz, valamint leolvashatjuk az egyes oszlopok típusát . Megfigyelhetjük, hogy nev oszlop karakteres, pont pedig numerikus vektor.Láttuk korábban, hogy az adattábla sorai és oszlopai névvel rendelkeznek.rownames() sorok nevét, colnames() és names() az oszlopok nevét írja ki, de segítségükkel ezeket módosíthatjuk . sorok és oszlopok nevének meghatározásánál ügyeljünk arra, hogy azok minden esetben legyenek egyediek. Két azonos sornév létrehozása hibaüzenethez vezet, de az azonos oszlopnevek használatát kerüljük.length() függvény az oszlopok számával tér vissza. Az nrow() és az ncol() sor- és oszlopok számával tér vissza.","code":"\nstr(df)     # a df adattábla szerkezete\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ nev : chr  \"Péter\" \"Éva\" \"Lajos\"\n#>  $ pont: num  34 32 29\nnames(df); colnames(df)  # oszlopnevek\n#> [1] \"nev\"  \"pont\"\n#> [1] \"nev\"  \"pont\"\nrownames(df)             # sornevek\n#> [1] \"1\" \"2\" \"3\"\nrownames(df) <- paste0(1:3, \".szemely\")   # soroknevek módosítása\nnames(df) <- c(\"X\",\"Y\")                   # oszlopnevek módosítása\ndf\n#>               X  Y\n#> 1.szemely Péter 34\n#> 2.szemely   Éva 32\n#> 3.szemely Lajos 29\nlength(df); ncol(df)   # oszlopok száma\n#> [1] 2\n#> [1] 2\nnrow(df)               # sorok száma\n#> [1] 3"},{"path":"az-r-nyelv.html","id":"adattábla-indexelése","chapter":"5 Az R nyelv","heading":"5.3.7.3 Adattábla indexelése","text":"Az adattáblák indexelése mátrixok és listáknál megtanult indexelési formákat jelentik. Az általános indexelése formák következők:mátrixokhoz hasonlóan indexelhetjük sorokat és az oszlopokat, hiszen az adattábla kétdimenziós. [] operátorban szerepel egy vessző, amely sor- és oszlopkoordinátákat választja el egymástól. Használhatjuk következő hivatkozásokat:Numerikus indexvektorok mellett használhatunk karakteres és logikai vektorokat indexelésre.Karakteres vektorok tipikusan oszlopindexekben fordulnak elő, logikai vektorok pedig, később látjuk, az adattábla szűrésénél kapnak fontos szerepet.Ha az adattáblára listaként tekintünk, akkor [] operátorban egyetlen indexvektort szerepltethetünk, amely az adattábla oszlopoit indexeli, és minden esetben adattáblát szolgáltat, még akkor , ha az adattábla egyetlen oszlopát érjük el.Az adattábla egyes oszlopai $ operátorral elérhetők, amely az adattábla nevét és az oszlop nevét választja el egymástól. Az eredmény minden esetben vektor vagy faktor lesz.Az adattábla indexelése után kapott adatszerkezetek tovább indexelhetők. Attól függően, hogy kiinduló adattábla indexelésével kapott adatszerkezet egy- vagy kétdimenziós használhatjuk [] és $ operátorokat .Ne feljetsük el, hogy adattábla indexelése során lekért elemek módosítására lehetőségünk van, és vektoraritmetika szabályai továbbra teljesülnek.","code":"adattábla[sorindexvektor, oszlopindexvektor] # adattábla, vektor vagy faktor \nadattábla[sorindexvektor]                    # adattábla\nadattábla$oszlopnév                          # vektor vagy faktor                    \ndf2               # a df2 adattábla kiírása\n#>   tipus pont.1 pont.2\n#> 1     A      6      1\n#> 2     B      7      2\n#> 3     A      8      3\n#> 4     B      6      4\n#> 5     A      7      5\n#> 6     B      8      6\ndf2[2, 3]         # a df2 2. sorában a 3. oszlop adata, vektor eredmény\n#> [1] 2\ndf2[c(2, 3), 3]   # a df2 2. és 3. sorában a 3. oszlop adata, vektor\n#> [1] 2 3\ndf2[c(2, 3), 1:2] # a df2 2. és 3. sorában a 1. és 2. oszlop adata, adattábla\n#>   tipus pont.1\n#> 2     B      7\n#> 3     A      8\ndf2[c(2, 3), ]    # a df2 2. és 3. sora, adattábla\n#>   tipus pont.1 pont.2\n#> 2     B      7      2\n#> 3     A      8      3\ndf2[2, ]          # a df2 2. sora, adattábla\n#>   tipus pont.1 pont.2\n#> 2     B      7      2\ndf2[, 3]          # a df2 3. oszlopa, vektor\n#> [1] 1 2 3 4 5 6\ndf2[, 3, drop=F]  # a df2 3. oszlopa, adattábla\n#>   pont.2\n#> 1      1\n#> 2      2\n#> 3      3\n#> 4      4\n#> 5      5\n#> 6      6\ndf2[, 1:2]        # a df2 1. és 2. oszlopa, adattábla\n#>   tipus pont.1\n#> 1     A      6\n#> 2     B      7\n#> 3     A      8\n#> 4     B      6\n#> 5     A      7\n#> 6     B      8\ndf2[, c(\"tipus\", \"pont.1\")]         # minden sor, 1. és 2. oszlop\n#>   tipus pont.1\n#> 1     A      6\n#> 2     B      7\n#> 3     A      8\n#> 4     B      6\n#> 5     A      7\n#> 6     B      8\ndf2[c(T, F), c(\"tipus\", \"pont.1\")]  # páratlan sorok 1. és 2. oszlop\n#>   tipus pont.1\n#> 1     A      6\n#> 3     A      8\n#> 5     A      7\ndf2[2]                    # a df2 2. oszlopa, adattábla\n#>   pont.1\n#> 1      6\n#> 2      7\n#> 3      8\n#> 4      6\n#> 5      7\n#> 6      8\ndf2[1:2]                  # a df2 1. és 2. oszlopa, adattábla\n#>   tipus pont.1\n#> 1     A      6\n#> 2     B      7\n#> 3     A      8\n#> 4     B      6\n#> 5     A      7\n#> 6     B      8\ndf2[\"tipus\"]              # a df2 1. oszlopa, adattábla\n#>   tipus\n#> 1     A\n#> 2     B\n#> 3     A\n#> 4     B\n#> 5     A\n#> 6     B\ndf2[c(\"tipus\", \"pont.2\")] # a df2 1. és 3. oszlopa, adattábla\n#>   tipus pont.2\n#> 1     A      1\n#> 2     B      2\n#> 3     A      3\n#> 4     B      4\n#> 5     A      5\n#> 6     B      6\ndf2$tipus               # a df2 1. oszlopa, faktor\n#> [1] A B A B A B\n#> Levels: A B\ndf2$pont.1              # a df2 2. oszlopa, vektor\n#> [1] 6 7 8 6 7 8\ndf2[4:1, 1:2][2]           # df2-ből adattábla, majd adattábla\n#>   pont.1\n#> 4      6\n#> 3      8\n#> 2      7\n#> 1      6\ndf2[4:1, 1:2]$tipus        # df2-ből adattábla, majd faktor\n#> [1] B A B A\n#> Levels: A B\ndf2$pont.2[1:3]            # df2-ből vektor, majd vektor\n#> [1] 1 2 3\ndf2[2, 3] <- 200              # egyetlen érték módosítása \ndf2$pont.2 <- df2$pont.2 + 1  # teljes oszlop módosítása\ndf2                           # df2 kiírása\n#>   tipus pont.1 pont.2\n#> 1     A      6      2\n#> 2     B      7    201\n#> 3     A      8      4\n#> 4     B      6      5\n#> 5     A      7      6\n#> 6     B      8      7"},{"path":"az-r-nyelv.html","id":"adattáblák-szűrése","chapter":"5 Az R nyelv","heading":"5.3.7.4 Adattáblák szűrése","text":"Az adattábla indexelésénél logikai vektorokat használhatunk sorindexvektorban, melyek az adattábla tartalmára vonatkozó relációs kifejezések lehetnek. Ezzel módszerrel érhetjük el, hogy az adattábla sorait valamilyen szempont szerint leválogassuk, megszűrjük.Az első szűrésünk az adattábla \"\" címkékkel rendelkező sorait válogatta le, de csak képernyőn olvashatók ezek sorok. második szűrés eredményét azonab megőrizzük egy új df3 objektumban, és látható, hogy pont.1 és pont.2 numerikus vektorokra vonatkozó összetett logikai kifejezéssel végezzük.","code":"\ndf2[df2$tipus == \"A\", ]                      # az A típusú sorok leválogatása\n#>   tipus pont.1 pont.2\n#> 1     A      6      2\n#> 3     A      8      4\n#> 5     A      7      6\ndf3 <- df2[df2$pont.1<8 & df2$pont.2>2, 2:3] # összetett logikai kifejezés"},{"path":"az-r-nyelv.html","id":"adattáblák-sorainak-rendezése","chapter":"5 Az R nyelv","heading":"5.3.7.5 Adattáblák sorainak rendezése","text":"Az adattábla sorainak rendezése vektoroknál megismert order() függvény és [] operátor kombinált alkalmazásával lehetséges. Rendezzük pont.1 változó alapján df2 sorait.Az order() függvény decreasing=TRUE argumentumával csökkenő sorrendet elérhetünk. Az order() függvény több oszlopot képes fogadni, így több oszlop alapján tudunk sorokat rendezni.","code":"\ndf2[order(df2$pont.1), ] # df2 sorainak rendezése pont.1 növekvő sorrendjében\n#>   tipus pont.1 pont.2\n#> 1     A      6      2\n#> 4     B      6      5\n#> 2     B      7    201\n#> 5     A      7      6\n#> 3     A      8      4\n#> 6     B      8      7\n# df2 sorainak rendezése pont.1 és pont.2 csökkenő sorrendjében\ndf2[order(df2$pont.1, df2$pont.2, decreasing=T), ] \n#>   tipus pont.1 pont.2\n#> 6     B      8      7\n#> 3     A      8      4\n#> 2     B      7    201\n#> 5     A      7      6\n#> 4     B      6      5\n#> 1     A      6      2"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-9-summary","chapter":"5 Az R nyelv","heading":"5.3.7.6 Részösszefoglalás","text":"\nAz adattábla minden statisztikai munka kiindulópontja. Kétdimenziós, inhomogén szerkezet, de mivel azonos hosszú vektorok vagy faktorok listájának tekinthető, oszlopaiban homogén adatszerkezet. Létrehozása data.frame() függvénnyel lehetséges, ahol az argumentumban az oszlopokat alkotó vektorokat és faktorokat kell felsorolni. Az adattábla indexelése mátrixoknál és listáknál tanultak alapján lehetséges.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-9-exercise","chapter":"5 Az R nyelv","heading":"5.3.7.7 Feladatok","text":"Hozzunk létre egy 30 \\(\\times\\) 3-adattáblát, csoport, matematika és magyar oszlopnevekkel. csoport változó legyen egy 5., 5.b és 5.c címkéket tetszőleges sorrendben tartalmazó faktor, matematika és magyar pedig 1-5 osztályzatokat tartalmazó numerikus vektor.","code":""},{"path":"az-r-nyelv.html","id":"további-adatszerkezetek-és-függvények","chapter":"5 Az R nyelv","heading":"5.4 További adatszerkezetek és függvények","text":"Ebben fejezetben:megismerjük tömb, táblázat, dátum, idő, időtartam és tibble adatszerkezeteket,valamint munkaterület és munkakönyvtár kezelésének függvényeit.Az R legfontosabb adatszerkezetit megismertük az előző fejezetben. Az adatelemzés kiindulópontja az adattábla, amely mátrix és lista adatszerkezet előnyeit egyesíti, lényegében vektorok és faktorok egymásutánja. munka során azonban találkozhatunk három vagy több dimenzióba szervezett adatokkal (tömb és táblázat), valamint szükség lehet dátum, idő és időtartam kezelésére . Tidyverse R megújította az adattáblát, és bevezette saját tibble típusát az adatok szokásos tárolására. Definiáljuk pontosabban fenti, új adatszerkezeteket:tömb - Azonos alaptípusú értékekből 3 vagy több dimenzió mentén készítünk adatszerkezetet.táblázat - gyakorisági táblázatok R megfelelője, amelyben tipikusan integer adatokat rögzítünk, egy, két vagy több dimenzió mentén.dátum - Egyetlen double érték, amelynek jelentése az 1970-01-01 óta eltelt napok száma.dátum-idő - Egyetlen double érték, amelynek jelentése az 1970-01-01 óta eltelt másodpercek száma.időtartam - Egyetlen double érték, amelynek különböző mértékegységekben mutatja két időpont közötti különbséget.tibble - Speciális adattábla, amely Tidyverse R része, és megkönnyíti az adatok kezelését.Az ?? táblázatban már korábban bemutattuk az R legfontosabb adatszerkezeteit, aZ ?? táblázat azokat az új adatszerkezeteket sorlja fel, amelyeket ebben fejezetben mutatunk . közöljük, hogy typeof() és class() milyen outputot szolgáltat az egyes adatszerkezetek esetén.","code":""},{"path":"az-r-nyelv.html","id":"tömbök-és-táblázatok","chapter":"5 Az R nyelv","heading":"5.4.1 Tömbök és táblázatok","text":"tömb mátrix általánosításával nyerhető adatszerkezet. Az azonos típusú adatokat mátrix két dimenzió mentén rendezi össze. Azonban három vagy több dimenzió mentén elvégezhető ez az összerendezés. Így nyerjük három vagy több dimenziós tömböket. mátrix két dimenziós tömbnek tekinthető (vagy vektor egy egy dimenziós tömbnek). táblázat tömbökhöz nagyon hasonló adatszerkezet, de tipikusan számlálással nyert integer értékeket rögzítünk bennük. tömbökhöz hasonlóan lehetnek egy, két, vagy több dimenziósok.","code":""},{"path":"az-r-nyelv.html","id":"tömb-és-táblázat-létrehozása","chapter":"5 Az R nyelv","heading":"5.4.1.1 Tömb és táblázat létrehozása","text":"Az array() függvénnyel egyszerűen hozhatunk létre tömböt. függvény data= argumentumban megadott vektor elemeit dim= argumentumban megadott dimenzió-méretek mentén rendezi össze.Fenti 3 dimenziós integer tömb 2 \\(\\times\\) 3 \\(\\times\\) 2-es, azaz 2 sorból, 3 oszlopból és 2 lapból áll. Természetesen double, karakteres és logikai tömbök hasonló módszerrel hozhatók létre.Tekintsünk egy másik példát.Tehát ha x például 3 dimenziós, akkor az x[1,3,2] egy lehetséges példa indexelésére, ahol az első sor harmadik oszlopában lévő elemre gondolunk, második lapról. kétdimenziós mátrixok esetén csak sor és oszlop azonosító indexre van szükségünk (például x[2,3]), 4 vagy afeletti dimenziószámok esetén természetesen 4 vagy több, vesszővel elválasztott indexre.Az egydimenziós vektor többdimenziós megfelelője tömb (array). tömb vektorhoz hasonlóan homogén adatszerkezet, amely dim attribútummal rendelkezik. Egy vektort könnyen átalakíthatunk például egy 3 dimenziós tömbbé dim() függvény segítségével:Az x vektorból egy háromdimenziós tömböt hoztunk létre. Az .vector() és az .array() függvények eligazítanak az objektum adatszerkezetével kapcsolatban, vektor, illetve tömb paraméter esetén logikai igaz értéket adnak. tömb kiíratása során az indexoperátorokban szereplő sorszámok segítségével igazodhatunk el az elemek között. háromdimenziós x tömb dimenziói sorok, oszlopok és lapok. 8 elemet két lapon , , 1 és , , 2 nevű lapokon két-két sorba [1, ], [2, ] és két-két oszlopba [ ,1], [ ,2] rendezve sorolja fel az R. második lapon 2. sor 1. eleméhez meg kell találnunk , , 2 lapot, [2, ] sort és az [ ,1] oszlopot, ami esetünkben 6.","code":"\nx <- array(data=1:12, dim=c(2, 3, 2)) # az 1:12 vektorból 3 dimenziós tömb \nx                       \n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\nx <- array(data=1:20, dim=c(4, 5))\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nx <- 1:8; is.vector(x)\n#> [1] TRUE\ndim(x) <- c(2,2,2); is.vector(x); is.array(x)\n#> [1] FALSE\n#> [1] TRUE\nattributes(x)\n#> $dim\n#> [1] 2 2 2\nx\n#> , , 1\n#> \n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\n#> \n#> , , 2\n#> \n#>      [,1] [,2]\n#> [1,]    5    7\n#> [2,]    6    8\nlibrary(MASS)\ntab1 <- table(survey$Sex)\ntab1\n#> \n#> Female   Male \n#>    118    118\ntypeof(tab1)\n#> [1] \"integer\"\nclass(tab1)\n#> [1] \"table\"\ndim(tab1)\n#> [1] 2\n\ntab2 <- table(survey$Sex, survey$Clap)\ntab2\n#>         \n#>          Left Neither Right\n#>   Female   21      24    73\n#>   Male     18      25    74\ntypeof(tab2)\n#> [1] \"integer\"\nclass(tab2)\n#> [1] \"table\"\ndim(tab2)\n#> [1] 2 3\n\ntab3 <- table(survey$Sex, survey$Clap, survey$Exer)\ntab3\n#> , ,  = Freq\n#> \n#>         \n#>          Left Neither Right\n#>   Female   11      17    21\n#>   Male      8      16    41\n#> \n#> , ,  = None\n#> \n#>         \n#>          Left Neither Right\n#>   Female    3       1     7\n#>   Male      3       4     6\n#> \n#> , ,  = Some\n#> \n#>         \n#>          Left Neither Right\n#>   Female    7       6    45\n#>   Male      7       5    27\ntypeof(tab3)\n#> [1] \"integer\"\nclass(tab3)\n#> [1] \"table\"\ndim(tab3)\n#> [1] 2 3 3\nftable(tab3)\n#>                 Freq None Some\n#>                               \n#> Female Left       11    3    7\n#>        Neither    17    1    6\n#>        Right      21    7   45\n#> Male   Left        8    3    7\n#>        Neither    16    4    5\n#>        Right      41    6   27\n\nas.array(tab1)\n#> \n#> Female   Male \n#>    118    118\nas.array(tab2)\n#>         \n#>          Left Neither Right\n#>   Female   21      24    73\n#>   Male     18      25    74\nas.array(tab3)\n#> , ,  = Freq\n#> \n#>         \n#>          Left Neither Right\n#>   Female   11      17    21\n#>   Male      8      16    41\n#> \n#> , ,  = None\n#> \n#>         \n#>          Left Neither Right\n#>   Female    3       1     7\n#>   Male      3       4     6\n#> \n#> , ,  = Some\n#> \n#>         \n#>          Left Neither Right\n#>   Female    7       6    45\n#>   Male      7       5    27\n\nas.vector(tab1)\n#> [1] 118 118\nas.matrix(tab2)\n#>         \n#>          Left Neither Right\n#>   Female   21      24    73\n#>   Male     18      25    74\nas.array(tab3)\n#> , ,  = Freq\n#> \n#>         \n#>          Left Neither Right\n#>   Female   11      17    21\n#>   Male      8      16    41\n#> \n#> , ,  = None\n#> \n#>         \n#>          Left Neither Right\n#>   Female    3       1     7\n#>   Male      3       4     6\n#> \n#> , ,  = Some\n#> \n#>         \n#>          Left Neither Right\n#>   Female    7       6    45\n#>   Male      7       5    27\n\nas.data.frame(tab1)\n#>     Var1 Freq\n#> 1 Female  118\n#> 2   Male  118\nas.data.frame(tab2)\n#>     Var1    Var2 Freq\n#> 1 Female    Left   21\n#> 2   Male    Left   18\n#> 3 Female Neither   24\n#> 4   Male Neither   25\n#> 5 Female   Right   73\n#> 6   Male   Right   74\nas.data.frame(tab3)\n#>      Var1    Var2 Var3 Freq\n#> 1  Female    Left Freq   11\n#> 2    Male    Left Freq    8\n#> 3  Female Neither Freq   17\n#> 4    Male Neither Freq   16\n#> 5  Female   Right Freq   21\n#> 6    Male   Right Freq   41\n#> 7  Female    Left None    3\n#> 8    Male    Left None    3\n#> 9  Female Neither None    1\n#> 10   Male Neither None    4\n#> 11 Female   Right None    7\n#> 12   Male   Right None    6\n#> 13 Female    Left Some    7\n#> 14   Male    Left Some    7\n#> 15 Female Neither Some    6\n#> 16   Male Neither Some    5\n#> 17 Female   Right Some   45\n#> 18   Male   Right Some   27\n\nm <- matrix(1:12, ncol=4)\nm\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\nas.data.frame(m)\n#>   V1 V2 V3 V4\n#> 1  1  4  7 10\n#> 2  2  5  8 11\n#> 3  3  6  9 12\nas.table(m)\n#>    A  B  C  D\n#> A  1  4  7 10\n#> B  2  5  8 11\n#> C  3  6  9 12\n\nd <- as.data.frame(tab2)\nas.matrix(xtabs(Freq~Var1+Var2, data=d))\n#>         Var2\n#> Var1     Left Neither Right\n#>   Female   21      24    73\n#>   Male     18      25    74\nxtabs(Freq~Var1+Var2, data=d)\n#>         Var2\n#> Var1     Left Neither Right\n#>   Female   21      24    73\n#>   Male     18      25    74"},{"path":"az-r-nyelv.html","id":"dátum-és-idő","chapter":"5 Az R nyelv","heading":"5.4.2 Dátum és idő","text":"Az adatelemzés során dátumok kezelésének két fő oka lehet, egyrészt szűrésekben használhatjuk őket, például adott dátum vagy időpont előtti, utáni vagy közötti sorok leválogatásában, másrészt statisztikai elemzések irányulhatnak két dátum vagy időpont között eltelt időtartamra.","code":""},{"path":"az-r-nyelv.html","id":"dátum-kezelése","chapter":"5 Az R nyelv","heading":"5.4.2.1 Dátum kezelése","text":"Amennyiben le akarjuk kérdezni az aktuális dátumot, akkor Sys.Date() függvényt kell használnunk.Láthatjuk, hogy datum.1 objektum dátum (Date) típusú annak ellenére, hogy az objektum értéke képernyőn kettős idézőjelek között jelenik meg. dátum típus alapja egy double szám van, amely az 1970. 01. 01. óta eltelt napok számát tartalmazza, ahogyan az unclass(datum.1) ezt számunkra meg mutatja. Világos, hogy az double érték lehet nulla vagy negatív .","code":"\ndatum.1 <- Sys.Date()    # aktuális dátum, dátum típusú objektum\ndatum.1                  # datum.1 kiírása\n#> [1] \"2021-12-28\"\nclass(datum.1)           # datum.1 típusa\n#> [1] \"Date\"\nunclass(datum.1)         # datum.1 alapja\n#> [1] 18989\nunclass(as.Date(\"1980-01-01\")) # a double szám pozitív\n#> [1] 3652\nunclass(as.Date(\"1970-01-01\")) # a double szám nulla\n#> [1] 0\nunclass(as.Date(\"1960-01-01\")) # a double szám negatív\n#> [1] -3653"},{"path":"az-r-nyelv.html","id":"dátum-létrehozása-karakteres-adatból","chapter":"5 Az R nyelv","heading":"5.4.2.1.1 Dátum létrehozása karakteres adatból","text":"Dátumot legtöbb esetben karakteres konstansból hozunk létre az .Date() függvény segítségével. dátumok változatos formában jelenhetnek meg, szabványos \"2019-02-12\" alak mellett sok olyan forma létezik, amelyben elválasztó karakterként perjel vagy pont szerepel, valamint az év-hó-nap hármas sorrendje változhat. konkrét dátum értelmézéséhez az .Date() függvény format= argumentumát kell helyesen beállítani. használható kódokat 5.1 táblázat tartalmazza.Magyar számítógépes környezetben helyi beállítás (locale) alapértelmezés szerint magyar, ennek megfelelően magyar hónapnevekkel dolgozik az .Date() függvény. Sys.getlocale(\"LC_TIME\") paranccsak vizsgálhatjuk meg, hogy milyen környezetben dolgozunk. Sys.setlocale(\"LC_TIME\", \"C\") utasítás észak-amerikai beállításokra vált, így angol hónapnevek felismerésére nyílik lehetőség.","code":"\nas.Date(\"2020-04-12\")   # szabványos, nem kell format= argumentum\n#> [1] \"2020-04-12\"\nas.Date(\"2020/04/12\")   # szabványos, nem kell format= argumentum\n#> [1] \"2020-04-12\"\nas.Date(\"04/12/2020\", format=\"%m/%d/%Y\")          # amerikai stílus\n#> [1] \"2020-04-12\"\nas.Date(\"12.04.2020\", format=\"%d.%m.%Y\")          # brit stílus\n#> [1] \"2020-04-12\"\nas.Date(\"2019. 04. 12.\", format=\"%Y. %m. %d.\")    # magyar stílus\n#> [1] \"2019-04-12\"\nSys.getlocale(\"LC_TIME\")                          # a helyi beállítás magyar?\n#> [1] \"Hungarian_Hungary.1250\"\nas.Date(\"2019. ápr. 12.\", format=\"%Y. %b %d.\")    # rövid mqgyar hónapnévvel\n#> [1] \"2019-04-12\"\nas.Date(\"2019. április 12.\", format=\"%Y. %B %d.\") # magyar hónapnévvel\n#> [1] \"2019-04-12\"\nlct <- Sys.getlocale(\"LC_TIME\")                   # helyi beállítás mentése\nSys.setlocale(\"LC_TIME\", \"C\")                     # észak-amerikai beállítás \n#> [1] \"C\"\nas.Date(\"Apr 12, 2020\", format=\"%b %d, %Y\")       # rövid angol hónapnévvel\n#> [1] \"2020-04-12\"\nas.Date(\"12 April 2020\", format=\"%d %B %Y\")       # angol hónapnévvel\n#> [1] \"2020-04-12\"\nSys.setlocale(\"LC_TIME\", lct)  # magyar helyi beállítás visszatöltése  \n#> [1] \"Hungarian_Hungary.1250\""},{"path":"az-r-nyelv.html","id":"dátum-létrehozása-numerikus-adatokból","chapter":"5 Az R nyelv","heading":"5.4.2.1.2 Dátum létrehozása numerikus adatokból","text":"Dátumot szeparáltan létező numerikus év, hónap, nap információkból létrehozhatunk. Ehhez először az ISOdate() függvénnyel időpontot állítunk elő, majd az .Date()-tel dátumot. Ezzel módszerrel egyszerre több dátumot előállíthatunk.","code":"\nas.Date(ISOdate(year = 2020, month = 4, day = 12))\n#> [1] \"2020-04-12\"\nas.Date(ISOdate(year = 2020, month = 1:4, day = 12))\n#> [1] \"2020-01-12\" \"2020-02-12\" \"2020-03-12\" \"2020-04-12\""},{"path":"az-r-nyelv.html","id":"dátum-konvertálása-karakteres","chapter":"5 Az R nyelv","heading":"5.4.2.1.3 Dátum konvertálása karakteres","text":"Sokszor dátumokat speciális karaktersorozatként szeretnénk látni speciális alakjára,TÁBLÁZAT 5.1:  Formátumkódok dátumokban","code":"\n(datum.2 <- as.Date(\"04/12/2020\", format = \"%m/%d/%Y\"))\n#> [1] \"2020-04-12\"\nformat(datum.2, \"%Y. %m. %d.\")\n#> [1] \"2020. 04. 12.\"\nformat(datum.2, \"%Y. %B %d.\")\n#> [1] \"2020. április 12.\"\nformat(datum.2, \"%Y. %b %d.\")\n#> [1] \"2020. ápr. 12.\"\ndatum.2\n#> [1] \"2020-04-12\"\n(ido.1 <- as.POSIXlt(datum.2))\n#> [1] \"2020-04-12 UTC\"\nido.1$year + 1900\n#> [1] 2020\nido.1$mon + 1\n#> [1] 4\nido.1$mday\n#> [1] 12\nas.Date(\"2061. július 26\", format=\"%Y. %B %d\")\n#> [1] \"2061-07-26\"\n\nlibrary(anytime)\nanytime::anydate(\"2061. július 26\")\n#> [1] NA\n\n\nlibrary(lubridate)\nymd(c(\"2061-07-26\", \"2061/07/26\", \"2061 July 26\", \n      \"2061. július 26\", \"2061 máj. 26\"))\n#> [1] \"2061-07-26\" \"2061-07-26\" \"2061-07-26\" \"2061-07-26\" \"2061-05-26\"\ndmy(c(\"26-07-2061\", \"2061/07/26\", \"2061 July 26\", \n      \"26 July, 2061\", \"26. júl. 2061.\"))\n#> [1] \"2061-07-26\" NA           NA           \"2061-07-26\" \"2061-07-26\"\n\nymd_hms(\"2061-07-26 12:12:32\")\n#> [1] \"2061-07-26 12:12:32 UTC\"\n\nparse_date_time(\"2020. June 12\", orders = \"Ymd\", locale=\"Hungarian_Hungary.1250\")\n#> [1] \"2020-06-12 UTC\"\n\nclass(Sys.getlocale(\"LC_TIME\"))\n#> [1] \"character\"\n\n# A Halley-üstökös visszatérése utoljára 1986-ban járt a Naprendszerünkben, így az előrejelzések szerint legközelebb 2061. július 26"},{"path":"az-r-nyelv.html","id":"két-dátum-közt-eltelt-idő","chapter":"5 Az R nyelv","heading":"5.4.2.1.4 Két dátum közt eltelt idő","text":"","code":"\n(diff.1 <- difftime(datum.1, datum.2, units = \"secs\"))\n#> Time difference of 5.4e+07 secs\nunclass(diff.1)\n#> [1] 5.4e+07\n#> attr(,\"units\")\n#> [1] \"secs\"\n(diff.2 <- difftime(datum.1, datum.2, units = \"mins\"))\n#> Time difference of 9e+05 mins\nunclass(diff.2)\n#> [1] 9e+05\n#> attr(,\"units\")\n#> [1] \"mins\"\n(diff.3 <- difftime(datum.1, datum.2, units = \"hours\"))\n#> Time difference of 15000 hours\n(diff.4 <- difftime(datum.1, datum.2, units = \"days\"))\n#> Time difference of 625 days\n(diff.5 <- difftime(datum.1, datum.2, units = \"weeks\"))\n#> Time difference of 89.28571 weeks\nas.numeric(diff.1)\n#> [1] 5.4e+07\nas.numeric(diff.2)\n#> [1] 9e+05\nas.numeric(diff.3)\n#> [1] 15000\nas.numeric(diff.4)\n#> [1] 625\nas.numeric(diff.5)\n#> [1] 89.28571"},{"path":"az-r-nyelv.html","id":"idő-kezelése","chapter":"5 Az R nyelv","heading":"5.4.2.2 Idő kezelése","text":"sec\nSeconds (0–61)min\nMinutes (0–59)hour\nHours (0–23)mday\nDay month (1–31)mon\nMonth (0–11)year\nYears since 1900wday\nDay week (0–6, 0 = Sunday)yday\nDay year (0–365)isdst\nDaylight Saving Time flag","code":"\nido.1 <- Sys.time()\nido.1\n#> [1] \"2021-12-28 22:36:56 CET\"\nunclass(ido.1)\n#> [1] 1640727417\n\nido.2 <- as.POSIXct(\"2020-12-02 22:12:23\", tz = \"Europe/Budapest\")\nSys.timezone()\n#> [1] \"Europe/Prague\"\ndatum.ido.1 <- Sys.time()\ndatum.ido.2 <- as.POSIXct(\"2018-12-02 22:12:23\", tz = \"Europe/Budapest\")\ndifftime(datum.ido.1, datum.ido.2, units=\"min\")\n#> Time difference of 1615705 mins\n\n\nas.POSIXct(strptime(\"2019.09.06. 16:34:17\", \"%Y.%m.%d. %H:%M:%S\"))\n#> [1] \"2019-09-06 16:34:17 CEST\"\n\n\n\nas.POSIXct(strptime(\"2010-10-31 01:30:00\", \"%Y-%m-%d %H:%M:%S\"))\n#> [1] \"2010-10-31 01:30:00 CEST\"\nOlsonNames()\n#>   [1] \"Africa/Abidjan\"                   \"Africa/Accra\"                    \n#>   [3] \"Africa/Addis_Ababa\"               \"Africa/Algiers\"                  \n#>   [5] \"Africa/Asmara\"                    \"Africa/Asmera\"                   \n#>   [7] \"Africa/Bamako\"                    \"Africa/Bangui\"                   \n#>   [9] \"Africa/Banjul\"                    \"Africa/Bissau\"                   \n#>  [11] \"Africa/Blantyre\"                  \"Africa/Brazzaville\"              \n#>  [13] \"Africa/Bujumbura\"                 \"Africa/Cairo\"                    \n#>  [15] \"Africa/Casablanca\"                \"Africa/Ceuta\"                    \n#>  [17] \"Africa/Conakry\"                   \"Africa/Dakar\"                    \n#>  [19] \"Africa/Dar_es_Salaam\"             \"Africa/Djibouti\"                 \n#>  [21] \"Africa/Douala\"                    \"Africa/El_Aaiun\"                 \n#>  [23] \"Africa/Freetown\"                  \"Africa/Gaborone\"                 \n#>  [25] \"Africa/Harare\"                    \"Africa/Johannesburg\"             \n#>  [27] \"Africa/Juba\"                      \"Africa/Kampala\"                  \n#>  [29] \"Africa/Khartoum\"                  \"Africa/Kigali\"                   \n#>  [31] \"Africa/Kinshasa\"                  \"Africa/Lagos\"                    \n#>  [33] \"Africa/Libreville\"                \"Africa/Lome\"                     \n#>  [35] \"Africa/Luanda\"                    \"Africa/Lubumbashi\"               \n#>  [37] \"Africa/Lusaka\"                    \"Africa/Malabo\"                   \n#>  [39] \"Africa/Maputo\"                    \"Africa/Maseru\"                   \n#>  [41] \"Africa/Mbabane\"                   \"Africa/Mogadishu\"                \n#>  [43] \"Africa/Monrovia\"                  \"Africa/Nairobi\"                  \n#>  [45] \"Africa/Ndjamena\"                  \"Africa/Niamey\"                   \n#>  [47] \"Africa/Nouakchott\"                \"Africa/Ouagadougou\"              \n#>  [49] \"Africa/Porto-Novo\"                \"Africa/Sao_Tome\"                 \n#>  [51] \"Africa/Timbuktu\"                  \"Africa/Tripoli\"                  \n#>  [53] \"Africa/Tunis\"                     \"Africa/Windhoek\"                 \n#>  [55] \"America/Adak\"                     \"America/Anchorage\"               \n#>  [57] \"America/Anguilla\"                 \"America/Antigua\"                 \n#>  [59] \"America/Araguaina\"                \"America/Argentina/Buenos_Aires\"  \n#>  [61] \"America/Argentina/Catamarca\"      \"America/Argentina/ComodRivadavia\"\n#>  [63] \"America/Argentina/Cordoba\"        \"America/Argentina/Jujuy\"         \n#>  [65] \"America/Argentina/La_Rioja\"       \"America/Argentina/Mendoza\"       \n#>  [67] \"America/Argentina/Rio_Gallegos\"   \"America/Argentina/Salta\"         \n#>  [69] \"America/Argentina/San_Juan\"       \"America/Argentina/San_Luis\"      \n#>  [71] \"America/Argentina/Tucuman\"        \"America/Argentina/Ushuaia\"       \n#>  [73] \"America/Aruba\"                    \"America/Asuncion\"                \n#>  [75] \"America/Atikokan\"                 \"America/Atka\"                    \n#>  [77] \"America/Bahia\"                    \"America/Bahia_Banderas\"          \n#>  [79] \"America/Barbados\"                 \"America/Belem\"                   \n#>  [81] \"America/Belize\"                   \"America/Blanc-Sablon\"            \n#>  [83] \"America/Boa_Vista\"                \"America/Bogota\"                  \n#>  [85] \"America/Boise\"                    \"America/Buenos_Aires\"            \n#>  [87] \"America/Cambridge_Bay\"            \"America/Campo_Grande\"            \n#>  [89] \"America/Cancun\"                   \"America/Caracas\"                 \n#>  [91] \"America/Catamarca\"                \"America/Cayenne\"                 \n#>  [93] \"America/Cayman\"                   \"America/Chicago\"                 \n#>  [95] \"America/Chihuahua\"                \"America/Coral_Harbour\"           \n#>  [97] \"America/Cordoba\"                  \"America/Costa_Rica\"              \n#>  [99] \"America/Creston\"                  \"America/Cuiaba\"                  \n#> [101] \"America/Curacao\"                  \"America/Danmarkshavn\"            \n#> [103] \"America/Dawson\"                   \"America/Dawson_Creek\"            \n#> [105] \"America/Denver\"                   \"America/Detroit\"                 \n#> [107] \"America/Dominica\"                 \"America/Edmonton\"                \n#> [109] \"America/Eirunepe\"                 \"America/El_Salvador\"             \n#> [111] \"America/Ensenada\"                 \"America/Fort_Nelson\"             \n#> [113] \"America/Fort_Wayne\"               \"America/Fortaleza\"               \n#> [115] \"America/Glace_Bay\"                \"America/Godthab\"                 \n#> [117] \"America/Goose_Bay\"                \"America/Grand_Turk\"              \n#> [119] \"America/Grenada\"                  \"America/Guadeloupe\"              \n#> [121] \"America/Guatemala\"                \"America/Guayaquil\"               \n#> [123] \"America/Guyana\"                   \"America/Halifax\"                 \n#> [125] \"America/Havana\"                   \"America/Hermosillo\"              \n#> [127] \"America/Indiana/Indianapolis\"     \"America/Indiana/Knox\"            \n#> [129] \"America/Indiana/Marengo\"          \"America/Indiana/Petersburg\"      \n#> [131] \"America/Indiana/Tell_City\"        \"America/Indiana/Vevay\"           \n#> [133] \"America/Indiana/Vincennes\"        \"America/Indiana/Winamac\"         \n#> [135] \"America/Indianapolis\"             \"America/Inuvik\"                  \n#> [137] \"America/Iqaluit\"                  \"America/Jamaica\"                 \n#> [139] \"America/Jujuy\"                    \"America/Juneau\"                  \n#> [141] \"America/Kentucky/Louisville\"      \"America/Kentucky/Monticello\"     \n#> [143] \"America/Knox_IN\"                  \"America/Kralendijk\"              \n#> [145] \"America/La_Paz\"                   \"America/Lima\"                    \n#> [147] \"America/Los_Angeles\"              \"America/Louisville\"              \n#> [149] \"America/Lower_Princes\"            \"America/Maceio\"                  \n#> [151] \"America/Managua\"                  \"America/Manaus\"                  \n#> [153] \"America/Marigot\"                  \"America/Martinique\"              \n#> [155] \"America/Matamoros\"                \"America/Mazatlan\"                \n#> [157] \"America/Mendoza\"                  \"America/Menominee\"               \n#> [159] \"America/Merida\"                   \"America/Metlakatla\"              \n#> [161] \"America/Mexico_City\"              \"America/Miquelon\"                \n#> [163] \"America/Moncton\"                  \"America/Monterrey\"               \n#> [165] \"America/Montevideo\"               \"America/Montreal\"                \n#> [167] \"America/Montserrat\"               \"America/Nassau\"                  \n#> [169] \"America/New_York\"                 \"America/Nipigon\"                 \n#> [171] \"America/Nome\"                     \"America/Noronha\"                 \n#> [173] \"America/North_Dakota/Beulah\"      \"America/North_Dakota/Center\"     \n#> [175] \"America/North_Dakota/New_Salem\"   \"America/Nuuk\"                    \n#> [177] \"America/Ojinaga\"                  \"America/Panama\"                  \n#> [179] \"America/Pangnirtung\"              \"America/Paramaribo\"              \n#> [181] \"America/Phoenix\"                  \"America/Port-au-Prince\"          \n#> [183] \"America/Port_of_Spain\"            \"America/Porto_Acre\"              \n#> [185] \"America/Porto_Velho\"              \"America/Puerto_Rico\"             \n#> [187] \"America/Punta_Arenas\"             \"America/Rainy_River\"             \n#> [189] \"America/Rankin_Inlet\"             \"America/Recife\"                  \n#> [191] \"America/Regina\"                   \"America/Resolute\"                \n#> [193] \"America/Rio_Branco\"               \"America/Rosario\"                 \n#> [195] \"America/Santa_Isabel\"             \"America/Santarem\"                \n#> [197] \"America/Santiago\"                 \"America/Santo_Domingo\"           \n#> [199] \"America/Sao_Paulo\"                \"America/Scoresbysund\"            \n#> [201] \"America/Shiprock\"                 \"America/Sitka\"                   \n#> [203] \"America/St_Barthelemy\"            \"America/St_Johns\"                \n#> [205] \"America/St_Kitts\"                 \"America/St_Lucia\"                \n#> [207] \"America/St_Thomas\"                \"America/St_Vincent\"              \n#> [209] \"America/Swift_Current\"            \"America/Tegucigalpa\"             \n#> [211] \"America/Thule\"                    \"America/Thunder_Bay\"             \n#> [213] \"America/Tijuana\"                  \"America/Toronto\"                 \n#> [215] \"America/Tortola\"                  \"America/Vancouver\"               \n#> [217] \"America/Virgin\"                   \"America/Whitehorse\"              \n#> [219] \"America/Winnipeg\"                 \"America/Yakutat\"                 \n#> [221] \"America/Yellowknife\"              \"Antarctica/Casey\"                \n#> [223] \"Antarctica/Davis\"                 \"Antarctica/DumontDUrville\"       \n#> [225] \"Antarctica/Macquarie\"             \"Antarctica/Mawson\"               \n#> [227] \"Antarctica/McMurdo\"               \"Antarctica/Palmer\"               \n#> [229] \"Antarctica/Rothera\"               \"Antarctica/South_Pole\"           \n#> [231] \"Antarctica/Syowa\"                 \"Antarctica/Troll\"                \n#> [233] \"Antarctica/Vostok\"                \"Arctic/Longyearbyen\"             \n#> [235] \"Asia/Aden\"                        \"Asia/Almaty\"                     \n#> [237] \"Asia/Amman\"                       \"Asia/Anadyr\"                     \n#> [239] \"Asia/Aqtau\"                       \"Asia/Aqtobe\"                     \n#> [241] \"Asia/Ashgabat\"                    \"Asia/Ashkhabad\"                  \n#> [243] \"Asia/Atyrau\"                      \"Asia/Baghdad\"                    \n#> [245] \"Asia/Bahrain\"                     \"Asia/Baku\"                       \n#> [247] \"Asia/Bangkok\"                     \"Asia/Barnaul\"                    \n#> [249] \"Asia/Beirut\"                      \"Asia/Bishkek\"                    \n#> [251] \"Asia/Brunei\"                      \"Asia/Calcutta\"                   \n#> [253] \"Asia/Chita\"                       \"Asia/Choibalsan\"                 \n#> [255] \"Asia/Chongqing\"                   \"Asia/Chungking\"                  \n#> [257] \"Asia/Colombo\"                     \"Asia/Dacca\"                      \n#> [259] \"Asia/Damascus\"                    \"Asia/Dhaka\"                      \n#> [261] \"Asia/Dili\"                        \"Asia/Dubai\"                      \n#> [263] \"Asia/Dushanbe\"                    \"Asia/Famagusta\"                  \n#> [265] \"Asia/Gaza\"                        \"Asia/Harbin\"                     \n#> [267] \"Asia/Hebron\"                      \"Asia/Ho_Chi_Minh\"                \n#> [269] \"Asia/Hong_Kong\"                   \"Asia/Hovd\"                       \n#> [271] \"Asia/Irkutsk\"                     \"Asia/Istanbul\"                   \n#> [273] \"Asia/Jakarta\"                     \"Asia/Jayapura\"                   \n#> [275] \"Asia/Jerusalem\"                   \"Asia/Kabul\"                      \n#> [277] \"Asia/Kamchatka\"                   \"Asia/Karachi\"                    \n#> [279] \"Asia/Kashgar\"                     \"Asia/Kathmandu\"                  \n#> [281] \"Asia/Katmandu\"                    \"Asia/Khandyga\"                   \n#> [283] \"Asia/Kolkata\"                     \"Asia/Krasnoyarsk\"                \n#> [285] \"Asia/Kuala_Lumpur\"                \"Asia/Kuching\"                    \n#> [287] \"Asia/Kuwait\"                      \"Asia/Macao\"                      \n#> [289] \"Asia/Macau\"                       \"Asia/Magadan\"                    \n#> [291] \"Asia/Makassar\"                    \"Asia/Manila\"                     \n#> [293] \"Asia/Muscat\"                      \"Asia/Nicosia\"                    \n#> [295] \"Asia/Novokuznetsk\"                \"Asia/Novosibirsk\"                \n#> [297] \"Asia/Omsk\"                        \"Asia/Oral\"                       \n#> [299] \"Asia/Phnom_Penh\"                  \"Asia/Pontianak\"                  \n#> [301] \"Asia/Pyongyang\"                   \"Asia/Qatar\"                      \n#> [303] \"Asia/Qostanay\"                    \"Asia/Qyzylorda\"                  \n#> [305] \"Asia/Rangoon\"                     \"Asia/Riyadh\"                     \n#> [307] \"Asia/Saigon\"                      \"Asia/Sakhalin\"                   \n#> [309] \"Asia/Samarkand\"                   \"Asia/Seoul\"                      \n#> [311] \"Asia/Shanghai\"                    \"Asia/Singapore\"                  \n#> [313] \"Asia/Srednekolymsk\"               \"Asia/Taipei\"                     \n#> [315] \"Asia/Tashkent\"                    \"Asia/Tbilisi\"                    \n#> [317] \"Asia/Tehran\"                      \"Asia/Tel_Aviv\"                   \n#> [319] \"Asia/Thimbu\"                      \"Asia/Thimphu\"                    \n#> [321] \"Asia/Tokyo\"                       \"Asia/Tomsk\"                      \n#> [323] \"Asia/Ujung_Pandang\"               \"Asia/Ulaanbaatar\"                \n#> [325] \"Asia/Ulan_Bator\"                  \"Asia/Urumqi\"                     \n#> [327] \"Asia/Ust-Nera\"                    \"Asia/Vientiane\"                  \n#> [329] \"Asia/Vladivostok\"                 \"Asia/Yakutsk\"                    \n#> [331] \"Asia/Yangon\"                      \"Asia/Yekaterinburg\"              \n#> [333] \"Asia/Yerevan\"                     \"Atlantic/Azores\"                 \n#> [335] \"Atlantic/Bermuda\"                 \"Atlantic/Canary\"                 \n#> [337] \"Atlantic/Cape_Verde\"              \"Atlantic/Faeroe\"                 \n#> [339] \"Atlantic/Faroe\"                   \"Atlantic/Jan_Mayen\"              \n#> [341] \"Atlantic/Madeira\"                 \"Atlantic/Reykjavik\"              \n#> [343] \"Atlantic/South_Georgia\"           \"Atlantic/St_Helena\"              \n#> [345] \"Atlantic/Stanley\"                 \"Australia/ACT\"                   \n#> [347] \"Australia/Adelaide\"               \"Australia/Brisbane\"              \n#> [349] \"Australia/Broken_Hill\"            \"Australia/Canberra\"              \n#> [351] \"Australia/Currie\"                 \"Australia/Darwin\"                \n#> [353] \"Australia/Eucla\"                  \"Australia/Hobart\"                \n#> [355] \"Australia/LHI\"                    \"Australia/Lindeman\"              \n#> [357] \"Australia/Lord_Howe\"              \"Australia/Melbourne\"             \n#> [359] \"Australia/North\"                  \"Australia/NSW\"                   \n#> [361] \"Australia/Perth\"                  \"Australia/Queensland\"            \n#> [363] \"Australia/South\"                  \"Australia/Sydney\"                \n#> [365] \"Australia/Tasmania\"               \"Australia/Victoria\"              \n#> [367] \"Australia/West\"                   \"Australia/Yancowinna\"            \n#> [369] \"Brazil/Acre\"                      \"Brazil/DeNoronha\"                \n#> [371] \"Brazil/East\"                      \"Brazil/West\"                     \n#> [373] \"Canada/Atlantic\"                  \"Canada/Central\"                  \n#> [375] \"Canada/Eastern\"                   \"Canada/Mountain\"                 \n#> [377] \"Canada/Newfoundland\"              \"Canada/Pacific\"                  \n#> [379] \"Canada/Saskatchewan\"              \"Canada/Yukon\"                    \n#> [381] \"CET\"                              \"Chile/Continental\"               \n#> [383] \"Chile/EasterIsland\"               \"Cuba\"                            \n#> [385] \"CST6CDT\"                          \"EET\"                             \n#> [387] \"Egypt\"                            \"Eire\"                            \n#> [389] \"EST\"                              \"EST5EDT\"                         \n#> [391] \"Etc/GMT\"                          \"Etc/GMT-0\"                       \n#> [393] \"Etc/GMT-1\"                        \"Etc/GMT-10\"                      \n#> [395] \"Etc/GMT-11\"                       \"Etc/GMT-12\"                      \n#> [397] \"Etc/GMT-13\"                       \"Etc/GMT-14\"                      \n#> [399] \"Etc/GMT-2\"                        \"Etc/GMT-3\"                       \n#> [401] \"Etc/GMT-4\"                        \"Etc/GMT-5\"                       \n#> [403] \"Etc/GMT-6\"                        \"Etc/GMT-7\"                       \n#> [405] \"Etc/GMT-8\"                        \"Etc/GMT-9\"                       \n#> [407] \"Etc/GMT+0\"                        \"Etc/GMT+1\"                       \n#> [409] \"Etc/GMT+10\"                       \"Etc/GMT+11\"                      \n#> [411] \"Etc/GMT+12\"                       \"Etc/GMT+2\"                       \n#> [413] \"Etc/GMT+3\"                        \"Etc/GMT+4\"                       \n#> [415] \"Etc/GMT+5\"                        \"Etc/GMT+6\"                       \n#> [417] \"Etc/GMT+7\"                        \"Etc/GMT+8\"                       \n#> [419] \"Etc/GMT+9\"                        \"Etc/GMT0\"                        \n#> [421] \"Etc/Greenwich\"                    \"Etc/UCT\"                         \n#> [423] \"Etc/Universal\"                    \"Etc/UTC\"                         \n#> [425] \"Etc/Zulu\"                         \"Europe/Amsterdam\"                \n#> [427] \"Europe/Andorra\"                   \"Europe/Astrakhan\"                \n#> [429] \"Europe/Athens\"                    \"Europe/Belfast\"                  \n#> [431] \"Europe/Belgrade\"                  \"Europe/Berlin\"                   \n#> [433] \"Europe/Bratislava\"                \"Europe/Brussels\"                 \n#> [435] \"Europe/Bucharest\"                 \"Europe/Budapest\"                 \n#> [437] \"Europe/Busingen\"                  \"Europe/Chisinau\"                 \n#> [439] \"Europe/Copenhagen\"                \"Europe/Dublin\"                   \n#> [441] \"Europe/Gibraltar\"                 \"Europe/Guernsey\"                 \n#> [443] \"Europe/Helsinki\"                  \"Europe/Isle_of_Man\"              \n#> [445] \"Europe/Istanbul\"                  \"Europe/Jersey\"                   \n#> [447] \"Europe/Kaliningrad\"               \"Europe/Kiev\"                     \n#> [449] \"Europe/Kirov\"                     \"Europe/Lisbon\"                   \n#> [451] \"Europe/Ljubljana\"                 \"Europe/London\"                   \n#> [453] \"Europe/Luxembourg\"                \"Europe/Madrid\"                   \n#> [455] \"Europe/Malta\"                     \"Europe/Mariehamn\"                \n#> [457] \"Europe/Minsk\"                     \"Europe/Monaco\"                   \n#> [459] \"Europe/Moscow\"                    \"Europe/Nicosia\"                  \n#> [461] \"Europe/Oslo\"                      \"Europe/Paris\"                    \n#> [463] \"Europe/Podgorica\"                 \"Europe/Prague\"                   \n#> [465] \"Europe/Riga\"                      \"Europe/Rome\"                     \n#> [467] \"Europe/Samara\"                    \"Europe/San_Marino\"               \n#> [469] \"Europe/Sarajevo\"                  \"Europe/Saratov\"                  \n#> [471] \"Europe/Simferopol\"                \"Europe/Skopje\"                   \n#> [473] \"Europe/Sofia\"                     \"Europe/Stockholm\"                \n#> [475] \"Europe/Tallinn\"                   \"Europe/Tirane\"                   \n#> [477] \"Europe/Tiraspol\"                  \"Europe/Ulyanovsk\"                \n#> [479] \"Europe/Uzhgorod\"                  \"Europe/Vaduz\"                    \n#> [481] \"Europe/Vatican\"                   \"Europe/Vienna\"                   \n#> [483] \"Europe/Vilnius\"                   \"Europe/Volgograd\"                \n#> [485] \"Europe/Warsaw\"                    \"Europe/Zagreb\"                   \n#> [487] \"Europe/Zaporozhye\"                \"Europe/Zurich\"                   \n#> [489] \"GB\"                               \"GB-Eire\"                         \n#> [491] \"GMT\"                              \"GMT-0\"                           \n#> [493] \"GMT+0\"                            \"GMT0\"                            \n#> [495] \"Greenwich\"                        \"Hongkong\"                        \n#> [497] \"HST\"                              \"Iceland\"                         \n#> [499] \"Indian/Antananarivo\"              \"Indian/Chagos\"                   \n#> [501] \"Indian/Christmas\"                 \"Indian/Cocos\"                    \n#> [503] \"Indian/Comoro\"                    \"Indian/Kerguelen\"                \n#> [505] \"Indian/Mahe\"                      \"Indian/Maldives\"                 \n#> [507] \"Indian/Mauritius\"                 \"Indian/Mayotte\"                  \n#> [509] \"Indian/Reunion\"                   \"Iran\"                            \n#> [511] \"Israel\"                           \"Jamaica\"                         \n#> [513] \"Japan\"                            \"Kwajalein\"                       \n#> [515] \"Libya\"                            \"MET\"                             \n#> [517] \"Mexico/BajaNorte\"                 \"Mexico/BajaSur\"                  \n#> [519] \"Mexico/General\"                   \"MST\"                             \n#> [521] \"MST7MDT\"                          \"Navajo\"                          \n#> [523] \"NZ\"                               \"NZ-CHAT\"                         \n#> [525] \"Pacific/Apia\"                     \"Pacific/Auckland\"                \n#> [527] \"Pacific/Bougainville\"             \"Pacific/Chatham\"                 \n#> [529] \"Pacific/Chuuk\"                    \"Pacific/Easter\"                  \n#> [531] \"Pacific/Efate\"                    \"Pacific/Enderbury\"               \n#> [533] \"Pacific/Fakaofo\"                  \"Pacific/Fiji\"                    \n#> [535] \"Pacific/Funafuti\"                 \"Pacific/Galapagos\"               \n#> [537] \"Pacific/Gambier\"                  \"Pacific/Guadalcanal\"             \n#> [539] \"Pacific/Guam\"                     \"Pacific/Honolulu\"                \n#> [541] \"Pacific/Johnston\"                 \"Pacific/Kanton\"                  \n#> [543] \"Pacific/Kiritimati\"               \"Pacific/Kosrae\"                  \n#> [545] \"Pacific/Kwajalein\"                \"Pacific/Majuro\"                  \n#> [547] \"Pacific/Marquesas\"                \"Pacific/Midway\"                  \n#> [549] \"Pacific/Nauru\"                    \"Pacific/Niue\"                    \n#> [551] \"Pacific/Norfolk\"                  \"Pacific/Noumea\"                  \n#> [553] \"Pacific/Pago_Pago\"                \"Pacific/Palau\"                   \n#> [555] \"Pacific/Pitcairn\"                 \"Pacific/Pohnpei\"                 \n#> [557] \"Pacific/Ponape\"                   \"Pacific/Port_Moresby\"            \n#> [559] \"Pacific/Rarotonga\"                \"Pacific/Saipan\"                  \n#> [561] \"Pacific/Samoa\"                    \"Pacific/Tahiti\"                  \n#> [563] \"Pacific/Tarawa\"                   \"Pacific/Tongatapu\"               \n#> [565] \"Pacific/Truk\"                     \"Pacific/Wake\"                    \n#> [567] \"Pacific/Wallis\"                   \"Pacific/Yap\"                     \n#> [569] \"Poland\"                           \"Portugal\"                        \n#> [571] \"PRC\"                              \"PST8PDT\"                         \n#> [573] \"ROC\"                              \"ROK\"                             \n#> [575] \"Singapore\"                        \"Turkey\"                          \n#> [577] \"UCT\"                              \"Universal\"                       \n#> [579] \"US/Alaska\"                        \"US/Aleutian\"                     \n#> [581] \"US/Arizona\"                       \"US/Central\"                      \n#> [583] \"US/East-Indiana\"                  \"US/Eastern\"                      \n#> [585] \"US/Hawaii\"                        \"US/Indiana-Starke\"               \n#> [587] \"US/Michigan\"                      \"US/Mountain\"                     \n#> [589] \"US/Pacific\"                       \"US/Samoa\"                        \n#> [591] \"UTC\"                              \"W-SU\"                            \n#> [593] \"WET\"                              \"Zulu\"                            \n#> attr(,\"Version\")\n#> [1] \"2021e\"\n\ndatum.1 > datum.2\n#> [1] TRUE\ndatum.ido.1 <= datum.ido.2\n#> [1] FALSE\n\nunclass(datum.ido.1)\n#> [1] 1640727417"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-12-summary","chapter":"5 Az R nyelv","heading":"5.4.3 Részösszefoglalás","text":"","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-12-exercise","chapter":"5 Az R nyelv","heading":"5.4.4 Feladatok","text":"Konvertáljuk dátummá következő két sztringet: \"6November2020\", \"2013-02-29\"! Utóbbi esetben mi lehet hiba oka?seq() függvény = és = argumentuma dátum típusú objektumokkal működik. = argumentum értéke ilyenkor lehet numerikus (ekkor napokat jelent), de lehet x weeks, x months vagy x years, ahol x nullánál nagyobb egész lehet. Hozzunk létre egy dátum-vektort 2020 összes hétfőjének dátumával!","code":""},{"path":"az-r-nyelv.html","id":"tibble","chapter":"5 Az R nyelv","heading":"5.4.5 Tibble","text":"Tidyverse R használata során az adatainkat tibble típusú objektumban tároljuk. Használatához töltsük tidyverse csomagot.tibble objektumok alaptípusa lista, de az osztálytípusok között megjelennek tibble-re specifikus osztályok . tbl_df osztály jelenléte hozza magával azokat az új tulajdonságokat és lehetőségeket, amit Tidyverse R központi adatszerkezetévé teszi ezt az objektumtípust.tibble és data frame típusú objektumok között az átjárhatóságot az as_tibble() és az .data.frame() függvény biztosítja.tibble típus tesztelése az is_tibble() segítségével történik, de tibble típusú objektumokra az .data.frame() igaz értékkel tér vissza:Melyek data frame és tibble közötti különbségek? Már három eltérést akár észre vehettünk. Az első tibble létrehozásához kötődik. Egy tibble típusú objektum, csak azonos hosszúságú oszlopvektorokból hozható létre, így biztonságosabban konstruálható, mint az ismétlést támogató data frame típusú objektumok. Tibble esetében csak az egy hosszú vektorok ismétlése megengedett. Tehát ez konstrukció működik:második különbség, hogy tibble létrehozás során nem végez automatikus típuskonverziót. Tehát karakteres vektorokat nem alakítja át faktorokká.harmadik különbség az adatok megjelenítésében van. Tibble esetében csak az első 10 sor jelenik meg, és annyi oszlop, amennyi az aktuális képernyőre kifér. több oszlop neve alul jelenik meg. Az oszlopnevek alatt az oszlop típusa megjelenik.negyedik eltérés tibble indexeléséhez kötődik. Az [ operátor használata során minden esetben tibble típusú objektumot kapunk, nem kaphatunk vektort, azaz nem történhet dimenzióvesztés.","code":"\nlibrary(tidyverse)\nx <- rep(c('A','B'), times=4); y <- rep(6:9, times=2); z <- 1:8\ndf <- tibble(nev=x, pont.1=y, pont.2=z)\ndf\n#> # A tibble: 8 x 3\n#>   nev   pont.1 pont.2\n#>   <chr>  <int>  <int>\n#> 1 A          6      1\n#> 2 B          7      2\n#> 3 A          8      3\n#> 4 B          9      4\n#> 5 A          6      5\n#> 6 B          7      6\n#> 7 A          8      7\n#> 8 B          9      8\nattributes(df)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5 6 7 8\n#> \n#> $names\n#> [1] \"nev\"    \"pont.1\" \"pont.2\"\ntypeof(df); class(df)\n#> [1] \"list\"\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\nas_tibble(df)\n#> # A tibble: 8 x 3\n#>   nev   pont.1 pont.2\n#>   <chr>  <int>  <int>\n#> 1 A          6      1\n#> 2 B          7      2\n#> 3 A          8      3\n#> 4 B          9      4\n#> 5 A          6      5\n#> 6 B          7      6\n#> 7 A          8      7\n#> 8 B          9      8\nas.data.frame(df)\n#>   nev pont.1 pont.2\n#> 1   A      6      1\n#> 2   B      7      2\n#> 3   A      8      3\n#> 4   B      9      4\n#> 5   A      6      5\n#> 6   B      7      6\n#> 7   A      8      7\n#> 8   B      9      8\nis_tibble(df); is.data.frame(df)\n#> [1] TRUE\n#> [1] TRUE\ntibble(a=c(\"a\", \"b\", \"c\"), p=1)\n#> # A tibble: 3 x 2\n#>   a         p\n#>   <chr> <dbl>\n#> 1 a         1\n#> 2 b         1\n#> 3 c         1\nstr(df)\n#> tibble [8 x 3] (S3: tbl_df/tbl/data.frame)\n#>  $ nev   : chr [1:8] \"A\" \"B\" \"A\" \"B\" ...\n#>  $ pont.1: int [1:8] 6 7 8 9 6 7 8 9\n#>  $ pont.2: int [1:8] 1 2 3 4 5 6 7 8\ndf[, 2]\n#> # A tibble: 8 x 1\n#>   pont.1\n#>    <int>\n#> 1      6\n#> 2      7\n#> 3      8\n#> 4      9\n#> 5      6\n#> 6      7\n#> 7      8\n#> 8      9\ndf[1, ]\n#> # A tibble: 1 x 3\n#>   nev   pont.1 pont.2\n#>   <chr>  <int>  <int>\n#> 1 A          6      1\ndf[1, 2]\n#> # A tibble: 1 x 1\n#>   pont.1\n#>    <int>\n#> 1      6\ndf[1, 2, drop=T]\n#> [1] 6"},{"path":"az-r-nyelv.html","id":"a-munkaterület-függvényei","chapter":"5 Az R nyelv","heading":"5.4.6 A munkaterület függvényei","text":"Megbeszéltük, hogy munka során az objektumaink memória speciális területére, munkaterületre (workspace) kerülnek. Ha még korábban nem hoztunk létre objektumot, akkor következő három parancs, három objektumot hoz létre munkaterületen:munkaterületen létrehozott objektumok neveit az ls() függvény listázza ki:munkaterületről objektumot az rm() paranccsal távolíthatunk el, például aa fib.0 objektumot távolította el, így az ls() eredményében ez nem szerepel. Az összes munkaterület-objektum eltávolítása asegítségével történik.","code":"\nfib.0 <- 0\nfib.1 <- 1\nfib.2 <- fib.0 + fib.1\n# ls()\nrm(fib.0)         # fib.0 törlése\nls()\n#>  [1] \"a\"               \"alap\"            \"d\"               \"D\"              \n#>  [5] \"datum.1\"         \"datum.2\"         \"datum.ido.1\"     \"datum.ido.2\"    \n#>  [9] \"df\"              \"df2\"             \"df3\"             \"diff.1\"         \n#> [13] \"diff.2\"          \"diff.3\"          \"diff.4\"          \"diff.5\"         \n#> [17] \"egyutthato.a\"    \"egyutthato.b\"    \"egyutthato.c\"    \"eset.1\"         \n#> [21] \"eset.2\"          \"eset.3\"          \"fib.1\"           \"fib.2\"          \n#> [25] \"fiu\"             \"foglalkozas\"     \"hazas\"           \"ido.1\"          \n#> [29] \"ido.2\"           \"import_example\"  \"isk.vegz\"        \"isk.vegz.f\"     \n#> [33] \"iteletek\"        \"lakohely\"        \"lct\"             \"m\"              \n#> [37] \"magassag\"        \"nev\"             \"nevek\"           \"obj.double\"     \n#> [41] \"obj.integer\"     \"obj.karakteres\"  \"obj.logikai\"     \"peter.bmi\"      \n#> [45] \"peter.magassaga\" \"peter.sulya\"     \"pontszamok\"      \"pulzus.atlag\"   \n#> [49] \"Pulzus.atlag\"    \"regi.v.1\"        \"regi.v.2\"        \"szamok\"         \n#> [53] \"tab1\"            \"tab2\"            \"tab3\"            \"table.kiir\"     \n#> [57] \"tan.ido\"         \"tipus\"           \"uj.v\"            \"v.d\"            \n#> [61] \"v.i\"             \"v.k\"             \"v.l\"             \"van.kocsija\"    \n#> [65] \"x\"               \"x.d\"             \"x.f\"             \"x.f.1\"          \n#> [69] \"x.f.2\"           \"x.f.3\"           \"y\"               \"z\"              \n#> [73] \"z.uj\"\n# rm(list = ls())   # összes objektum törlése\n# ls()"},{"path":"az-r-nyelv.html","id":"a-munkakönyvtár-függvényei","chapter":"5 Az R nyelv","heading":"5.4.7 A munkakönyvtár függvényei","text":"Az R használata során mindig van egy kitüntetett, aktuális könyvtárunk, amelyet munkakönyvtárnak nevezünk. munkakönyvtár célja, hogy az állományok nyitása és mentése során, ha nem használunk külön könyvtárhivatkozást, akkor ez lesz az alapértelmezett könyvtár.munkakönyvtár az R-ben lekérdezhető ill. beállítható getwd() és setwd() parancsok kiadásával. Példáulparancsokkal először megismerjük az aktuális könyvtárat, majd megváltoztatjuk C:/Data/peldak könyvtárra. Figyeljük meg, hogy az elérési útban perjelet (/) használtunk.Megjegyezzük, hogy az RStudio projekt üzemmódú használata során nincs szükség munkakönyvtár beállítására setwd() paranccsal, sőt, kerüljük használatát. munkakönyvtárunk munka során végig maradjon meg az alapértelmezetten beállított könyvtár, maga projektkönyvtár.munkakönyvtár jelentőségét tovább növeli, hogy az R indításakor ebben könyvtárban 2 állomány létezését figyeli:\n* .Rhistory (visszahívható parancsokat tartalmazó szöveges állomány)\n* .RData (tárolt objektumokat tartalmazó bináris állomány).fenti állományok ugyanis betöltésre kerülnek az R indításakor, ha azokat az R megtalálja munkakönyvtárban. Így ezek után, az .Rhistory állományból jövő parancsok között válogathatunk parancssor használata során, illetve az .RData állományban tárolt objektumok azonnal elérhetőek, vagyis lesz egy induló munkaterületünk.","code":"\ngetwd()\nsetwd(\"C:/Data/peldak\")"},{"path":"az-r-nyelv.html","id":"csomagkezelő-függvények","chapter":"5 Az R nyelv","heading":"5.4.8 Csomagkezelő függvények","text":"Korábban megbeszéltük, hogy csomagok adatobjektumokat és függvényeket tartalmaznak. Az ún. egyéb csomagok (számuk kb. 17000) elsődleges célja az Alap R tudásának kiegészítése.Az R indítása után néhány csomag automatikusan betöltésre kerül standard csomagok közül. Ezeket csomagokat és egyéb ún. környezeteket listázhatunk ki search() függvénnyel.fenti eredményben package karaktersorozattal kezdődő elemek mutatják, hogy melyek az éppen betöltött csomagok. listában nem szereplő, de korábban telepített csomagok betöltéséhez használjuk library() vagy require() függvényeket.fenti példában MASS és foreign csomag betöltését és annak hatását követhetjük nyomon search() függvény ouputjára. Egy csomag betöltése azt jelenti, hogy csomagban lévő függvények és objektumok memóriába kerültek, azokat parancsainkban ezután szabadon felhasználhatjuk.Egy adott csomagban (esetünkben foreign csomagban) lévő függvények és objektumok avagy aparanccsal kérdezhetők le. Betöltött csomagok esetében használhatjuk azparancsot , amely csomag adatobjektumainak és függvényeinek nevét listázza.Betöltött csomagot detach() függvénnyel távolíthatunk el memóriából:Ha használni kívánt csomag még nincs telepítve számítógépünkre, akkor az @ref(Csomagok_telepitese) fejezetben ismertetett módok egyikét válasszuk, attól függően, hogy csomag melyik tárhelyről érhető el.CRAN-ról elérhető csomagok közül telepítsük fel DescTools és psych csomagokat:számítógépünkön telepített csomagokról az installed.packages() függvény ad tájékoztatást. Amennyiben aparancsot kiadjuk az RStudio-ban, akkor csomagjainkat kényelmesen áttekinthetjük.Csomagok frissítésére használjuk már korábban említettparancsot.","code":"\nsearch()\ndetach(\"tools:rstudio\")\n## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(MASS)\nrequire(foreign)\nsearch()\n##  [1] \".GlobalEnv\"        \"package:foreign\"   \"package:MASS\"     \n##  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n##  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n## [10] \"Autoloads\"         \"package:base\"  \nlibrary(help=foreign)\nhelp(package=foreign)\nls(name=\"package:foreign\", all.names = T)\nls(name=\"package:base\", all.names = T)\ndetach(package:foreign)\ndetach(package:MASS)\ninstall.packages(\"DescTools\")\ninstall.packages(\"psych\")\ncsomagok <- installed.packages()\nView(csomagok)                    # RStudio-ban vagy RGui-ban\nupdate.packages()"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-14-exercise","chapter":"5 Az R nyelv","heading":"5.4.9 Feladatok","text":"Írassuk ki munkaterület objektumait!Hozzunk létre egy pulzus nevű objektumot és újra írassuk ki munkaterület objektumneveit!Távolítsuk el pulzus objektumot munkaterületről!Határozzuk meg az aktuális munkakönyvtárat!Növeljük meg betű méretét az RGui, az R Commander és az R Studio alkalmazásokban !Vizsgáljuk meg, hogy számítógépünkön van-e telepítve DescTools csomag, ha nincs telepítsük! Derítsük ki, hogy DescTools csomagnak mi célja? Soroljunk fel három függvényt és adattáblát ebből csomagból! Távolítsuk el memóriából DescTools csomagot!Telepítsük számítógépünkre következő csomagokat: HSAUR2, psych, prettyR, descr és pastecs!","code":""},{"path":"az-r-nyelv.html","id":"objektumok-és-típusok","chapter":"5 Az R nyelv","heading":"5.5 Objektumok és típusok","text":"Az R-ben használható objektumok név-érték párok, vagyis minden objektumnak van neve és értéke. Objektumok alatt ebben könyvben az adatobjektumokat értjük, bár már említettünk, hogy valójában függvények objektumoknak tekinthetők az R-ben, hiszen függvénynek van neve, és értéke, az utóbbi pedig utasítások sorozata. Az R-ben minden objektum, például az eddig vizsgált vektorok, attribútumokkal rendelkezhetnek. Az attribútumok név-értek párok, amelyek speciális tulajdonságokkal ruházzák fel az objektumunkat. Például names nevű attribútummal vektor egyes elemeit nevezhetjük el. Későbbiekben látjuk dim, dimnames, level és class attribútumok jelentőségét .Egy objektum összes attribútuma az attributes() függvénnyel kérdezhetők le. Ha names attribútumra vagyunk kíváncsiak names() függvényt használhatjuk. Ha létrehozunk egy x numerikus vektort, akkorAz x numerikus vektornak nincsenek attribútumai. NULL az általános, elem nélküli vektort jelenti. fenti outputban szereplő két NULL esetünkben azt jelzi, hogy nem állítottunk semmilyen attribútumot, így names attribútumot sem.names attribútum beállítható names() függvénnyel .names attribútum értéke karakteres vektor lehet, amely az outputokban megjelenik és indexelésben felhasználhatjuk.Rögzítsük (0, 1, 2) értékek előfordulási gyakoriságait (18, 12, 20) elemeket tartalmazó vektorban. Az elemek nevei karakteres konstansok lesznek, az automatikus konverzióról az R gondoskodik.Az y vektor indexelésénél fontos, hogy megkülönböztessük numerikus és karakteres indexeket, az utóbbiaknál mindig idézőjelet kell használnunk.Egyetlen attribútum lekérdezésére és beállítására az attr() függvényt használhatjuk. Az attr() függvényben meg kell adnunk az elérendő attribútum nevét .Attribútumok törlésére NULL értéket használjuk.dim argumentumAmennyibenOsztályokA faktor ennek megfelelően tartalmaz egy levels attribútumot, amely faktor különböző értékeit (szintjeit) sorolja fel. faktorok class attribútumának értéke pedig factor.class() függvény az objektum class argumentumával tér vissza. Azok az objektumok, amelyek nem rendelkeznek class argumentummal, class() visszatérési értéke\"numeric\", ha az objektum integer vagy double vektor\"array\" és/vagy \"matrix\", ha az objektum rendelkezik dim attributummalmás esetben typeof() visszatérési értékével.Az unclass() visszatérési értéke az az objektum, amelynek class attribűtumát eltávolították.korábban tárgyat típusok mindegyike osztály: Date, difftime, POSIXct, POSIXlt, table.listaelemek nevét x lis names attribútuma tartalmazza, segítségével többi elemnek adhatunk értéket:","code":"\nx <- 1:5        # integer vektor\nattributes(x)   # x attribútumainak kiírása \n#> NULL\nnames(x)        # x name attribútumának kiírása\n#> NULL\n\nx <- numeric(0)\nmode(x) <- \"list\"\nclass(x)\n#> [1] \"list\"\nlength(x)\n#> [1] 0\n\nattr(x, \"length\") <- \"integer\"\nx <- c(\"a\"=1, \"b\"=2, \"c\"=3, \"d\"=4, \"e\"=5) # integer vektor\nattributes(x)                  # x attribútumainak kiírása \n#> $names\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\"\nnames(x)                       # x name attribútumának kiírása\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\"\nnames(x) <- c(\"elégtelen\", \"elégséges\", \"közepes\", \"jó\", \"jeles\")\nattributes(x)                  # x attribútumainak kiírása \n#> $names\n#> [1] \"elégtelen\" \"elégséges\" \"közepes\"   \"jó\"        \"jeles\"\nnames(x)                       # x name attribútumának kiírása\n#> [1] \"elégtelen\" \"elégséges\" \"közepes\"   \"jó\"        \"jeles\"\nx\n#> elégtelen elégséges   közepes        jó     jeles \n#>         1         2         3         4         5\nx[c(\"közepes\", \"jó\")]\n#> közepes      jó \n#>       3       4\ny <- c(18, 12, 20)\nnames(y) <- 0:2\ny\n#>  0  1  2 \n#> 18 12 20\nnames(y)\n#> [1] \"0\" \"1\" \"2\"\nx[1]\n#> elégtelen \n#>         1\nx[\"1\"]\n#> <NA> \n#>   NA\nx[c(1,3)]; x[c(\"0\", \"2\")]\n#> elégtelen   közepes \n#>         1         3\n#> <NA> <NA> \n#>   NA   NA\nattr(x, \"names\") <- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nattr(x, \"names\")\n#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nattributes(x)\n#> $names\n#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nnames(x) <- NULL             # names attribútum törlése\nattr(x, \"names\") <- NULL     # names attribútum törlése\nattributes(x) <- NULL        # az összes attribútum törlése\nx <- 1:12                      # integer vektor\nx\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12\nattr(x, \"dim\") <- c(2,6)       # integer mátrix (2x6-os)       \nattributes(x)\n#> $dim\n#> [1] 2 6\nx\n#>      [,1] [,2] [,3] [,4] [,5] [,6]\n#> [1,]    1    3    5    7    9   11\n#> [2,]    2    4    6    8   10   12\nattr(x, \"dim\") <- c(2, 3, 2)   # integer tömb (2x3x2-es)\nattributes(x)\n#> $dim\n#> [1] 2 3 2\nx\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\nx <- 1:12                      # integer vektor\nattr(x, \"dim\") <- c(2,6)       # integer mátrix (2x6-os)       \ndimnames(x) <- list(nem=c(\"férfi\", \"nő\"), osztaly=LETTERS[1:6])        \nx\n#>        osztaly\n#> nem     A B C D  E  F\n#>   férfi 1 3 5 7  9 11\n#>   nő    2 4 6 8 10 12\nattributes(x)\n#> $dim\n#> [1] 2 6\n#> \n#> $dimnames\n#> $dimnames$nem\n#> [1] \"férfi\" \"nő\"   \n#> \n#> $dimnames$osztaly\n#> [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\nf <- factor(c(\"a\", \"b\", \"a\"))\nattributes(f)\n#> $levels\n#> [1] \"a\" \"b\"\n#> \n#> $class\n#> [1] \"factor\"\nlevels(f)\n#> [1] \"a\" \"b\"\nclass(f)\n#> [1] \"factor\"\nclass(f) <- NULL\n#attributes(f)<- NULL\n#f\nunclass(f)\n#> [1] 1 2 1\n#> attr(,\"levels\")\n#> [1] \"a\" \"b\"\nx <- as.Date(\"2020-03-12\")\nattributes(x)\n#> $class\n#> [1] \"Date\"\nclass(x)\n#> [1] \"Date\"\n\nx <- Sys.Date()-as.Date(\"2020-03-12\")\nx\n#> Time difference of 656 days\nattributes(x)\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"days\"\nclass(x)\n#> [1] \"difftime\"\n\nx <- ISOdate(year = 2020, month = 12, day = 2)\nx\n#> [1] \"2020-12-02 12:00:00 GMT\"\nattributes(x)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"GMT\"\nclass(x)\n#> [1] \"POSIXct\" \"POSIXt\"\n\nx <- as.POSIXlt(x)\nx\n#> [1] \"2020-12-02 12:00:00 GMT\"\nattributes(x)\n#> $names\n#> [1] \"sec\"   \"min\"   \"hour\"  \"mday\"  \"mon\"   \"year\"  \"wday\"  \"yday\"  \"isdst\"\n#> \n#> $class\n#> [1] \"POSIXlt\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"GMT\"\nclass(x)\n#> [1] \"POSIXlt\" \"POSIXt\"\n\nx <- table(sample(LETTERS[1:3], 100, replace = T))\nx\n#> \n#>  A  B  C \n#> 44 24 32\nattributes(x)\n#> $dim\n#> [1] 3\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> \n#> $class\n#> [1] \"table\"\nclass(x)\n#> [1] \"table\"\nnames(x)\n#> [1] \"A\" \"B\" \"C\"\nnames(x)[c(1,2)] <- c(\"a\",\"b\")\nnames(x)\n#> [1] \"a\" \"b\" \"C\"\nx\n#>  a  b  C \n#> 44 24 32"},{"path":"az-r-nyelv.html","id":"értékek-kizárása","chapter":"5 Az R nyelv","heading":"5.5.0.1 Értékek kizárása","text":"faktor létrehozásánál gondoskodhatunk bizonyos értékek kizárásáról, olyan értékekről, amelyeket nem szeretnénk faktorban felsorolni:Alapértelmezés szerint az NA értéket zárjuk ki faktor szintjeiből, de ezt megváltoztathatjuk az exclude= paraméter használatával:Ahogy látjuk fenti példában, akár az NA értéket bevonhatjuk faktor szintjeibe, akár más értékeket kizárhatunk az NA-n kívül.Nézzük, hogyan tekint az R az adattáblára.Az adattáblák alaptípusa list, osztálytípusa pedig data.frame hossza pedig az alkotó (oszlop)vektorok/faktorok száma. Az adattáblára tehát tekinthetünk úgy, mint egy listára, melynek elemei az adattábla oszlopai lesznek.Feladat234\n(23)4\n2(34)","code":"\nfactor(c(1:5, NA, 3:6))\n#>  [1] 1    2    3    4    5    <NA> 3    4    5    6   \n#> Levels: 1 2 3 4 5 6\nfactor(c(1:5, NA, 3:6), exclude=NULL)\n#>  [1] 1    2    3    4    5    <NA> 3    4    5    6   \n#> Levels: 1 2 3 4 5 6 <NA>\nfactor(c(1:5, NA, 3:6), exclude=c(4, NA))\n#>  [1] 1    2    3    <NA> 5    <NA> 3    <NA> 5    6   \n#> Levels: 1 2 3 5 6\n#typeof(df); class(df); length(df)\n#is.list(df); is.matrix(df); is.data.frame(df)"},{"path":"beolvasas.html","id":"beolvasas","chapter":"6 Beolvasás","heading":"6 Beolvasás","text":"","code":""},{"path":"beolvasas.html","id":"beolvas-kiir","chapter":"6 Beolvasás","heading":"6.1 Alapvető formátumok","text":"Ebben fejezetben áttekintjük:mit nevezünk tagolt szöveges állománynak, hogyan hozzuk létreinline és állományos beolvasás közötti különbségaz inline beolvasás eseteitagolt szöveges állomány beolvasása és kiírása (AR és TR)fix széles mezővel rendelkező állományok olvasásamás statisztikai programcsomagok adatállományainak olvasása és írásaobjektumok írása és olvasása bináris állományba","code":""},{"path":"adatmanipulacio.html","id":"adatmanipulacio","chapter":"7 Adatmanipuláció","heading":"7 Adatmanipuláció","text":"","code":""},{"path":"adatmanipulacio.html","id":"adatkezelés-az-alap-r-ben","chapter":"7 Adatmanipuláció","heading":"7.1 Adatkezelés az Alap R-ben","text":"","code":""},{"path":"leiro-statisztika.html","id":"leiro-statisztika","chapter":"8 Leíró statisztika","heading":"8 Leíró statisztika","text":"","code":""},{"path":"grafika-az-r-ben.html","id":"grafika-az-r-ben","chapter":"9 Grafika az R-ben","heading":"9 Grafika az R-ben","text":"Ebben fejezetben áttekintjük:az R grafikus rendszereia hagyományos grafika alapfogalmaimagasszintű és alacsonyszintű rajzfüggvények hagyományos grafikábana ggplot2 rendszer alapelveábrák létrehozása ggplot2-benábrák mentése háttértárra","code":""},{"path":"hipotezisvizsgalatok.html","id":"hipotezisvizsgalatok","chapter":"10 Hipotézisvizsgálatok","heading":"10 Hipotézisvizsgálatok","text":"Ebben fejezetben statisztika azon klasszikus próbáit foglaltuk össze, amelyek jellemzően egy- vagy kétmintás hipotézisvizsgálatokat jelentenek. Az öt alfejezet nullhipotézisben szereplő állításoknak és paramétereknek megfelelően statisztikai próbák különböző csoportjait fedi le:várható értékre vonatkozó próbákmediánra vonatkozó nemparaméteres próbákvalószínűségre vonatkozó próbákvarianciára vonatkozó próbákaz eloszlás egészére vonatkozó próbák.","code":""},{"path":"publikacio.html","id":"publikacio","chapter":"11 Publikáció","heading":"11 Publikáció","text":"","code":""},{"path":"publikacio.html","id":"reprodukálható-kutatás","chapter":"11 Publikáció","heading":"11.1 Reprodukálható kutatás","text":"kutatás és oktatás világában jelentős elmozdulás figyelhető meg reprodukálható kutatás felé.igénye felé. „Az akadémiai kutatás végső terméke papír, laboratóriumi jegyzetfüzetekkel és teljes számítási környezettel együtt az eredmények előállítása érdekében, mint például kód, az adatok stb., Amelyek felhasználhatók az eredmények reprodukálására és új munka létrehozására kutatás ”(Wikipedia).Ennek következménye az, hogy meg kell változtatnunk szokásainkat, és minden kéziratunkat, előadásainkat, házi feladatainkat stb. Tiszta és reprodukálható formában kell elkezdenünk, azaz ha valaki megadja kódot, akkor ez személy pontosan reprodukálhatja dokumentumot. Ez dokumentum megkönnyíti ezt az átmenetet az R Markdown segítségével.","code":""},{"path":"megoldasok.html","id":"megoldasok","chapter":"A Megoldások","heading":"A Megoldások","text":"","code":""},{"path":"megoldasok.html","id":"itt-kezdodik-1-exercise-solution","chapter":"A Megoldások","heading":"A.1 Megoldások az 1.1.2 feladatokhoz","text":"Milyen online vagy nyomtat könyvek segítik az R elsajátítását? Próbáljuk összegyűjteni magyar nyelvű könyveket !Az R könyvekkel kapcsolatban könnyen az lehet az érzésünk, hogy túl sok könyv, és túl kevés az idő. Valóban tengernyi R könyv vásárolható meg, melyek többsége angol nyelvű. Elegendő Springer Use R! könyvsorozatára gondolni, amely önmagában több mint 80 címet tartalmaz. Az Amazon-ról elérhető, 2020. januárja után megjelent könyvek száma túl van kétszázon.Különösen értékesek lehetnek az online elérhető könyvek. Az idegen nyelvű könyvek tematikus gyűjteménye Big Book R, míg az R erőforrásokról saját listát karbantartok.magyar nyelvű könyvek közül külön felsorolunk néhányat:Reiczigel Jenő, Harnos Andrea, Solymosi Norbert (2021). Biostatisztika nem statisztikusoknak. Pars Kft., Nagykovácsi.Dinya Elek, Solymosi Norbert (2016). Biometria klinikumban 2. Feladatok megoldása R-környezetben. Medicina Kiadó.Münnich Ákos, Nagy Ágnes, Abari Kálmán. Többváltozós statisztika pszichológus hallgatók számára. Bölcsész Konzorcium, Debrecen, 2006. (http://psycho.unideb.hu/statisztika)\nISBN 963 9704 04 0Térképezzük fel az online videókurzusokat az R tanulásához!videókurzusok többsége angol nyelvű, Youtube-ról ingyenesen, de Udemy vagy datacamp oldaláról előfizetés ellenében több száz kurzust elérhetünk.Az R-rel való ismerkedést kezdhetjük az R gyakorlatban videósorozatommal .bevezető példa (Két tanítási módszer összehasonlítása) megoldásában hipotézisvizsgálat alapján adjunk szöveges értékelést!Mann-Whitney-próba alapján azt mondhatjuk, elegendő bizonyítékot találtunk arra, hogy modern (Sprego) módszer eredményesebb (Mdn=0,36), mint hagyományos (Mdn=0,66) tanítási módszer (W=24; p=0,001).","code":""},{"path":"szinek.html","id":"szinek","chapter":"B Színek","heading":"B Színek","text":"Az R grafikus elemeinek színét magunk megválaszthatjuk. Ehhez nyújt segítséget ez függelék.Megismerjükaz előre definiált paletta színeit (B.1 fejezet),színek választását az RColorBrewer csomag segítségével (B.2 fejezet),színek választása dichromat csomag segítségével (B.3 fejezet),színek választását egyéb paletták segítségével (B.4 fejezet),és végül az előre definiált 657 színnevet (B.5 fejezet).","code":""},{"path":"szinek.html","id":"az-elore-definialt","chapter":"B Színek","heading":"B.1 Az előre definiált paletta színei","text":"Az előre definiált paletta 8 színt tartalmaz. B.1 ábra az alapértelmezett színeket tartalmazza. Az előre definiált paletta egyes színeit sorszámokkal (1, 2 stb.) tudjuk elérni, amelyeket rendszerint rajzfüggvények col= argumentumában kell elhelyezni. Az 1. szín palettán fekete, második piros, és így tovább.\nÁBRA B.1: Az alapértelmezett paletta 8 színének sorszáma és neve\nMás színeket alapértelmezetté tehetünk, sőt színek számát megnövelhetjük palettán. Ennek legegyszerűbb módja, ha palette() függvény argumentumában színkódokat tartalmazó karakteres vektort adunk meg.rajzfüggvények ezután paletta új színeit használják.Ha megváltoztattuk paletta színeit, akkor az alapértelmezett színekhez palette(\"default\") paranccsal térhetünk vissza.","code":"\nset.seed(0)\nx <- rpois(n = 50, lambda = 100)\npar(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1))\nbar <- barplot(x[1:8], col = 1:8, names.arg = 1:8)\nmtext(side = 1, at = bar, text = palette(), line = 1)\nszinek <- c(\"#E84F2C\", \"#E31307\", \"#E84F2C\", \"#E4BA51\", \"#E3B786\", \"#825846\", \n    \"#59392A\", \"#564C30\", \"#897D6E\", \"#627C82\", \"#93AF8A\", \"#A0BA5E\", \"#63BA5E\", \n    \"#5EBAB2\", \"#6596B7\")\npalette(value = szinek)\nbarplot(x[1:15], col = 1:15)\npalette(value = \"default\")  # alapértelmezett paletta visszaállítása"},{"path":"szinek.html","id":"szinek-valasztasa-rcolorbrewer","chapter":"B Színek","heading":"B.2 Színek választása az RColorBrewer csomag segítségével","text":"Az RColorBrewer csomag brewer.pal() függvénye szolgál az előre definiált színpaletták alapján színkódokat tartalmazó vektor létrehozására. függvény általános alakja:Az n= kívánt színek számát határozza meg, amely háromnál nem lehet kevesebb. name= színpaletta nevét tartalmazza. választható neveket brewer.pal.info adattábla tartalmazza, amely palettából elérhető összes szín számát és paletta típusát tartalmazza. Ez utóbbi category oszlopban olvasható, amelynek lehetséges értékei: seq, div és qual. szekvenciális palettákat (seq) rendezett adatok ábrázolására használhatjuk: világosabb színek kisebb értékeket, sötétebbek nagyobbakat szemléltethetik. divergens (div) paletták középső részt világosabb színekkel, szélső értékeket sötétebb színekkel jelenítik meg. kvalitatív (qual) paletta kategorikus változók megjelenítésére használható.továbbiakban brewer.pal() függvény használatára mutatunk példát:","code":"\nlibrary(RColorBrewer)\nbrewer.pal(n, name)\nlibrary(RColorBrewer)\nbrewer.pal.info\n#>          maxcolors category colorblind\n#> BrBG            11      div       TRUE\n#> PiYG            11      div       TRUE\n#> PRGn            11      div       TRUE\n#> PuOr            11      div       TRUE\n#> RdBu            11      div       TRUE\n#> RdGy            11      div      FALSE\n#> RdYlBu          11      div       TRUE\n#> RdYlGn          11      div      FALSE\n#> Spectral        11      div      FALSE\n#> Accent           8     qual      FALSE\n#> Dark2            8     qual       TRUE\n#> Paired          12     qual       TRUE\n#> Pastel1          9     qual      FALSE\n#> Pastel2          8     qual      FALSE\n#> Set1             9     qual      FALSE\n#> Set2             8     qual       TRUE\n#> Set3            12     qual      FALSE\n#> Blues            9      seq       TRUE\n#> BuGn             9      seq       TRUE\n#> BuPu             9      seq       TRUE\n#> GnBu             9      seq       TRUE\n#> Greens           9      seq       TRUE\n#> Greys            9      seq       TRUE\n#> Oranges          9      seq       TRUE\n#> OrRd             9      seq       TRUE\n#> PuBu             9      seq       TRUE\n#> PuBuGn           9      seq       TRUE\n#> PuRd             9      seq       TRUE\n#> Purples          9      seq       TRUE\n#> RdPu             9      seq       TRUE\n#> Reds             9      seq       TRUE\n#> YlGn             9      seq       TRUE\n#> YlGnBu           9      seq       TRUE\n#> YlOrBr           9      seq       TRUE\n#> YlOrRd           9      seq       TRUE\n# az x adatvektor beállítása\nset.seed(0)\nx <- rpois(n = 50, lambda = 100)\n# grafikus paraméterek beállítása\npar(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1))\nlibrary(RColorBrewer)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"BrBG\"), names.arg = 1:11, \n    main = \"BrBG, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"BrBG\"), names.arg = 1:11, \n    main = \"BrBG, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"PiYG\"), names.arg = 1:11, \n    main = \"PiYG, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"PiYG\"), names.arg = 1:11, \n    main = \"PiYG, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"PRGn\"), names.arg = 1:11, \n    main = \"PRGn, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"PRGn\"), names.arg = 1:11, \n    main = \"PRGn, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"PuOr\"), names.arg = 1:11, \n    main = \"PuOr, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"PuOr\"), names.arg = 1:11, \n    main = \"PuOr, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdBu\"), names.arg = 1:11, \n    main = \"RdBu, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdBu\"), names.arg = 1:11, \n    main = \"RdBu, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdGy\"), names.arg = 1:11, \n    main = \"RdGy, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdGy\"), names.arg = 1:11, \n    main = \"RdGy, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdYlBu\"), names.arg = 1:11, \n    main = \"RdYlBu, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdYlBu\"), names.arg = 1:11, \n    main = \"RdYlBu, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdYlGn\"), names.arg = 1:11, \n    main = \"RdYlGn, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"RdYlGn\"), names.arg = 1:11, \n    main = \"RdYlGn, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"Spectral\"), names.arg = 1:11, \n    main = \"Spectral, div\")\nbarplot(x[1:11], col = brewer.pal(n = 11, name = \"Spectral\"), names.arg = 1:11, \n    main = \"Spectral, div\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Accent\"), names.arg = 1:8, main = \"Accent, qual\")\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Accent\"), names.arg = 1:8, main = \"Accent, qual\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Dark2\"), names.arg = 1:8, main = \"Dark2, qual\")\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Dark2\"), names.arg = 1:8, main = \"Dark2, qual\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:12], col = brewer.pal(n = 12, name = \"Paired\"), names.arg = 1:12, \n    main = \"Paired, qual\")\nbarplot(x[1:12], col = brewer.pal(n = 12, name = \"Paired\"), names.arg = 1:12, \n    main = \"Paired, qual\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Pastel1\"), names.arg = 1:9, \n    main = \"Pastel1, qual\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Pastel1\"), names.arg = 1:9, \n    main = \"Pastel1, qual\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Pastel2\"), names.arg = 1:8, \n    main = \"Pastel2, qual\")\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Pastel2\"), names.arg = 1:8, \n    main = \"Pastel2, qual\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Set1\"), names.arg = 1:9, main = \"Set1, qual\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Set1\"), names.arg = 1:9, main = \"Set1, qual\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Set2\"), names.arg = 1:8, main = \"Set2, qual\")\nbarplot(x[1:8], col = brewer.pal(n = 8, name = \"Set2\"), names.arg = 1:8, main = \"Set2, qual\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:12], col = brewer.pal(n = 12, name = \"Set3\"), names.arg = 1:12, \n    main = \"Set3, qual\")\nbarplot(x[1:12], col = brewer.pal(n = 12, name = \"Set3\"), names.arg = 1:12, \n    main = \"Set3, qual\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Blues\"), names.arg = 1:9, main = \"Blues, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Blues\"), names.arg = 1:9, main = \"Blues, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"BuGn\"), names.arg = 1:9, main = \"BuGn, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"BuGn\"), names.arg = 1:9, main = \"BuGn, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"BuPu\"), names.arg = 1:9, main = \"BuPu, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"BuPu\"), names.arg = 1:9, main = \"BuPu, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"GnBu\"), names.arg = 1:9, main = \"GnBu, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"GnBu\"), names.arg = 1:9, main = \"GnBu, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Greens\"), names.arg = 1:9, main = \"Greens, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Greens\"), names.arg = 1:9, main = \"Greens, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Greys\"), names.arg = 1:9, main = \"Greys, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Greys\"), names.arg = 1:9, main = \"Greys, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Oranges\"), names.arg = 1:9, \n    main = \"Oranges, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Oranges\"), names.arg = 1:9, \n    main = \"Oranges, seq\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"OrRd\"), names.arg = 1:9, main = \"OrRd, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"OrRd\"), names.arg = 1:9, main = \"OrRd, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"PuBu\"), names.arg = 1:9, main = \"PuBu, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"PuBu\"), names.arg = 1:9, main = \"PuBu, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"PuBuGn\"), names.arg = 1:9, main = \"PuBuGn, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"PuBuGn\"), names.arg = 1:9, main = \"PuBuGn, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"PuRd\"), names.arg = 1:9, main = \"PuRd, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"PuRd\"), names.arg = 1:9, main = \"PuRd, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Purples\"), names.arg = 1:9, \n    main = \"Purples, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Purples\"), names.arg = 1:9, \n    main = \"Purples, seq\", border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"RdPu\"), names.arg = 1:9, main = \"RdPu, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"RdPu\"), names.arg = 1:9, main = \"RdPu, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Reds\"), names.arg = 1:9, main = \"Reds, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"Reds\"), names.arg = 1:9, main = \"Reds, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlGn\"), names.arg = 1:9, main = \"YlGn, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlGn\"), names.arg = 1:9, main = \"YlGn, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlGnBu\"), names.arg = 1:9, main = \"YlGnBu, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlGnBu\"), names.arg = 1:9, main = \"YlGnBu, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlOrBr\"), names.arg = 1:9, main = \"YlOrBr, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlOrBr\"), names.arg = 1:9, main = \"YlOrBr, seq\", \n    border = NA)\npar(mfrow = c(1, 2))\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlOrRd\"), names.arg = 1:9, main = \"YlOrRd, seq\")\nbarplot(x[1:9], col = brewer.pal(n = 9, name = \"YlOrRd\"), names.arg = 1:9, main = \"YlOrRd, seq\", \n    border = NA)"},{"path":"szinek.html","id":"szinek-valasztasa-dichromat","chapter":"B Színek","heading":"B.3 Színek választása a dichromat csomag segítségével","text":"dichromat csomag színsémai közül választhatunk. színsémákat colorschemes lista tartalmazza. lisatelemek neve:Példák színek választására:","code":"\nlibrary(dichromat)\nnames(colorschemes)\n#>  [1] \"BrowntoBlue.10\"         \"BrowntoBlue.12\"         \"BluetoDarkOrange.12\"   \n#>  [4] \"BluetoDarkOrange.18\"    \"DarkRedtoBlue.12\"       \"DarkRedtoBlue.18\"      \n#>  [7] \"BluetoGreen.14\"         \"BluetoGray.8\"           \"BluetoOrangeRed.14\"    \n#> [10] \"BluetoOrange.10\"        \"BluetoOrange.12\"        \"BluetoOrange.8\"        \n#> [13] \"LightBluetoDarkBlue.10\" \"LightBluetoDarkBlue.7\"  \"Categorical.12\"        \n#> [16] \"GreentoMagenta.16\"      \"SteppedSequential.5\"\n# az x adatvektor beállítása\nset.seed(0)\nx <- rpois(n = 50, lambda = 100)\n# grafikus paraméterek beállítása\npar(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1))\nlibrary(dichromat)\npar(mfrow=c(1,2))\nbarplot(x[1:10], col = colorschemes$BrowntoBlue.10, names.arg = 1:10, main = \"BrowntoBlue.10\")\nbarplot(x[1:10], col = colorschemes$BrowntoBlue.10, names.arg = 1:10, main = \"BrowntoBlue.10\", border=NA)\npar(mfrow=c(1,2))\nbarplot(x[1:12], col = colorschemes$BrowntoBlue.12, names.arg = 1:12, main = \"BrowntoBlue.12\")\nbarplot(x[1:12], col = colorschemes$BrowntoBlue.12, names.arg = 1:12, main = \"BrowntoBlue.12\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:12], col = colorschemes$BluetoDarkOrange.12, names.arg = 1:12, main = \"BluetoDarkOrange.12\")\nbarplot(x[1:12], col = colorschemes$BluetoDarkOrange.12, names.arg = 1:12, main = \"BluetoDarkOrange.12\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:18], col = colorschemes$BluetoDarkOrange.18, names.arg = 1:18, main = \"BluetoDarkOrange.18\")\nbarplot(x[1:18], col = colorschemes$BluetoDarkOrange.18, names.arg = 1:18, main = \"BluetoDarkOrange.18\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:12], col = colorschemes$DarkRedtoBlue.12, names.arg = 1:12, main = \"DarkRedtoBlue.12\")\nbarplot(x[1:12], col = colorschemes$DarkRedtoBlue.12, names.arg = 1:12, main = \"DarkRedtoBlue.12\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:18], col = colorschemes$DarkRedtoBlue.18, names.arg = 1:18, main = \"DarkRedtoBlue.18\")\nbarplot(x[1:18], col = colorschemes$DarkRedtoBlue.18, names.arg = 1:18, main = \"DarkRedtoBlue.18\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:14], col = colorschemes$BluetoGreen.14, names.arg = 1:14, main = \"BluetoGreen.14\")\nbarplot(x[1:14], col = colorschemes$BluetoGreen.14, names.arg = 1:14, main = \"BluetoGreen.14\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:8], col = colorschemes$BluetoGray.8, names.arg = 1:8, main = \"BluetoGray.8\")\nbarplot(x[1:8], col = colorschemes$BluetoGray.8, names.arg = 1:8, main = \"BluetoGray.8\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:14], col = colorschemes$BluetoOrangeRed.14, names.arg = 1:14, main = \"BluetoOrangeRed.14\")\nbarplot(x[1:14], col = colorschemes$BluetoOrangeRed.14, names.arg = 1:14, main = \"BluetoOrangeRed.14\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:10], col = colorschemes$BluetoOrange.10, names.arg = 1:10, main = \"BluetoOrange.10\")\nbarplot(x[1:10], col = colorschemes$BluetoOrange.10, names.arg = 1:10, main = \"BluetoOrange.10\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:12], col = colorschemes$BluetoOrange.12, names.arg = 1:12, main = \"BluetoOrange.12\")\nbarplot(x[1:12], col = colorschemes$BluetoOrange.12, names.arg = 1:12, main = \"BluetoOrange.12\", border = T)\npar(mfrow=c(1,2))\nbarplot(x[1:8], col = colorschemes$BluetoOrange.8, names.arg = 1:8, main = \"BluetoOrange.8\")\nbarplot(x[1:8], col = colorschemes$BluetoOrange.8, names.arg = 1:8, main = \"BluetoOrange.8\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:10], col = colorschemes$LightBluetoDarkBlue.10, names.arg = 1:10, \n    main = \"LightBluetoDarkBlue.10\")\nbarplot(x[1:10], col = colorschemes$LightBluetoDarkBlue.10, names.arg = 1:10, \n    main = \"LightBluetoDarkBlue.10\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:7], col = colorschemes$LightBluetoDarkBlue.7, names.arg = 1:7, main = \"LightBluetoDarkBlue.7\")\nbarplot(x[1:7], col = colorschemes$LightBluetoDarkBlue.7, names.arg = 1:7, main = \"LightBluetoDarkBlue.7\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:12], col = colorschemes$Categorical.12, names.arg = 1:12, main = \"Categorical.12\")\nbarplot(x[1:12], col = colorschemes$Categorical.12, names.arg = 1:12, main = \"Categorical.12\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = colorschemes$GreentoMagenta.16, names.arg = 1:16, main = \"GreentoMagenta.16\")\nbarplot(x[1:16], col = colorschemes$GreentoMagenta.16, names.arg = 1:16, main = \"GreentoMagenta.16\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:25], col = colorschemes$SteppedSequential.5, names.arg = 1:25, main = \"SteppedSequential.5\")\nbarplot(x[1:25], col = colorschemes$SteppedSequential.5, names.arg = 1:25, main = \"SteppedSequential.5\", border = NA)"},{"path":"szinek.html","id":"szinek-valasztasa-egyeb","chapter":"B Színek","heading":"B.4 Színek választása egyéb paletta segítségével","text":"Színpaletta létrehozásához több beépített lehetőségek közül választhatunk.Az n= argumentum létrehozandó színek számát jelenti.Példák színpaletta létrehozására:","code":"\nrainbow(n, start=0, end, alpha = 1)\nheat.colors(n, alpha = 1)\nterrain.colors(n, alpha = 1)\ntopo.colors(n, alpha = 1)\ncm.colors(n, alpha = 1)\n# az x adatvektor beállítása\nset.seed(0)\nx <- rpois(n = 50, lambda = 100)\n# grafikus paraméterek beállítása\npar(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1))\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = rainbow(16), names.arg = 1:16, main = \"rainbow(n=16)\")\nbarplot(x[1:16], col = rainbow(16), names.arg = 1:16, main = \"rainbow(n=16)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = rainbow(16, start = 0, end = 0.2), names.arg = 1:16, \n    main = \"rainbow(n=16, start=0, end=0.2)\")\nbarplot(x[1:16], col = rainbow(16, start = 0, end = 0.2), names.arg = 1:16, \n    main = \"rainbow(n=16, start=0, end=0.2)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = rainbow(16, start = 0, end = 0.5), names.arg = 1:16, \n    main = \"rainbow(n=16, start=0, end=0.5)\")\nbarplot(x[1:16], col = rainbow(16, start = 0, end = 0.5), names.arg = 1:16, \n    main = \"rainbow(n=16, start=0, end=0.5)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = rainbow(16, start = 0, end = 0.8), names.arg = 1:16, \n    main = \"rainbow(n=16, start=0, end=0.8)\")\nbarplot(x[1:16], col = rainbow(16, start = 0, end = 0.8), names.arg = 1:16, \n    main = \"rainbow(n=16, start=0, end=0.8)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = heat.colors(16), names.arg = 1:16, main = \"heat.colors(n=16)\")\nbarplot(x[1:16], col = heat.colors(16), names.arg = 1:16, main = \"heat.colors(n=16)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = terrain.colors(16), names.arg = 1:16, main = \"terrain.colors(n=16)\")\nbarplot(x[1:16], col = terrain.colors(16), names.arg = 1:16, main = \"terrain.colors(n=16)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = topo.colors(16), names.arg = 1:16, main = \"topo.colors(n=16)\")\nbarplot(x[1:16], col = topo.colors(16), names.arg = 1:16, main = \"topo.colors(n=16)\", border = NA)\npar(mfrow=c(1,2))\nbarplot(x[1:16], col = cm.colors(16), names.arg = 1:16, main = \"cm.colors(n=16)\")\nbarplot(x[1:16], col = cm.colors(16), names.arg = 1:16, main = \"cm.colors(n=16)\", border = NA)"},{"path":"szinek.html","id":"a-657-szinnev","chapter":"B Színek","heading":"B.5 A 657 színnév","text":"","code":"\ncolors()\n#>   [1] \"white\"                \"aliceblue\"            \"antiquewhite\"        \n#>   [4] \"antiquewhite1\"        \"antiquewhite2\"        \"antiquewhite3\"       \n#>   [7] \"antiquewhite4\"        \"aquamarine\"           \"aquamarine1\"         \n#>  [10] \"aquamarine2\"          \"aquamarine3\"          \"aquamarine4\"         \n#>  [13] \"azure\"                \"azure1\"               \"azure2\"              \n#>  [16] \"azure3\"               \"azure4\"               \"beige\"               \n#>  [19] \"bisque\"               \"bisque1\"              \"bisque2\"             \n#>  [22] \"bisque3\"              \"bisque4\"              \"black\"               \n#>  [25] \"blanchedalmond\"       \"blue\"                 \"blue1\"               \n#>  [28] \"blue2\"                \"blue3\"                \"blue4\"               \n#>  [31] \"blueviolet\"           \"brown\"                \"brown1\"              \n#>  [34] \"brown2\"               \"brown3\"               \"brown4\"              \n#>  [37] \"burlywood\"            \"burlywood1\"           \"burlywood2\"          \n#>  [40] \"burlywood3\"           \"burlywood4\"           \"cadetblue\"           \n#>  [43] \"cadetblue1\"           \"cadetblue2\"           \"cadetblue3\"          \n#>  [46] \"cadetblue4\"           \"chartreuse\"           \"chartreuse1\"         \n#>  [49] \"chartreuse2\"          \"chartreuse3\"          \"chartreuse4\"         \n#>  [52] \"chocolate\"            \"chocolate1\"           \"chocolate2\"          \n#>  [55] \"chocolate3\"           \"chocolate4\"           \"coral\"               \n#>  [58] \"coral1\"               \"coral2\"               \"coral3\"              \n#>  [61] \"coral4\"               \"cornflowerblue\"       \"cornsilk\"            \n#>  [64] \"cornsilk1\"            \"cornsilk2\"            \"cornsilk3\"           \n#>  [67] \"cornsilk4\"            \"cyan\"                 \"cyan1\"               \n#>  [70] \"cyan2\"                \"cyan3\"                \"cyan4\"               \n#>  [73] \"darkblue\"             \"darkcyan\"             \"darkgoldenrod\"       \n#>  [76] \"darkgoldenrod1\"       \"darkgoldenrod2\"       \"darkgoldenrod3\"      \n#>  [79] \"darkgoldenrod4\"       \"darkgray\"             \"darkgreen\"           \n#>  [82] \"darkgrey\"             \"darkkhaki\"            \"darkmagenta\"         \n#>  [85] \"darkolivegreen\"       \"darkolivegreen1\"      \"darkolivegreen2\"     \n#>  [88] \"darkolivegreen3\"      \"darkolivegreen4\"      \"darkorange\"          \n#>  [91] \"darkorange1\"          \"darkorange2\"          \"darkorange3\"         \n#>  [94] \"darkorange4\"          \"darkorchid\"           \"darkorchid1\"         \n#>  [97] \"darkorchid2\"          \"darkorchid3\"          \"darkorchid4\"         \n#> [100] \"darkred\"              \"darksalmon\"           \"darkseagreen\"        \n#> [103] \"darkseagreen1\"        \"darkseagreen2\"        \"darkseagreen3\"       \n#> [106] \"darkseagreen4\"        \"darkslateblue\"        \"darkslategray\"       \n#> [109] \"darkslategray1\"       \"darkslategray2\"       \"darkslategray3\"      \n#> [112] \"darkslategray4\"       \"darkslategrey\"        \"darkturquoise\"       \n#> [115] \"darkviolet\"           \"deeppink\"             \"deeppink1\"           \n#> [118] \"deeppink2\"            \"deeppink3\"            \"deeppink4\"           \n#> [121] \"deepskyblue\"          \"deepskyblue1\"         \"deepskyblue2\"        \n#> [124] \"deepskyblue3\"         \"deepskyblue4\"         \"dimgray\"             \n#> [127] \"dimgrey\"              \"dodgerblue\"           \"dodgerblue1\"         \n#> [130] \"dodgerblue2\"          \"dodgerblue3\"          \"dodgerblue4\"         \n#> [133] \"firebrick\"            \"firebrick1\"           \"firebrick2\"          \n#> [136] \"firebrick3\"           \"firebrick4\"           \"floralwhite\"         \n#> [139] \"forestgreen\"          \"gainsboro\"            \"ghostwhite\"          \n#> [142] \"gold\"                 \"gold1\"                \"gold2\"               \n#> [145] \"gold3\"                \"gold4\"                \"goldenrod\"           \n#> [148] \"goldenrod1\"           \"goldenrod2\"           \"goldenrod3\"          \n#> [151] \"goldenrod4\"           \"gray\"                 \"gray0\"               \n#> [154] \"gray1\"                \"gray2\"                \"gray3\"               \n#> [157] \"gray4\"                \"gray5\"                \"gray6\"               \n#> [160] \"gray7\"                \"gray8\"                \"gray9\"               \n#> [163] \"gray10\"               \"gray11\"               \"gray12\"              \n#> [166] \"gray13\"               \"gray14\"               \"gray15\"              \n#> [169] \"gray16\"               \"gray17\"               \"gray18\"              \n#> [172] \"gray19\"               \"gray20\"               \"gray21\"              \n#> [175] \"gray22\"               \"gray23\"               \"gray24\"              \n#> [178] \"gray25\"               \"gray26\"               \"gray27\"              \n#> [181] \"gray28\"               \"gray29\"               \"gray30\"              \n#> [184] \"gray31\"               \"gray32\"               \"gray33\"              \n#> [187] \"gray34\"               \"gray35\"               \"gray36\"              \n#> [190] \"gray37\"               \"gray38\"               \"gray39\"              \n#> [193] \"gray40\"               \"gray41\"               \"gray42\"              \n#> [196] \"gray43\"               \"gray44\"               \"gray45\"              \n#> [199] \"gray46\"               \"gray47\"               \"gray48\"              \n#> [202] \"gray49\"               \"gray50\"               \"gray51\"              \n#> [205] \"gray52\"               \"gray53\"               \"gray54\"              \n#> [208] \"gray55\"               \"gray56\"               \"gray57\"              \n#> [211] \"gray58\"               \"gray59\"               \"gray60\"              \n#> [214] \"gray61\"               \"gray62\"               \"gray63\"              \n#> [217] \"gray64\"               \"gray65\"               \"gray66\"              \n#> [220] \"gray67\"               \"gray68\"               \"gray69\"              \n#> [223] \"gray70\"               \"gray71\"               \"gray72\"              \n#> [226] \"gray73\"               \"gray74\"               \"gray75\"              \n#> [229] \"gray76\"               \"gray77\"               \"gray78\"              \n#> [232] \"gray79\"               \"gray80\"               \"gray81\"              \n#> [235] \"gray82\"               \"gray83\"               \"gray84\"              \n#> [238] \"gray85\"               \"gray86\"               \"gray87\"              \n#> [241] \"gray88\"               \"gray89\"               \"gray90\"              \n#> [244] \"gray91\"               \"gray92\"               \"gray93\"              \n#> [247] \"gray94\"               \"gray95\"               \"gray96\"              \n#> [250] \"gray97\"               \"gray98\"               \"gray99\"              \n#> [253] \"gray100\"              \"green\"                \"green1\"              \n#> [256] \"green2\"               \"green3\"               \"green4\"              \n#> [259] \"greenyellow\"          \"grey\"                 \"grey0\"               \n#> [262] \"grey1\"                \"grey2\"                \"grey3\"               \n#> [265] \"grey4\"                \"grey5\"                \"grey6\"               \n#> [268] \"grey7\"                \"grey8\"                \"grey9\"               \n#> [271] \"grey10\"               \"grey11\"               \"grey12\"              \n#> [274] \"grey13\"               \"grey14\"               \"grey15\"              \n#> [277] \"grey16\"               \"grey17\"               \"grey18\"              \n#> [280] \"grey19\"               \"grey20\"               \"grey21\"              \n#> [283] \"grey22\"               \"grey23\"               \"grey24\"              \n#> [286] \"grey25\"               \"grey26\"               \"grey27\"              \n#> [289] \"grey28\"               \"grey29\"               \"grey30\"              \n#> [292] \"grey31\"               \"grey32\"               \"grey33\"              \n#> [295] \"grey34\"               \"grey35\"               \"grey36\"              \n#> [298] \"grey37\"               \"grey38\"               \"grey39\"              \n#> [301] \"grey40\"               \"grey41\"               \"grey42\"              \n#> [304] \"grey43\"               \"grey44\"               \"grey45\"              \n#> [307] \"grey46\"               \"grey47\"               \"grey48\"              \n#> [310] \"grey49\"               \"grey50\"               \"grey51\"              \n#> [313] \"grey52\"               \"grey53\"               \"grey54\"              \n#> [316] \"grey55\"               \"grey56\"               \"grey57\"              \n#> [319] \"grey58\"               \"grey59\"               \"grey60\"              \n#> [322] \"grey61\"               \"grey62\"               \"grey63\"              \n#> [325] \"grey64\"               \"grey65\"               \"grey66\"              \n#> [328] \"grey67\"               \"grey68\"               \"grey69\"              \n#> [331] \"grey70\"               \"grey71\"               \"grey72\"              \n#> [334] \"grey73\"               \"grey74\"               \"grey75\"              \n#> [337] \"grey76\"               \"grey77\"               \"grey78\"              \n#> [340] \"grey79\"               \"grey80\"               \"grey81\"              \n#> [343] \"grey82\"               \"grey83\"               \"grey84\"              \n#> [346] \"grey85\"               \"grey86\"               \"grey87\"              \n#> [349] \"grey88\"               \"grey89\"               \"grey90\"              \n#> [352] \"grey91\"               \"grey92\"               \"grey93\"              \n#> [355] \"grey94\"               \"grey95\"               \"grey96\"              \n#> [358] \"grey97\"               \"grey98\"               \"grey99\"              \n#> [361] \"grey100\"              \"honeydew\"             \"honeydew1\"           \n#> [364] \"honeydew2\"            \"honeydew3\"            \"honeydew4\"           \n#> [367] \"hotpink\"              \"hotpink1\"             \"hotpink2\"            \n#> [370] \"hotpink3\"             \"hotpink4\"             \"indianred\"           \n#> [373] \"indianred1\"           \"indianred2\"           \"indianred3\"          \n#> [376] \"indianred4\"           \"ivory\"                \"ivory1\"              \n#> [379] \"ivory2\"               \"ivory3\"               \"ivory4\"              \n#> [382] \"khaki\"                \"khaki1\"               \"khaki2\"              \n#> [385] \"khaki3\"               \"khaki4\"               \"lavender\"            \n#> [388] \"lavenderblush\"        \"lavenderblush1\"       \"lavenderblush2\"      \n#> [391] \"lavenderblush3\"       \"lavenderblush4\"       \"lawngreen\"           \n#> [394] \"lemonchiffon\"         \"lemonchiffon1\"        \"lemonchiffon2\"       \n#> [397] \"lemonchiffon3\"        \"lemonchiffon4\"        \"lightblue\"           \n#> [400] \"lightblue1\"           \"lightblue2\"           \"lightblue3\"          \n#> [403] \"lightblue4\"           \"lightcoral\"           \"lightcyan\"           \n#> [406] \"lightcyan1\"           \"lightcyan2\"           \"lightcyan3\"          \n#> [409] \"lightcyan4\"           \"lightgoldenrod\"       \"lightgoldenrod1\"     \n#> [412] \"lightgoldenrod2\"      \"lightgoldenrod3\"      \"lightgoldenrod4\"     \n#> [415] \"lightgoldenrodyellow\" \"lightgray\"            \"lightgreen\"          \n#> [418] \"lightgrey\"            \"lightpink\"            \"lightpink1\"          \n#> [421] \"lightpink2\"           \"lightpink3\"           \"lightpink4\"          \n#> [424] \"lightsalmon\"          \"lightsalmon1\"         \"lightsalmon2\"        \n#> [427] \"lightsalmon3\"         \"lightsalmon4\"         \"lightseagreen\"       \n#> [430] \"lightskyblue\"         \"lightskyblue1\"        \"lightskyblue2\"       \n#> [433] \"lightskyblue3\"        \"lightskyblue4\"        \"lightslateblue\"      \n#> [436] \"lightslategray\"       \"lightslategrey\"       \"lightsteelblue\"      \n#> [439] \"lightsteelblue1\"      \"lightsteelblue2\"      \"lightsteelblue3\"     \n#> [442] \"lightsteelblue4\"      \"lightyellow\"          \"lightyellow1\"        \n#> [445] \"lightyellow2\"         \"lightyellow3\"         \"lightyellow4\"        \n#> [448] \"limegreen\"            \"linen\"                \"magenta\"             \n#> [451] \"magenta1\"             \"magenta2\"             \"magenta3\"            \n#> [454] \"magenta4\"             \"maroon\"               \"maroon1\"             \n#> [457] \"maroon2\"              \"maroon3\"              \"maroon4\"             \n#> [460] \"mediumaquamarine\"     \"mediumblue\"           \"mediumorchid\"        \n#> [463] \"mediumorchid1\"        \"mediumorchid2\"        \"mediumorchid3\"       \n#> [466] \"mediumorchid4\"        \"mediumpurple\"         \"mediumpurple1\"       \n#> [469] \"mediumpurple2\"        \"mediumpurple3\"        \"mediumpurple4\"       \n#> [472] \"mediumseagreen\"       \"mediumslateblue\"      \"mediumspringgreen\"   \n#> [475] \"mediumturquoise\"      \"mediumvioletred\"      \"midnightblue\"        \n#> [478] \"mintcream\"            \"mistyrose\"            \"mistyrose1\"          \n#> [481] \"mistyrose2\"           \"mistyrose3\"           \"mistyrose4\"          \n#> [484] \"moccasin\"             \"navajowhite\"          \"navajowhite1\"        \n#> [487] \"navajowhite2\"         \"navajowhite3\"         \"navajowhite4\"        \n#> [490] \"navy\"                 \"navyblue\"             \"oldlace\"             \n#> [493] \"olivedrab\"            \"olivedrab1\"           \"olivedrab2\"          \n#> [496] \"olivedrab3\"           \"olivedrab4\"           \"orange\"              \n#> [499] \"orange1\"              \"orange2\"              \"orange3\"             \n#> [502] \"orange4\"              \"orangered\"            \"orangered1\"          \n#> [505] \"orangered2\"           \"orangered3\"           \"orangered4\"          \n#> [508] \"orchid\"               \"orchid1\"              \"orchid2\"             \n#> [511] \"orchid3\"              \"orchid4\"              \"palegoldenrod\"       \n#> [514] \"palegreen\"            \"palegreen1\"           \"palegreen2\"          \n#> [517] \"palegreen3\"           \"palegreen4\"           \"paleturquoise\"       \n#> [520] \"paleturquoise1\"       \"paleturquoise2\"       \"paleturquoise3\"      \n#> [523] \"paleturquoise4\"       \"palevioletred\"        \"palevioletred1\"      \n#> [526] \"palevioletred2\"       \"palevioletred3\"       \"palevioletred4\"      \n#> [529] \"papayawhip\"           \"peachpuff\"            \"peachpuff1\"          \n#> [532] \"peachpuff2\"           \"peachpuff3\"           \"peachpuff4\"          \n#> [535] \"peru\"                 \"pink\"                 \"pink1\"               \n#> [538] \"pink2\"                \"pink3\"                \"pink4\"               \n#> [541] \"plum\"                 \"plum1\"                \"plum2\"               \n#> [544] \"plum3\"                \"plum4\"                \"powderblue\"          \n#> [547] \"purple\"               \"purple1\"              \"purple2\"             \n#> [550] \"purple3\"              \"purple4\"              \"red\"                 \n#> [553] \"red1\"                 \"red2\"                 \"red3\"                \n#> [556] \"red4\"                 \"rosybrown\"            \"rosybrown1\"          \n#> [559] \"rosybrown2\"           \"rosybrown3\"           \"rosybrown4\"          \n#> [562] \"royalblue\"            \"royalblue1\"           \"royalblue2\"          \n#> [565] \"royalblue3\"           \"royalblue4\"           \"saddlebrown\"         \n#> [568] \"salmon\"               \"salmon1\"              \"salmon2\"             \n#> [571] \"salmon3\"              \"salmon4\"              \"sandybrown\"          \n#> [574] \"seagreen\"             \"seagreen1\"            \"seagreen2\"           \n#> [577] \"seagreen3\"            \"seagreen4\"            \"seashell\"            \n#> [580] \"seashell1\"            \"seashell2\"            \"seashell3\"           \n#> [583] \"seashell4\"            \"sienna\"               \"sienna1\"             \n#> [586] \"sienna2\"              \"sienna3\"              \"sienna4\"             \n#> [589] \"skyblue\"              \"skyblue1\"             \"skyblue2\"            \n#> [592] \"skyblue3\"             \"skyblue4\"             \"slateblue\"           \n#> [595] \"slateblue1\"           \"slateblue2\"           \"slateblue3\"          \n#> [598] \"slateblue4\"           \"slategray\"            \"slategray1\"          \n#> [601] \"slategray2\"           \"slategray3\"           \"slategray4\"          \n#> [604] \"slategrey\"            \"snow\"                 \"snow1\"               \n#> [607] \"snow2\"                \"snow3\"                \"snow4\"               \n#> [610] \"springgreen\"          \"springgreen1\"         \"springgreen2\"        \n#> [613] \"springgreen3\"         \"springgreen4\"         \"steelblue\"           \n#> [616] \"steelblue1\"           \"steelblue2\"           \"steelblue3\"          \n#> [619] \"steelblue4\"           \"tan\"                  \"tan1\"                \n#> [622] \"tan2\"                 \"tan3\"                 \"tan4\"                \n#> [625] \"thistle\"              \"thistle1\"             \"thistle2\"            \n#> [628] \"thistle3\"             \"thistle4\"             \"tomato\"              \n#> [631] \"tomato1\"              \"tomato2\"              \"tomato3\"             \n#> [634] \"tomato4\"              \"turquoise\"            \"turquoise1\"          \n#> [637] \"turquoise2\"           \"turquoise3\"           \"turquoise4\"          \n#> [640] \"violet\"               \"violetred\"            \"violetred1\"          \n#> [643] \"violetred2\"           \"violetred3\"           \"violetred4\"          \n#> [646] \"wheat\"                \"wheat1\"               \"wheat2\"              \n#> [649] \"wheat3\"               \"wheat4\"               \"whitesmoke\"          \n#> [652] \"yellow\"               \"yellow1\"              \"yellow2\"             \n#> [655] \"yellow3\"              \"yellow4\"              \"yellowgreen\""},{"path":"oravazlat-az-r-tanitasahoz.html","id":"oravazlat-az-r-tanitasahoz","chapter":"C Óravázlat az R tanításához","heading":"C Óravázlat az R tanításához","text":"Az R oktatásához és tanulásához egy lehetséges tanmenet vázlatát\nmutatjuk . Az R tanulmányozását két féléves rendszerben, félévenként\n10 duplaórában képzeltük el. lent felsorolt óravázlat összesen 20\nduplaórában sorolja fel azokat az ismeretelemeket, amelyek az R\ngyakorlati felhasználásához nem nélkülözhetők.","code":""},{"path":"oravazlat-az-r-tanitasahoz.html","id":"felev-1","chapter":"C Óravázlat az R tanításához","heading":"1. félév","text":"1. óra\nAz Alap R és az RStudio letöltése és telepítése, dokumentációk az\nR használatához. Az RGui áttekintése, konzol használata, \nszkriptablak használata, parancsok végrehajtása. Az RStudio\nhasználata.2. óra\nSzámok írása, numerikus operátorok. Karakteres konstansok az R-ben.\nLogikai konstansok és logikai műveletek. Objektum létrehozása, értékének megváltoztatása. Objektumokat tartalmazó kifejezések.3. óra\nFüggvények hívása, például log() és exp() függvények bemutatása, egyéb matematikai függvények. Függvényparaméterek elnevezése, sorrendjük cseréje. Kifejezés definíciója. Vektor adatszerkezet definíciója. Vektor létrehozása: c(), : (kettőspont operátor), seq(), rep()4. óra\nfaktor adatszerkezet definíciója, faktor létrehozása factor() függvénnyel. Objektumok adattípusának megtekintése és az objektum hossza: class(), typeof(), length(). Adattábla definíciója, létrehozása data.frame() függvénnyel. Mátrix adatszerkezet, létrehozása matrix() függvénnyel. Tömb adatszerkezet, létrehozása az array() függvénnyel. Lista adatszerkezet, létrehozása list() függvénnyel. Indexelés vektor, mátrix, tömb és adattábla esetén. Hivatkozás listaelemekre lista és adattábla esetén.5. óra\nTagolt szöveges állomány létrehozása táblázatkezelővel és szövegszerkesztővel. Tagolt szöveges állomány beolvasása read.table() függvénnyel. paraméterek megbeszélése (file=, sep=, header=, dec=, quote=, stringsAsFactors=, comment.char=, na.strings=, strip.white=, fileEncode=). Táblázatkezelők és más statisztikai programcsomagok saját formátomú állományainak beolvasása rio::import() segítségével. beolvasás helyességének ellenőrzése az str() függvénnyel read.table() argumentumainak hatása az str() outputjára. Adatállomány kiírása write.table() és rio::export() segítségével.6. óra\nEgyszerű típuskonverziók (numerikus vektorból faktor és karakteres vektorból faktor előállítása factor() függvénnyel, valamint az .character() és .numeric() használata). Kapcsolat statisztikai skálák és változók típusai között. Faktor szintjeinek átnevezése, szintek sorrendjének meghatározása. Vektor rendezése sort() és order() függvénnyel. Adattábla rendezése az order() függvénnyel. Adattábla szűrése egyszerű logikai kifejezéssel és összetett logikai kifejezéssel.7. óra\nAz R környezet fogalmai: munkakönyvtár, munkaterület, csomag. Munkakönyvtár kezelése Objektum létrehozása és eltávolítása munkaterületről, objektumok listája. Csomag telepítése, telepített csomagok listája, csomag betöltése, csomag eltávolítása, betöltött csomagok listája. Az R Commander telepítése és használatának bemutatása. jamovi telepítése és használata. Az RGUI, RStudio, jamovi és az R Commander összehasonlítása.8. óra\nLeíró statisztikai mérőszámok meghatározása: summary(), mean(), median(), sd() stb. Hiányzó értékek kezelése (na.rm=T, .na(), na.ommit()). Műveletek több változóra és csoportra (apply(), sapply(), tapply(), aggregate(), ()). psych::describe(), psych::describeBy() és DescTools::Desc() függvényének bemutatása.9. óra\nGyakorisági táblázatok létrehozása table() és xtabs() függvénnyel. Hiányzó értékek kezelése (useNA=\"ifany\"). Relatív gyakorisági táblázatok. Kumulált gyakorisági táblázatok. Soronként vagy oszloponként vett kétdimenziós gyakorisági táblázatok. Három vagy többdimenziós táblázatok (array() és ftable()). Gyakorisági táblázatok DescTools::Desc() függvénnyel.10. óra\nhagyományos grafika magasszintű függvényei. Oszlopdiagram rajzolása (barplot()). Egydimenziós pontdiagram létrehozása (stripchart()). Grafikus paraméterek fogalma és beállítása par() függvénnyel. Feliratok (main=, sub=, xlab=, ylab=, las=), tengelyek (xlim=, ylim=, mgp=, tcl=), pontkarakterek (pch=), margók (mar=), színek (col=) beállítása. Pontdiagram és vonaldiagram rajzolása (plot()). Dobozdiagram rajzolása (boxplot()). Hisztogram rajzolása (hist()). További grafikus paraméterek: rajzterület felosztása (mfrow=, mfcol=). Grafikus eszközök típusai (windows(), png(), jpeg(), pdf()). Képállományok létrehozása és beállítási lehetőségek (res=, width=, height=). Grafikus eszközök bezárása.","code":""},{"path":"oravazlat-az-r-tanitasahoz.html","id":"felev-2","chapter":"C Óravázlat az R tanításához","heading":"2. félév","text":"11. óra\nreprodukálható kutatás elvének bemutatása. Az RStudio és jamovi lehetőségei reprodukálható kutatásban. RMarkdown állomány (*.Rmd) létrehozása, szintaxisának bemutatása. fejléc lehetőségei. szöveges rész formázása Markdown segítségével. Az R csonkok lehetőségei. PDF, Word és HTML állomány generálása. Egyedi template-ek használata.12. óra\nInformációk az adatobjektumokról (str(), head(), dim(), nrow(), ncol(), names(), colnames(), rownames(), levels(), nlevels()). Egyszerű típuskonverzió karakters, numerikus, logikai és faktor típusok között (factor(), .factor(), .numeric(), .character(), .logical()). Mátrix és adattábla sor- és oszlopmanipulációja: sor és oszlopnevek megadása, átnevezése, sorok és oszlopok törlése, beszúrása és cseréje (pl. rbind(), cbind()) Numerikusból numerikus transzformáció (tetszőleges matematikai függvény, transform(), recode()). Numerikusból faktor transzformáció (cut(), car::recode()). Faktorból faktor transzformáció (car::recode()).13. óra\nAdatelőkészítés egy- és kétmintás próbákhoz. Adatbázis létrehozás data.frame() függvénnyel varianciaelemzés számára (kiegyensúlyozott és nem kiegyensúlyozott esetek). hosszú és széles adatbázisok fogalma Adatbázis átalakítása két formátum között (reshape(), melt(), dcast()) Adattáblák összefűzése (merge()).14. óra\nEgymintás és kétmintás próbák végrehajtása Argumentumok és outputok értelmezése. Például BSDA::z.test(), t.test(), prop.test(), binom.test(), fisher.test(), mcnemar.test(), wilcox.test(), kruskal.test() és friedman.test() függvényekkel. varianciaelemzés különböző változatainak végrehajtása. Argumentumok és outputok értelmezése az aov() és lm() függvények esetében. Korreláció- és regressziószámítás végrehajtása. Argumentumok és outputok értelmezése cor(), cor.test() és lm() esetében.15. óra\nVéletlen sample() függvény segítségével. Eloszlások függvényei (r...(), d...(), q...(), p...()). Kritikus értékek és p-értékek meghatározása q...(), p...() függvényekkel. Eloszlások sűrűségfüggvényeinek rajzolása curve() függvény segítségével.16. óra\nTidyverse R bemutatása. pipe operátor (%>%) használata. tibble adatobjektumok kezelése. Adatállományok beolvasás és kiírása. Adatobjektom vizsgálata, sor- és oszlopnevek manipulációja. Oszlopok leválogatása, beszúrása és törlése. Adatobjektum rendezése.17. óra\nTidyverse R bemutatása. Sorok szűrése, törlése és beszúrása. Adatok összesítése, csoportosítása és transzformációja, valamint adattáblák összefűzése dplyr csomag segítségével. Kategorikus változók kezelése forcats csomag segítségével.18. óra\nTidyverse R bemutatása. Széles-hosszú átalakítás tidyr csomag segítségével (pivot_wider(), pivot_longer()). Hiányzó, duplikált és kiugró értékek kezelése dplyr csomag segítségével. Karakterláncok kezelése stringr csomag segítségével.19. óra\nggplot2 grafikus rendszer elemei: az adat, az alakzat (geom) és megjelenés (aes) rétegek. Az x=, y=, alpha=, colour=, fill=, group=, shape= és size= paraméterek használata az aes() függvényben. Jelmagyarázat megjelenítése. Több ábra megjelenítése kategorikus változó alapján (faceting). Ábra elemeinek beállítása: feliratok, tengelyek, színek és témák. Ábrák mentése.20. óra\nAz alavető ábratípusok megjelenítése és paraméterezései: oszlopdiagram, egydimenziós pontdiagram, hisztogram, dobozdiagram, pontdiagram, vonaldiagram, Q-Q ábra, hegedűdiagram, lollipop ábra és terület diagram.20+1. óra\nAz R programozási lehetőségei: szekvencia, feltételes utasítások, ciklusok. Függvények létrehozása. Objektum-orientált lehetőségek.","code":""},{"path":"irodalomjegyzek.html","id":"irodalomjegyzek","chapter":"Irodalomjegyzék","heading":"Irodalomjegyzék","text":"","code":""}]
