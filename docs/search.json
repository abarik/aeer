[{"path":"index.html","id":"üdvözöljük","chapter":"Üdvözöljük","heading":"Üdvözöljük","text":"Ez honlap az Adatkezelés és egyváltozós elemzések c. könyv elektronikus változatát mutatja . nyomtatásban megjelent könyvhöz képest számos bővítést tartalmaz:függelék fejezetei, például kitűzött feladatok megoldásai itt jelennek meg,az R grafikus lehetőségeit tartalmazó fejezet bővebb hagyományos grafika résszel.teljes könyv, az adatbázisok és az R kódok megtalálhatók következő címen.könyvet Máth János lektorálta, és Friss Kinga illusztrálta.","code":""},{"path":"eloszo.html","id":"eloszo","chapter":"Előszó","heading":"Előszó","text":"Kedves Olvasó!Köszönjük, hogy bizalmat szavaz könyvünknek, és az R megismeréséhez ezt az utat választja. Az első lépésektől komplett adatelemzési feladatok megoldásáig vezetjük az Olvasót, és főként kezdő vagy újrakezdő felhasználókhoz szólunk. Utunk során áttekintjük az adatfeldolgozás minden lépését: az adatok beolvasását, előkészítését, elemzését és az eredmények publikálását .Könyvünk összesen 11 fejezetet tartalmaz. Az egyes fejezeteket alkotó alfejezeteket három különböző ikon egyikével jelöltük meg, amelyek jelzőtáblaként szolgálnak az R megismerésének útján. Az egyes ikonok jelentése következő:\nEgy hegy. Az így jelölt fejezet az R alaptudás\nrésze, megismerése feltétlenül javasolt. könyvben megfogalmazott célok\nezen fejezetek megismerésével elérhetők, azaz komplett\nadatelemzéseket hajthatunk végre csupán ezek végig olvasásával .\n\nKét hegy. Kiegészítő tudást tartalmazó fejezetek.\nÚjabb eszközök megismerését teszik lehetővé, és/vagy hozzájárulnak az\negy hegy fejezetek mélyebb megértéséhez.\n\nHárom hegy. Az R ismeretek további részletezése, \nmeglévő eszközök finomabb kezelése, vagy további beállítási lehetőségek\nolvashatók ezekben fejezetekben. Elképzelhető, hogy ritkábban\nfelmerülő problémák megoldásához kapunk itt segítséget.\nfejezetek hármas tagolása azt célt szolgálja, hogy minél hamarabb örömet és sikert okozhasson az R használata, ugyanakkor további olvasással részletesebb ismeretek utáni vágyunkat kielégíthessük. Könyvünk olvasását tehát az 1. fejezet egy hegy alfejezetével (1.1 Elindulás) érdemes kezdeni, ott kapunk ajánlást folytatásra. további fejezetek olvasási sorrendje teljes mértékben az elvégzendő feladattól, tudásunktól és kíváncsiságunktól függ.fejezetek végén összefoglaljuk tanultakat. Megismételjük legfontosabb fogalmakat és felsoroljuk megismert függvényeket.\nÖsszefoglalás. Nem csak fejezet áttanulmányozása\nután, hanem időről-időre javasoljuk fejezet végi összefoglalások\náttekintését. Ezzel leellenőrizhetjük R tudásunk frissességét,\neldönthetjük, hogy érdemes-e újra átolvasni fejezetben leírtakat. És\nmit jegyezzünk meg az előszóból: könyv 11 fejezetet tartalmaz, az\nalfejezeteket nehézségük alapján három különböző ikon egyikével\njelöltük: egy hegy, két hegy vagy három\nhegy.\nAz R tanulmányozása kitartást és némi időt igényel. Nagyon fontos szerepet kap gyakorlás, ezért minden fejezet végén találunk feladatokat.\nFeladatok. fejezet végi feladatok megoldásával\njelentősen hozzájárulunk magabiztos R tudás megszerzéséhez. Találunk\nszórakoztató és érdekes feladatokat .\nÖrömmel fogadjuk Olvasóink észrevételeit az abari.kalman@gmail.com címen.","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik","chapter":"1 Itt kezdődik","heading":"1 Itt kezdődik","text":"","code":""},{"path":"itt-kezdodik.html","id":"Itt-kezdodik-1-szint","chapter":"1 Itt kezdődik","heading":"1.1 Elindulás","text":"\nEbben fejezetben:\n\nbemutatunk egy konkrét adatelemzési példát,\n\náttekintjük könyv tartalmát,\n\nlehetőséget adunk az előzetes R ismeretek felmérésére,\n\nés segítünk megfelelő fejezet kiválasztására folytatáshoz.\nKönyvünk elsődleges célja az R bemutatása kezdő felhasználók számára, de minden bizonnyal azok találni fognak hasznos részeket, akik már rendelkeznek R ismeretekkel. Bevezetést nyújtunk az R által lefedett három nagy terület mindegyikébe: az adatkezelésbe, grafikus megjelenítésbe és az adatelemzésbe . leírtak megértéséhez statisztikai alapismereteken túl semmilyen előzetes tudás nem szükséges.egy konkrét adatelemzési példa segítségével bemutatjuk, hogy mit nyújt e könyv az Olvasó számára. bevezető példa megoldása során az előismeretekkel rendelkező Olvasó saját R tudását felmérheti, és ezzel egyben segítséget kaphat tudásához és céljaihoz legjobban illeszkedő fejezet kiválasztására, amellyel tovább folytathatja az olvasást.Bevezető példa: Két tanítási módszer összehasonlítása\nEgy 2020-kutatásunkban (Csapó, Csernoch, Abari 2020) 7. osztályos tanulóknak Excel ismereteket oktattunk két különböző megközelítésben. Az egyik csoportban hagyományos, míg másikban modern (Sprego) tanítási módszert használtunk. tanulási időszak az Excel ismeretek felmérésével zárult. Az összegyűjtött adatok az excel_2020.xlsx állományban állnak rendelkezésre.\nNézzük az adatelemzés lépéseit és egyben könyvünk felépítését!2. fejezet: Mi az R?\nbevezető példa megoldását R-ben fogjuk elvégezni (és nem más eszközben, mint például az SPSS, jamovi, JASP, SAS stb.). Érdemes tehát ismerni az R céljait és lehetőségeit, jó ha van egy összképünk használt statisztikai programcsomagról. Ezt az áttekintést nyújtja 2 fejezet.3. fejezet: Az R telepítése.\nAdatelemzésünk konkrét lépéseinek elvégzéséhez telepített Alap R és RStudio szükséges. Ha ezek nem állnak rendelkezésre, vagy még nem találkoztunk ezekkel az eszközökkel, akkor 3. fejezet nekünk szól.4. fejezet: Munka az R-ben.\nAz adatelemzés végrehajtásához az RStudio-t ajánljuk, és azon belül pedig projektek használatát szorgalmazzuk. 4. fejezetben megismerjük az RStudio legalapvetőbb funkcióit, parancsállományok létrehozását és futtatását.fenti előzmények után elkezdhetjük bevezető példa megoldását:indítsuk el az RStudio-t,hozzunk létre egy új projektet,hozzunk létre egy új RMarkdown állományt,helyezzük el lentebb szereplő R parancsokat az RMarkdown állomány egyes csonkjaiban.5. fejezet: Az R nyelv.\nAz R parancsok létrehozásának vannak szabályai, amelyeket munka során kell tartanunk. Ismernünk kell jó néhány függvényt, és általában el kell tudnunk igazodni az R nyelvben. Az 5. fejezet ezért kulcsfontosságú, tanulmányozzuk alaposan, és lehetőleg minden kitűzött feladatát oldjuk meg.6. fejezet: Beolvasás\nMinden adatelemzés első lépése az adatállomány beolvasása. Adataink változatos formában állhatnak rendelkezésre, 6. fejezetben ezek beolvasására kapunk receptet.bevezető példa megoldásához az RMarkdown állomány egyik csonkját bővítsük lenti sorokkal.7. fejezet: Adatkezelés\nstatisztikai elemzés elkezdése előtt számos adatkezelési tevékenységre lehet szükség. Ezt sokszor rendkívül időigényes folyamatot 7. fejezetben részletezzük.bevezető példa megoldásához az RMarkdown állomány egyik csonkját bővítsük lenti sorokkal. Az adatkezelés legtöbbször beolvasott állomány jellemzőinek lekérésével kezdődik.karakteres vagy numerikus vektorok faktorrá konvertálása az egyik leggyakoribb előkészítő parancs.táblázatok és ábrák megfelelő megjelenéséhez, végezzük el faktorszintek sorrendbe állítását.8. fejezet: Mutatók és táblázatok.\nHa az adatainkat már megfelelő formába hoztuk, akkor továbbléphetünk az elemzés felé. 8. fejezet leíró statisztikai elemzésekből mutatók és táblázatok létrehozását mutatja .felmérés eredményeinek statisztikai mutatóit íratjuk ki két tanítási módszert használó csoportban.9. fejezet: Grafika.\ngrafikus megjelenítés leíró statisztikai elemzés része. 9. fejezetben részletesebben olvashatunk publikációkész ábrák létrehozásáról.numerikus változók esetén használt egyik elterjedt ábrázolási formát, dobozdiagramot használjuk két tanítási csoport eredményének grafikus összehasonlítására.10. fejezet: Hipotézisvizsgálatok.\nstatisztikai hipotézisvizsgálat minden adatelemzés központi része, gyűjtött adatokból populációra nézve következtetést vonhatunk le. 10. fejezetben leggyakoribb egyváltozós elemzéseket mutatjuk .Mann-Whitney-próbát hajtunk végre két tanítási módszer eredményességének összehasonlítására.11. fejezet: Publikálás.\nAz adatelemzési folyamat utolsó lépése, az elemzés eredményének publikációkész formába öntése. 11. fejezetben megismerjük azokat legegyszerűbb folyamatokat, amelyekkel többnyire formanyelvtől függetlenül, publikációkész eredményközlést végezhetünk.bevezető példában kapott eredmények publikálását végezzük el. korábban használt psych::describeBy() függvény hívását úgy módosítjuk, hogy az bármely formanyelven (PDF, HTML, Docx) megfelelő eredményt adjon. Ehhez mindössze egészítsük ki következő sorokkal leíró statisztikai elemzést, majd Knit nyomógomb segítségével fordítsuk le az RMarkdown állományt. leíró statisztikai mutatók máris táblázatos, könnyen áttekinthető formában jelennek meg.Publikációnk szerves része magyarázó ábra. korábban rajzolt dobozdiagramunkat csinosítsuk ki következő sorok R csonkba helyezésével. ggsave() függvény háttértárra rögzítésről gondoskodik.bevezető példa megoldásához természetesen hipotézisvizsgálat szöveges értékelés hozzátartozik, de ezt az alfejezet végén szereplő egyik kitűzött feladatra halasztjuk. hangsúly könyv vázlatos tartalomjegyzékének bemutatásán volt, részletesebb, de felsorolásszerű tartalomjegyzéket következő két alfejezetben találunk.","code":"\n# install.packages(\"rio\")                         # rio csomag telepítése\nlibrary(rio)                                      # rio csomag betöltése\nfelmeres <- import(file = \"adat/excel_2020.xlsx\") # beolvasás\nstr(felmeres)              # a dataframe szerkezete\nnames(felmeres)            # változónevek  \nunique(felmeres$modszer)   # különböző értékek\nfelmeres$modszer <- factor(felmeres$modszer)\nfelmeres$modszer <- factor(felmeres$modszer, levels=c(\"modern\", \"hagyományos\"))\n# install.packages(\"psych\") # psych csomag telepítése\npsych::describeBy(x = felmeres$eredmeny, group = felmeres$modszer,\n                  mat=T, fast=T, digits = 2)\n#>     item      group1 vars  n mean   sd  min  max range   se\n#> X11    1      modern    1 13 0.65 0.20 0.33 0.95  0.63 0.05\n#> X12    2 hagyományos    1 13 0.38 0.13 0.08 0.55  0.47 0.04\nlibrary(ggplot2)\nggplot(data = felmeres, mapping = aes(x=modszer, y=eredmeny)) + geom_boxplot()\nwilcox.test(eredmeny~modszer, data=felmeres)\n#> \n#>  Wilcoxon rank sum exact test\n#> \n#> data:  eredmeny by modszer\n#> W = 145, p-value = 0.001\n#> alternative hypothesis: true location shift is not equal to 0\noptions(OutDec = \",\")  # a tizedesjel beállítása\nst <- psych::describeBy(x = felmeres$eredmeny, group = felmeres$modszer, \n                        mat=T, fast=T, digits = 2)\nknitr::kable(st[-1], align = c(\"c\", \"c\"), row.names = F)\nlibrary(ggplot2)\np1 <- ggplot(data = felmeres, mapping = aes(x=modszer, y=eredmeny)) + \n  geom_boxplot() + \n  labs(x=NULL, y=\"Eredmény (%)\", \n       title=\"7. osztályos tanulók Excel eredménye\", \n       subtitle = \"Két tanulási módszer összehasonlítása\") + \n  scale_y_continuous(labels = scales::percent) + theme_bw()\nggsave(filename = \"output/kep/dd.png\", plot = p1)\np1"},{"path":"itt-kezdodik.html","id":"itt-kezdodik-1-summary","chapter":"1 Itt kezdődik","heading":"1.1.1 Összefoglalás","text":"\nEbben az alfejezetben egy adatelemzési példát oldottunk meg, melynek\nsegítségével illusztrálni tudtuk további fejezetek tartalmát. 2.\nfejezetben áttekintést adunk az R-ről, 3.-ban az Alap R és\nRStudio telepítését, 4.-ben az RStudio használatát\nmutatjuk . Az 5. fejezetben kellő részletességgel ismertetjük az R\nnyelvet. további fejezetekben az adatelemzés szokásos lépéseit vesszük\nsorra, 6. fejezetben beolvasást, 7. fejezetben az adatok\nelőkészítését, 8. és 9. fejezetben leíró statisztikai műveleteket\nmutatjuk . 10. fejezet az egyváltozós hipotézisvizsgálatoké, az\nutolsó, 11. fejezet az eredmények publikálását foglalja össze.\n","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-1-exercise","chapter":"1 Itt kezdődik","heading":"1.1.2 Feladatok","text":"\nMilyen online vagy nyomtat könyvek segítik az R elsajátítását?\nPróbáljuk összegyűjteni magyar nyelvű könyveket !\n\nTérképezzük fel az online videókurzusokat az R tanulásához!\n\nbevezető példa (Két tanítási módszer összehasonlítása)\nmegoldásában hipotézisvizsgálat alapján adjunk szöveges\nértékelést!\nfenti feladatok megoldása","code":""},{"path":"itt-kezdodik.html","id":"a-könyv-felépítése","chapter":"1 Itt kezdődik","heading":"1.2 A könyv felépítése","text":"\nEbben fejezetben:\n\nbemutatjuk könyv részletes felépítését,\n\nezzel tovább segítjük választást folytatáshoz.\nkönyv 11 fejezetből áll, és fejezetenként 3 vagy több alfejezetből. röviden bemutatjuk az egyes alfejezetek tartalmát.","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-2-summary","chapter":"1 Itt kezdődik","heading":"1.2.1 Összefoglalás","text":"\nEbben részben röviden bemutattuk könyv összes alfejezetét. \nkésőbbiekben térképként használhatja az Olvasó az itt ismertetett\ntáblázatot.\n","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-2-exercise","chapter":"1 Itt kezdődik","heading":"1.2.2 Feladatok","text":"Az adatfeldolgozás 4 lépése következő: (1) adatok beolvasása, (2) adatok előkészítése elemzésre, (3) adatok elemzése és (4) az eredmények publikálása. könyv mely fejezetei tartoznak az adatfeldolgozás fenti lépéseihez?Az R-rel való munka általunk javasolt módja: RStudio-ban, projektmódban, R vagy RMarkdown állományokat szerkesztünk és hajtunk végre. Mely fejezetekben találunk hasznos információkat az R ezen használatával kapcsolatban?fenti feladatok megoldása","code":""},{"path":"itt-kezdodik.html","id":"próbák-listája","chapter":"1 Itt kezdődik","heading":"1.3 Próbák listája","text":"\nEbben fejezetben:\n\náttekintést adunk az egy- és kétváltozós\nhipotézisvizsgálatokról.\n10. fejezetben bemutatjuk az egy- és kétváltozós hipotézisvizsgálatok végrehajtását. Ebben fejezetben felsoroljuk legfontosabb próbákat, összesen öt táblázatban soroljuk fel őket:egy mintát vizsgáló próbák (1.1. táblázat),páros mintát vizsgáló próbák (1.2. táblázat),két független mintát vizsgáló próbák (1.3. táblázat),több összetartozó mintát vizsgáló próbák (1.4. táblázat),több független mintát vizsgáló próbák (1.5. táblázat).táblázatokban megadjuk, hogy vizsgálatnak mi célja, vagyis populációbeli változó(k) melyik paraméterére vonatkoznak próbák, várható értékre, mediánra, varianciára vagy valószínűségre. 10. fejezetben foglalkozunk az eloszlásvizsgálatok közül normalitást ellenőrző próbákkal , így 1.1. táblázat ezeket számba veszi.TÁBLÁZAT 1.1:  Egy minta vizsgálataTÁBLÁZAT 1.2:  Páros minta vizsgálataTÁBLÁZAT 1.3:  Két független minta vizsgálataTÁBLÁZAT 1.4:  Több összetartozó minta vizsgálataTÁBLÁZAT 1.5:  Több független minta vizsgálata","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-3-summary","chapter":"1 Itt kezdődik","heading":"1.3.1 Összefoglalás","text":"\nEbben részben rövid áttekintést adtunk könyv 10. fejezetében\nsorra kerülő statisztikai próbákról. Megneveztük próbákat, R\nparancsokkal szemléltettük használatukat, valamint jeleztük céljukat.\ntáblázatok áttekintésével képet kaphatunk arról, hogy későbbiekben\nmilyen jellegű statisztikai következtetéseket tudunk levonni az R\nhasználatával.\n","code":""},{"path":"itt-kezdodik.html","id":"itt-kezdodik-3-exercise","chapter":"1 Itt kezdődik","heading":"1.3.2 Feladatok","text":"Minden statisztikai próba esetében négy dolgot érdemes tudni: (1) statisztikai próba neve, (2) null- és ellenhipotézise, (3) alkalmazási feltételei, és (4) próba végrehajtásának módja valamely statisztikai programcsomagban. 10. fejezetben statisztikai próbák végrehajtását természetesen R-beli eszközökkel mutatjuk . Ismerjük fenti táblázatokban megnevezett próbák null- és ellenhipotézisét, valamint az alkalmazási feltételeit? Próbáljuk ezeket felidézni! Hol találunk ezekről információt?Mely próbák maradtak ki ebből könyvből? Hol találunk ezek R-beli végrehajtására példát?\nfenti feladatok megoldása","code":""},{"path":"mi-az-r.html","id":"mi-az-r","chapter":"2 Mi az R?","heading":"2 Mi az R?","text":"","code":""},{"path":"mi-az-r.html","id":"az-r-bemutatása","chapter":"2 Mi az R?","heading":"2.1 Az R bemutatása","text":"\nEbben fejezetben:\n\nmegismerjük az R jellemzőit,\n\nmegtudjuk, hogy melyek parancssoros interfész előnyei,\n\nmegismerjük az Alap R fogalmát,\n\nkörülhatároljuk az R nyelv, az Alap R és csomag\nfogalmát.\n","code":""},{"path":"mi-az-r.html","id":"az-r-jellemzői","chapter":"2 Mi az R?","heading":"2.1.1 Az R jellemzői","text":"Az R egy magas szintű programozási nyelv és környezet, amelynek legfontosabb felhasználása az adatelemzés és az ahhoz kapcsolódó grafikus megjelenítés. Három alapvető jellemzője kiemeli többi statisztikai programcsomag közül: (1) az R ingyenesen telepíthető és használható; (2) az R nyílt forrású, így bárki hozzájárulhat az R fejlesztéséhez, azaz létrehozhat új csomagokat, és ezzel kiegészítheti az R tudását; és (3) az R felhasználók rendkívül aktív és befogadó online közösséget alkotnak, szinte minden felmerülő kérdésünkre azonnal választ kaphatunk.Álljon itt egy bővített lista azokról jellemzőkről, amelyek vonzóvá tehetik számunkra az R statisztikai programcsomagot.Az R szabad szoftver, bárki ingyenesen letöltheti és használhatja. Ez egyfelől megkönnyíti az oktatási intézmények, tanszékek és oktatók munkáját, hiszen nincs szükség kereskedelmi programok licenceléséből adódó pénzügyi vagy más természetű nehézségek kezelésére. Másrészt hallgatók statisztika kurzusok során tanultakat otthon vagy később munkájukban felhasználhatják.Az R platform-független, azaz Windows, Linux és macOS környezetben használható. Nem kell lemondanunk kedvenc operációs rendszerünkről, ha az R-t szeretnénk használni.Az R nemcsak egy statisztikai programcsomag önmagában, hanem egy teljes értékű programozási nyelv.Az R statisztikai módszerek szinte végtelen választékát kínálja. R-ben felhasználható statisztikai eljárásokat statisztikusok fejlesztik folyamatosan és csomagok formájában teszik elérhetővé. Valószínű, hogy egy új statisztikai módszer leghamarabb az R-ben válik elérhetővé.Az R rendkívül gazdag grafikus lehetőségekkel rendelkezik.statisztikai szakirodalomban és az egyetemi oktatók körében egyre elterjedtebb az R mint közös (statisztikai program)nyelv használata. Ha valamilyen statisztikai problémára keressük megoldást, vagy csak konzultálunk egy statisztikussal, az R ismerete (akár csak olvasási szinten) rendkívüli előnyt jelenthet.Az R igen jól dokumentált, beépített súgón kívül számos könyv és leírás érhető el.Az R parancssoros interfésszel rendelkezik, amely számos előnnyel jár. Egyrészt szkript állományok létrehozása és végrehajtása statisztikai elemzések megismételhetőségét biztosítják, másrészt ez az oktatók és hallgatók könnyebb kommunikációját lehetővé teszi.Az R az adatelemzés eredményének sokszínű publikálását biztosítja. Az RMarkdown formanyelv segítségével HTML, PDF és Word dokumentumot, illetve prezentációs diákat vagy akár kész cikkeket hozhatunk létre. Shiny csomag interaktív Webes alkalmazások építését teszi lehetővé.Mára az R használata szinte egyet jelent az ingyenesen elérhető RStudio használatával, amely egy kényelmes integrált fejlesztői környezetet biztosít parancsállományok létrehozásához.Érdemes bepillantani az R árnyékosabb oldalába . Az R egyik gyengesége, hogy nagy adatbázisok kezeléséhez erős hardverre van szüksége, de legtöbb felhasználás során ez semmilyen problémát nem okoz. másik gyengeség, hogy az R elsajátításához nem kevés idő és kitartás szükséges. Jelen könyv éppen ezt folyamatot kívánja megkönnyíteni és lerövidíteni.","code":""},{"path":"mi-az-r.html","id":"a-r-parancssoros","chapter":"2 Mi az R?","heading":"2.1.2 A R parancssoros","text":"Az R alapvető használata során parancsokat gépelünk és hajtunk végre. Ez lényegesen eltér ma megszokott felhasználói programok világától, ahol egy grafikus felhasználói felületen egérrel vagy az ujjunkkal mutogatjuk el kívánt tevékenységet. Az R egészen más megközelítést vall, használata kezdeti lépésektől nagyfokú figyelmet és pontosságot követel. Parancsokban kell gondolkodnunk, ám ezt végig áthatja tudom mit csinálok elv, így némi idő elteltével érezni fogjuk, hogy az R megszelídül, már nem köt bele minden szavunkba, egyre több dologra tudjuk rávenni, és végül egy rendkívül értékes társsá válik. Jelen könyv ezen az úton szeretné végigvezetni az Olvasót.Már tanulás elején szeretnénk tisztázni, hogy az R elsajátításához nem szükséges programozói alaptudás. Az R felhasználók többsége egyáltalán nem programozó, és mindennapi adatelemző munka sem igényli az R nyelv programozói fokú ismeretét. Természetesen, ha rendelkezünk ilyen irányú előtanulmányokkal tanulási folyamat néhány szakasza lerövidíthető, de könyvünk elsősorban azok számra íródott, akik programozási nyelvekkel korábban nem találkoztak, és nem vágynak az R ilyen mélységű ismeretére. Az R nyelv elsajátítása során bevezetjük azokat az egyszerű fogalmakat, amelyeket nem nélkülözhetők az adatelemzés során, azonban az R programozásához más szakkönyveket javaslunk olvasásra.","code":""},{"path":"mi-az-r.html","id":"mi-valójában-az-r","chapter":"2 Mi az R?","heading":"2.1.3 Mi valójában az R?","text":"Az R nyelv fejlesztője az R Core Team. Az R nyelv egy rendkívül népszerű szkriptnyelv, több millióan használják világszerte. Elsősorban adatelemzésre, adatmodellezésre és grafikus megjelenítésre, vagyis arra, amit ma adattudományok (data science) alatt értünk. Azonban az R nyelv önmagában nem szoftver, hanem egy rendkívül rugalmas szkriptnyelv, amely például előírja, hogy milyen szintaktikai szabályok mentén fogalmazhatjuk meg az utasításainkat. Ahhoz, hogy az R nyelvet használni tudjuk, vagyis, hogy számítógép valóban végre hajtsa szintaktikailag helyes utasításainkat, szükség van egy szoftveres környezetre, egy olyan futtató rendszerre, amely kódunkat értelmezi és végrehajtja.\nÁBRA 2.1: Az R környezet: Alap R és az egyéb csomagok\nAz R környezet három fő összetevőt tartalmaz (2.1. ábra): (1) egy konzolt, ahová parancsainkat begépelhetjük; (2) parancsok végrehajtásáért felelős R interpretert; (3) csomagokokat. konzol és az interpreter biztosítja az R nyelven írt parancsok tényleges végrehajtását. Így tudunk adatokat beolvasni, átlagot számolni, varianciaelemzést futtatni, vagy publikációkész ábrákat létrehozni. csomagok adatokat és függvényeket tartalmaznak, például MASS csomag 88 adatobjektumot és 78 függvényt tartalmaz. függvények valamilyen tevékenységet hajtanak végre, és valójában ezeket csomag-függvényeket használjuk fel konzolban, ha bármilyen tevékenységet szeretnénk végrehajtani (például adatokat beolvasni, átlagot számolni stb.). könyv írásának időpontjában kb. 21 ezer csomag volt érhető el az R-hez. Csomagok 3 csoportját különböztetjük meg: standard csomagok (14 db), ajánlott csomagok (15 db) és egyéb csomagok (kb. 21 ezer db). standard csomagok fejlesztője az R Core Team. standard csomagok: base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils. Az ajánlott csomagok: KernSmooth, MASS, Matrix, boot, class, cluster, codetools, foreign, lattice, mgcv, nlme, nnet, rpart, spatial, survival. Az ajánlott csomagok közül foreign és az nlme fejlesztője az R Core Team, többit más felhasználók fejlesztették, például már említett MASS csomag fejlesztője Brian Ripley. Csomagot bárki szabadon fejleszthet és terjeszthet, az egyéb csomagok csoportját akár mi gyarapíthatjuk.R környezet már igazi szoftver, terjesztésének koordinálását az R Foundation végzi CRAN infrastruktúráján keresztül. Ez biztosítja, hogy számítógépünkre telepíthessük az R környezetet. Ezt CRAN-ról elérhető R futtatási környezetet Alap R-nek nevezzük. Fő komponensei már említett konzol parancsok begépelésére, az R értelmező begépelt parancsok végrehajtására és csomagok közül standard és ajánlott csomagok. Az Alap R telepítése után már tudunk R parancsokat végrehajtani, és nagyon sok adatelemzési probléma megoldására nyílik módunk, sőt azt mondhatjuk, hogy tetszőleges problémát megoldhatunk kisebb-nagyobb erőfeszítéssel, mert az R egy teljes értékű nyelv. Azonban sokszor érdemesebb az egyéb csomagok közül választani, hiszen könnyen elképzelhető, hogy számtalan csomag között találunk olyat, amely segítségünkre lehet speciális feladataink megoldása során. Valószínű, hogy létezik olyan csomag és benne olyan függvény, amely adatkezelési, adatelemzési, grafikai vagy publikálási feladatunkat jelentősen megkönnyíti. Az egyéb csomagok csoportjába tartozó csomagok forrása több tárhely lehet, ezek közül legjelentősebb az R Foundation által karbantartott CRAN (18619 csomaggal), Bioconductor (2140 csomaggal) és GitHub.Az R tehát egyszerre több dolgot jelent. Az R egyrészt egy magas szintű programozási nyelv, hamarosan megtanuljuk, hogyan írjunk ezen nyelven értelmes utasításokat. Másrészt nyelv körüli környezetet jelenti, amely magába foglalja konzolt, parancsaink értelmezésért felelős R interpretert, valamint azokat csomagokat, amelyekkel az R tudása kiegészíthető.","code":""},{"path":"mi-az-r.html","id":"mi-az-r-1-summary","chapter":"2 Mi az R?","heading":"2.1.4 Összefoglalás","text":"\nMinden statisztikai programcsomag, így az R , alapvetően \nszámításigényes statisztikai eljárások kézi végrehajtásától kímél meg\nminket. Az R nagyon gazdag adatmanipulációs és grafikus funkciókban ,\ntámogatja reprodukálható adatelemzés végrehajtását. Az R ingyenes,\ntöbbplatformos és egyik legfontosabb jellemzője, hogy parancsok útján\nbírhatjuk működésre. Az Alap R biztosítja konzolt parancsok\nbegépelésére, az R interpretert parancsok tényleges végrehajtására, és\njó néhány csomagba szervezett eljárást az adatelemzési feladatok\nelvégzéséhez. Az Alap R mindössze néhány tucat csomagot\ntartalmaz, standard csomagokat és az ajánlott\ncsomagokat, de több tízezer további csomaggal bővíthetjük az R\ntudását. Az adatelemzési munka során egy R környezet vesz minket körül,\namely az R nyelven megírt parancsok értelmezésére és végrehajtására\nképes Alap R-ből, és az ún. egyéb csomagokból áll.\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r-1-exercise","chapter":"2 Mi az R?","heading":"2.1.5 Feladatok","text":"Keressünk weboldalakat, amelyek az R előnyeit és hátrányait listázzák!Keressük meg, hogy az R optimális futtatásához, milyen hardver követelmények szükségesek!Nézzünk utána, hogy ma kb. hány csomag érhető el az R-hez? Keressünk ábrát, amely bemutatja, hogy az évek során hány csomag volt elérhető az R-hez?Hol áll az R népszerűsége többi programozási nyelvhez, illetve statisztikai programcsomaghoz képest?Milyen ingyenesen elérhető, grafikus felhasználói felülettel rendelkező statisztikai programcsomagok építenek az R-re?Említettük, hogy az adatelmezési munka nem igényli az R programozói fokú ismeretét, de soroljunk fel néhány könyvet, amelyből az R programozása megtanulható!fenti feladatok megoldása","code":""},{"path":"mi-az-r.html","id":"a-modern-r","chapter":"2 Mi az R?","heading":"2.2 A modern R","text":"\nEbben fejezetben:\n\nmegismerjük Tidyverse R fogalmát,\n\nmegtudjuk mit értünk modern R alatt.\n2014-es év az R nyelv életében meghatározó változást hozott. Egyrészt megjelent magrittr csomagban pipe operátor (%>%), amellyel olvashatóbb kódok írására nyílt lehetőség1, másrészt pipe operátorra alapozva Hadley Wickham bemutatta dplyr és tidyr csomagokat. Ezzel az R funkcionális2 oldalát úgy erősítették meg3, hogy sokszoros egymásba ágyazás során kiküszöbölték kerek zárójelek írásának problémáját. Az ebben szellemben készült csomagok listája bővült az idők folyamán, és Tidyverse nevet kapta ez csomaggyűjtemény. Jelenleg következő csomagok alkotják: ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats. Ezek csomagok nem egyszerűen új funkciókkal ruházzák fel az Alap R tudását, mint általában az egyéb csomagok. Tidyverse csomagjai konzisztens módon együttműködnek, és egy új megközelítést hoznak az adatelemzési folyamatok végrehajtásában és kódok írásában. Rövidebb idő alatt hozhatunk létre könnyebben karbantartható kódokat, és műveleteink végrehajtása rendszerint gyorsabb. Amikor ebben megközelítésben hozzuk létre és hajtjuk végre utasításainkat, akkor azt mondjuk hogy Tidyverse R-t használjuk. Tidyverse R nem helyettesíti az Alap R-t, és csak bizonyos feladatokra használható. Lássunk tisztán, amit elvégezhetünk Tidyverse R-ben, azt az Alap R-ben meg tudnánk tenni, de valószínűleg több gépeléssel, lassabb és rosszabbul karbantartható kóddal.Eddig láttuk, hogy az R használatához szükséges az Alap R telepítése, majd speciális problémánknak megfelelően kiegészíthetjük az R tudását úgy, hogy telepítünk egyet vagy többet az egyéb csomagok kategóriájából. Választhatjuk akár Tidyverse csomagjait telepítésre, ugyanis így lehetőségünk nyílik Tidyverse R használatára. Utasításaink megfogalmazásának ma ez legmodernebb módja.modern R alatt lényegében azokat funkciókat értjük, amelyek Tidyverse gyűjteményben található csomagokhoz kötődnek. Ezekkel csomagokkal, gyorsabb, olvashatóbb és könnyebben karbantartható kódokat hozhatunk létre. Tidyverse használata tehát erősen javasolt, de ebben könyvben “hagyományos”, Tidyverse R előtti lehetőségeket bemutatjuk.","code":""},{"path":"mi-az-r.html","id":"mi-az-r-2-summary","chapter":"2 Mi az R?","heading":"2.2.1 Összefoglalás","text":"\nTidyverse R egy csomaggyűjtemény az egyéb\ncsomagok csoportjából, amely újabb szemléletű R parancsok írására\nad lehetőséget. Az így készült kódjaink rendszerint gyorsabban futnak és\nkönnyebben karbantarthatók. modern R Tidyverse R\ncsomagjaival kiegészített Alap R, de legfőképp egy új lehetőség\nparancsaink megfogalmazására.\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r-2-exercise","chapter":"2 Mi az R?","heading":"2.2.2 Feladatok","text":"Ki Hadley Wickham?Mikor történt az egyik legjobb dolog az R-rel?fenti feladatok megoldása","code":""},{"path":"mi-az-r.html","id":"múlt-és-jelen","chapter":"2 Mi az R?","heading":"2.3 Múlt és jelen","text":"\nEbben fejezetben:\n\nmegismerjük az R rövid történetét és annak szereplőit,\n\nmajd egy szubjektív listával segítjük az R tanulását,\n\nilletve megismerjük az R alaptudás elemeit.\n","code":""},{"path":"mi-az-r.html","id":"szereplők-és-fogalmak","chapter":"2 Mi az R?","heading":"2.3.1 Szereplők és fogalmak","text":"Érdemes néhány szereplőt és fogalmat tisztázni az R világán belül. Az R nyelvet 1992-ben kezdte fejleszteni Ross Ihaka és Robert Gentleman, 1997-től pedig egy nagyobb csapat, az R Development Core Team vezeti fejlesztést (rövidebben R Core Team). Ettől az évtől az R hivatalosan GNU projekt része. Az R Core Team tagjai 2002-ben létrehozták R Foundation Statistical Computing (rövidebben R Foundation) közhasznú, nonprofit szervezetet, amelynek célja (1) az R folyamatos fejlesztésének biztosítása, és ehhez kapcsolódóan nyílt forráskódú számítógépes statisztikai innovációk támogatása, (2) az R fejlesztői közösség (R Core Team) hivatalos hangjaként felhasználók, intézmények és üzleti vállalkozások számára kommunikáció biztosítása, és (3) az R program és dokumentációk szerzői jogainak kezelése. szervezet rendszeresen konferenciákat, találkozókat szervez, referált folyóiratot, kézikönyveket és technikai leírásokat ad ki, valamint fenntart egy számítógépes infrastruktúrát (ez CRAN, amely levelező listákat, FTP- és Webszervereket üzemeltet). Az R Foundation hivatalos oldala – egyben az R hivatalos oldala – https://www.r-project.org/. Az R Foundation (és más önkéntesek) által üzemeltetett számítógépes hálózat neve CRAN (Comprehensive R Archive Network), amely szabad hozzáférést nyújt az R legfrissebb verziójához, az R kiterjesztéseihez (csomagokhoz) és részletes dokumentációkhoz. CRAN fő számítógépe Ausztriában található https://CRAN.R-project.org/, azonban nagyon sok naponta frissülő tükörszerver érhető el világszerte.","code":""},{"path":"mi-az-r.html","id":"alapelvek","chapter":"2 Mi az R?","heading":"2.3.2 Alapelvek","text":"Az R elsődleges célja, hasonlóan más statisztikai programcsomagokhoz, statisztikai adatelemzés, amelyet négy lépésre bonthatunk:adatok beolvasása,adatok előkészítése elemzésre,adatelemzés,eredmények publikálása.Az R mára fenti 4 tevékenység elvégzését teljes körűen támogatja. könyv célja ezek bemutatása. Mielőtt elkezdjük ezt az izgalmas utat – az R tanulmányozását – néhány alapelvet szeretnék megemlíteni, ami segíthet minket az utazásunk során:Magabiztosság - Az R nagyon nagy, így teljes megismerése nem lehet célunk. Mindig lesz valaki, aki az R egyik vagy másik részét jobban, vagy kevésbé ismeri nálunk. Ez természetes, ezen soha ne csodálkozzunk. Az eltérő ismeretek azonban az R speciális területeire vonatkoznak, az R alaptudás (2.3.3. fejezet) minden R-ben jártas felhasználó számára közös. E könyv célja ennek az alaptudásnak az átadása, melynek birtokában már kellő magabiztossággal vághatunk neki az R azon részeinek elsajátításába, amelyek az éppen elénk kerülő speciális feladat megoldásához szükségesek. Hisszük, hogy e könyv elolvasásával, mind az R alaptudás, mind kellő magabiztosság elérhetővé válik számunkra.Gyakorlás - Az R alaptudásának megszerzése némi időbe telik, ez tagadhatatlan. motiváció megtartásához viszonylag jól kell éreznünk magunkat tanulás és gyakorlás során. könyvben ezért minden fejezet végén találunk megoldandó feladatokat, amelyek között szórakoztató, érdekes és kihívást jelentő gyakorlatok szerepelnek.Svájci bicska - R nagyon sokféle statisztikai és nem-statisztikai probléma megoldására képes, sőt ugyanarra problémára nagyon sok különböző eszközt kínál. Ha elsőre nem legszebb, legoptimálisabb megoldás jut az eszünkbe, ne csüggedjünk, ez legtöbb esetben nem jelent gondot. Azon se csodálkozzunk, ha korábban megoldott problémánkra idővel újabb és újabb megoldási lehetőségeket találunk.","code":""},{"path":"mi-az-r.html","id":"Ralaptudas","chapter":"2 Mi az R?","heading":"2.3.3 Az R alaptudás","text":"Melyek az R-ben való munkavégzéshez nélkülözhetetlen alapismeretek? Meggyőződésünk, ha lentebb felsorolt témakörökkel tisztában vagyunk, akkor már magabiztos R tudással rendelkezünk, és bármilyen további R témakör könnyen elsajátítható lesz. Ezekre az ismeretekre úgy gondolhatunk, mint egy ablakra, amelyen keresztül az R szinte végtelen lehetőségeinek tárháza nyílik meg előttünk. Később visszatérhetünk ehhez listához, és ellenőrizhetjük, hány elemet tudunk már kipipálni.Az R alaptudás elemei:Az R környezet alapszintű ismerete\n\naz Alap R, az RStudio és csomagok telepítése\n\nprojektek használata és R parancsok futtatása az RStudio-ban\n\naz Alap R, az RStudio és csomagok telepítése\nprojektek használata és R parancsok futtatása az RStudio-banAz R nyelv alapszintű ismerete\n\nkonstansok írása\n\nobjektumok kezelése\n\negyszerű adattípusok\n\nalapvető operátorok\n\nkifejezés fogalma\n\nfüggvényhívás lehetőségei\n\nösszetett adattípusok,\n\nvektoraritmetika szabályai\n\nkonstansok írása\nobjektumok kezelése\negyszerű adattípusok\nalapvető operátorok\nkifejezés fogalma\nfüggvényhívás lehetőségei\nösszetett adattípusok,\nvektoraritmetika szabályaiAz alapvető függvények ismerete\n\ncsomagkezelő függvények\n\nmunkaterület függvényei\n\nmatematikai függvények\n\ninput/output függvények\n\nindexelés, szűrés, rendezés\n\ninformáció kérés az objektumokról\n\negyszerű típuskonverzió\n\ntranszformáció\n\nismétlő és összesítő függvények\n\nhagyományos grafika néhány eleme\n\nggplot2 alapszintű ismerete\n\ncsomagkezelő függvények\nmunkaterület függvényei\nmatematikai függvények\ninput/output függvények\nindexelés, szűrés, rendezés\ninformáció kérés az objektumokról\negyszerű típuskonverzió\ntranszformáció\nismétlő és összesítő függvények\nhagyományos grafika néhány eleme\nggplot2 alapszintű ismereteEgyéb ismeretek\n\nszövegszerkesztési és állománykezelési ismeretek\n\ntagolt szöveges állomány fogalma\n\nreprodukálható kutatás az RMarkdown segítségével\n\nszövegszerkesztési és állománykezelési ismeretek\ntagolt szöveges állomány fogalma\nreprodukálható kutatás az RMarkdown segítségével","code":""},{"path":"mi-az-r.html","id":"mi-az-r-3-summary","chapter":"2 Mi az R?","heading":"2.3.4 Összefoglalás","text":"\nAz R fejlesztését Ross Ihaka és Robert Gentleman kezdte, majd\n1997-től egy nagyobb csapat, az R Development Core Team vezeti\nfejlesztést. Az R Core Team tagjai 2002-ben létrehozták \nR Foundation Statistical Computing közhasznú, nonprofit\nszervezetet, amelynek fő célja az R folyamatos fejlesztésének\nbiztosítása. szervezet fenntart egy CRAN nevű számítógépes hálózatot,\namely szabad hozzáférést biztosít az R legfrissebb verziójához, \ncsomagokhoz és részletes dokumentációkhoz.\nAz R alaptudás megszerzése elegendő magabiztosságot fog nyújtani az\nadatelemzési munka során, azonban vegyük figyelembe, hogy ezt csak kellő\ngyakorlással érhetjük el. Az R sokféle megoldást biztosít ugyanarra \nproblémára, legyen az statisztikai vagy bármilyen más jellegű\nfeladat.\n","code":""},{"path":"mi-az-r.html","id":"mi-az-r-3-exercise","chapter":"2 Mi az R?","heading":"2.3.5 Feladatok","text":"Keressünk olyan statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet?Keressünk olyan nem-statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet?Nézzünk át néhány online elérhető R könyvet, és hasonlítsuk össze az R alaptudás egyes elemeivel! Melyek az átfedő részek, és hol vannak különbségek?Melyek fontosabb lépcsőfokok az R fejlődősében?\nfenti feladatok megoldása","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese","chapter":"3 Az R telepítése","heading":"3 Az R telepítése","text":"","code":""},{"path":"az-r-telepitese.html","id":"a-fő-komponensek-telepítése","chapter":"3 Az R telepítése","heading":"3.1 A fő komponensek telepítése","text":"\nEbben fejezetben:\n\nmegismerjük az Alap R, az RStudio és csomagok\ntelepítését.\nkorábbi fejezetekben megismertük az R világának néhány fogalmát és szereplőjét. Tudjuk, hogy az R nyelv használatához megfelelő szoftveres környezetre van szükség, amely magába foglalja az Alap R-t és az egyéb csomagok kategóriájából esetlegesen telepített csomagokat . Az R már ezen eszközök birtokában teljes körűen használható, azonban egy újabb ingyenes eszköz, az RStudio, kényelmessé és hatékonnyá teszi az adatelemzési munkát.Könyvünk legfontosabb gondolata: ma akkor tudjuk legjobban kihasználni az R lehetőségeit, és ezzel egyidőben legkényelmesebb módon elvégezni az adatelemzési feladatunkat, haaz Rstudio-t használjuk,projekt üzemmódban dolgozunk, ésRMarkdown állományokban rögzítjük az R parancsainkat.Ezt szemléletet következetesen képviseljük az egyes fejezetekben, és későbbiekben részletesebben bemutatjuk, hogyan tudjuk mindezt megvalósítani (3.1. ábra).\nÁBRA 3.1: Az R kényelmes használata\nR kényelmes használatához legelső lépés szoftveres környezet egyes elemeinek telepítése. Három fő komponens telepítésére lesz szükségünk:Alap R, amely tartalmazza konzolt, az R interpretert, illetve standard csomagokat és az ajánlott csomagokat,RStudio, amely egy új konzollal “eltakarja” az Alap R-t, és kényelmesebb hozzáférést biztosít az Alap R interpreteréhez és csomagjaihoz.Csomagok, amelyek az egyéb csomagok nagy halmazából származnak, és telepítésükkel újabb és újabb képességekkel ruházzuk fel az Alap R-t.","code":""},{"path":"az-r-telepitese.html","id":"az-alap-r-telepitese","chapter":"3 Az R telepítése","heading":"3.1.1 Az Alap R telepítése","text":"Az Alap R telepítéséhez látogassunk el az R hivatalos letöltő oldalára: https://cran.r-project.org/. Az operációs rendszerünknek megfelelő link kiválasztásával folytassuk navigálást.Windows felhasználók Download R Windows linken, majd base linken kattintva jutnak el telepítőprogram linkjéhez: Download R X.X.X Windows. sikeres letöltés után indítsuk el telepítőt, és az alapértelmezetten felajánlott opciók nyugtázásával végezzük el telepítést. telepítést lehetőleg olyan Windows felhasználó alatt végezzük el, amelynek neve sem ékezetes karaktert, sem szóközt, sem egyéb írásjelet nem tartalmaz.macOS felhasználók Download R (Mac) OS X linken kattintva jutnak telepítőhöz: R-X.X.X.pkg. letöltés után indítsuk el telepítőt, és Next gombok segítségével végezzük el telepítést.Linux felhasználók az aktuális R verzió telepítéséhez Download R Linux linken keresztül jutnak el, ahol megfelelő disztribúció (Debian, Redhat, Suse, Ubuntu) kiválasztása után konkrét információkat kapnak telepítésről.","code":""},{"path":"az-r-telepitese.html","id":"az-rstudio-telepitese","chapter":"3 Az R telepítése","heading":"3.1.2 Az RStudio telepítése","text":"Az RStudio telepítéséhez az operációs rendszerünknek megfelelő telepítőt kell letöltenünk https://www.rstudio.com/products/rstudio/download/ oldalról. Az RStudio Desktop (Open Source License) változatra lesz szükségünk, töltsük le és telepítsük ezt számítógépünkre. telepítés során fogadjuk el az alapértelmezett opciókat. Az RStudio automatikusan megtalálja és használja korábban telepített Alap R példányunkat, így későbbiekben elegendő lesz az RStudio-t használni, azon keresztül elérhetjük az Alap R minden funkcióját (3.1. ábra).","code":""},{"path":"az-r-telepitese.html","id":"Csomagoktelepitese","chapter":"3 Az R telepítése","heading":"3.1.3 Csomagok telepítése","text":"csomagok telepítésére az Alap R vagy az RStudio elindítása után van módunk. Érdemes telepítéseket az RStudio-ból végezni. csomag fellelési helye alapján, három különböző tárhelyről mutatjuk csomagok telepítését. Látni fogjuk, hogy csomagok telepítéséhez R parancsokat fogunk használni. Ha még nem vagyunk jártasak R parancsok futtatásban, akkor 4.1. fejezet fellapozásával segítséget kaphatunk lenti parancsok kipróbálásához, de úgy eljárhatunk, hogy kihagyjuk ennek résznek az áttekintését, és később térünk vissza, amikor valóban felmerül az igény csomagok telepítésére.Az R csomagok hivatalos helye CRAN (Comprehensive R Archive Network). CRAN számítógépei tárolják nyílt forráskódú R nyelv és környezet különböző verzióinak kódjait és dokumentációit, így az összes R csomag forráskódját . Egy bírálási folyamat után bármely felhasználó csomagja CRAN-ból elérhető lehet.Az Alap R vagy az RStudio elindítása után az install.packages() függvénnyel tölthetünk le és telepíthetünk csomagot CRAN-ról. Tetszőleges csomag telepítéséhez írjuk csomag nevét idézőjelekben függvény argumentumába:psych csomagot, amely pszichológia kutatások adatainak elemzéséhez nyújt segítséget, például így telepíthetjük:csomagok másik fontos forrása Bioconductor, ahol alaposan tesztelt és igen jól dokumentált bioinformatikai témájú csomagokat találunk. Az innen elérhető csomagokat – például DESeq2 csomagot az RNS-szekvenálási elemzésekhez – következő parancsokkal telepíthetjük:csomagok harmadik fő forrása GitHub. felhasználók saját fejlesztésű csomagjaikat rendszerint először GitHub-keresztül teszik elérhetővé. Ha ezeket csomagokat szeretnénk kipróbálni, akkor felhasználó és csomag nevének birtokában következő parancsot kell kiadnunk:Például GitHub-ról telepíthető emo csomag segítségével hangulatjeleket szúrhatunk az RMarkdown állományainkba. Ezzel sorral telepíthetjük csomagot:Fontos tudnunk, hogy csomagok telepítésére egy számítógépen egy adott R verzión belül csak egyszer van szükség. telepítő parancsainkat azonban érdemes megőrizni, ugyanis egy új R verzióban könnyebben tudjuk így telepíteni korábban használt csomagjainkat. Nagyon fontos, hogy telepítő parancsok futtatása után, tegyük azokat megjegyzésbe, vagyis írjunk eléjük kettőskereszt (#) karaktert (részletesebb információkat megjegyzésekről 5.1.3. fejezetben olvashatunk). Ezzel tudjuk megvédeni ezeket telepítő parancsokat az újbóli, véletlen, felesleges végrehajtástól. Ennek megfelelően telepítő parancsainkat ilyen formában kell őriznünk:Vegyük figyelembe, hogy egy csomag telepítése során más, egyéb csomagok telepítése automatikusan megtörténhet, tehát egy helyett valójában több csomag felkerülhet gépünkre. Az előfordulhat, hogy egy csomag telepítése csak akkor lesz sikeres, ha más csomagok frissítését engedélyezzük az adott csomag telepítése során. Végül előfordulhat olyan eset , amikor egy csomag telepítése valamilyen oknál fogva meghiúsul. Erről minden esetben hibaüzenet tájékoztat minket, és ez szinte minden esetben jó kiindulásul szolgál hibát okozó körülmény elhárításában. legtöbbször egy másik csomag hiánya okozza sikertelen telepítést, ezért olvassuk ki hibaüzenetből hiányolt csomag nevét, és először ennek telepítését végezzük el. Nagyon ritka esetben az előfordulhat, hogy egy csomag telepítését az RStudio helyett az Alap R-ben kell elvégeznünk.","code":"install.packages(\"csomag_neve\")\ninstall.packages(\"psych\")        # psych csomag telepítése\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(\"DESeq2\")devtools::install_github(\"felhasznalo_neve/csomag_neve\")\ndevtools::install_github(\"hadley/emo\")\n# install.packages(\"psych\")        # psych csomag telepítése\n# if (!requireNamespace(\"BiocManager\", quietly = TRUE))\n#     install.packages(\"BiocManager\")\n# BiocManager::install(\"DESeq2\")\n# devtools::install_github(\"hadley/emo\")"},{"path":"az-r-telepitese.html","id":"az-r-telepitese-1-summary","chapter":"3 Az R telepítése","heading":"3.1.4 Összefoglalás","text":"\nAz R kényelmes használatához először telepítsük az operációs\nrendszerünknek megfelelő Alap R, majd az RStudio\nlegújabb verzióját. Az R képességeit csomagok segítségével bővíthetjük,\nmelyek három különböző tárhelyről származhatnak. legtöbb csomagot \nCRAN-ről telepíthetjük az install.packages() parancs\nhasználatával. Bioconductor-ról vagy GitHub-ról származó csomagok\ntelepítéséhez más parancsokat kell használnunk.\n","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese-1-exercise","chapter":"3 Az R telepítése","heading":"3.1.5 Feladatok","text":"Melyik az R legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest?Melyik az RStudio legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest?Hogyan deríthető ki, hogy egy csomagban (például MASS) csomagban, hány adatobjektum, és hány függvény található?fenti feladatok megoldása","code":""},{"path":"az-r-telepitese.html","id":"a-tidyverse-r-telepítése","chapter":"3 Az R telepítése","heading":"3.2 A Tidyverse R telepítése","text":"\nEbben fejezetben:\n\nmegismerjük Tidyverse R telepítését.\nTidyverse R az R meglévő funkcióinak új szemléletű használatát jelenti. modern R jelenleg egyet jelent Tidyverse R-rel, az ebben szemléleteben készült parancsaink gyorsak, jól olvashatók és könnyen módosíthatók. Tidyverse R funkciói összesen több csomagba (például ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats) vannak szétosztva, mindegyik csomag egy-egy témakört fed le. fenti csomagok telepítése egyetlen gyűjtőcsomag tidyverse nevű csomag telepítésével elvégezhető:Tidyverse R telepítését követően csomagokban lévő függvények használatához Tidyverse R betöltésére szükség van. Hívjuk meg library() függvényt, amely ebben az esetben igen részletes tájékoztatást ad az újonnan elérhető csomagokról.Tidyverse R csomagjait jelenleg intenzíven fejlesztik, így gyakran jelenik meg újabb és újabb verzió. Érdemes ellenőrizni, hogy Tidyverse R csomagjai közül legfrissebbeket használjuk-e. Ehhez tidyverse csomag tidyverse_update() függvényét használjuk.Például fenti esetben 3 csomag frissítését javasolja tidyverse_update() függvény, és segítséget ad telepítőparancs listázásával. javaslatban szereplő munkamenet törlés (Start clean R session) az RStudio-ban az .rs.restartR() parancs vagy Ctrl+Shift+F10 billentyűkombináció kiadásával valósítható meg.","code":"\ninstall.packages(\"tidyverse\") # a Tidyverse R telepítése\nlibrary(tidyverse)\n#> -- Attaching packages ----------------------------- tidyverse 1.3.0 --\n#> <U+221A> ggplot2 3.3.0     <U+221A> purrr   0.3.3\n#> <U+221A> tibble  3.0.0     <U+221A> dplyr   0.8.5\n#> <U+221A> tidyr   1.0.2     <U+221A> stringr 1.4.0\n#> <U+221A> readr   1.3.1     <U+221A> forcats 0.5.0\n#> -- Conflicts -------------------------------- tidyverse_conflicts() --\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()\ntidyverse::tidyverse_update()  # a Tidyverse R frissítése\n#> The following packages are out of date:\n#> \n#> * lubridate (1.7.4 -> 1.7.8)\n#> * purrr     (0.3.3 -> 0.3.4)\n#> * xml2      (1.2.5 -> 1.3.1)\n#> \n#> Start a clean R session then run:\n#> install.packages(c(\"lubridate\", \"purrr\", \"xml2\"))"},{"path":"az-r-telepitese.html","id":"az-r-telepitese-2-summary","chapter":"3 Az R telepítése","heading":"3.2.1 Összefoglalás","text":"\nTidyverse R használatához elegendő telepítenünk \ntidyverse csomagot, amely többi 8 csomag telepítését\nautomatikusan elvégzi. telepítést \ninstall.packages(“tidyverse”) paranccsal végezzük. Időnként\nellenőrizzük tidyverse::tidyverse_update() segítségével,\nhogy legfrissebb változatát használjuk-e Tidyverse R-t\nalkotó csomagoknak.\n","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese-2-exercise","chapter":"3 Az R telepítése","heading":"3.2.2 Feladatok","text":"Keressünk rá Tidyverse R csomagjaira, és próbáljuk kideríteni az egyes csomagok fő célját, alkalmazási területeit!Derítsük ki, hogy az R Core Team vagy Hadley Wickham több R csomag szerzője!fenti feladatok megoldása","code":""},{"path":"az-r-telepitese.html","id":"az-r-frissítése","chapter":"3 Az R telepítése","heading":"3.3 Az R frissítése","text":"\nEbben fejezetben:\n\nbemutatjuk az Alap R, az RStudio és csomagok\nfrissítését.\nR ideális használata során az RStudio-ban dolgozunk, és így érjük el az Alap R és az egyes csomagok szolgáltatásait. mai napig mindhárom komponenst intenzíven fejlesztik, újabb és újabb funkciókat építenek , és az esetleges hibákat rendre javítják frissebb változatokban. Az Alap R évente kb. négyszer frissül, az RStudio háromszor, és érdemes időnként azt ellenőrizni, hogy gyakran használt csomagjainkból nincs-e frissebb példány.","code":""},{"path":"az-r-telepitese.html","id":"az-alap-r-frissítése","chapter":"3 Az R telepítése","heading":"3.3.1 Az Alap R frissítése","text":"telepített Alap R verzióját az R.version.string végrehajtásával ellenőrizhetjük. Amennyiben az R hivatalos oldalán találunk frissebb példányt, akkor legalább két módszer segítségével frissíthetjük az Alap R-t. Megjegyezzük, hogy az Alap R sikeres frissítése után az RStudio automatikusan az új példányt fogja használni.1. módszer (csak Windows alatt) Windows operációs rendszer alatt rendelkezésre áll az installr csomag, amelynek pontosan az feladata, hogy kényelmesen telepíthessük számítógépünkre az Alap R legfrissebb verzióját. Az installr régebbi verzióban lévő csomagokat az új változatba átmozgatja, és ott azok frissítését elvégzi. következő parancsok futtatására van szükség.2. módszer (minden operációs rendszeren) Az Alap R frissítésének másik módja, hogy telepítünk egy új példányt régi R mellé. Azaz korábban látott módon letöltjük és telepítjük az Alap R legújabb változatát, pontosan úgy, mintha még nem lenne gépünkön működő R. Ez az új verzió azonban félkarú óriás mindaddig, amíg régi R verzióban használt összes csomagot nem telepítjük újra az új verzióban . Ezt magunk megtehetjük, ha korábban összegyűjtöttük csomagtelepítő parancsainkat, legyen szó akár akár CRAN, Bioconductor vagy GitHub oldaláról származó csomagokról. Ha ezek parancsok nem állnak rendelkezésre, akkor az Alap R frissítésének általános útját három lépésben foglalhatjuk össze.Indítsuk el az RStudio-t még az új R verzió telepítése előtt, és futtassuk le következő sorokat. futtatás eredménye egy bináris állomány (csomagok.rds), amely régi R összes telepített csomagjának nevét és más információkat tartalmaz. Lépjünk ki az RStudio-ból.Telepítsük az Alap R új verzióját.Telepítsük az Alap R új verzióját.Indítsuk el az RStudio-t és futtassuk le lenti sorokat. folyamat több percig eltarthat. Az RStudio már az új R verziót használja, így csomagok az új R tudását egészítik ki.Indítsuk el az RStudio-t és futtassuk le lenti sorokat. folyamat több percig eltarthat. Az RStudio már az új R verziót használja, így csomagok az új R tudását egészítik ki.Megjegyezzük, hogy fenti módszer segítségével csak CRAN csomagjait tudjuk telepíteni, Bioconductor és GitHub oldalakról származó csomagok telepítését magunknak kell megismételni. Tehát nem CRAN-ről származó csomagok telepítő parancsait mindenképp érdemes megőrizni.","code":"\n# install.packages(\"installr\") # az installr csomag telepítése\nlibrary(installr)              # az installr csomag betöltése\nupdateR()                      # az Alap R és a csomagok frissítése\ntelepitett.csomagok <- installed.packages(priority=\"NA\")\nsaveRDS(object = telepitett.csomagok, file = \"csomagok.rds\")\ntelepitett.csomagok <- readRDS(file = \"csomagok.rds\")\ninstall.packages(pkgs=telepitett.csomagok[,1])"},{"path":"az-r-telepitese.html","id":"az-rstudio-frissítése","chapter":"3 Az R telepítése","heading":"3.3.2 Az RStudio frissítése","text":"telepített RStudio példányunk verziószámát Help / RStudio menüpont segítségével, vagy az rstudioapi::versionInfo() parancs futtatásával ellenőrizhetjük. Frissebb verzió létezéséről Help / Check Updates menüpont ad tájékoztatást. Amennyiben találunk újabb verziót az RStudio hivatalos honlapján, töltsük le az operációs rendszerünknek megfelelő változatot és indítsuk el telepítőt. Szerencsére régi RStudio beállításait örökli az új példány, és továbbiakban csak az új példány lesz elérhető.","code":""},{"path":"az-r-telepitese.html","id":"csomagok-frissítése","chapter":"3 Az R telepítése","heading":"3.3.3 Csomagok frissítése","text":"korábban telepített csomagokat az RStudio Tools/Check Package Updates menüpontjával frissíthetjük. frissíthető csomagok megjelennek egy dialógus dobozban, jelöljük ki az összes csomagot és indítsuk el telepítési folyamatot. következő R parancs végrehajtásával frissíthetjük csomagjainkat.","code":"\nupdate.packages(ask=FALSE) "},{"path":"az-r-telepitese.html","id":"az-r-telepitese-3-summary","chapter":"3 Az R telepítése","heading":"3.3.4 Összefoglalás","text":"\nAz Alap R, az RStudio és az egyes csomagok\nidőről-időre megújulnak, érdemes évente legalább egy-két alkalommal\nelvégezni ezek frissítését. Az Alap R frissítése lényegében egy\núj verzió telepítését jelenti, régi R továbbra elérhető marad. Az\nRStudio frissítése után csak az új verziót használhatjuk. Az\nAlap R és az RStudio friss verziója hivatalos\nhonlapokról szerezhető . csomagok frissítéséhez használjuk az\nupdate.packages(ask=FALSE) parancsot.\n","code":""},{"path":"az-r-telepitese.html","id":"az-r-telepitese-3-exercise","chapter":"3 Az R telepítése","heading":"3.3.5 Feladatok","text":"Az RStudio Tools/Check Package Updates menüpontjával tájékozódjunk telepített csomagjaink állapotáról. Végezzük el szükséges frissítéseket! Mit tegyünk, ha nem sikerül valamelyik csomag telepítése?Ismerjük meg telepített csomagjaink számát és forrását (CRAN vagy Bioconductor vagy GitHub)!\nfenti feladatok megoldása","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben","chapter":"4 Munka az R-ben","heading":"4 Munka az R-ben","text":"","code":""},{"path":"munka-az-r-ben.html","id":"AzRStudiohasznalata","chapter":"4 Munka az R-ben","heading":"4.1 Az RStudio használata","text":"\nEbben fejezetben:\n\nmegismerjük az RStudio jellemzőit és felépítését,\n\nkonzolos és parancsállományos használat különbségeit,\n\nparancsállományok és az RMarkdown állományok lehetőségeit,\n\nprojekt fogalmát és használatát,\n\nés az RStudio billentyűparancsait.\nMiután minden szükséges szoftverkomponenst feltelepítettünk, hogyan tudjuk működésre bírni az R-t?\nTegyük fel, hogy van egy nagyon egyszerű adatfeldolgozási problémánk, szeretnénk megtudni Csillagok háborúja c. film karaktereinek átlagos testmagasságát filmben szereplő egyes fajokra jellemzően. Ha rátalálunk egy alkalmas adatbázisra, amely tartalmazza szereplők testmagasságait és azt, hogy melyik fajhoz tartoznak, akkor még két konkrét adatelemzési lépés vár ránk:az adatbázis megnyitása,az átlagos testmagasságok meghatározása fajonként.Korábban láttuk, hogy az R parancssoros, tehát fenti két lépést R parancsok formájában kell megfogalmaznunk. Azonban több kérdés felmerül ezen ponton:hová írjuk parancsainkat,hogyan hajthatjuk őket végre, és végül,hol jelenik meg az eredmény.Ebben fejezetben fenti három kérdésekre fókuszálunk, és azt kérdést, hogy mely konkrét parancsokkal érhetjük el célunkat könyv további fejezeteire halasztjuk.Máris megválaszoljuk kérdéseket. Korábban láttuk, hogy az Alap R telepítésével elérhetővé válik konzol, ahová parancsainkat begépelve, majd ENTER-t ütve utasításokat tudunk végrehajtani. Az RStudio telepítésével kapunk egy konzolt, amelynek működése megegyezik az Alap R konzoljával: ide gépelhetünk parancsokat, és ENTER-rel végrehajthatjuk őket. parancsok eredmény itt, konzolban fog megjelenni.kiinduló adatelemzési feladatunk megoldásához tehát vagy az Alap R vagy az RStudio konzoljába gépeljük következő parancsokat, sorról-sorra, és minden egyes sor végén üssünk ENTER-t (konzol használatához 4.1.4. és 4.1.4. fejezetekben találunk segítséget). #-el kezdődő részeket nem szükséges begépelnünk, azok nem az R-nek szólnak, hanem megjegyzés szerepét töltik .konzol azonban nem legkényelmesebb módja az R parancsok végrehajtásának. Ezzel minden bizonnyal egyet értenek azok, akik fenti sorok begépelését és végrehajtását valóban elvégezték konzolban. konzolba gépelés helyett érdemes egy szöveges állományban összegyűjteni az adatfeldolgozáshoz kapcsolódó R parancsainkat, ugyanis ezeket később kényelmesen elküldhetjük konzolba végrehajtásra, pont úgy, mintha közvetlenül konzolba gépeltük volna őket. Ezeknek szöveges állományoknak két fajtáját ismerjük meg ebben könyvben: parancsállományokat és az RMarkdown állományokat (??. fejezetben az RMarkdown állományokról többet olvashatunk).parancsállományok és az RMarkdown állományok létrehozásához legtöbb segítséget az RStudio nyújtja: parancsok begépelését drámaian leegyszerűsíti, és egyben számos más kényelmi funkciót ajánl. Hová írjuk tehát az R parancsainkat? legjobb válasz erre kérdésre: az RStudio parancsállományaiba vagy RMarkdown állományaiba. Mielőtt valóban elvégeznénk ezen állományok létrehozását, ismerkedjünk meg az RStudio lehetőségeivel!","code":"\ninstall.packages(\"dplyr\")      # a dplyr csomag telepítése\ninstall.packages(\"psych\")      # a psych csomag telepítése\ndata(starwars, package=\"dplyr\")  # adatbázis beolvasása csomagból\n# testmagasság átlagok fajonként\npsych::describeBy(starwars$height, starwars$species, fast=T, mat=T)"},{"path":"munka-az-r-ben.html","id":"az-rstudio-jellemzői","chapter":"4 Munka az R-ben","heading":"4.1.1 Az RStudio jellemzői","text":"Fontos tisztázni, az RStudio használatához feltétlenül szükség van telepített Alap R-re, nélküle nem tudunk R parancsokat futtatni. Jó gyakorlat, ha az RStudio telepítése előtt telepítjük fel az Alap R-t, de fordított sorrend sem okoz problémát. Sőt, ha az Alap R egy új verzióját telepítjük fel, akkor korábban telepített RStudio már az új verziójú R futtató környezetét fogja használni. Az RStudio tudása tehát végrehajtható R parancsok tekintetében megegyezik az Alap R tudásával, hiszen minden utasítás, amelynek végrehajtását az RStudio-ban kezdeményezzük, végső soron az Alap R-rel telepített interpreterhez kerül, és végrehajtásáért ő felel (4.1. ábra).\nÁBRA 4.1: Az R kényelmes használata\nAz RStudio elsősorban parancsok írását könnyíti meg, segítségével parancsok létrehozásához kapunk rendkívüli segítséget. Megjegyezzük, hogy az RStudio egy üzleti vállalkozás neve egyben, amely többféle terméket fejleszt. Ezek egyike az RStudio-nak nevezett integrált fejlesztőkörnyezet, kimondottan az R programozási nyelv számára. Foglaljuk össze, hogy melyek az RStudio erősségei:Parancsok írásának könnyítése. Az R parancsok begépelését számos eszköz segíti, például kódkiegészítés, szintaxisnak megfelelő kódszínezés és tippek megjelenítése.Integrált környezetben, egy felületen látjuk munka során szükséges összes komponenst. Az adatelemzési munka nem merül ki parancsok begépelésében és végrehajtásában. Az R parancsokat jelentő forráskódon kívül kezelnünk kell az outputot, ami lehet szöveges és ábra jellegű , valamint el kell igazodnunk memóriában tárolt adatok között . Sokszor súgót meg kell jelenítenünk, és információval kell rendelkeznünk telepített csomagokról . Az RStudio nagy előnye, hogy mindezt egyetlen integrált felületen láthatjuk és ezen keresztül vezérelhetjük.Projektek használata. Az RStudio támogatja projektek használatát , amellyel az adott adatfeldolgozási folyamat összetevőit – az adatállományokat, parancsállományokat, RMarkdown állományokat, képállományokat és dokumentációkat –, egyetlen könyvtárba foghatjuk össze, és forráskódból relatívan hivatkozhatunk ezekre az állományokra.Publikálás támogatása. Az RMarkdown segítségével kényelmesen és reprodukálható módon hozhatunk létre például PDF, HTML és Word formanyelvű dokumentumokat, vagy PDF, HTML és PowerPoint bemutatókat.További lehetőségek. Az RStudio támogatja Shiny Webes alkalmazások fejlesztését, de saját csomagok létrehozásához kapunk segítséget. Az RStudio támogatja Git verziókezelő használatát .Az RStudio fenti lehetőségeinek bemutatása külön könyvet igényelne, de mindennapi munkához szükséges ismereteket bemutatjuk.","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-felepitese","chapter":"4 Munka az R-ben","heading":"4.1.2 Az RStudio felépítése","text":"Az RStudio indítása után egy több panelból álló alkalmazást látunk. Első indításnál három részre van osztva az alkalmazás, vagyis három panel látható, de tipikus használat során négy panelünk van. Válasszuk ki először File / New file / New R Script menüpontot, amely egy új parancsállomány létrehozását kezdeményezi. E lépés után már biztosan négy-paneles, 4.2. ábrán látható elrendezést kapjuk. Az ábrán megneveztük az egyes részeket, két bal oldali panel Forrás és Konzol, jobb oldaliak Környezet és az Ábra. Figyeljük meg, hogy panelek tetején fülek láthatók, így az egyes paneleken különböző lapokat tudunk kiválasztani, egy panel tehát több lapot tartalmazhat. panelek szélessége és magassága állítható, egyrészt az elválasztó sávokat az egér segítségével mozgathatjuk, másrészt panelek méretező gombjain (az egyes panelek jobb felső sarkában) kattinthatunk. méretezés során eltűnhetnek panelek, de sávok mozgatásával vagy View / Panes / Show Panes menüponttal láthatóvá tehetjük az összes panelt.\nÁBRA 4.2: Az RStudio tipikus képernyőképe\nlegtöbb időt Forrás nevű bal felső panelben töltjük, mert alapértelmezetten itt jelennek meg parancsállományok és az RMarkdown állományok lapjai. Az R parancsainkat tehát ide írjuk. Az RStudio első indításánál ez panel üres, de további indításoknál korábban szerkesztett, de nem zárt lapok automatikusan megnyílnak. Itt helyeztünk el korábban egy parancsállomány lapot File / New file / New R Script segítségével. Ez lap egy egyszerű szövegszerkesztő. Győződjünk meg erről, próbáljuk ki, mert jövőben ebben szövegszerkesztőben töltjük legtöbb időt! fejezet végi kitűzött feladatok között rákérdezünk szövegszerkesztési ismeretekre. Oldjuk meg azt feladatot, majd térjünk vissza ide!bal alsó panel Konzol nevet viseli, vagyis ez az RStudio konzolja, melynek használata és célja megegyezik az Alap R konzoljával. Vagyis begépelhetünk parancsokat, és az ENTER-rel végrehajtjuk őket. Azonban konzol mindössze egysoros szövegszerkesztési lehetőséget kínál, lényegében egyszerre egy parancs begépelésére és végrehajtására van lehetőségünk. Ez lényegesen eltér Forrás panel parancsállomány vagy RMarkdown lapján lévő teljes értékű szövegszerkesztőtől, ahol több sor begépelésére és végrehajtására van lehetőségünk. konzol azonban mégis központi szerepet kap, mert alapesetben az R csak konzolba kerülő parancsokat tudja végrehajtani. parancsállományok és RMarkdown állományok R parancsait valahogyan át kell ide irányítani, úgy mintha ide gépeltük volna őket. De konzol nem csak parancsainkat, azaz az inputot, hanem azok eredményét, az outputot tartalmazza.két jobb oldali panel többfunkciós. jobb felső, Környezet panelben jelennek meg munka során létrehozott objektumok nevei (Environment lap), valamint parancsok története (History lap). Az Environment lapon megjelenő adatbázis nevén kattintva Forrás panelben egy külön lapon megjelenik az adatbázis tartalma, így kapjuk az ún. adatbázis lapot. jobb alsó Ábra panel tartalmazza súgót (Help lap), munka során rajzolt ábráinkat (Plot lap), csomagjaink listáját (Packages lap) és munkakönyvtárunk állományait, könyvtárait (Files lap). két jobb oldali panel elnevezés önkényes volt, hiszen az Environment és Plot csak egy-egy lap neve ezeken többfunkciós paneleken.","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-beállításai","chapter":"4 Munka az R-ben","heading":"4.1.3 Az RStudio beállításai","text":"Mielőtt elkezdjük munkát az RStudio-ban feltétlenül módosítsunk néhány alapbeállítást. Az RStudio működését az Tools / Global Options menüpont alatt változtathatjuk meg.UTF-8 kódolás beállítása. fenti menüpont kiválasztása után bal oldali listából Code, majd fenti opciók közül Saving opciót válasszuk. 4.3. ábrán látható módon, érjük el, hogy Default text encoding alatt az UTF-8 legyen kiválasztva. Fontos, hogy minden szöveges állományunk UTF-8 kódolású legyen.\nÁBRA 4.3: Az UTF-8 beállítása az RStudio-ban\nmunkaterület automatikus mentésének tiltása. bal oldalon General menüpont kiválasztása után Basic opció alatt vegyük ki pipát Restore .RData workspace startup elől, valamint Save workspace .RData exit választót állítsuk Never-re (4.4. ábra). Az RStudio projekt szemléletű használata mellett erre mentési funkcióra nincs szükség.\nÁBRA 4.4: munkaterület automatikus mentésének tiltása az RStudio-ban\nAz output megjelenítésének tiltása az RMarkdown lapon. bal oldalon az RMarkdown menüpont kiválasztása után vegyük ki pipát Show output inline R Markdown documents elől (4.5. ábra). Ez beállítás gördülékenyebb szerkesztést biztosít az RMarkdown lapokon.\nÁBRA 4.5: Az output megjelenítésének tiltása az RMarkdown lapon\nOpcionális lehetőségként panelek tartalmán változtathatunk Tools / Global Options / Pane Layout menüpontban. Az RStudio színösszeállításán az Appearance menüpont Editor theme beállításával változtathatunk. Javasolt Tomorrow Night Bright vagy más, sötétebb háttérszínnel rendelkező téma használata.","code":""},{"path":"munka-az-r-ben.html","id":"az-rstudio-konzol","chapter":"4 Munka az R-ben","heading":"4.1.4 Az RStudio konzol","text":"Az RStudio konzolja Konzol panel egyik lapján található (4.2. ábra). konzol az RStudio kulcsfontosságú része, korábban láttuk, hogy minden R parancsot végrehajtás előtt ide kell irányítani. Végrehajtása után szöveges eredmények itt jelennek meg, és hibaüzeneteket itt olvashatjuk. Láthatjuk tehát, hogy konzol figyelmünk középpontjában áll munka során.Közvetlenül azonban nagyon ritkán gépelünk parancsot konzolba, erre Forrás panel parancsállomány vagy RMarkdown lapját fogjuk használni. Ebben részben mégis konzolt mutatjuk , ugyanis meghatározó szerepe miatt értenünk kell működését.konzol működése nagyon egyszerű:egysoros parancsokat gépelünk > prompt után,ENTER-t nyomunk,az R interpreter értelmezi és végrehajtja begépelt parancsot, ésmegjelenik az eredmény vagy egy hibaüzenet.Ezt követően egy újabb sor begépelésére van lehetőségünk, ENTER után annak az értelmezése következhet, majd az eredmény megjelenítése jön, és így tovább.Próbáljuk ki mi konzolt! Bátran gépeljünk parancsokat. Például citation() parancs outputja fontos lehet az R-el végzett munkáink publikálásánál, hiszen megmutatja hogyan hivatkozhatunk az R statisztikai programra, vagy valamelyik csomagjára.Fontos információ az Alap R és az RStudio pontos verziószáma, ezt információt az R.Version() és RStudio.Version() függvény szolgáltatja. Gépelésnél vigyázzunk kis- és nagybetűk helyes bevitelére, mert az R megkülönbözteti ezeket.konzol lehetőségeinek szisztematikus megismerését folytassuk egy egyszerű paranccsal:konzolban megjelent az eredmény, ahogy ezt az összes eddigi parancsunk esetében láthattuk. Azonban nem minden parancs után jelenik meg output konzolban. Például következő parancsnak nincs eredménysora konzolban, de ez messze nem jelenti azt, hogy nem történt semmi (történt: létrehoztunk egy objektumot).Sőt, az előfordulhat, hogy az R nem talált valamit rendben parancsban. Ekkor természetesen nem hajtja/hajthatja végre begépelt sort, helyette hibát jelez.válasz fenti “parancsra” az Error: unexpected symbol \"Ez nem\" hibaüzenet lesz. Alapvető szabály, ha válaszban megjelenik az Error szócska, akkor parancsunkat valamilyen ok miatt nem tudta végrehajtani az R értelmező, és az Error utáni részből tájékozódhatunk hiba okáról. Minden más esetben sikeres volt végrehajtás.Hosszabb, bonyolult parancsok gépelésénél gyakran előfordul, hogy valamiért nem sikerül “teljessé” tenni begépelt parancsot, valami még hiányzik belőle (például egy záró kerek zárójel). Ezt az R értelmező észreveszi és az ENTER megnyomása után egy + folytatás prompt megjelenítésével jelzi ezt számunkra. + prompt után van lehetőségünk hiányzó részek pótlására, majd ha készen vagyunk az ENTER billentyűvel az összes eddig még végre nem hajtott sort elküldhetjük az értelmezőnek.Gépeljük következő parancsot, három egymás utáni sorba, ENTER-ekkel elválasztva.paste(\"Ez már\", kerüljön az első sorba, majd nyomjunk ENTER-t. Az R nem hajtja végre sort, de erre nyilvánvalóan hibás, befejezetlen parancsra hibaüzenetet sem jelenít meg. Helyette felajánlja parancs folytatását, befejezését egy új sorban, amely már + prompttal kezdődik. második sorba gépeljük az \"jó\" karaktersorozatot, nyomjuk meg az ENTER-t. Sajnos még ez sem tette teljessé parancsunkat, így további folytatásra van lehetőségünk + után harmadik sorban. Ide gépeljük hiányzó ) részt, és üssünk ENTER-t. parancsunk teljessé vált, megkapjuk az eredményt konzolban, pontosan úgy, mintha három sort egyetlen sorba gépeltük volna.Legyünk nagyon óvatosak konzol folytatás prompt funkciójával. Ha például az R nem találja parancs hiányzó részét, akkor konzol ezen kényelmi funkciója oda vezethet, hogy folyamatosan + promptot kapjuk az ENTER megnyomása után. Ezt helyzetet hivatott megoldani az ESC billentyű, mellyel megszakíthatjuk az értelmező parancsfeldolgozási kísérletét. Az ESC megnyomása után visszakapjuk > prompttal kezdődő (üres) sort, vagyis tiszta lappal, új, lehetőség szerint teljes parancs gépelésébe kezdhetünk. parancssorba mindig teljes parancsot gépeljünk, amint megjelenik + folytatás prompt, azonnal szakítsuk meg az ESC megnyomásával az értelmezési folyamatot.Az R konzolos használatát két funkció valóban kényelmesebbé teszi. Egyrészt korábban végrehajtott parancsainkat visszahívhatjuk, lapozhatunk bennük előre, hátra. Erre FEL/LE NYÍL billentyűkkel van lehetőségünk. Ezt history-nak nevezzük, vagyis parancsok történetének. Természetesen, az így visszahívott parancsot tetszőleges módon átszerkeszthetjük: navigálhatunk sorban előre hátra, beszúrhatunk/törölhetünk karaktereket vagy használhatjuk vágóasztal billentyűparancsait. visszahívott és módosított parancsot az ENTER segítségével újra végrehajthatjuk, és ehhez még sor végére sem kell szövegkurzort pozicionálni, az sorban tetszőleges helyen állhat, az R mégis teljes sort fogja értelmezni.másik kényelmi lehetőség TAB billentyű használata, amellyel az elkezdett, de még nem fejezett sorokat egészíthetjük ki. Ha egy sort többféleképpen kiegészíthet az R, akkor egy listát kapunk lehetőségekről, amelyet továbbgépeléssel szűkíthetünk, ha pedig csak egyetlen szóba jöhető befejezése van begépelt karaktereknek, akkor TAB megnyomása után ezzel résszel kiegészül az elkezdett sorunk. Így nemcsak egyszerűen gépelést, illetve időt takaríthatunk meg, hanem például tájékozódhatunk korábban létrehozott objektumok nevéről vagy az elérhető függvények névéről és paramétereiről .Az objektum, függvények és az egyéb ebben fejezetben homályosan hagyott fogalmak definícióit könyv későbbi részeiben részletesen tárgyaljuk.","code":"> citation()\n> citation(package = \"ggplot2\")> R.Version()       \n> RStudio.Version()> 1+2\n[1] 3> x <- 3> Ez nem lesz jó.> paste(\"Ez már\",\n+        \"jó\"\n+       )\n[1] \"Ez már jó\""},{"path":"munka-az-r-ben.html","id":"parancsallomanyok","chapter":"4 Munka az R-ben","heading":"4.1.5 Parancsállományok","text":"Láthattuk, hogy konzolba egyszerre csak egy parancsot gépelhetünk , úgy gondolhatunk konzolra, mint egy egysoros szövegszerkesztőre. Begépelünk egy sort és végrehajtjuk az ENTER-rel. problémáink többsége viszont nem oldható meg egyetlen paranccsal, csak több tízzel vagy százzal, ezért ez az interaktív, konzolos használat nem alkalmas hosszabb elemzésre.Parancsainkat begépelhetjük egy .R kiterjesztésű, egyszerű, formázás nélküli szöveges állományba . Az ilyen szöveges állományt parancsállománynak vagy szkriptállománynak nevezzük. Ilyen szöveges állományok létrehozására tetszőleges szövegszerkesztő alkalmas, de természetesen mi az RStudio segítségével fogjuk ezeket elkészíteni, ugyanis itt kapjuk legnagyobb segítséget parancsok gépeléséhez, majd végrehajtásához. Forrás panel tartalmazza parancsállomány lapokat, létrehozásuk korábban látott File / New file / New R Script menüponttal történik. Parancsállományok mentésére és már létező megnyitására van lehetőségünk megfelelő menüpont kiválasztásával (File / Save és File / Open File).parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, hiszen konzol egysoros szövegszerkesztője helyett egy szinte végtelen sok parancssor begépelésére alkalmas szövegszerkesztő áll rendelkezésünkre. Mint minden szövegszerkesztőben, különböző billentyűparancsok és vágóasztal itt megkönnyíti szerkesztés folyamatát. Az ENTER jelentése parancsállományos környezetben szövegszerkesztőkben megszokott újsor beszúrása, ami lényegesen különbözik konzolos használat parancs végrehajtási funkciójától. parancsaink interaktív végrehajtásáért az RStudio-ban Code/Run selected line(s) menüpont, vagy még gyakrabban Ctrl+Enter billentyűkombináció felel. Ezekkel módszerekkel tudjuk parancsainkat konzolba irányítani és végrehajtani. De nézzük meg ezt gyakorlatban!","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-rstudio-ban","chapter":"4 Munka az R-ben","heading":"4.1.6 Munka az RStudio-ban","text":"Kezdjük munkát! Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljünk néhány sort. Figyeljük meg, hogy milyen sokat segít az RStudio lenti sorok begépelésében. Az értékadás (<-) operátort az Alt+- billentyűkombináció segítségével vigyük .szövegkurzorral álljunk az első sorra, és hajtsuk végre Ctrl+Enter billentyűparancsot. Láthatjuk, hogy (1) sor átkerül konzolba, (2) az RStudio végrehajtja sort és az eredményt konzolban megjeleníti, és (3) szövegkurzor lejjebb lép következő végrehajtható sorra. Egy újabb Ctrl+Enter így már ezt sort hatja végre, és így tovább. Ha sorok végrehajtása közben hibaüzenetet kapunk (Error), ne essünk kétségbe, hibaüzenet munka része. Nézzük át figyelmesen begépelt sorainkat, javítsuk őket, és futtassuk újra az összes sort, fentről lefelé Ctrl+Enter-ek segítségével.parancsok végrehajtása során láthatjuk mennyire kényelmes, integrált környezetben találtuk magunkat. Az x <- mean(1:100) hatására az Environment lapon megjelent az x objektum neve és értéke. Plot lapon láthatunk egy ábrát, amit plot(1:10) rajzolt meg, és ?mean Help lapon mutatja meg mean() átlagszámoló függvény beépített súgóját.Mentsük el parancsállományunkat File / Save vagy Ctrl+S segítségével. Korábban létrehozott parancsállományokat File / Open menüponttal nyithatunk meg.soronkénti végrehajtás mellett nagyon gyakori kijelölt szövegrészek végrehajtása, amit szintén Ctrl+Enter-rel tudunk kezdeményezni. kijelölt rész lehet több sor, teljes parancsállomány, vagy valamelyik sor egy része. Ez utóbbi próbáljuk ki úgy, hogy parancsállomány első sorában csak az 1+2 részt jelöljük ki, és ezt hajtsuk végre Ctrl+Enter segítségével. Az eredmény konzolban 3 lesz. teljes szkriptállomány végrehajtásához jelöljük ki Ctrl+segítségével parancsállomány összes sorát, és nyomjuk meg Ctrl+Enter-t. konzolban tudjuk ellenőrizni, hogy minden sort újra végrehajtottunk.Térjünk vissza kiinduló adatelemzési problémánk megoldásához. Láttuk, hogy az R parancsok összegyűjtésére és végrehajtására .R kiterjesztésű parancsállományok kiváló megoldást nyújtanak. Emlékezzünk vissza fejezet eleji példára, amelyben Csillagok háborúja c. film karaktereinek átlagos testmagasságát kerestük. Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljük megoldást jelentő sorokat.Látható, hogy feladat tényleges megoldását jelentő két R parancs mellett megjegyzéseket becsempésztünk, hogy később tudjuk, ki, mikor és miért készítette ezt parancsállományt (# utáni részeket sor végéig az R figyelmen kívül hagyja; részletesebb információkat megjegyzésekről 5.1.3. fejezetben olvashatunk). Futtassuk sorokat Ctrl+Enter segítségével, fussuk át kiszámolt átlagos testmagasságokat az output mean oszlopában, majd mentsük el szkriptállományt Ctrl+S-sel starwars.R néven. Később, napok, hetek vagy hónapok múlva, újra megnyithatjuk starwars.R állományunkat (File / Open), és újra lefuttathatjuk mini-elemzésünket. Ezzel fejezet eleji adatelemzési feladatunkat megoldottuk. Vajon lehet ezt ennél jobban csinálni? Igen!","code":"\n1+23\ngetwd()          # munkakönyvtár kiírása\nx <- mean(1:100)\nplot(1:10)\n?mean\ncat(\"- Vége -\\n\")\n# A Csillagok háborúja c. film karaktereinek átlagos testmagassága\n# Abari Kálmán\n# 2022. 07. 06.\n\n# install.packages(\"dplyr\")      # a dplyr csomag telepítése\n# install.packages(\"psych\")      # a psych csomag telepítése\ndata(starwars, package=\"dplyr\")  # adatbázis beolvasása csomagból\n# testmagasság átlagok fajonként\npsych::describeBy(starwars$height, starwars$species, fast=T, mat=T)"},{"path":"munka-az-r-ben.html","id":"rmarkdown-allomanyok","chapter":"4 Munka az R-ben","heading":"4.1.7 RMarkdown állományok","text":"Az R parancsainkat olyan .Rmd kiterjesztésű, egyszerű, szöveges állományokban összegyűjthetjük, amelyek többet nyújtanak, mint parancsállományok, de szerkezetük kicsit kötöttebb. Az ilyen szöveges állományok az RMarkdown állományok. Miben nyújtanak többet: ahogyan ??. fejezetben részletesen áttekintjük, az RMarkdown állományok az eredmények publikálásához, például HTML, PDF vagy Word formanyelvű állományok létrehozását teszik lehetővé.Hozzunk létre az RStudio-ban File / New File / R Markdown menüponttal egy új RMarkdown állományt. megjelenő dialógusdobozban töltsük ki Title és Author mezőket, azaz adjunk címet és szerzőt dokumentumhoz, majd kattintsunk az OK gombon. Forrás panelen megjelenik egy új RMarkdown lap, amely egy alapértelmezett tartalommal jön létre, és nem üresen, mint parancsállományok esetében. Említettük, hogy az RMarkdown állományok szerkezete kötöttebb, ez az alapértelmezett tartalom az eligazodásban segít minket. Érjük el, hogy az új RMarkdown ezeket sorokat tartalmazza (szerző neve sajátunk legyen):Minden RMarkdown állomány egy fejléccel kezdődik, amelyet --- karakterek határolnak. természetes nyelvű szöveget szabadon fejléc alatti részben bárhová írhatjuk, az R parancsokat azonban ún. R csonkokban kell elhelyeznünk, amelyeket speciális kezdő és záró sorok határolnak. ??. fejezetben részletesebben olvashatunk ezekről. elégedjünk meg annyival, hogy egy RMarkdown állományban tetszőlegesen sok R csonkot elhelyezhetünk, és egy R csonk tetszőlegesen sok R parancsot tartalmazhat. Egy R csonkon belül parancsok végrehajtása ugyanúgy Ctrl+Enter-rel történik, mint parancsállományok esetében. Próbáljuk ki! begépelt RMarkdown állományunk második csonkjában lévő két R parancsot hajtsuk végre két Ctrl+Enter segítségével. mini-elemzés eredménye ismét konzolban látható.Hogyan foglalhatnánk össze parancsállományok és az RMarkdown állományok közötti különbséget? 4.1. táblázatban láthatjuk, hogy mindkét állományban összesen három különböző tartalmat szoktunk rögzíteni:fejléc információt arról, hogy mi az elemzés célja, ki és mikor készítette az állományt,magyarázó, természetes nyelvű szöveget (pl. magyar vagy angol nyelven), ésaz adatelemző R parancsokat.Az R parancsokat szabadon írhatjuk parancsállományokba, viszont fejléc információt és magyarázó szövegeket megjegyzésbe kell tenni. Az RMarkdown állományokba magyarázó, természetes nyelvű szövegek írhatók szabadon, míg az R parancsokat csonkokba, fejléc információt pedig kötött módon, az állomány elejére kell írnunk.TÁBLÁZAT 4.1:  parancsállomány és az RMarkdown állomány összehasonlításaValóban annyiban áll különbség két állománytípus között, hogy máshová és máshogyan írjuk az R parancsokat és az egyéb magyarázó/fejléc szövegeinket? Nem. ??. fejezetben részletesen bemutatjuk, hogy az RMardown állományok ereje abban van, hogy egy fordítási folyamat (knit-elés) során, olyan PDF, HTML vagy Word állományt tudunk előállítani, amely magyarázó/fejléc szövegeken, és az R parancsokon kívül, az R parancsok outputját tartalmazza, legyen az szöveges vagy ábra jellegű output.","code":"---\ntitle: \"A Csillagok háborúja c. film karaktereinek átlagos testmagassága\"\nauthor: \"Abari Kálmán\"\ndate: '2022. 07. 06.'\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\nAdatok beolvasása és az átlagok kiírása\n\n```{r}\n# install.packages(\"dplyr\")      # a dplyr csomag telepítése\n# install.packages(\"psych\")      # a psych csomag telepítése\ndata(starwars, package=\"dplyr\")  # adatbázis beolvasása csomagból\n# testmagasság átlagok fajonként\npsych::describeBy(starwars$height, starwars$species, fast=T, mat=T)\n```"},{"path":"munka-az-r-ben.html","id":"projektek-hasznalata","chapter":"4 Munka az R-ben","heading":"4.1.8 Projektek használata","text":"Mostanra nagyon közel kerültünk az általunk ajánlott adatelemzési munkaformához, ugyanis már tudunk az RStudio-n belül parancsállományokat és RMarkdown állományokat használni. Még egy összetevő azonban kulcsfontosságú kényelmes munkához: az RStudio-ban minden esetben projektet kell használnunk.Az RStudio lehetőséget ad arra, hogy minden egyes adatfeldolgozási feladatunkhoz egy projektet rendeljünk. Egy RStudio projekt minimálisan egy projekt könyvtárat és az ebben lévő lévő .Rproj kiterjesztésű projektállományt jelenti. Ezeket következő módszerrel hozhatjuk létre. Először kattintsunk File / New Project menüponton. Válasszuk ki New Directory opciót (4.6. ábra), majd New Project nyomógombon kattintsunk (4.7. ábra).\nÁBRA 4.6: RStudio projekt létrehozása: 1. lépés\nDirectory name szöveges mezőbe projektünk nevét határozhatjuk meg, ami egyben az új projektünk könyvtárneve lesz. Adjuk meg itt az elso_projekt nevet. Create project subdirectory mezőben azt szülő könyvtárat határozhatjuk meg, ahová projekt könyvtárunkat el szeretnénk helyezni. Ezt szabadon megválaszthatjuk, lehet az adott felhasználó dokumentumok könyvtára . projekt létrehozását Create Project nyomógombbal fejezhetjük .\nÁBRA 4.7: RStudio projekt létrehozása: 2. lépés\nKét nagyon fontos dolog történt fentiek hatására. Egyrészt számítógépünkön létrejött az elso_projekt projektkönyvtár, és benne az elso_projekt.Rproj projektállomány, másrészt az RStudio ún. projekt üzemmódba került, azaz az elso_projekt lesz az aktív projekt. Az RStudio-ban egyszerre egy projekt lehet aktív, de elképzelhető, hogy egyetlen projekt sem aktív. Az RStudio felületén jobb felső sarokban tájékozódhatunk, ahol az elso_project feliratot látjuk, de amennyiben nincs aktív projektünk, akkor Project: (none) feliratot olvashatjuk. Kerüljük projekt nélküli állapotot.\nÁBRA 4.8: RStudio projekt létrehozása: 3. lépés\nMinden adatfeldolgozási feladathoz – még legkisebbhez – hozzunk létre projektet. Minden állományt, amely feladathoz tartozik projektkönyvtáron belül helyezzünk el. Milyen állományok jöhetnek szóba: például parancsállományok, RMarkdown állományok, adatállományok, képállományok, dokumentációk és hivatkozásokat tartalmazó állományok. Érdemes ezeket rendezetten, ha szükséges, alkönyvtárakba szétosztva tárolni. Jó gyakorlat lehet, hogy parancsállományokat és az RMarkdown állományokat közvetlenül projektkönyvtárban (ez az elso_projekt), az adatállományokat egy adat alkönyvtárban projektkönyvtáron belül (elso_projekt/adat) tároljuk, képállományok és dokumentációk helye pedig lehet az elso_project/kep, illetve elso_projekt/doku alkönyvtár.Válthatunk egy másik projektre (File / Open Project), de zárhatjuk az aktív projektet (File / Close project). Később újra megnyithatjuk ezt File / Open Project segítségével. megnyitás során természetesen az .Rproj kiterjesztésű projektállományt kell kiválasztanunk.Ritkábban az előfordulhat, hogy az adatfeldolgozási folyamatunkkal kapcsolatos állományok összegyűjtését korábban elkezdtük, és csak később szeretnénk ezt könyvtárat egyben RStudio projektkönyvtárként felhasználni.\nÁBRA 4.9: RStudio projekt létrehozása: létező könyvtár megadása\nKorábban létrehozott könyvtárból szintén File / New Project menüpont segítségével hozhatunk létre RSudio projektkönyvtárat. Itt azonban az Existing Directory opciót kell kiválasztani (4.6. ábra). Ezt követően ennek létező könyvtárnak az elérési útját kell megadnunk az 4.9. ábrán látható beviteli mezőben.Végül foglaljuk össze, milyen előnyökkel jár projekt használata:logikailag egy adatfeldolgozási folyamathoz tartozó állományainkat fizikailag együtt tudjuk tartani.Projekt üzemmódban az RStudio az aktuális könyvtárat projektkönyvtárra állítja, így relatív hivatkozást használhatunk kódunkban, amely projekt hordozhatóságát biztosítja különböző számítógépek között.","code":""},{"path":"munka-az-r-ben.html","id":"billenytűparancsok","chapter":"4 Munka az R-ben","heading":"4.1.9 Billenytűparancsok","text":"Az RStudio legfontosabb billentyűparancsa Ctrl+Enter, amely parancsot konzolba küldi végrehajtásra. Van még néhány további billentyűparancs, amelyet érdemes felsorolni, hiszen ezek használatával gyorsítani, egyszerűsíteni tudjuk munkánkat.Ctrl+Shift+N: új parancsállomány létrehozása,Ctrl+S: állomány mentése,Ctrl+W: lap bezárása Forrás panelen,Ctrl+Tab / Ctrl+Shift+Tab: aktív lap léptetése előre és hátra Forrás panelen,Ctrl+F: szöveg keresése és cseréje,Tab: kód kiegészítése,Ctrl+Shift+C: kijelölt sorok - vagy kikommentelése,Ctrl+Alt+Fel / Le (és Shift+Jobbra / Balra): kurzor magasságának állítása (és az oszlopszélesség beállítása) több sor szerkesztésére,Esc: Konzol panelen kilépés folytatás promptból, Forrás panelen kilépés többsoros szerkesztésből,Alt+Fel / Le: sor mozgatása fel vagy le,Alt+Shift+K: billentyűparancsok módosítása,Alt+-: értékadó operátor (<-) beszúrása,Ctrl+Shift+M: pipe operátor (%>%) beszúrása,Ctrl+Enter: az aktuális sor vagy kijelölt rész futtatása,Ctrl+Alt+R: teljes parancsállomány futtatása,Ctrl+Shift+P: kurzor feletti csonkok parancsainak futtatása,Ctrl++ / Ctrl+-: betűméret nagyítása vagy kicsinyítése,Ctrl+Shift+F10: munkamenet újraindítása.Ha valamelyik kombináció nem működik számítógépünkön, akkor Tools / Modify Keyboard Shortcuts menüpont alatt új billentyűparancsot adhatunk az ott felsorolt funkciókhoz.","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-1-summary","chapter":"4 Munka az R-ben","heading":"4.1.10 Összefoglalás","text":"\nAz adatelemzési munka során az RStudio -t használjuk projekt\nüzemmódban, miközben RMarkdown állományba gyűjtjük az elemző R\nparancsokat és az egyéb magyarázó és fejléc szövegeket. Ebben \nfejezetben ezt tételmondatot töltöttük meg tartalommal. Megismertük az\nRStudio integrált környezetét. Forrás panel\nlehetséges lapjai parancsállomány, az RMarkdown állomány és az\nadatbázis. Konzol panel legfontosabb lapja konzol,\namely központi szerepet játszik munka során, hiszen \nCtrl+Enter-rel végrehajtott R parancsok eredménye és az\nesetleges hibaüzenetek itt jelennek meg. munka során \n.R kiterjesztésű parancsállományok kiválóan alkalmasak \nhosszabb elemzések R parancsainak tárolására, de ha publikáláshoz \nsegítséget szeretnénk kapni, akkor inkább kötöttebb szerkezetű\n.Rmd kiterjesztésű RMarkdown állományba rögzítsük\nparancsainkat. Az RStudio rutinszerű használatához \nbillentyűparancsok ismerete hozzátartozik. projektszemlélet az\nadatelemzéssel kapcsolatos állományok egyben tartásáról, és \nhordozhatóság biztosításáról szól.\n","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-1-exercise","chapter":"4 Munka az R-ben","heading":"4.1.11 Feladatok","text":"Bizonyosudjunk meg róla, hogy az alapvető szövegszerkesztési ismeretek birtokában vagyunk. Ismerjük az Insert billentyű funkcióját? Találjunk legalább 8 módszert, amely kizárólag billentyű segítségével mozgatja szövegkurzort! szövegkijelölésnek milyen billentyűparancsait ismerjük? Milyen karaktertörlési lehetőségeket ismerünk? Ismerjük mindhárom vágóasztal-művelet billentyűparancsát?Az RStudio mellett milyen más intergrált fejlesztőeszközök léteznek az R-hez?Az Appearance menüpont Editor theme beállításával változtassunk az RStudio színösszeállításán. Keressük meg legjobban hozzánk illőt! Vegyük figyelembe, hogy hosszútávon minél sötétebb háttér jó választás.fenti feladatok megoldása","code":""},{"path":"munka-az-r-ben.html","id":"segítség-az-r-használatához","chapter":"4 Munka az R-ben","heading":"4.2 Segítség az R használatához","text":"\nEbben fejezetben:\n\nmegismerjük az R hivatalos dokumentációit,\n\naz ún. cheet-sheet-ek forrását,\n\nés parancssorból elérhető súgó parancsokat.\nAz R használatához számos segítséget találunk az Interneten, telepített Alap R-ben és az RStudio-ban egyaránt. Az online segítségek közül elsősorban http://cran.r-project.org címen olvasható R dokumentációkat emeljük ki, ahol több tucat, elsősorban angol nyelvű leírást találunk az R megismeréséhez. bal oldali Documentation / Manuals menüpont alatt találjuk például az R hivatalos bevezető dokumentumát (Introduction R), melynek tanulmányozása rendkívül nagy lépést jelenthet az R alaptudás megszerzéséhez. Az említett menüpont alatt találjuk még contributed documentation linket , amely számos rövidebb, és hosszabb dokumentációt tartalmaz, angol és más nyelveken. Itt találjuk Solymosi Norbert nagyszerű magyar nyelvű R bevezetőjét .Az R népszerűségének köszönhetően, nagyon sok további dokumentációt, tutoriált és példát találhatunk, ha az internetes keresőkhöz fordulunk. fejezet végi egyik kitűzött feladatban összeállíthatjuk saját listánkat.Rendkívül népszerűek ma az ún. cheat-sheet-ek, amelyek néhány PDF oldalon sok ábrával, és lényeg kiemelésével mutatják egy-egy témakör legfontosabb tudnivalóit. Az RStudio Help / Cheetsheets menüjéből, vagy közvetlenül https://www.rstudio.com/resources/cheatsheets/ címről számos R téma cheet-sheet-jét érhetjük el.tekintsük át azokat súgókat, amelyek az R parancssorából indíthatók. Az R megismerését kezdhetjük aparanccsal, ahol számos, az R nyelvet részletesen tárgyaló dokumentum közül választhatunk.Ha csak egyetlen függvénnyel kapcsolatban szeretnénk segítséget kérni, akkor használhatjuk beépített súgórendszer parancsait. Adjuk ki avagy rövidebbparancsot, ha t.test() függvényről szeretnénk részletes leírását kapni. ?függvénynév lehetőség, minden függvény esetében rendelkezésre áll súgó kikérésére. Abban az esetben, ha nem ismerjük teljesen függvény nevét, használhatjuk aparancsot, ekkor az összes olyan függvényt kilistázhatjuk, amelynek nevében vagy leírásában test karaktersorozat előfordul.Hasznos lehet továbbá find() parancs, amely elárulja, hogy az illető függvény melyik már betöltött csomagban foglal helyet.fenti példából kiolvasható, hogy az aov() függvény stats csomagban található.Ugyancsak betöltött csomagokban végez keresést az apropos() függvény, amellyel lehetőség van parancssorból elérhető függvények vagy objektumok nevében keresni.Tovább segítheti az egyes függvények használatának elsajátítását az example() parancs, amely az egyes függvények használatára mutat példát.Utolsó lehetőségként ejtsünk szót demo() függvényről, amellyel olyan beépített szkripteket futtathatunk, amelyek az R tudását, erejét hivatottak demonstrálni. Próbáljuk ki következő parancsokat.","code":"\nhelp.start()\nhelp(t.test)\n ?t.test\nhelp.search(\"test\")\nfind(\"aov\")\n#> [1] \"package:stats\"\napropos(\"aov\")\n#> [1] \"aov\"         \"eff.aovlist\" \"summary.aov\"\nexample(t.test)\ndemo(graphics)\ndemo(persp)\ndemo(plotmath)\ndemo(Hershey)"},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-2-summary","chapter":"4 Munka az R-ben","heading":"4.2.1 Összefoglalás","text":"\nAz RStudio parancsok gépelését számos módon könnyíti meg,\nde ha egy függvényről részletesebb leírást szeretnénk olvasni, akkor \n?függvénynév parancsot használjuk. Egy-egy témakör gyors\nmegismeréséhez cheet-sheet-eket ajánljuk, amelyek az RStudio\nHelp / Cheetsheets menüjéből elérhetők. Az R hivatalos\nhonlapján hosszabb leírásokat találunk.\n","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-2-exercise","chapter":"4 Munka az R-ben","heading":"4.2.2 Feladatok","text":"Keressünk magyar nyelvű leírásokat az R-hez!közösségi médiában melyek az R legfontosabb fórumai?Hogyan indíthatjuk el egy csomag beépített súgóját? Ismerjük meg így fun csomagot!fenti feladatok megoldása","code":""},{"path":"munka-az-r-ben.html","id":"az-alap-r-használata","chapter":"4 Munka az R-ben","heading":"4.3 Az Alap R használata","text":"\nEbben fejezetben:\n\nmegtanuljuk az Alap R-ben konzol,\n\nés parancsállományok használatát,\n\naz R Commander kezelését,\n\nvalamint kötegelt feldolgozás módszereit.\nAmennyiben nagygépes környezetben dolgozunk, vagy valamilyen oknál fogva az RStudio-t nem tudjuk használni, akkor az Alap R lehet az egyetlen lehetőség R parancsok futtatására. Ebben az esetben sajnos le kell mondanunk parancsok kényelmes bevitelét és végrehajtását támogató interaktív eszközökről, de természetesen az R teljes ereje, összes függvénye továbbra rendelkezésünkre áll. Ebben részben az Alap R lehetőségeit tekintjük át.Az Alap R elindítása az adott platformon megfelelő bináris állomány futtatását jelenti.Windows operációs rendszerekben az R indítása többnyire az Asztalon lévő R ikon segítségével lehetséges. Ez az RGui.exe grafikus felhasználói felülettel rendelkező alkalmazást indítja, amelynek legfontosabb része külön ablakban (R Console) megjelenő konzol (4.10. ábra).MacOs környezetben indítsuk el az R.app alkalmazást, amely egyetlen konzolt tartalmaz.Linux környezetben az R parancssori futtatásával szintén egy konzolt kapunk.","code":""},{"path":"munka-az-r-ben.html","id":"az-rgui-konzol","chapter":"4 Munka az R-ben","heading":"4.3.1 A konzol használata","text":"konzol az Alap R környezet központi része mindegyik platformon. konzol működése lényegében megegyezik korábban megismert RStudio-s konzol működésével: egysoros parancsokat gépelünk prompt (>) után, ENTER-t nyomunk, majd az R interpreter értelmezi és végrehajtja begépelt parancsot, és megjelenik az eredmény. 4.10. ábrán Windows környezetben használható RGui alkalmazás látható, miután konzolba két parancsot gépeltünk és hajtottunk végre.\nÁBRA 4.10: RGui alkalmazás konzollal Windows környezetben\nAz RStudio konzoljának minden korábban említett alapfunkciója az Alap R konzoljában elérhető, tudjuk használni parancsok történetét, kódkiegészítést TAB billentyűvel, és folytatás prompt (+) megjelenik befejezetlen sorok esetén. Sőt Windows alatt futó RGui ismeri parancsállományokat , bár gépeléshez korántsem kapunk annyi támogatást mint az RStudio-ban.","code":""},{"path":"munka-az-r-ben.html","id":"parancsállományok-az-rgui-ban","chapter":"4 Munka az R-ben","heading":"4.3.2 Parancsállományok az RGui-ban","text":"Az RGui Windows-os Alap R része, és ahogyan láthattuk, egy nagyon egyszerű grafikus környezet, amelynek központjában konzol található (R Console ablak 4.10. ábrán). Az RGui nagyszerű tulajdonsága, hogy támogatja parancsállományok használatát. Az RGui-ban találunk menüpontokat (File/New script, File/Open script és File/Save), amelyekkel létrehozhatunk, megnyithatunk, és elmenthetünk parancsállományokat. Tudjuk, hogy parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, de fontos műveletként jelenik meg az átirányítás, amely szövegszerkesztőben összegyűjtött parancsokat vezeti át konzolba. Az RGui-ban ez Ctrl+R billentyűkombinációval lehetséges – ez gyakorlatilag az Rstudio-beli Ctrl+Enter –, de az Edit/Run line selection vagy az Edit/Run menüpontok rendelkezésre állnak. soronkénti végrehajtás mellett itt lehetőség van kijelölt szövegrészek végrehajtására, de több sort, teljes parancsállományt, vagy valamelyik sor egy részét elküldhetjük konzolba Ctrl+R segítségével.","code":""},{"path":"munka-az-r-ben.html","id":"r-commander","chapter":"4 Munka az R-ben","heading":"4.3.3 R Commander","text":"Eddig az R használatának két lényegesen eltérő módját mutattuk : konzolos használatot és parancsállományos használatot (az RMarkdown állományok használatát ez utóbbi csoportba sorolhatjuk). Láttuk, hogy konzol az RStudio és az Alap R központi része, de az RStudio és az RGui parancsállományos használatot támogatja. Mindegyik fenti használati mód parancsok gépelésével jár együtt.Azonban létezik egy harmadik, az eddigiektől lényegesen eltérő módja az R használatának. Parancsok gépelése nélkül, csupán egérkattintássokkal végezhetünk statisztikai elemzést. Az R erre alkalmas beépített eszközét R Commander-nek nevezik, de külső eszközök képesek az R parancssoros lényét elfedni előlünk. Ilyen külső eszköz például jamovi és JASP. Mindhárom felsorolt eszközben közös, hogy grafikus felhasználói felületen mozgunk, és egérkattintással, menüben való navigálással, vezérlőelemek (rádiógombok, jelölőnégyzetek, listák, nyomógombok, beviteli mezők) használatával magyarázzuk el kívánt tevékenységet.továbbiakban az R Commander lehetőségeit tekintjük át röviden. Az R Commander az Rcmdr nevű csomagban foglal helyet, így használatához ezt csomagot telepítenünk kell. Ezt követően library() függvény segítségével tudjuk elindítani az R Commander-t:Az indítás után egy külön R Commander ablak jelenik meg (4.11. ábra), melynek felépítése fentről lefelé következő: (1) gazdag menürendszer, (2) az eszköztár az aktuális adatbázis (Adattábla) mezővel és az Adattábla megtekintése gombokkal, (3) parancsállomány vagy RMarkdown lapok, (4) az output számára fenntartott szöveges mező, és (5) az üzenetek helye. Megjegyezzük, hogy 4.11. ábrán látható R Commander-t az Alap R-ből indítottuk. Amennyiben RStudio-ból adjuk ki library(Rcmdr) parancsot, akkor 4. és az 5. elem, azaz az output és az üzenetek rész nem lesz látható, mert az RStudio konzolja ezeket magába integrálja.\nÁBRA 4.11: Az R Commander induló ablaka\nkilépést az R Commander-ből File / Kilépés menüpont segítségével kezdeményezhetjük. Kilépés után az R Commander újraindításához következő parancsokat kell használnunk:Az R Commander lényegét legkönnyebben úgy tudjuk szemléltetni, ha egérkattintásokkal megoldjuk Csillagok háborúja c. filmmel kapcsolatos adatelemzési feladatunkat. Első lépésként telepítsük dplyr csomagot. Természetesen, ha már korábban telepítést bármilyen apropóból elvégeztük, akkor ezt nem kell megismételni, de teljesség kedvéért kezdjük azzal, hogyan tudunk interaktívan csomagot telepíteni az R Commander segítségével. Válasszuk ki Eszközök / Csomag telepítése menüpontot, ha szükséges válasszunk tükörszerverek közül, majd válasszuk ki megjelenő listából dplyr csomagot. Ezt követően töltsük dplyr csomagot az Eszközök / Csomag(ok) betöltése menüponttal. Keressük meg listában dplyr csomagnevet és kattintsunk az OK gombon. Ezt követően olvassuk starwars adatbázist dplyr csomagból, az Adatok / Csomagban lévő adatok / Adattábla beolvasása betöltött csomagból menüpont segítségével. Kattintsunk duplán dplyr csomagneven, majd jobb oldali listában szintén duplán starwars adatbázison, majd az OK gombbal fejezzük műveletet. Figyeljük meg, hogy az R szkript és R Markdown lapok tartalmazni fogják az egérrel elmutogatott tevékenységeinknek megfelelő R parancsokat, illetve az output és üzenetek részben ezek végrehajtásáról értesítést kapunk.Még egy rendkívül fontos dolog történt dplyr csomag starwars adatbázisának beolvasása után. Az eszköztárban az Adattábla részben már nem Nincs aktív adattábla szöveg szerepel, hanem starwars adatbázis neve. Azt kell megjegyeznünk az R Commander használata során, hogy mindig van egy kitüntetett, aktív adattáblánk, és minden további tevékenység, amit menüpontok segítségével el tudunk érni, az erre kitüntetett, aktív adattáblára vonatkozik. Az aktív adattáblát le lehet cserélni. Amennyiben nyitnánk egy másik adatbázist, akkor starwars feliratú gombon kattintva, egy listából kiválaszthatnánk, hogy melyik adatbázisunk legyen az R Commander-ben aktív.Folytassuk az adatelemzést az Elemzések / Összegzések / Numerikus változók összegzése menüpont kiválasztásával. megjelenő dialógusdobozból válasszuk ki height változót, az Összegzés csoportonként gombon kattintva pedig species változót. Az OK gombok megnyomása után az output részben látjuk az elemzés eredményét.Az R Commander nagyon hatékony eszköz gyors elemzések, egyszerű adatbetekintések elvégzésére. Számos menüpontot kínál az adatok beolvasásához, előkészítéséhez és az elemzéséhez. Ráadásul az egyes menüpontokban elmutogatott tevékenységek R parancsait szorgalmasan gyűjti, így azokat File / Szkript mentése vagy File / R Markdown mentése kiválasztásával, el tudjuk menteni magunk számára. Az R Commander vagy jamovi és JASP ismerete nagyban hozzájárul hatékony adatelemzéshez.Végül megemlítjük, hogy az R Commander tudása kibővíthető beépülő modulok (plugin-ek) segítségével. Ezek új menüpontokat, dialógusdobozokat és természetesen új függvényeket tartalmaznak. beépülő modulok csomagok formájában érhetők el. Például az Easy R beépülő modul telepítéséhez az RcmdrPlugin.EZR csomagra van szükség.Telepítés után beépülő modul betöltésére szükség van, csak így tudjuk az új funkciókat elérni. Ezt az Eszközök / Rcmdr plugin(ok) betöltése menüpontban tehetjük meg. Az R Commander újraindulása után, már az új menüszerkezetet fogjuk látni. Az R Commander hivatalos oldalán részletesebb információkat olvashatunk.","code":"\n# install.packages(\"Rcmdr\")  # R Commander telepítése\nlibrary(Rcmdr)               # R Commander indítása\n# ha véletlenül bezártuk az R Commander-t\ndetach(package:Rcmdr)\nlibrary(Rcmdr)\n# egy beépülő modul telepítése \ninstall.packages(\"RcmdrPlugin.EZR\")"},{"path":"munka-az-r-ben.html","id":"kötegelt-futtatás","chapter":"4 Munka az R-ben","heading":"4.3.4 Kötegelt futtatás","text":"Ha felidézzük az eddig tanultakat az R használati módjairól, akkor világos, hogy mindegyik az interaktív használathoz kötődik. Egy tipikus adatelemzési munka során pontosan erre van szükség: kezdeményezzük egy művelet végrehajtását és várjuk az eredményt. Újabb művelet, újabb output. Ezt fajta interaktív használatot láttuk konzolban, parancsállományok és RMarkdown állományok esetén, és az R Commander-ben . Azonban az interaktív használat mellett beszélünk ún. kötegelt feldolgozásról . Ez azt jelenti, hogy egy parancsállomány összes sorát egyetlen lépésben hatjuk végre. Nem vagyunk kíváncsiak soronkénti eredményekre, teljes szkriptállomány futtatása ad olyan eredményt, amelyre nekünk éppen szükségünk van. Kötegelt futtatásra source() függvényt használhatjuk, valamint az Alap R egy külső alkalmazását, az Rscript programot.Tegyük fel, hogy egy netflix.R parancsállományban összegyűjtöttük az összes olyan R sort, amely egyetlen ábra létrehozásához szükséges. Ez az ábra meglehetősen összetett, mert az egyes években megjelent filmek és sorozatok számát tartalmazza, és viszonylag sok adatelőkészítési műveletet előzte meg. Ezek nem mindig izgalmasak számunkra, annál inkább maga az ábra, amelynek létrehozása netflix.R egyetlen célja.következő sort az Alap R vagy az RStudio konzoljába/parancsállományába, vagy az RStudio RMarkdown állományába elhelyezhetjük. source() függvény netflix.R minden sorát végrehajtja és reményeink szerint előállítja kívánt ábrát.source() függvény kicsit másként közelít parancsainkhoz, mint amit megszoktunk az interaktív konzolos és parancsállományos használat során. source() először teljes állományban ellenőrzi parancsok szintaktikai helyességét, és csak akkor kezdi el az első majd az azt követő parancsok végrehajtásához, ha mindent rendben talált.Másik lehetőség parancsállomány kötegelt futtatására, az RScript program, amely ugyanúgy az Alap R része, mint konzol vagy az interpreter. Az operációs rendszer parancssorából kell kiadnunk következő parancsot:fenti sor hatására ugyanúgy létrejön kívánt ábra, de az output.txt-ben megkapjuk futás közben keletkező egyéb outputokat .Kötegelt feldolgozásra viszonylag ritkán van szükségünk, akkor többnyire nagygépes környezetben. Az interaktív használat legtöbb adatelemzési munka során elegendő rugalmasságot ad.","code":"\nsource(\"netflix.R\", echo = T)Rscript --vanilla netflix.R > output.txt"},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-3-summary","chapter":"4 Munka az R-ben","heading":"4.3.5 Összefoglalás","text":"\nAmennyiben az RStudio használatára nincs lehetőségünk, akkor\naz Alap R eszközeivel kiválóan megoldhatjuk adatelemzési\nfeladatainkat. konzol és az RGui parancsállományai interaktív\nparancsvégrehajtást biztosítanak, source() függvény és az\nRScript alkalmazás pedig .R kiterjesztésű\nparancsállományok kötegelt feldolgozását segítik. Az R\nCommander parancsok gépelése nélkül teszi lehetővé elemzések\nvégrehajtását, mindössze megfelelő menüpontot kell kiválasztani, majd\ndialógusdobozban elvégezni szükséges beállításokat. Érdemes\nkipróbálni jamovi és JASP statisztikai programokat\n.\n","code":""},{"path":"munka-az-r-ben.html","id":"munka-az-r-ben-3-exercise","chapter":"4 Munka az R-ben","heading":"4.3.6 Feladatok","text":"Foglaljuk össze az R használati módjait! Soroljuk fel mind négy lehetőséget!Hasonlítsuk össze parancsállományok használatát RGui-ban és RStudio-ban!Hasonlítsuk össze parancsállományok és az RMarkdown használatát R Commander-ben és RStudio-ban!Töltsük le és telepítsük az ingyenesen elérhető jamovi és JASP statisztikai programokat, majd nyissuk meg beépített adatbázisait, és végezzünk néhány egyszerűbb elemzést! Ha elakadunk, keressünk videó tutoriált az eszközök használatáról. Melyik eszköz tetszik jobban? Miben hasonlítanak és miben térnek el?fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv","chapter":"5 Az R nyelv","heading":"5 Az R nyelv","text":"Az előző fejezetekben megismertük az R környezetet, az Alap R, az RStudio és csomagok telepítését, megtanultuk projektek, parancsállományok és RMarkdown állományok létrehozását. Tudjuk, különböző környezetekben eltérő módszerekkel hajthatjuk végre az R parancsokat: konzolban az Enter, Windows-os RGui-ban Ctrl+R, míg az RStudio-ban Ctrl+Enter billentyűkombinációt kell használnunk. parancsok végrehajtása közben érdemes észben tartani, ha folytatás prompt (+) feltűnik, akkor kattintsunk bele konzolba, és nyomjuk meg az Esc billentyűt, így tudunk kilépni befejezetlen sor szerkesztésébőlE fejezet példáinak kipróbáláshoz hozzunk létre egy gyakorlas nevű új projektet az RStudio-ban (File / New Project), majd készítsünk egy gyakorlas.Rmd RMarkdown állományt (File / New File / R Markdown) és egy gyakorlas.R parancsállományt (File / New File / R Script). fejezet példáit egyaránt gépeljük az RMarkdown állomány R csonkjaiba, illetve parancsállomány egymást követő soraiba. fejezet további részében az R nyelvre koncentrálunk, arra, hogy mit írunk, és nem arra, hogy hová írjuk parancsokat.","code":""},{"path":"az-r-nyelv.html","id":"adatobjektumok","chapter":"5 Az R nyelv","heading":"5.1 Adatobjektumok","text":"Ebben fejezetben:áttekintjük az egyszerű számolási lehetőségeket R-ben,bevezetjük az aritmetikai operátor és kifejezés fogalmát,megismerjük az objektum létrehozását és elnevezését,több parancs elhelyezését egy sorban,és megjegyzések használatát.Az R nyelv megismerését számadatok írásával kezdjük. Az adatelemzés során számszerű adatok kezelése leggyakoribb, hiszen méréssel és számlálással ilyen jellegű adatokhoz jutunk. Számszerű adat testmagasságunk cm-ben kifejezve, az IQ-teszten elért pontszámunk, vagy testvéreink és Facebook ismerőseink száma .","code":""},{"path":"az-r-nyelv.html","id":"számolás-az-r-ben","chapter":"5 Az R nyelv","heading":"5.1.1 Számolás az R-ben","text":"Kezdjük számszerű adatok megismerését egy egyszerű sor begépelésével.Végrehajtás után konzolban láthatjuk az összeadás eredményét, 4-et. Az eredmény előtt egy szögletes zárójelben lévő sorszámot láthatunk ([1]), amely bonyolultabb outputokban segít eligazodni. Később az 5.3.3.2. fejezetben visszatérünk [1] értelmezésére.Látjuk, ebben az esetben az R úgy viselkedik, mint egy számológép. Kiszámolja parancssorba gépelt algebrai kifejezés értékét, majd képernyőn megjeleníti. Természetesen az összeadáson túl más műveletet használhatunk.fenti példából látható, hogy az R követi műveletek elvégzésének matematikában megszokott sorrendjét. Azaz szorzás műveletre (*) hamarabb sor kerül, ennek eredménye 12. Ezt követi az összeadás (+), már 4 és 12 között. Ennek az összeadás műveletnek az eredménye 16, ami egyben kifejezés értéke , tehát ez jelenik meg konzolban.Természetesen matematikában megszokott módon változtathatunk műveletek végrehajtásának alapértelmezett sorrendjén, azaz használhatunk kerek zárójeleket. Ezeket az R megszokott módon értelmezi: zárójelben szereplő műveletek végrehajtását előreveszi.fenti példában az összeadás művelet lesz az első, amelynek az eredménye 10. Ezt követi szorzás, így kapjuk kifejezés értékeként 20-.Ezeket matematikában megszokott algebrai kifejezéseket, az R-ben egyszerűen kifejezésnek vagy – utalva arra, hogy kifejezés értéke szám – aritmetikai kifejezésnek nevezünk. Az eddigiek alapján az aritmetikai kifejezések tehát következő nyelvi elemeket tartalmazhatják:számok, amelyeket numerikus konstansoknak nevezünk,műveleti jelek, amelyeket aritmetikai operátoroknak nevezünk,és kerek zárójelek.fentiek alapján összetettebb aritmetikai kifejezéseket megformálhatunk. Az R minden esetben kiszámolja kifejezések értékét – azaz kiértékeli kifejezést –, és kapott értéket megjeleníti konzolban.\nTÁBLÁZAT 5.1: Matematikai operátorok precedenciájuk csökkenő sorrendjében\nAz aritmetikai kifejezések használata során ne felejtkezzünk el műveletek alapértelmezett végrehajtási sorrendjéről. műveletek megjelenítését az operátorok végzik, melyeknek fontos tulajdonsága, hogy mennyire szorosan kötik magukhoz az adatokat (vagy más néven az operandusokat). Az operátorok ezen fonos tulajdonságát precedenciának nevezzük. Az R-ben használható aritmetikai operátorokat precedenciájuk csökkenő sorrendjében az 5.1. táblázat tartalmazza.Például hatványozás és az előjel operátor precedenciája eltér egymástól, hatványozás nagyobb precedenciájú, azaz szorosabban köti magához az adatokat, így végrehajtása megelőzi az előjel operátort. Ha nem vagyunk elég óvatosak, és plusz zárójelek segítségével nem biztosítjuk kívánt végrehajtási sorrendet, akkor “váratlan” eredményhez juthatunk. lenti példában láthatjuk, hogy zárójelek nélkül nagyobb precedenciájú hatványozás az elsőként végrehajtott művelet.Eddig láthattuk, hogy kifejezéseinket operátorok, numerikus konstansok és zárójelek segítségével építettük fel. Ezek kifejezések két alkotójukban általánosíthatók:általánosítható kifejezés adat része, amelyet eddig numerikus konstansok képviseltek (ezekből lesznek az objektumok),általánosíthatő kifejezés művelet része, amelyet eddig az operátorok jelenítettek meg (ezek lesznek függvények).Az adatrész általánosítása tehát az adatobjektum (vagy röviden objektum), műveleteké pedig függvényobjektum (vagy röviden függvény). Ezeket tekintjük át következőkben.","code":"\n2+2 \n#> [1] 4\n4+6*2\n#> [1] 16\n(4+6)*2\n#> [1] 20\n4^2-3*2+1\n#> [1] 11\n(104-20)/6-4*7*10/(5**2-5)\n#> [1] 0\n-2^2    # először hatványozás, majd előjel\n#> [1] -4\n(-2)^2  # először előjel, majd hatványozás\n#> [1] 4"},{"path":"az-r-nyelv.html","id":"objektumok","chapter":"5 Az R nyelv","heading":"5.1.2 Objektumok","text":"Ha egy kifejezés értéket nem egyszerűen képernyőn szeretnénk megjeleníteni, hanem azt később fel szeretnénk használni, akkor objektumot4 kell létrehoznunk. Az objektumok révén memóriába rögzíthetünk tetszőleges értékeket, később pedig elővehetjük és felhasználhatjuk ezeket az értékeket.\nTudjuk, ha lenti aritmetikai kifejezést parancssorba írjuk, az R miután kiértékelte kifejezést, kifejezés értékét megjeleníti konzolban. Ez az érték azonban megjelenítés után rögtön el vész, többször nem használhatjuk fel.Ha létrehozunk egy x nevű objektumot, akkor ezt az értéket további kifejezésekben szerepeltethetjük. Minden olyan helyen, ahol eddig számok jelentek meg kifejezésekben, oda ez az x objektumnév beírható.fenti sor végrehajtása után írhatjuk következőket, hiszen kifejezések kiértékelése során az x objektum memóriában tárolt értékével fog számolni az R.Minden objektumnak van neve és tartozik hozzá memóriában egy terület, ahol kérdéses érték tárolásra kerül. Esetünkben az objektum neve x, hozzá tartozó memóriaterületen pedig 97 értéket tárolja az R. Az objektum leegyszerűsítve tehát egy név-érték pár, ahol nevet és memóriában eltárolandó értéket mi magunk választjuk meg.Az objektumok kezeléséhez 3 művelet kapcsolódik:objektum létrehozása,objektum értékének lekérdezése,és az objektum értékének megváltoztatása.","code":"\n1157/13+2^3 \n#> [1] 97\nx <- 1157/13+2^3 \nx+2       # mintha 97+2 lenne\n#> [1] 99\n2*x^3+5   # 2*97^3+5\n#> [1] 1825351"},{"path":"az-r-nyelv.html","id":"objektumok-létrehozása","chapter":"5 Az R nyelv","heading":"5.1.2.1 Objektumok létrehozása","text":"Objektumot értékadással hozhatunk létre. Az értékadás tartalmaz egy értékadás operátort, melynek alakja <- (balra nyíl), vagyis egy kisebb jel és egy mínusz előjel egymás után írva szóköz nélkül5.Az értékadás általános alakja:Ahol lehet továbbiakban ezt balra nyíl alakú értékadó operátort használjuk az értékadás során, és nem szintén legális egyenlőségjelet (=). balra nyíl írását az RStudio az Alt+- segítségével támogatja, így bevitele nem okozhat nehézséget. Az egyenlőségjelet megtartjuk függvényargumentumok elnevezésére. Az egyszerűség kedvéért balra nyíl előtt lévő objektumnevet az értékadás bal oldalának, az utána lévő kifejezést az értékadás jobb oldalának nevezzük.Ha olyan objektumnevet szerepeltetünk az értékadásban, amely még nem létezik, akkor az R létrehoz egy ilyen nevű új objektumot, és hozzá tartozó memóriaterületen pedig az értékadás jobb oldalán lévő kifejezés kiértékelése után kapott értéket tárolja el.fenti sor végrehajtása után konzolban nem jelenik meg eredmény, mégis egy nagyon fontos dolog történik, létrejön az nevű objektum, amelynek értéke 3 lesz mindaddig, amig ezen nem változtatunk. munkánk során létrehozott objektumok memória egy speciális területére, munkaterületre (workspace) kerülnek.Ha az értékadásban használt objektum már létezik, akkor jobb oldali kifejezés kiértékelése után kapott értékkel felülírja bal oldali objektumhoz tartozó memóriaterületet. Ezzel módszerrel tehát korábban létrehozott objektum értékét módosíthatjuk.már létező objektum értékét könnyen megváltoztathatjuk.","code":"objektumnév <- kifejezés    # értékadó utasítás\na <- 1+2    # objektum létrehozása\na <- 10/3   # objektum értékének megváltoztatása"},{"path":"az-r-nyelv.html","id":"objektumok-értékének-lekérdezése","chapter":"5 Az R nyelv","heading":"5.1.2.2 Objektumok értékének lekérdezése","text":"Az objektum memóriában tárolt értékét le kérdezhetjük. legegyszerűbb mód erre, ha az objektum nevét parancssorba írjuk és végrehajtjuk sort, máris megkapjuk az objektum memóriában tárolt értékét.Objektumok tetszőleges kifejezésben megjelenhetnek, akár egy értékadás jobb oldalán lévő kifejezésben . kifejezések kiértékelésében az objektum memóriában tárolt értékével vesz részt.fenti sorokból kiolvasható, hogy immár az objektum értéke 14.","code":"\na     # vajon mi az \"a\" objektum értéke\n#> [1] 3.333\na*3              # a kifejezés értéke konzolba kerül\n#> [1] 10\na <- 4 + a * 3   # megváltozik az objektum értéke, nincs output\na                # megtudjuk az objektum értékét\n#> [1] 14"},{"path":"az-r-nyelv.html","id":"objektumelnevezes","chapter":"5 Az R nyelv","heading":"5.1.2.3 Objektumok elnevezése","text":"Az objektumok elnevezésére eddig egyetlen betűt (karaktert) használtunk, de ez elég ritka eset munka során. Helyes gyakorlat, ha az objektum neve utal az objektum tartalmára, céljára. Ha például testmagasságot tárolunk el egy objektumban, akkor írhatjuk következőt:fenti sor létrehozza munkaterületen magassag nevű objektumot 179 értékkel.Az objektumok elnevezésérebetűket,számjegyeket,és az aláhúzás (_) vagy pont (.) szimbólumokat használhatjuk.Az objektum neve csak betűvel vagy ponttal kezdődhet, számjeggyel vagy aláhúzással nem. Továbbá név nem lehet az R-ben már lefoglalt kulcsszó, mint például , function vagy TRUE (kulcsszavak listáját ?Reserved paranccsal ismerhetjük meg). Hagyományosan pont karaktert használjuk az objektumnevekben tagolásra (például magassag.peter Péter magasságának tárolására). Az R magyar ékezetes karakterek használatát megengedi az objektumnevekben, de csakúgy mint az állományok és könyvtárak elnevezésében, érdemes ezek használatát mellőzni.Az objektumoknak érdemes “beszédes” nevet választani, még ha ennek az ára némi extra gépelés . Tudjuk, Tab billentyű segíti gépelést az RStudio-ban.Az R kis- és nagybetű érzékeny, vagyis az x és X különböző objektumoknak számítanak. Például következőparancs után asor hibát jelez (Error: object 'Pulzus.atlag' found), azaz Pulzus.atlag objektumot nem találja az R. Minden olyan esetben, ha nem létező objektumra hivatkozunk, fenti hibaüzenet jelenik meg konzolban.Amennyiben gondoskodunk nagy P-vel kezdődő objektumról , akkor lehetőségünk van hibaüzenet nélkül mindkét objektum értékének kiíratására.gyakorlatban kerüljük el az olyan helyzeteket, amikor két objektumnév csak kis- nagybetűk használatában tér el.fenti példában egy további apró újdonság szerepelt. Ha egy parancssorban több utasítást szeretnénk elhelyezni, akkor ezeket pontosvesszővel (;) kell elválasztanunk. pontosvesszővel elválasztott utasításokat az R értelmező egymás után, balról jobbra haladva hajtja végre, mintha külön sorba írtuk volna őket. lenti sor 3 kifejezést (parancsot) tartalmaz pontosvesszővel elválasztva, mindegyik eredménye külön-külön jelenik meg konzolban, mintha 3 különböző sorba írtuk volna őket.","code":"\nmagassag <- 179\npulzus.atlag <- 72\nPulzus.atlag\n#> Error: object 'Pulzus.atlag' not found\nPulzus.atlag <- 69           # új objektumot hozunk létre\nPulzus.atlag; pulzus.atlag   # két parancs egy sorban\n#> [1] 69\n#> [1] 72\n1+2; 3+4; 5+6     # három kifejezés egy sorban\n#> [1] 3\n#> [1] 7\n#> [1] 11"},{"path":"az-r-nyelv.html","id":"MegjegyzesazRben","chapter":"5 Az R nyelv","heading":"5.1.3 Megjegyzések","text":"Nagyon sok példában láttunk már magyar nyelvű, magyarázó, értelmező szövegrészeket az R parancsok körül. Ezek az R megjegyzések. Megjegyzést az R-ben kettőskereszt (#) karakter használatával vezetünk . Az R értelmező kettőskereszttől sor végéig tartó részt figyelmen kívül hagyja. Itt helyezhetjük el paranccsal kapcsolatos magyarázatainkat magunk vagy kódot később olvasók számára. Teljes sorokat, vagy sorok végét tudjuk így kivonni végrehajtás alól.Nem kizárólag magyarázó szövegek kerülhetnek megjegyzésbe, sokszor R parancsok végrehajtását akadályozzuk meg ezzel módszerrel. Úgy kerülhetjük el egy parancs végrehajtását, hogy nem kell kitörölnünk parancsállományból vagy az RMarkdown állományból, egyszerűen csak megjegyzésbe kell tennünk őket. Emlékezzünk vissza, hogy az 3.1.3. fejezetben csomagok telepítésért felelős parancsok esetében kifezetten javasoltuk megjegyzések használatát:Végül megemlítjük, hogy az RStudio-ban egyszerre több kijelölt sort tudunk megjegyzésbe tenni, vagy onnan kivenni Ctrl+Shift+C segítségével.","code":"\n# Érdekes tény, ha a 153 számjegyeit köbre emeljük, \n#   majd összeadjuk őket, pontosan 153-at kapunk\n1^3+5^3+3^3       # hatványozás a ^ operátorral\n#> [1] 153\n1**3+5**3+3**3    # hatványozás a ** operátorral\n#> [1] 153\n# xkcd: Randall Munroe webképregényei\n# install.packages(\"RXKCD\")\nlibrary(RXKCD)             # csomag betöltése       \nsearchXKCD(\"Star Wars\")    # keresés címben vagy leírásban\ngetXKCD(1769)              # webképregény megjelenítése"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-1-summary","chapter":"5 Az R nyelv","heading":"5.1.4 Összefoglalás","text":"\nEgyszerű kifejezéseket építhetünk numerikus konstansok (számok),\noperátorok és kerek zárójelek segítségével. legfontosabb matematikai\noperátorok négy alapművelet és hatványozás. kifejezés kiértékelése\nbalról jobbra sorrendben történik, de ezt felülírhatja kerek zárójelek\nhasználata és az operátorok precedenciája. Egy kifejezés értékét\neltárolhatjuk memória speciális területén, munkamemóriában. Ehhez az\nértékadó operátorral (<-) létre kell hoznunk egy új\nobjektumot. Az objektum egy név-érték páros. Az objektum létrehozása\nután az objektum neve megjelenhet egy tetszőleges kifejezés adat\nrészében. Több parancsot pontosvesszővel (;) írhatunk egy\nsorba. Megjegyzéseket kettőskereszt (#) segítségével\nhelyezhetünk el.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-1-exercise","chapter":"5 Az R nyelv","heading":"5.1.5 Feladatok","text":"Gondoljuk át, mi lehet következő algebrai kifejezés eredménye, majd ellenőrizzük R-ben : \\(8/2(2+2)\\).Gondoljuk át, hogy .342e1 név miért nem lehet érvényes objektumnév? Próbáljuk ki make.names(\".342e1\") parancsot, majd tanulmányozzuk ?make.names leírást!Magyarázzuk meg make.names(c(\"\", \"\", \"\")) és make.names(c(\"\", \"\", \"\"), unique = T) parancsok közötti különbséget!Gondoljuk át, hogy egy parancsállomány mely pontjain érdemes feltétlenül megjegyzéseket használni!Jelentősen segíthetjük navigációt az RStudio parancsállományaiban, ha bizonyos megjegyzések végére ezt írjuk: ---- (szóköz és négy mínusz jel). Hogyan használhatjuk ezt lehetőséget az RStudio-ban, és milyen előnyei vannak?Az RStudio-ban parancsállomány (.R) szerkesztése közben próbáljuk ki Ctrl+Alt+R billentyűparancsot, és hozzá kapcsolódó Shift+Alt+J billentyűparancsot . Mi jelentése az Alt+L, Shift+Alt+L, Alt+O és Shift+Alt+O billentyűparancsoknak? megismert funkciók hogyan válthatók ki RMarkdown (.Rmd) állomány szerkesztése közben?\nfenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"függvények","chapter":"5 Az R nyelv","heading":"5.2 Függvények","text":"Ebben fejezetben:áttekintjük függvényhívás lehetőségeit nevesített argumentumokkal, az alapértelmezésekkel és az argumentumok sorrendjének megváltoztatásával,megismerjük legfontosabb matematikai függvényeket,és pontosítjuk kifejezés fogalmát.Az aritmetikai kifejezéseinkben használható operátorok nem teszik lehetővé minden matematikai művelet elvégzését. Mit tegyünk ha 2 négyzetgyökét szeretnénk kiszámolni? négyzetgyökvonás operátor nem létezik az R-ben, de ebben speciális esetben hatványozás operátor segítségével elérhetjük célunkat.Az R azonban más lehetőséget biztosít négyzetgyök kiszámítására és ez az sqrt() függvény.függvények valamilyen utasítássorozatot hajtanak végre és számítás eredményét szolgáltatják. Esetünkben az sqrt() függvény egy szám (pozitív) négyzetgyökét számolja ki, annak számnak négyzetgyökét, amely kerek zárójelek között szerepel. Tehát az R paraméterben megadott 2 értékre meghívja az sqrt() függvényt, ami visszatér 2 négyzetgyökével.","code":"\n2^0.5\n#> [1] 1.414\nsqrt(2)\n#> [1] 1.414"},{"path":"az-r-nyelv.html","id":"a-függvényhívás-szabályai","chapter":"5 Az R nyelv","heading":"5.2.1 A függvényhívás szabályai","text":"függvényhívás általános alakja:függvény neve ugyanazoknak szabályoknak engedelmeskedik, amelyeket az objektumok nevénél megtárgyaltunk (lévén függvény egy objektum). függvény neve után kerek zárójelben következnek függvény argumentumai, amelyek függvény utasításainak bemenő paraméterei. függvény bemenő paraméterek alapján az utasításainak megfelelően egy visszatérési értéket fog szolgáltatni.Egy függvény különböző hívásainál az előforduló argumentumok száma és azok sorrendje igen változatos képet mutathat. Elöljáróban elmondhatjuk, hogy függvények argumentumai alapértelmezett értékkel rendelkezhetnek, így ezek az argumentumok elhagyhatók. Továbbá, függvények argumentumai névvel rendelkeznek, amelyeket ha függvény hívásánál felhasználjuk, az argumentumok sorrendje tetszőleges lehet.Először tekintsük át az R alapvető matematikai függvényeit (5.2. táblázat). Nézzük meg részletesebben log() függvényt. Ha kikérjük súgóját ?log parancs begépelésével, akkor megtudhatjuk, hogy ez legáltalánosabb logaritmus függvény, tetszőleges alap esetén hívható. Számunkra legfontosabb súgónak az sora, amely logaritmus függvény használatát mutatja: log(x, base=exp(1)).\nTÁBLÁZAT 5.2: Az R alapvető matematikai függvényei\nEbből kiolvasható, hogy log() függvénynek 2 argumentuma (más néven paramétere) van. Az elsőt x-nek, másodikat base-nek nevezik. második paraméter alapértelmezett értékkel rendelkezik, tehát ez paraméter hívásnál elhagyható, míg az x= argumentum megadása kötelező. base= paraméter értéke könnyen kideríthető azparancsból. Ezt az irracionális számot matematikában e-vel jelöljük, és Euler-féle számnak nevezzük, ez természetes logaritmus alapja. Ha nem határozzuk meg második paramétert, akkor log() függvény ezzel természetes alappal (base=exp(1)) számítja ki az x logaritmusát.Ezek alapján 2 természetes alapú logaritmusát afüggvényhívás adja meg. Azt megtehetjük, hogy felhasználjuk hívásnál az argumentum nevét (x), és egy egyenlőségjel (=) felhasználásával ezt 2 elé szúrjuk .fenti sor természetesen ugyanúgy 2 természetes alapú logaritmusát szolgáltatja, csak explicit módon közöltük, hogy az aktuális paraméterben szereplő 2-es értéket az x= nevű formális paraméternek feleltetjük meg. Ez felesleges gépelést jelentett és általában elmondhatjuk, hogy matematikai függvények esetében az oly gyakori x= argumentumnevet szokás szerint nem írjuk ki függvényhívás során.Hívjuk két argumentummal log() függvényt. 100 10-es alapú logaritmusát aparanccsal tudhatjuk meg. függvényhívásnál az x= formális argumentum 100, base= pedig 10 értéket kapja. Természetesen ezt hívásnál mi rögzíthetjük világosabb értelmezés kedvéért saját magunk számára avagy akárformában .Arra lehetőség van, hogy megcseréljük az aktuális paraméterek sorrendjét. legbiztonságosabb ekkor az összes paraméter nevesítése,de két argumentum esetén így egyértelmű hozzárendelés:Ha az argumentumok nevesítése nélkül cseréljük fel az aktuális paramétereket, akkor természetesen nem várt eredményt kapjuk, mert 10 100-alapú logaritmusa lesz az eredmény.Kényelmi lehetőség az aktuális paraméterek elnevezésénél, hogy rövidítéseket használhatunk, addig csonkolhatjuk az argumentum nevét, amíg az argumentumok egyértelműen azonosíthatók maradnak. Így példában akár b=-vel helyettesíthetjük base= argumentumnevet:Mint korábban említettük, az x= argumentum nem rendelkezik alapértelmezett értékkel, így paraméter nélkül nem hívható log() függvény.fenti hibaüzenethez hasonlót láthatunk, ha egy függvényt nem megfelelő számú paraméterrel hívunk.Eddig függvények aktuális paramétereiként csak numerikus konstansokat használtunk, pedig valójában tetszőleges kifejezéseket megadhatunk. függvény hívása előtt ezek kiértékelődnek és hívás során ezek az értékek rendelődnek formális paraméterekhez.fenti példa következő numerikus konstansokkal történő hívásoknak felel meg:függvények sokféle csoportja létezik az R-ben, látott matematikai függvények osztálya csak egy sok közül. következő fejezetekben függvények más csoportjait megismerjük.","code":"függvénynév(argNév1=arg1, argNév2=arg2, ..., argNévN=argN)\nexp(1)    #  Euler-féle szám, a természetes logaritmus alapja \n#> [1] 2.718\nlog(2)    # 2 természetes alapú logaritmusa\n#> [1] 0.6931\nlog(x=2)   # 2 természetes alapú logaritmusa\n#> [1] 0.6931\nlog(100, 10)        # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(100, base=10)    # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(x=100, base=10)  # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(base=10, x=100)  # 100 10-es alapú logaritmusa\n#> [1] 2\nlog(base=10, 100); log(10, x=100)  # 100 10-es alapú logaritmusa 2x\n#> [1] 2\n#> [1] 2\nlog(10, 100)  # 10 100-as alapú logaritmusa\n#> [1] 0.5\nlog(b=10, 100)   # 100 10-es alapú logaritmusa\n#> [1] 2\nlog()\n#> Error: argument \"x\" is missing, with no default\nalap <- 10; log(exp(1)); log(exp(4),base=alap); log(2*exp(2),b=alap/2)\n#> [1] 1\n#> [1] 1.737\n#> [1] 1.673\nlog(2.718282); log(54.59815, base=10); log(14.77811, base=5)\n#> [1] 1\n#> [1] 1.737\n#> [1] 1.673"},{"path":"az-r-nyelv.html","id":"a-kifejezés-fogalma","chapter":"5 Az R nyelv","heading":"5.2.2 A kifejezés fogalma","text":"Elérkezett az idő, hogy kifejezés fogalmát pontosíthassuk: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerek zárójelekkel helyesen összefűzött sorozata kifejezés.Az R nyelv parancsai, vagy más néven utasításai lényegében kifejezések. Az R nyelvben egy parancs végrehajtása lényegében egy kifejezés kiértékelését jelenti, és legtöbb esetben kifejezés értékének megjelenítését konzolban.munka során az R értelmező az utasítások egymás utáni kiértékelését végzi. Az utasításokat újsor karakter vagy pontosvessző választhatja el. szintaktikailag helyes utasítások kiértékelése mindig egy értéket eredményez, ez lesz az utasítás értéke. Még akkor rendelkezik értékkel az utasításunk, ha az nem jelenik meg parancssorban, például az értékadó utasítás értéke jobb oldali kifejezés értéke. Ezért írhatjuk következő parancsot:Amennyiben egy értékadás, mint kifejezés értékét szeretnénk megjeleníteni konzolban, akkor tegyük kerekzárójelbe teljes sort:kifejezés fogalmának gyakorlásához nézzünk egy példát. másodfokú egyenlet megoldóképlete segítségével oldjuk meg az \\(x^{2}–5x+4=0\\) egyenletet. Gépeljük következő sorokat:fenti hat sor mindegyike egy-egy kifejezés. Az első három sorban lévő kifejezéseknek nincs outputja konzolban, céljuk új objektumok létrehozása, és maguk kifejezések csupán értékadó operátort, objektumnevet és konstanst tartalmaznak. negyedik sor kifejezése szintén output nélkül hajtódik végre, és itt új objektum jön létre, kifejezés több összetevőt tartalmaz: objektumneveket, függvényhívást, matematikai operátorokat és konstansokat. Az ötödik és hatodik sorban lévő kifejezések értékei kiértékelés után megjelennek az outputban, és objektumnevekből, matematikai operátorokból, kerek zárójelekből és konstansokból épülnek fel.","code":"\ny <- x <- 10\nx; y\n#> [1] 10\n#> [1] 10\n(x <- 20)\n#> [1] 20\negyutthato.a <- 1\negyutthato.b <- -5\negyutthato.c <- 4\nD <- sqrt(egyutthato.b^2-4*egyutthato.a*egyutthato.c)\n(-egyutthato.b+D)/(2*egyutthato.a)   # 1. gyök\n#> [1] 4\n(-egyutthato.b-D)/(2*egyutthato.a)   # 2. gyök\n#> [1] 1"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-2-summary","chapter":"5 Az R nyelv","heading":"5.2.3 Összefoglalás","text":"\nfüggvényobjektumok (vagy röviden függvények) előre definiált\nutasítások sorozatát hajtják végre, és egy visszatérési értéket\nszolgáltatnak. visszatérési érték meghatározását függvény bemenő\nparaméterei, azaz az argumentumok befolyásolják. Minden argumentumnak\nvan neve, és rendelkezhetnek alapértelmezett értékkel . Az R-rel való\nmunka nem más, mint kifejezések létrehozása és végrehajtása, vagyis\nkiértékelése. kifejezés fogalma: egy konstans, egy objektum vagy egy\nfüggvényhívás önmagában kifejezés, de ezek operátorokkal és kerek\nzárójelekkel helyesen összefűzött sorozata kifejezés. kifejezések\nkiértékelése során az eredmény megjelenhet konzolban, de látható\noutput nélkül végbemehet kifejezés végrehajtása.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-2-exercise","chapter":"5 Az R nyelv","heading":"5.2.4 Feladatok","text":"Tekintsük át az 5.2. táblázat utolsó oszlopában szereplő R függvényeket. Próbáljuk megjósolni függvények visszatérési értékét. Végezzünk ellenőrzést: gépeljük , és hajtsuk végre matematikai függvényeket! Egészítsük ki begépelt matematikai függvényeket az argumentumok nevével, mindegyik argumentumnak adjunk nevet az 5.2. táblázat első oszlopa alapján!Az előző feladatban matematikai függvények gépelése során milyen RStudio kényelmi funkciókat fedeztünk fel. Soroljunk fel legalább hármat!Az aranymetszés arányait tartalmazó épületek, képzőművészeti alkotások máig nagy esztétikai értékkel bírnak. Határozzuk meg ezt az arányt \\(\\phi=\\frac{1+\\sqrt{5}}{2}\\)\nképlet segítségével! Egy /4-es oldalra kb. 47 sort írhatunk 12-es betűmérettel, és kb. 35 sort 16-os betűmérettel. Egy üres lap hanyadik sorába írnánk címet 12-es és 16-os betűméret esetén? Próbáljuk ki mindezt egy szövegszerkesztőben !trigonometrikus függvények argumentumában radiánban kell megadni szög értékét, és nem fokban. Ezt figyelembe véve határozzuk meg 0, 30, 45, 60, 90 és 180 fok szinuszát, koszinuszát és tangensét!\nfenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"adatszerkezetek","chapter":"5 Az R nyelv","heading":"5.3 Adatszerkezetek","text":"Ebben fejezetben:áttekintjük numerikus, karakteres és logikai konstansok írását,vektor, mátrix, faktor, lista, és adattábla adatszerkezeteket,ezek kezelését, indexelését, tesztelését és konvertálását.Kezdünk egyre mélyebre ásni az R nyelvben. Megismertük már az adatobjektum, függvény és kifejezés fogalmát. Ezek birtokában már bátran belevághatunk könyvünk kulcsfontosságú fejezetébe, az adatszerkezetek tanulmányozásába. Legyünk alaposak az itt szereplő témakörök áttekintésében, és lehetőleg oldjunk meg minden kitűzött feladatot. Később ez sokszorosan megtérül.Minden statisztikai programcsomag adatokkal dolgozik. Az R-ben nevekkel ellátott objektumokban tároljuk ezeket az adatokat. Lényegében minden tevékenység ezen objektumok létrehozása, módosítása és lekérdezése köré csoportosítható. Ezeket műveleteket az R-ben az operátorok és függvények végzik. Láttuk, adatokból (objektumokból), operátorokból és függvényekből kifejezéseket építünk, és hajtunk végre – így foglalható össze minden egyes tevékenység az R-ben.Ebben fejezetben kifejezések adat részére összpontosítunk, hiszen minden adatelemzési munka kiinduló pontja maga az adat. Eddig csak számszerű (numerikus) adatokkal találkoztunk, és azok közül csak az egész számok leírására fókuszáltunk. Adatfeldolgozási folyamatainkban mért adatok azonban numerikus mellett karakteres formában előfordulnak, valamint az R-ben egy harmadik adattípus, logikai fontos szerepet kap. Összefoglalva, három R alaptípus lesz fontos számunkra az adatfeldolgozás során:numerikus típus, amely lehet double vagy integer, attól függően, hogy tizedestörteket vagy egész számokat szeretnénk tárolni,karakteres típus, amelyek nem egyetlen karaktert, hanem egy karaktersorozatot vagy más néven sztringet jelentenek,logikai típus, amely az adatszerkezetek manipulációja során jut nagyon fontos szerephez.továbbiakban megismerjük, hogyan adhatjuk meg az R számára fenti típusokba tartozó értékeket, illetve ezek felhasználásával, hogyan tudunk bonyolultabb adatszerkezeteket, összetett típusokat létrehozni.","code":""},{"path":"az-r-nyelv.html","id":"konstansok","chapter":"5 Az R nyelv","heading":"5.3.1 Konstansok","text":"Mért adatokat közvetlenül az R-konstansok segítségével írhatunk . konstansok olyan objektumoknak tekinthetők, amelyeknek nincs nevük, csak értékük, és azt nem tudjuk megváltoztatni. Ha Péter 18 éves, akkor azt 18 leírásával közölhetjük az R-rel, és ez nem jelenthet mást (nem lehet más az értéke), mint 18. már említett három egyszerű típusnak megfelelően tekintsük át numerikus, karakteres és logikai konstansokat.","code":""},{"path":"az-r-nyelv.html","id":"numerikus-konstansok","chapter":"5 Az R nyelv","heading":"5.3.1.1 Numerikus konstansok","text":"numerikus konstansok többféle alakban megjelenhetnek az R-ben. Az integer szóval az egész számok tárolását végző konstansra hivatkozunk, double konstansok pedig törtrészt tartalmazhatnak, de ez nem kötelező. Ha nem érdekes, hogy szám integer vagy double, akkor egyszerűen numerikus (R-ben numeric) elnevezést használjuk.\nTÁBLÁZAT 5.3: Numerikus konstansok írása\nAz 5.3. táblázatban látható, hogy integer értékek írásához szükséges az L utótag használata, egyébként double-ként kezeli az R számot, még akkor ha nem adtunk meg törtrészt.Fontos szabály, hogy tizedesvessző alakja az R-ben pont. nulla egész részű tizedes törtek esetében az értéktelen nullát elhagyhatjuk.Használhatunk az R-ben exponenciális alakú és hexadecimális (16-os számrendszerű) számokat .Az exponenciális alakú számokat e vagy E karakter vágja ketté, egy bal oldali és egy jobb oldali részre. Az exponenciális alakú szám értéke: bal oldali rész szorozva 10 annyiadik hatványával, mint amennyi jobb oldali rész. Érdemes időt szentelni az exponenciális alakú számok értelmezésére, mert az R outputokban gyakran előfordulnak: szám előjelét bal oldali rész előjele dönti el, viszont nagyságrendjét jobb oldali szám nagyságrendje és előjele együtt határozza meg.Az exponenciális alakú számok nagy előnye, hogy nagyon kis, illetve nagyon nagy számok nagyságát jobban meg tudjuk ítélni, és persze az ilyen alakú számok leírásánál helyet megtakarítunk.Az R automatikusan exponenciális alakra vált túl kicsi vagy túl nagy számok konzolbeli megjelenítésénél. Ezt viselkedést az R egyik globális opciójának beállításával tudjuk szabályozni. globális opciókat az options() függvénnyel tudjuk állítani az R-ben (?options), amelyben scipen= paramétert kell megadnunk. Minél nagyobb pozitív értéket adunk meg, annál jobban törekszik az R számok fix alakú megjelenítésére, negatív érték megadásánál pedig ugyanez igaz az exponenciális alakra.16-os számrendszerű számok írásához 0-9 és kis -f vagy nagy -F betűket használhatjuk fel. hexadecimális számokat 0x vagy 0X előtag vezeti .Aritmetikai műveleteinkben rendszerint double típusú számokat, 10-es számrendszerben és fix (nem exponenciális) alakban használunk. De ettől bármikor eltérhetünk:számok megjelenését konzolban még egy globális opció befolyásolja. digits megszabja, hány értékes jegyre pontosan jelenjenek meg számaink konzolban. Lehetséges értékei az 1-22 tartományba esnek, alapértelmezés szerint 7 az értéke. beállított érték csak egy ajánlás az R számára, és főképp tizedes törtek esetén okozhat meglepetést, ha túl kicsire állítjuk digits értékét.Természetesen objektumokat létrehozhatunk numerikus értékek tárolására, ahogyan korábban már láttuk. Az objektum típusa konstans típusával fog megegyezni:","code":"\n0.04; .04; -.04 # utóbbi egy negatív szám, a nulla egészrész megadása nélkül\n#> [1] 0.04\n#> [1] 0.04\n#> [1] -0.04\n12e3; 12E+3; 12e-3; 0xa2e; 0Xa2e\n#> [1] 12000\n#> [1] 12000\n#> [1] 0.012\n#> [1] 2606\n#> [1] 2606\n0.0000000000000000000000000016726         # proton tömege (kg)\n#> [1] 1.673e-27\n0.00000000000000000000000000000091093822  # elektron tömege (kg)\n#> [1] 9.109e-31\n100000000        # ennyi fele kell figyelni egy diáknak (százmillió)\n#> [1] 1e+08\n5970000000000000000000000                 # A Föld tömege (kg)\n#> [1] 5.97e+24\noptions(scipen= 0)       # az alapértelmezés\n0.0000001                # túl kicsi: exponenciális lesz\n#> [1] 1e-07\n123                      # marad fix alakú \n#> [1] 123\n100000000                # túl nagy: exponenciális lesz\n#> [1] 1e+08\noptions(scipen=-8); 0.0000001; 123; 100000000 # exponenciális lesz mind\n#> [1] 1e-07\n#> [1] 1.23e+02\n#> [1] 1e+08\noptions(scipen= 8); 0.0000001; 123; 100000000 # fix lesz mind\n#> [1] 0.0000001\n#> [1] 123\n#> [1] 100000000\noptions(scipen= 0)       # az alapértelmezés visszaállítása\n12L + -3.04 + 3.4e2 + -0x1af  # számok 4 különböző formában\n#> [1] -82.04\noptions(digits = 1); 12.36\n#> [1] 12\noptions(digits = 2); 12.36\n#> [1] 12\noptions(digits = 3); 12.36\n#> [1] 12.4\noptions(digits = 4); 12.36\n#> [1] 12.36\noptions(digits = 7)        # alapértelmezés visszaállítása\npeter.magassaga <- 181                                  # double objektum\npeter.sulya     <- 72L                                  # integer objektum\npeter.bmi       <- peter.sulya /(peter.magassaga/100)^2 # double objektum"},{"path":"az-r-nyelv.html","id":"karakteres-konstansok","chapter":"5 Az R nyelv","heading":"5.3.1.2 Karakteres konstansok","text":"Az R-ben karakteres konstans (vagy más néven sztring vagy karaktersorozat) speciális karakterekkel határolt, tetszőleges karaktereket tartalmazó sorozat. karakteres konstans tehát nem egyetlen karaktert jelent tipikusan, hanem többet. Három módszerrel adhatunk meg karakteres konstanst:Karakteres konstansok készítésekor tetszőleges karaktersorozatunkat dupla (\") vagy egyszeres (') idézőjellel kell körbevennünk, de az R 4.0.0-ás verziójától az r\"(tetszőleges_karaktersorozat)\" forma elérhetővé vált. Láthatjuk, hogy az R dupla idézőjelet részesíti előnyben az output megjelenítése során.Egy karakteres konstans tetszőleges karaktert (betűt, számjegyet, írásjeleket, szóközt stb.) tartalmazhat, de az első két megadási forma esetében azt határolójelet el kell elkerülnünk, amelyet az illető karakteres konstans létrehozásánál használtuk. Látjuk, hogy az r\"(tetszőleges_karaktersorozat)\" forma adja legnagyobb szabadságot, de legtöbbször dupla (\") idézőjeles formával találkozunk.karakteres konstansok tartalmazhatnak ún. escape szekvenciákat, olyan backslash jellel (\\, fordított perjel) kezdődő karaktersorozatokat, amelyeket speciálisan értelmez az R. legfontosabb escape szekvenciákat és jelentésüket az 5.4. táblázat tartalmazza.\nTÁBLÁZAT 5.4: Néhány escape szekvencia\nTermészetesen, karakteres objektumokat létrehozhatunk.Karakteres operátor az R-ben nincs, de számos karakterkezelő függvény segíti sztringek kezelését (5.5. táblázat).\nTÁBLÁZAT 5.5: Néhány karakterkezelő függvény\n","code":"\n\"Látni távol kis falucska tornyát.\"\n#> [1] \"Látni távol kis falucska tornyát.\"\n'Látni távol kis falucska tornyát.'\n#> [1] \"Látni távol kis falucska tornyát.\"\nr\"(Látni távol kis falucska tornyát.)\"\n#> [1] \"Látni távol kis falucska tornyát.\"\nnev <- 'Zsolt'; foglalkozas <- \"festő\"; lakohely <- r\"(Érd)\"\nnev; foglalkozas; lakohely\n#> [1] \"Zsolt\"\n#> [1] \"festő\"\n#> [1] \"Érd\""},{"path":"az-r-nyelv.html","id":"logikai-konstansok","chapter":"5 Az R nyelv","heading":"5.3.1.3 Logikai konstansok","text":"Az eddigiekben megismert numerikus és karakteres konstansok nagyon sokfélék lehetnek, de ugyanígy numerikus és karakteres objektumokhoz nagyon sok lehetséges numerikus és karakteres érték rendelhető. logikai adattípus ezektől lényegesen egyszerűbb típus, mivel itt összesen két érték tárolására van módunk. Ez logikai igaz és logikai hamis érték, amelyek az R nyelvben TRUE és FALSE logikai értékeket jelentik. Az R logikai értékek írását T és F globális változók bevezetésével segíti, ezek induló értéke TRUE és FALSE logikai érték.Ezeket logikai konstansokat értékadásban szerepeltethetjük, így logikai objektumokat hozhatunk létre.Logikai értékeket vagy objektumokat relációs operátorok segítségével létrehozhatunk (5.6. táblázat).\nTÁBLÁZAT 5.6: Relációs operátorok\nNumerikus és karakteres adatok lehetnek relációs operátorok bemenő adatai. Numerikus adatok esetén számok nagysága, karakteres adatok esetén az ábécében elfoglalt hely és sztringek hossza (lexikografikus sorrend) alapján végzi az R az összehasonlítást. sztringek lexikografikus összehasonlítása, magyar területi beállítások esetén, magyar ékezetes karaktereket helyesen kezeli.logikai értékkel visszatérő kifejezéseket (egyszerű) logikai kifejezéseknek nevezzük. Ezekből az egyszerű logikai kifejezésekből logikai operátorok segítségével összetett logikai kifejezéseket hozhatunk létre (5.7. táblázat).\nTÁBLÁZAT 5.7: Logikai operátorok\n","code":"\nfiu <- TRUE; van.kocsija <- FALSE; hazas <- T\nfiu; van.kocsija; hazas\n#> [1] TRUE\n#> [1] FALSE\n#> [1] TRUE"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-3-1-summary","chapter":"5 Az R nyelv","heading":"5.3.1.4 Összefoglalás","text":"\nAz adatfeldolgozás során többnyire számokkal és szövegekkel\ndolgozunk. Az R numerikus és karakteres adatok írásának szabályait\npontosan rögzíti. Numerikus konstansok írása matematikában megszokott\nmódon történik (például 12, -24,\n12e+3, 0xabc3), azonban fontos megjegyeznünk,\nhogy tizedestörtek esetében pontot kell használnunk az egész és \ntörtrész elválasztására (például 12.34, -0.04,\n3.12e+12). Karakteres konstansok esetében következő\nformákat használhatjuk: “tetszőleges karakterek”,\n‘tetszőleges karakterek’, és\nr”(tetszőleges karakterek)“. logikai konstansok az\nadatmanipuláció során nyújtanak segítséget, két leheséges értékük \nlogikai igaz és hamis: TRUE, FALSE vagy\nrövidebben T, F.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-3-1-exercise","chapter":"5 Az R nyelv","heading":"5.3.1.5 Feladatok","text":"Mi hasonlóság következő három numerikus konstans között: 0xabc, 2748, .2748e4.Az R öt előre definiált konstassal rendelkezik (?Constants). Írassuk ki ezek értékeit, állapítsuk meg típusukat!Az aranymetszés arányszámát (\\(\\phi=\\frac{1+\\sqrt{5}}{2}\\)) írassuk konzolba legalább 8 tizedes pontossággal!Az r\"(tetszőleges karakterek)\" formájú karakteres konstans megadásnak több válozata létezik, soroljunk fel még legalább öt lehetőséget (?Quotes)! Milyen előnyökkel rendelkezik ez megadási forma az idézőjelek és fordított perjel tekintetében?Helyezzünk el idézőjeleket karakteres konstansokban, mindhárom megadási forma mellett!Próbáljuk ki az 5.5. táblázat karakterkezelő függvényeit! Gépeljük az utolsó oszlopban lévő példákat, és vizsgáljuk meg függvények visszatérési értékét.Próbáljuk ki az 5.6. táblázat relációs operátorait! Gépeljük példákat és ellenőrizzük az eredményeket.logikai operátorok működéséről teljes képet kaphatunk az 5.7. táblázatból. Próbáljuk ki ezeket parancsokat !fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"áttekintés","chapter":"5 Az R nyelv","heading":"5.3.2 Áttekintés","text":"Az előző fejezetben láttuk, hogy az R-ben leírható értékek alapvetően 4 típusba sorolhatók. Ezek double, az integer, karakteres és logikai alaptípusok. Ezen értékek felhasználásával nagyon egyszerűen tudunk objektumokat létrehozni. Ezek az objektumok, mindjárt látjuk, az R legalapvetőbb adatszerkezetének, vektornak az egyelemű változatai.fenti objektumok típusa rendre double, integer, karakteres és logikai. Ezt könnyen ellenőrizhetjük typeof() vagy class() függvényekkel. typeof() az objektum alaptípusát adja meg, class() pedig inkább az R objektum-orientált lehetőségeihez kapcsolódó függvény, de fenti objektumok esetében nagyon hasonló eredményt szolgáltat, és későbbiek során sokat fogjuk használni. Egyedül double objektumokok esetén tér el visszatérési értéke, class() ugyanis ekkor numeric outputot adja.Az adatelemzési problémáink megoldásához egyszerre több adatérték feldolgozására van szükséges. Mivel az R nyelvet statisztikai adatfeldolgozásra tervezték, így nem csodálkozhatunk azon, ha több értéket el tudunk tárolni egymás utáni memóriahelyeken fenti 4 alaptípusból (double, integer, karakteres és logikai). Ezt többféleképp megtehetjük, például egy vagy több dimenzió mentén, illetve keverhetjük típusokat vagy ragaszkodhatunk az azonos típusba tartozó értékek egymásutánjához. Ennek megfelelően több különböző R adatszerkezettel kell számolnunk. Ebben fejezetben az R leggyakrabban használt adatszerkezetit tekintjük át. felsoroljuk és jellemezzük őket:vektor - Azonos alaptípusú értékeket egymás után sorolunk fel, egy dimenzó mentén.mátrix - Azonos alaptípusú értékekből egy kétdimenziós szerkezetet hozunk létre, amelynek vannak sorai és oszlopai.faktor - Integer értékeket egymás után teszünk, egy dimenzió mentén, de megadjuk, hogy melyik szám milyen címkét jelöl.lista - Tetszőleges típusú objektumokat egymás után sorolunk fel, egy dimenzió mentén.adattábla - Tetszőleges típusú, de azonos elemszámú objektumokat egymás után sorolunk fel. Tipikusan azonos hosszúságú vektorokat vagy faktorokat teszünk egymás mellé, és így egy kétdimenziós szerkezetet kapunk, amelynek vannak sorai és oszlopai.Az 5.1 ábra összefoglalja az adatszerkezetek fenti tulajdonságait. Beszélünk numerikus (double vagy integer), karakteres és logikai vektorokról, melyek egydimenziósak és homogének, azaz azonos típusú adatokat tartalmaznak. Ugyanez igaz mátrixokra, csak két dimenzióban, sorokkal és oszlopokkal. faktor egy integer vektor (azaz egydimenziós és homogén), azonban külön nyilvántartást vezet arról, hogy az egyes integer értékeknek milyen címke felel meg. Az adattábla lesz legfontosabb adatszerkezet számunkra: kétdimenziós, de oszlopai homogének, hiszen ezek vektorok (numerikus, karakteres vagy logikai) vagy faktorok lehetnek. lista legszabadabb adatszerkezet, egydimenziós, de elemei bármilyen adatszerkezethez tartozhatnak. Például az 5.1. ábrán egy 8 elemű lista jelenik meg, amelynek első eleme egy numerikus vektor, utolsó eleme pedig egy adattábla.\nÁBRA 5.1: Az R legfontosabb adatszerkezetei\nAz 5.8. táblázatban más szempontból mutatjuk az adatszerkezeteket: példát mutatunk adott típusú (adatszerkezetű) objektumok létrehozására, és közöljük, hogy typeof() és class() milyen outputot szolgáltat az így létrehozott objektumok esetében.\nTÁBLÁZAT 5.8: Adatszerkezetek\nkövetkező alfejezetekben részletesen áttekintjük vektor, mátrix, faktor, lista és az adattábla adatszerkezeteket, ugyanis ezek töltik legfontosabb szerepet az adatelemzések során. Mindegyik esetben megvizsgáljuk:hogyan hozhatjuk létre az adott adatszerkezetű objektumot,hogyan tesztelhetjük, hogy az adott típusú objektumról van-e szó,hogyan konvertálhatunk más adatszerkezetekből ilyen típusú objektumot,milyen műveletekben vehet részt,hogyan érhetjük el az objektum részeit, azaz hogyan indexelhetjük az objektumokat.","code":"\nobj.double     <- 12.03\nobj.integer    <- 12L\nobj.karakteres <- \"Péter\"\nobj.logikai    <- TRUE\ntypeof(obj.double);     class(obj.double)\n#> [1] \"double\"\n#> [1] \"numeric\"\ntypeof(obj.integer);    class(obj.integer)\n#> [1] \"integer\"\n#> [1] \"integer\"\ntypeof(obj.karakteres); class(obj.karakteres)\n#> [1] \"character\"\n#> [1] \"character\"\ntypeof(obj.logikai);    class(obj.logikai)\n#> [1] \"logical\"\n#> [1] \"logical\""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-4-summary","chapter":"5 Az R nyelv","heading":"5.3.2.1 Összefoglalás","text":"\nkülönböző típusú konstansokat objektumok létrehozására\nhasználhatjuk fel. statisztikában egy objektumok értéke több konstans\negymásutánja. legegyszerűbb adatszerkezet az R-ben vektor,\namelyben tetszőlegesen sok, azonos típusú értéket helyezhetünk el egy\ndimenzió mentén. faktor és lista egydimenziós,\nmíg mátrix és az adattábla kétdimenziós. \nfaktor integer vektor, amelyben számoknak címkéket\nfeleltetünk meg. lista elemi tetszőleges típusúak lehetnek. \nmátrix ugyanúgy homogén, minta vektor és \nfaktor. Az adattábla felfogható azonos elemszámú\nvektorok/faktorok listájának.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-4-exercise","chapter":"5 Az R nyelv","heading":"5.3.2.2 Feladatok","text":"Próbáljuk ki az 5.8. táblázatban szereplő példákat. Hozzuk létre különböző típusú objektumokat és vizsgáljuk meg typeof() és class() függvényekkel az objektumok típusát.fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"vektor","chapter":"5 Az R nyelv","heading":"5.3.3 Vektor","text":"Az R legalapvetőbb adatszerkezete vektor. vektort egymás melletti (vagy alatti) cellákban tárolt értékek sorozataként képzelhetjük el (5.1. ábra), mely értékek mindegyike azonos típusú. Így azt mondhatjuk, hogy vektor azonos típusú (egynemű, homogén) adatok egydimenziós együttese. vektor fontos jellemzője, hogy homogén, tehát vektort alkotó értékek vagy kizárólag integer, vagy kizárólag double, vagy kizárólag karakteres, vagy kizárólag logikai típusúak lehetnek.","code":""},{"path":"az-r-nyelv.html","id":"vektor-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.3.1 Vektor létrehozása","text":"Vektort legegyszerűbben c() függvénnyel hozhatunk létre, az argumentumlistában egymás felsoroljuk vektort alkotó értékeket. Double vektort hozhatunk létre például, ha paraméterben numerikus konstansokat sorolunk fel:v.d objektum egy 4 elemű double vektor. Az első eleme 2, második eleme 4, harmadik 6 és negyedik egyben utolsó eleme 8. vektor elemei szóközökkel elválasztva jelennek meg konzolban.Karakteres vektort hasonlóan hozhatunk létre, v.k vektor 3 elemű lesz.Egy logikai vektor csak logikai konstansokat tartalmazhat (TRUE vagy FALSE, illetve T és F rövidebb változatot használhatjuk):v.d, v.k és v.l objektum egy-egy példa az R különböző típusú vektoraira. Az objektumok fontos jellemzője az objektum hossza, ami vektorok esetén vektort alkotó elemek számát jelenti. Ezt length() függvénnyel kérdezhetjük le.vektor hosszát létrehozása után módosíthatjuk, szintén length() függvényt használjuk, de az értékadás bal oldalán.v.l logikai vektor már 5 elemű lesz:Mivel nem adtuk meg 4. és 5. elemét, így az NA lesz, ami hiányzó érték jele az R-ben. Az NA minden vektornak eleme lehet, vektor típusától függetlenül.Térjünk vissza vektorok létrehozásához. c() függvény paraméterébe természetesen konstansok helyett tetszőleges kifejezéseket írhatunk:vektorok esetében homogenitás központi szerepet játszik. Az R abban az esetben sem fog különböző típusú elemekből vektort létrehozni, ha ezeket egyetlen c() függvényhívásban szerepeltetjük. Ekkor automatikus típuskonverzió történik. Nézzük ezeknek az eseteit:Amennyiben karakteres konstans szerepel az elemek között, vektor karakteres típusú lesz. Ha numerikus és logikai értéket sorolunk fel, akkor vektor numerikus lesz, azzal kiegészítéssel, hogy TRUE logikai érték 1-re, FALSE pedig 0-ra konvertálódik.További lehetőség c() függvény használata során, hogy paraméterben vektort szerepeltethetünk. Ekkor ezek az elemek szerepelni fognak az eredményvektorban:fenti példában létrehozott uj.v 13 elemű numerikus vektor összerakásához felhasználtunk két 3 elemű vektort és egy kételemű vektort .Vektorok létrehozása során még egy érdekes lehetőségről érdemes szót ejteni. c() függvényben vektor egyes elemeit elnevezhetjük, és ezek nevek az outputban meg fognak jelenni. Az elemek elnevezéséhez írjunk egy nevet és egy egyenlőségjelet az argumentumként használt elem elé. Ha név nem egyetlen szó (vagyis tartalmaz szóközt), akkor karakterkonstansok megadásánál látott három módszer valamelyikét használhatjuk (tehát dupla és szimpla idézőjeleket és az r\"()\" konstrukciót), vagy backtick (`) szimbólumot. Ezzel módszerrel például naponta tanulással töltött időnket úgy rögzíthetjük, hogy az output “beszédesebb” lesz, több információt tartalmaz.vektorelemek nevei lekérdezhetők names() függvénnyel. Amennyiben az értékadás bal oldalán szerepeltetjük, vektor elemneveit tudjuk módosítani.","code":"\nv.d <- c(2, 4, 6, 8); v.d  # numerikus (double) vektor létrehozása\n#> [1] 2 4 6 8\nv.k <- c(\"erős\", 'közepes', \"gyenge\"); v.k # karakteres vektor létrehozása\n#> [1] \"erős\"    \"közepes\" \"gyenge\"\nv.l <- c(TRUE, FALSE, T); v.l  # logikai vektor létrehozása\n#> [1]  TRUE FALSE  TRUE\nlength(v.d); length(v.k); length(v.l)  # vektor hossza\n#> [1] 4\n#> [1] 3\n#> [1] 3\nlength(v.l) <- 5  # vektor hosszának módosítása\nv.l\n#> [1]  TRUE FALSE  TRUE    NA    NA\nv.i <- c(12L, NA, 15L)  # 3 elemű integer vektor; a 2. eleme nem ismert\nszamok <- c(1, (2+3)*4, 1/4, .5^3);        szamok\n#> [1]  1.000 20.000  0.250  0.125\nnevek  <- c(\"Péter\", paste0('Zso', \"lt\")); nevek\n#> [1] \"Péter\" \"Zsolt\"\niteletek <- c(T, 1<2, 2==3);               iteletek\n#> [1]  TRUE  TRUE FALSE\neset.1 <- c(2,4,\"6\",8);    eset.1\n#> [1] \"2\" \"4\" \"6\" \"8\"\neset.2 <- c(T, FALSE,\"6\"); eset.2\n#> [1] \"TRUE\"  \"FALSE\" \"6\"\neset.3 <- c(T, FALSE, 3);  eset.3\n#> [1] 1 0 3\nregi.v.1 <- c(1, 2, 3)\nregi.v.2 <- c(7, 8, 9)\nuj.v <- c(0, regi.v.1, 4, 5, 6, regi.v.2, 10, c(11, 12)); uj.v\n#>  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12\ntan.ido <- c(Hétfő=35, Kedd=95); tan.ido\n#> Hétfő  Kedd \n#>    35    95\ntan.ido <- c(Hétfő=35, \"Kedd délelőtt\"=50, `Kedd délután`=45); tan.ido\n#>         Hétfő Kedd délelőtt  Kedd délután \n#>            35            50            45\nnames(tan.ido)                         # elemnevek lekérdezése\n#> [1] \"Hétfő\"         \"Kedd délelőtt\" \"Kedd délután\"\nnames(tan.ido) <- c(\"H\", \"K.1\", \"K.2\") # elemnevek módosítása\ntan.ido\n#>   H K.1 K.2 \n#>  35  50  45"},{"path":"az-r-nyelv.html","id":"szabalyosvektorokalfejezet","chapter":"5 Az R nyelv","heading":"5.3.3.2 Szabályos vektorok létrehozása","text":"Ha egy vektor elemei szabályos rendben követik egymást, akkor szabályos vektorokról beszélünk. Ilyen lehet például következő három numerikus vektor és két karakteres vektor.Szabályos numerikus vektorokat hozhatunk létre kettőspont (:) operátorral vagy seq() függvénnyel. Az így létrehozott vektorok ugyanis valamilyen számtani sorozat egymást követő elemei, vagyis az egymás mellett lévő elemek különbsége (lépésköz) állandó.","code":"\nc(1, 2, 3, 4, 5); c(1, 3, 5, 7); c(1, 1, 1, 2, 2, 2)\nc(\"férfi\", \"nő\", \"férfi\", \"nő\"); c(\"f.1\", \"f.2\", \"f.3\")"},{"path":"az-r-nyelv.html","id":"a-kettőspont-operátor.","chapter":"5 Az R nyelv","heading":"5.3.3.2.1 A kettőspont operátor.","text":"legegyszerűbb vektorlétrehozási mód kettőspont (:) operátor, ahol az egymást követő elemek távolsága 1 vagy -1. Általános alakja: start:stop.Látható, hogy az így létrehozott vektorok lehetnek csökkenő vagy növekvő rendezettségűek, valamint tört értékeket használhatunk operandusként. sorozat nem feltétlenül kettőspont utáni értékig tart, mindössze annyi igaz, hogy sorozat vége stop értéknél mindig kisebb egyenlő (vagy nagyobb egyenlő, csökkenő sorozat esetén).Hosszabb numerikus vektorokat könnyűszerrel létrehozhatunk. 101:140 parancs hatására 40 elemet hozunk létre. Hosszabb vektorok outputjában könnyebben el tudunk igazodni sorok elején lévő [x] konstrukció segítségével: minden sorban sor első eleme vektor x. eleme. lenti outputban szereplő [17] például azt mutatja, hogy sor elején lévő 117 40 elemű vektor 17. eleme.","code":"\n1:10    # a lépésköz +1, növekvő sorozat\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n10:1    # a lépésköz -1, csökkenő sorozat\n#>  [1] 10  9  8  7  6  5  4  3  2  1\n-1.5:5  # a lépésköz +1, növekvő sorozat\n#> [1] -1.5 -0.5  0.5  1.5  2.5  3.5  4.5\n10.5:3  # a lépésköz -1, csökkenő sorozat\n#> [1] 10.5  9.5  8.5  7.5  6.5  5.5  4.5  3.5\n101:140  # a lépésköz +1, növekvő sorozat\n#>  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116\n#> [17] 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132\n#> [33] 133 134 135 136 137 138 139 140"},{"path":"az-r-nyelv.html","id":"a-seq-függvény","chapter":"5 Az R nyelv","heading":"5.3.3.2.2 A seq() függvény","text":"seq() függvény nagyobb szabadságot ad numerikus sorozatok generálására. Legegyszerűbb használata esetén kettőspont (:) operátort kapjuk vissza:seq() függvény használatához négy argumentum nevét és jelentését kell megtanulnunk: = sorozat első elemét határozza meg, = az utolsó elemet, = lépésközt és length.= létrehozandó vektor elemeinek számát. négy paraméterből három megadása már egyértelműen azonosítja kívánt vektort:seq_along() függvénnyel szintén tudunk 1-től induló, +1-es lépésközű sorozatot alkotni, amelynek utolsó értéke, paraméterben megadott vektor elemszáma.","code":"\nseq(1, 10) # a lépésköz +1, növekvő sorozat\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nseq(from=1, to=10, by=2)           # a lépésköz +2, növekvő sorozat\n#> [1] 1 3 5 7 9\nseq(from=1, to=10, length.out=5)   # a lépésköz +2.25, növekvő sorozat\n#> [1]  1.00  3.25  5.50  7.75 10.00\nseq(to=10, by=-1.3, length.out=5)  # a lépésköz -1.3, csökkenő sorozat\n#> [1] 15.2 13.9 12.6 11.3 10.0\nseq(from=1, by=1.3, length.out=5)  # a lépésköz +1.3, növekvő sorozat\n#> [1] 1.0 2.3 3.6 4.9 6.2\nx <- c(\"Hétfő\", \"Kedd\", \"Szerda\"); y <- 11:20\nseq_along(x) # numerikus vektor 1-től, +1-es lépésközzel, 3 elemű\n#> [1] 1 2 3\nseq_along(y) # numerikus vektor 1-től, +1-es lépésközzel, 10 elemű\n#>  [1]  1  2  3  4  5  6  7  8  9 10"},{"path":"az-r-nyelv.html","id":"a-rep-függvény","chapter":"5 Az R nyelv","heading":"5.3.3.2.3 A rep() függvény","text":"Tetszőleges típusú vektor létrehozására használhatjuk rep() függvényt, amely egy létező vektor értékeit ismétli meg. rep() első paramétere az ismétlendő vektor, times= pedig az ismétlések számát adja meg.fenti példában mindenhol háromszor ismételtük meg az első paramétert, méghozzá úgy, hogy az R egymás után sorolta fel őket.Egy vektor ismétlésének van egy másik esete , amikor az elemeit sorban egyenként véve végezzük el az ismétlést (helyben ismétlés). Ekkor nem times= paramétert, hanem az = argumentumot kell használnunk függvény hívásánál.Látjuk, hogy egyelemű vektorok ismétlése esetén nincs különbség times= és az = paraméterek használata között.Utolsó esetként elemenként szeretnénk ismételni, de eltérő ismétlésszámmal. Ekkor times= paraméterben bemenő vektor elemszámával azonos hosszú vektort kell megadni. Ez vektor tartalmazza az elemek ismétlés számát.Végezetül bemutatjuk, hogy az = és az egyelemű értékkel rendelkező times= egyszerre alkalmazható. Ekkor először helyben ismétlés (=), majd az így kapott vektor teljes ismétlése következik (times=).","code":"\nrep(2, times=3)            # számot ismétlünk 3-szor\n#> [1] 2 2 2\nrep(c(2, 0, -2), times=3)  # numerikus vektort ismétlünk 3-szor\n#> [1]  2  0 -2  2  0 -2  2  0 -2\nrep(\"nap\", times=3)        # sztringet ismétlünk 3-szor\n#> [1] \"nap\" \"nap\" \"nap\"\nrep(c(F, T, T), times=3)   # logikai vektort ismétlünk 3-szor\n#> [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\nrep(2, each=3)            # számot ismétlünk 3-szor\n#> [1] 2 2 2\nrep(c(2, 0, -2), each=3)  # numerikus vektort elemeit ismételjük 3-szor\n#> [1]  2  2  2  0  0  0 -2 -2 -2\nrep(\"nap\", each=3)        # sztringet ismétlünk 3-szor\n#> [1] \"nap\" \"nap\" \"nap\"\nrep(c(F,T,T), each=3)     # logikai vektor elemeit ismételjük 3-szor\n#> [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\nrep(c(2, 3, 4), times=c(1, 2, 3))    # numerikus vektort elemeit ismételjük\n#> [1] 2 3 3 4 4 4\nrep(c(\"nap\", \"part\"), times=c(2, 3)) # karakteres vektort elemeit ismételjük\n#> [1] \"nap\"  \"nap\"  \"part\" \"part\" \"part\"\nrep(c(T, F, T), times=c(2, 3, 4))    # logikai vektort elemeit ismételjük\n#> [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nrep(1:5, each=2, times=3) # kombinált ismétlés\n#>  [1] 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5"},{"path":"az-r-nyelv.html","id":"a-paste-függvény","chapter":"5 Az R nyelv","heading":"5.3.3.2.4 A paste() függvény","text":"Szabályos karakteres vektor létrehozására használhatjuk paste() függvényt. Egy előtaghoz (például f) hozzáfűzhetünk 10 különböző számot, amely így egy 10 elemű karakteres vektort eredményez.Láthatjuk, hogy az f karakter és számok közé egy szóköz került, de ezt sep= argumentummal megváltoztathatjuk:collapse= argumentum használatával, akár egyetlen karakteres értékbe összeolvaszthatjuk fenti elemeket. Az argumentumban az összevonásnál használt elválasztó karaktert adjuk meg.Az eddigiek összefoglalásaként nézzünk példát különböző típusú és elemhosszú vektorok létrehozására.","code":"\npaste(\"f\", 1:10) # 10 elemű sztring vektor\n#>  [1] \"f 1\"  \"f 2\"  \"f 3\"  \"f 4\"  \"f 5\"  \"f 6\"  \"f 7\"  \"f 8\"  \"f 9\"  \"f 10\"\npaste(\"f\", 1:10, sep=\"-\") # gondolatjel az elválasztó\n#>  [1] \"f-1\"  \"f-2\"  \"f-3\"  \"f-4\"  \"f-5\"  \"f-6\"  \"f-7\"  \"f-8\"  \"f-9\"  \"f-10\"\npaste(\"f\", 1:10, sep=\"\")  # nincs elválasztó\n#>  [1] \"f1\"  \"f2\"  \"f3\"  \"f4\"  \"f5\"  \"f6\"  \"f7\"  \"f8\"  \"f9\"  \"f10\"\npaste(\"f\", 1:10, sep=\"-\", collapse=\"_\") # gondolatjel az elválasztó, egy sztring\n#> [1] \"f-1_f-2_f-3_f-4_f-5_f-6_f-7_f-8_f-9_f-10\"\ny <- 12L                        # 1 elemű integer vektor\ny <- 12                         # 1 elemű double vektor\ny <- \"Bízz magadban!\"           # 1 elemű karakteres vektor\ny <- TRUE                       # 1 elemű logikai vektor\ny <- c(23.8, -5)                # 2 elemű double vektor\ny <- c(\"H\", \"K\")                # 2 elemű karakteres vektor\ny <- c(T, FALSE)                # 2 elemű logikai vektor\ny <- c(1, 2, 3, 4, 5)           # 5 elemű double vektor\ny <- 1:5                        # 5 elemű integer vektor\ny <- seq(from=9, to=100, by=2)  # 46 elemű double vektor\ny <- rep(c(\"H\", \"K\"), times=10) # 20 elemű karakteres vektor\nz <- seq_along(y)               # 20 elemű integer vektor\ny <- paste(\"év\", 2001:2020)     # 20 elemű karakteres vektor"},{"path":"az-r-nyelv.html","id":"a-vektoraritmetika-szabályai","chapter":"5 Az R nyelv","heading":"5.3.3.3 A vektoraritmetika szabályai","text":"Amint az előzőekben láttuk, az R rendszer legalapvetőbb adattárolási szerkezete vektor. Az R egyik legnagyszerűbb tulajdonsága pedig az, ahogyan vektorokkal műveleteket végezhetünk. Korábban már láttuk, hogyan tudunk összeadni két számot az R-ben. Próbáljunk meg összeadni két 2 elemű vektort:két fenti vektort parancssorban hoztuk létre c() függvénnyel. Az összeadás eredménye egy 2 elemű vektor. Az eredményvektor az 1+3 és 2+4 műveletek alapján jött létre, vagyis az összeadás operandusaiban szereplő vektor azonos sorszámú elemeire hajtotta végre kijelölt műveletet az R.Két vektor összeadásánál természetesen használhatunk objektumneveket :Itt az eredményvektor 3 elemű, és komponensenkénti művelet végrehajtás szabályainak megfelelően az 1+2, 2+3 és 3+4 összeadások eredménye lesz 3 új elem.Az összeadás műveletet tetszőleges operátorral felcserélhetjük, használhatjuk az összes aritmetikai, relációs és logikai operátort.fenti műveletek közül hatványozás végrehajtása tűnhet kicsit szokatlannak, itt ugyanis egy 3 elemű vektort, mint alapot egy 3 elemű másik vektorra, mint kitevőre emeljük. Ha azonban komponensenkénti végrehajtás szabályát észben tartjuk, akkor világos, hogy az eredményvektor az 1^2, 2^3 és 3^4 eredménye.\nkomponensenkénti végrehajtás szabálya logikai operátorokra érvényes.vektorok közötti műveletek legegyszerűbb esetét tekintettük át eddig, azaz azonos elemszámú vektorokat adtunk össze vagy vontunk ki egymásból. Ha az operátor két oldalán lévő vektorok elemszáma eltér, akkor az általános szabály az, hogy rövidebbik vektort az R megismétli mindaddig, míg hosszabbik vektor elemszámát el nem éri. Ha rövidebbik vektort nem egész számszor megismételve kapjuk hosszabb vektor hosszát, akkor figyelmeztetést kapunk az R-től, melyben erre tényre felhívja figyelmünket, de kijelölt műveletet az R ennek ellenére végrehajtja.fenti példában egy 2 elemű és egy 1 elemű vektort adunk össze. rövidebb vektort még egyszer megismételve már az c(5, 5) vektort kapjuk, így kijelölt összeadás minden fennakadás nélkül végrehajtható. Az eredményvektor az 1+5 és 2+5 összeadások eredménye lesz.egy 2 elemű és egy 3 elemű vektort adunk össze.rövidebbik vektort még egyszer megismételve c(1, 2, 1, 2) vektort kapjuk, de mivel nincs szükség minden elemre, ezért figyelmeztető üzenetet kapunk. Az eredményvektor az 1+3, 2+4 és az 1+5 összeadások eredménye lesz.\nkövetkező példában már nincs figyelmeztetés, hiszen rövidebb vektort egész számszor, pontosan kétszer kellett megismételni koordinátánkénti művelet végrehajtáshoz.Foglaljuk össze vektoraritmetika szabályait:azonos elemszámú vektorok között az azonos pozícióban lévő vektorelemek között hajtódik végre kijelölt művelet (vagyis koordinátánkénti végrehajtás történik),különböző elemszámú vektorok esetében pedig először rövidebbik vektor ismétléssel kiegészül hosszabbik vektor hosszára, és ezt követi koordinátánkénti végrehajtás.Az operátorokon túl az 5.2. táblázatban szereplő matematikai függvények támogatják vektor paramétert. Ekkor nem egyetlen értékkel térnek vissza, hanem bemenő vektor minden elemére kiszámolt függvényértékek vektorával.","code":"\nc(1, 2) + c(3, 4) # két vektor összeadása\n#> [1] 4 6\nx <- c(1, 2, 3); y <- c(2, 3, 4)\nx + y # két vektor összeadása\n#> [1] 3 5 7\nc(1,2) - c(2,3) # két vektor összeadása \n#> [1] -1 -1\nx <- c(1, 2, 3); y <- c(2, 3, 4)\nx - y           # két vektor különbsége\n#> [1] -1 -1 -1\nx * y           # két vektor szorzata\n#> [1]  2  6 12\nx / y           # két vektor hányadosa\n#> [1] 0.5000000 0.6666667 0.7500000\nx ^ y           # x az y-adikon\n#> [1]  1  8 81\nx == y          # x egyenlő y-nal?\n#> [1] FALSE FALSE FALSE\nx < y           # x kisebb, mint y?\n#> [1] TRUE TRUE TRUE\n!c(T, T, F, F)                 # logikai NEM egy vektorra\n#> [1] FALSE FALSE  TRUE  TRUE\nc(T, T, F, F) & c(T, F, T, F)  # logikai ÉS két vektorral\n#> [1]  TRUE FALSE FALSE FALSE\nc(T, T, F, F) | c(T, F, T, F)  # logikai VAGY két vektorral\n#> [1]  TRUE  TRUE  TRUE FALSE\nc(1, 2) + 5  # két eltérő elemszámú vektor összeadása \n#> [1] 6 7\nc(1, 2) + c(3, 4, 5)  # két eltérő elemszámú vektor összeadása \n#> Warning in c(1, 2) + c(3, 4, 5) :\n#>   longer object length is not a multiple of shorter object length\n#> [1] 4 6 6\nc(1, 2) + c(3, 4, 5, 6)  # két eltérő elemszámú vektor összeadása \n#> [1] 4 6 6 8\nsqrt(c(4, 9, 16))              # 3 szám négyzetgyöke\n#> [1] 2 3 4\nlog(x=c(1, 10, 100), base=10)  # 3 szám 10-es alapú logaritmusa\n#> [1] 0 1 2\nx <- 1.3:10; round(x)          # 9 szám egészre kerekítve \n#> [1] 1 2 3 4 5 6 7 8 9"},{"path":"az-r-nyelv.html","id":"függvények-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.4 Függvények vektorokkal","text":"Az előző fejezetben láttuk, hogy matematikai függvények vektor argumentumot elfogadnak, és vektor minden elemére kiszámolják függvényértéket. Míg log(x=16, base=2) függvényhívás matematikában megszokott módon egyetlen bemenő értékhez (16) egyetlen kimenő éréket szolgáltat (4), addig az R lehetőségeit jobban kihasználó log(x = c(1, 2, 4, 8, 16), base=2) függvényhívás négy bemenő értékből (c(1, 2, 4, 8, 16)) négy kimenő érték c(0, 1, 2, 3, 4) állít elő. függvények és vektorok kapcsolatának azonban van egy másik aspektusa, amely szorosan kötődik statisztikai műveletek végrehajtásához.Az R függvények egy nagy csoportja eleve olyan vektort vár az argumentumába, amely több tíz vagy több száz elemet tartalmaz, és tipikusan egyetlen értékkel tér vissza. Ezeket függvényeket vektor alapú függvényeknek nevezzük, és ebbe csoportba tartoznak az R statisztikai mutatókat számoló függvényei . vektor alapú függvényekre az jellemző, hogy bemenő vektor elemeivel egy előre definiált műveletsorozatot hajtanak végre, például összeadják vektor elemeit, kiszámolják az elemek átlagát vagy szórását, és visszatérési értékként ezt az összeget, átlagot vagy szórást szolgáltatják. legfontosabb vektor alapú függvényeket az 5.9. táblázat tartalmazza.\nTÁBLÁZAT 5.9: Függvények vektorokkal\n","code":""},{"path":"az-r-nyelv.html","id":"típusok-kezelése","chapter":"5 Az R nyelv","heading":"5.3.3.5 Típusok kezelése","text":"Minden R vektor típusa négy alaptípus egyike lehet: double, integer, karakteres vagy logikai. Korábban láttuk, hogy class() és typeof() függvények pontos tájékoztatást adnak vektorok típusáról. Létezik azonban egy függvénycsalád, amellyel megvizsgálhatjuk, hogy egy tetszőleges objektum az adott típushoz tartozik-e. Ez az .*() függvénycsalád, amelynek eleme az .double(), .integer(), .logical() ésis.character() függvény. Nézzünk egy példát használatukra.Láttuk korábban, hogy logikai értékek esetében, ha szükséges, automatikus típuskonverzió történik numerikus típusra (TRUE - 1, FALSE - 0). Sok esetben azonban explicit típuskonverzióra van szükség, amit az .*() függvénycsaláddal hajthatunk végre. Vektorok esetében használhatjuk az .double(), .integer(), .logical() vagy .character() függvényeket. Nézzünk ezekre néhány példát.Karakteres értékből könnyen kaphatunk számot, például \"2.9\" vagy \"3\" esetén, viszont az \"\" karakter esetében NA érték kerül az integer vektorba, ahogyan ezt fenti példában láthatjuk.","code":"\nx.d <- c(3.5, 4.1, 9.2)  # új objektum - double vektor\nis.double(x.d)           # x.d vajon double\n#> [1] TRUE\nis.integer(x.d)          # x.d vajon integer\n#> [1] FALSE\nis.character(x.d)        # x.d vajon karakteres\n#> [1] FALSE\nis.logical(x.d)          # x.d vajon logikai\n#> [1] FALSE\nas.double(c(T, F))              # logikai vektorból double \n#> [1] 1 0\nas.integer(c(\"2.9\", \"a\", \"3\"))  # karakteres vektorból integer\n#> [1]  2 NA  3\nas.character(1:5)               # integer vektorból karakteres           \n#> [1] \"1\" \"2\" \"3\" \"4\" \"5\"\nas.logical(0:3)                 # integer vektorból logikai\n#> [1] FALSE  TRUE  TRUE  TRUE"},{"path":"az-r-nyelv.html","id":"az-na-hiányzó-érték","chapter":"5 Az R nyelv","heading":"5.3.3.6 Az NA hiányzó érték","text":"Korábbi példáinkban már felbukkant hiányzó érték, amelyet az R-ben az NA jelöl. Az adatelemzési munkánkat végigkísérik hiányzó adatok. Első lépésként azt jegyezzük meg, hogy az NA hiányzó érték tetszőleges típusú vektorban lehet elem.Egy NA érték jelenlétét vektorban az .na() függvénnyel tudjuk kimutatni. Az .na() argumentuma tetszőleges vektor lehet, visszatérési értéke pedig bemenő vektor elemszámával megegyező logikai vektor. visszatérő logikai vektor csak abban pozícióban tartalmaz TRUE értéket, ahol bemenő vektorban hiányzó adatot találunk.Hiányzó értékeket tartalmazó vektor esetén néhány vektor alapú függvény meglepő eredményt adhat. statisztikai mutatókat számoló függvények rendre NA-val térnek vissza, ha bemenő vektorban van hiányzó érték.Ha kíváncsiak vagyunk az NA értéken kívüli elemek átlagára, akkor egy második paramétert szerepeltetnünk kell mean() függvényben, és minden más statisztikai mutatót számoló függvényben. Az na.rm= argumentum TRUE értéke biztosítja, hogy az átlag számítása során hiányzó értékeket figyelmen kívül hagyjuk.","code":"\nx <- c(2, NA, 4); x              # NA numerikus vektorban\n#> [1]  2 NA  4\nx <- c(NA, \"erős\", \"gyenge\"); x  # NA karakteres vektorban\n#> [1] NA       \"erős\"   \"gyenge\"\nx <- c(T, NA, NA); x             # NA logikai vektorban\n#> [1] TRUE   NA   NA\nx <- c(1, NA, 3, 4, NA)    # két NA a numerikus vektorban\nis.na(x)                   # két TRUE a logikai vektorban\n#> [1] FALSE  TRUE FALSE FALSE  TRUE\nmean(c(2, NA, 3, 4, 2, 5))  # NA-t tartalmazó vektor átlaga NA\n#> [1] NA\nmean(c(2, NA, 3, 4, 2, 5), na.rm=T)  # NA-t tartalmazó vektor átlaga már nem NA\n#> [1] 3.2"},{"path":"az-r-nyelv.html","id":"az-inf-és-a-nan","chapter":"5 Az R nyelv","heading":"5.3.3.7 Az Inf és a NaN","text":"Az R-ben numerikus műveletek eredménye – matematikai értelmezéstől sokszor eltérően – vezethet pozitív vagy negatív végtelen eredményre. Ezeket az Inf és -Inf szimbólumok jelölik, amelyeket különböző kifejezésekben akár mi felhasználhatunk.Néhány esetben numerikus kifejezések eredménye nem értelmezhető számként, ezt az R-ben NaN (Number) jelöli. Ilyen kifejezések például:Egy kifejezés véges vagy végtelen voltát az .finite() vagy .infinite() függvényekkel tesztelhetjük. NaN értékre az .nan() függvénnyel kérdezhetünk rá. Figyeljük meg, NaN értékre, mind az .nan(), mind az .na() függvény TRUE értéket ad.","code":"\n1/0                 # ez a matematikában nem értelmes, de R-ben Inf\n#> [1] Inf\nlog(0)\n#> [1] -Inf\nexp(Inf)\n#> [1] Inf\nmean(c(1, 2, Inf))\n#> [1] Inf\n0/0\n#> [1] NaN\nInf-Inf\n#> [1] NaN\nInf/Inf\n#> [1] NaN\nx <- c(1, NA, NaN, Inf, -Inf)\nis.na(x)           # melyik elem hiányzó\n#> [1] FALSE  TRUE  TRUE FALSE FALSE\nis.nan(x)          # melyik elem nem szám\n#> [1] FALSE FALSE  TRUE FALSE FALSE\nis.infinite(x)     # melyik elem végtelen\n#> [1] FALSE FALSE FALSE  TRUE  TRUE\nis.finite(x)       # melyik elem véges\n#> [1]  TRUE FALSE FALSE FALSE FALSE"},{"path":"az-r-nyelv.html","id":"vektor-indexelése","chapter":"5 Az R nyelv","heading":"5.3.3.8 Vektor indexelése","text":"Fontos részhez érkeztünk, érdemes kicsit lassítanunk. Már nagyon sok mindent megtanultunk vektorokról: egy vektorban egy dimenzió mentén azonos típusú értékeket sorolhatunk fel, amellyel vektoraritmetika szabályai szerint műveleteket tudunk végezni. Például hozzunk létre egy 10 elemű vektort, növeljük meg minden egyes vektorelem értékét 1-gyel.fenti sorok hatására konzolban egy 10 elemű vektor elemei jelennek meg, minden elem 1-gyel nagyobb, mint az x adott eleme. Egyetlen összeadás (+) operátor segítségével valójában 10 összeadás végrehajtását írtuk elő. Vegyük észre, hogy maga az x vektor nem módosult, továbbra az eredeti 11:20 elemeket tartalmazza. Egy objektum ugyanis addig őrzi az értékét, amíg értékadó operátor segítségével felül nem írjük.Tekintsük következő sorokat.Az y vektor 10 elemű, 11:20 értékekkel hoztuk létre. második sorban azonban megváltoztatjuk az y értékét, mert újra az értékadás bal oldalán szerepel az y objektum. Az y új értéke az értékadás jobb oldalán szereplő kifejezés értéke lesz, azaz y+1 összeadás eredménye, ami nem más, mint 12:21. Az y értékének megjelenítésével ellenőrizhetjük, hogy valóban 12:21 elemek kerülnek konzolba.fenti példában y minden értékét megváltoztattuk. Az eredeti 11:20 helyett az új érték 12:21. Az y vektor minden egyes eleme megváltozott, például ahol 11 volt, ott 12 van, ahol 12 volt ott 13. Ha szükség van az eredeti és az új y értékekre akkor kicsit módosítanunk kell az eddigi sorokon.z vektor 10 elemű, 11:20 kezdőértéke, és jól látható, hogy fenti sorok hatására ez nem változik meg, hiszen z újra már nem jelenik meg értékadás bal oldalán. Értékadás jobb oldalán viszont felbukkan, második sorban z.uj objektum létrehozásához használtuk fel z értékét. Az z és z.uj objektumok értékének kiírásával ellenőrizhetjük, hogy z továbbra biztonságosan tárolja 11.20 értékeket, de z.uj-ban kívánt 12:21 módosított értékek megtalálhatók. további munkafázisokban így az eredeti és módosított értékek elérhetők lesznek, ami újdonság, mert az előző példákban ez lehetőség nem volt elérhető. Az x objektumot használó példában csak az eredeti, az y vektoros példában csak módosított értékeket tudnánk későbbiekben használni.Összefoglalva az eddigieket, két tanulságot vonhatunk le. Egyfelől, vektorműveleteknek csak akkor lesz “maradandó” hatása, ha objektumban őrizzük számítás eredményét, azaz értékadást használunk. Ez az objektum lehet kiindulásként használt eredeti objektum (y <- y + 1), de biztonságosabb ha új objektumot hozunk létre az új értékek számára (z.uj <- z + 1), mert így az eredeti értékeket jövőben tudjuk használni. Másfelől, ezek példák ráirányítják figyelmet vektoraritmetika egy nagyszerű jellemzőjére: vektorműveletek megadása független vektor hosszától, nem lesz bonyolultabb egy vektorművelet, például az x+1 összeadás ha x nem 10 elemű, hanem mondjuk 100 hosszú. Az összeadás művelet parancsa 100 elemű vektor esetén csupán x+1, azonban háttérben nem 10, hanem 100 összeadás történik. Akár 10, akár 100 elemű az x, az összes elemre az x segítségével hivatkozhatunk, és az x+1 összeadás az x összes eleméhez hozzáad 1-et.\nDe mit tegyünk, ha nincs szükségünk x összes elemére, vagy nem szeretném x összes elemét megnövelni 1-gyel, csak néhányat. Ekkor indexelést kell használnunk.Az adatfeldolgozás során gyakori, hogy vektor egyes elemeit külön-külön szeretnénk elérni, lekérdezni vagy módosítani. vektor egy tetszőleges részét, egy vagy több elemét az indexelés művelettel érhetjük el, melynek eredménye szintén vektor lesz. Az index operátor jele szögletes zárójel ([]) az R-ben, amit vektor neve után kell írnunk. Vektorok indexelésének általános alakja:Az indexvektor lehet numerikus, karakteres és logikai vektor . Nézzük ezeket sorban.","code":"\nx <- 11:20         # x integer vektor létrehozása\nx + 1              # kiíratjuk az 1-gyel megnövelt értékeket (x nem változik)\n#>  [1] 12 13 14 15 16 17 18 19 20 21\nx                  # x értékének kiírása\n#>  [1] 11 12 13 14 15 16 17 18 19 20\ny <- 11:20         # y integer vektor létrehozása\ny <- y + 1         # megnöveljük 1-gyel y értékeit (y megváltozik)\ny                  # y értékének kiírása \n#>  [1] 12 13 14 15 16 17 18 19 20 21\nz    <- 11:20         # z integer vektor létrehozása\nz.uj <- z + 1         # z.uj double vektor létrehozása (z nem változik)\nz                     # z értékének kiírása\n#>  [1] 11 12 13 14 15 16 17 18 19 20\nz.uj                  # z.uj értékének kiírása\n#>  [1] 12 13 14 15 16 17 18 19 20 21vektor[indexvektor]        # az eredmény egy vektor"},{"path":"az-r-nyelv.html","id":"indexelés-numerikus-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.8.1 Indexelés numerikus vektorokkal","text":"Kezdjük egy 10 elemű x vektor létrehozásával.Megfigyelhetjük, hogy az x vektor 1. eleme 11, 2. 12, az utolsó, 10. pedig éppen 20. Ebben felsorolásban az elemek sorszámai (1., 2., 10.) pontosan vektor indexeit jelentik. vektor indexelése tehát 1-gyel kezdődik, ez az 1. elem indexe, 2. elem indexe 2, az utolsó elemé pedig 10. Ha az index operátorba egy ilyen egyszerű sorszámot írunk, akkor vektor adott indexű elemét érhetjük el.Nem csak lekérdezhetjük, hanem az értékadó operátor segítségével módosíthatjuk valamelyik elemet.Itt először második elemet 100-ra cseréljük, majd harmadikat második kétszeresére. változást ellenőrizhetjük konzolban.Ha az x vektort az elemszámánál nagyobb indexszel próbáljuk elérni, akkor NA értéket kapunk:Vektorokat azonban nem csak egy elemű indexvektorokkal indexelhetünk, hanem két vagy több elemű numerikus vektorokat használhatunk. Ebben az esetben az indexvektorban felsorolt sorszámoknak megfelelő indexű elemeket érhetjük el.fenti példákban látható, hogy az indexelés során létrejött vektorok elemszáma az indexvektor elemszámával egyenlő. Egy indexet akár többször felsorolhatunk, és tetszőleges sorrend megengedett. szögletes zárójelben lévő indexvektort helyben elkészíthetjük c() és seq() függvénnyel (vagy bármilyen más vektorlétrehozó függvénnyel), vagy kettőspont (:) operátorral, de korábban létrehozott objektumot használhatunk indexelésre (x[y]).Az indexelés során több vektorelemet egy lépésben tudunk módosítani. Az indexelt elemek kaphatnak azonos vagy különböző értéket. Itt vektoraritmetika szabályai működnek.fenti példában az x vektor három-három elemét módosítjuk az egyes értékadások során. Az értékadó operátor (<-) engedelmeskedik vektoraritmetika szabályainak, azaz az értékadás bal és jobb oldalán szereplő vektorokat tekinthetjük két olyan vektornak, amelyek között műveletet szeretnénk végrehajtani. Az első értékadásban azonos elemszámú két vektor, koordinátánkénti értékadás azonnal megtörténik (x[c(1, 2, 3)] <- c(110, 120, 130)). másik két értékadásban különbözik két vektor elemszáma, így először ismétléssel kiegészül jobb oldali, rövidebbik vektor, majd ezután következhet koordinátánkénti végrehajtás.Egy vektor indexe mindig egész szám, de az R megengedi, hogy tört értékeket tartalmazó indexvektort szerepeltessünk az index operátorban, ekkor az egész részét veszi az indexeknek, egyszerűen csonkolja őket.Negatív értékeket tartalmazó numerikus vektorral indexelhetünk, ekkor negatív előjellel megadott sorszámokon kívül az összes többi elemet tudjuk elérni vagy módosítani.","code":"\nx <- 11:20; x\n#>  [1] 11 12 13 14 15 16 17 18 19 20\nx[1]     # x vektor 1. eleme\n#> [1] 11\nx[2]     # x vektor 2. eleme\n#> [1] 12\nx[10]    # x vektor 10. eleme\n#> [1] 20\nx[2] <- 100       # x 2. elemének módosítása\nx[3] <- 2*x[2]    # x 3. elemének módosítása\nx\n#>  [1]  11 100 200  14  15  16  17  18  19  20\nx[11]     # x csak 10 elemű, a 11. nem létező elem\n#> [1] NA\nx <- 11:20 \nx[c(1, 3, 5)]               # x vektor 1., 3. és 5. eleme\n#> [1] 11 13 15\nx[c(3, 5, 3, 1)]            # x vektor 3., 5., 3. és 1. eleme\n#> [1] 13 15 13 11\nx[3:6]                      # x vektor 3., 4., 5. és 6. eleme\n#> [1] 13 14 15 16\ny <- c(3,7)\nx[y]                        # x vektor 3. és 7. eleme\n#> [1] 13 17\nx[seq(from=2, to=10, by=2)] # x vektor páros indexű elemei  \n#> [1] 12 14 16 18 20\nx <- 11:20           \nx[c(1, 2, 3)] <- c(110, 120, 130) # x 1., 2. és 3. elemét módosítjuk\nx[c(4, 5, 6)] <- 0                # x 4., 5. és 6. elemét módosítjuk\nx[c(7, 8, 9)] <- c(170, 180)      # x 7., 8. és 9. elemét módosítjuk\nx\n#>  [1] 110 120 130   0   0   0 170 180 170  20\nx <- 11:20\nx[2.3]       # x 2. eleme\n#> [1] 12\nx[2.8]       # x 2. eleme\n#> [1] 12\nx <- 11:15\nx[-3]                         # minden x elem, kivéve a 3.\n#> [1] 11 12 14 15\nx[-c(1, 5)]                   # minden x elem, kivéve az 1. és az 5.\n#> [1] 12 13 14\nx[-(1:3)]                     # minden x elem, kivéve az első 3\n#> [1] 14 15\nx[-2] <- 0                    # minden x elem módosul, kivéve a 2.      \nx\n#> [1]  0 12  0  0  0"},{"path":"az-r-nyelv.html","id":"indexelés-karaketeres-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.8.2 Indexelés karaketeres vektorokkal","text":"Amennyiben egy vektor elemei rendelkeznek névvel, akkor karakteres indexvektorokat használhatunk az indexeléshez. Ez meglehetősen nagy könnyebbséget jelent, ugyanis nem kell ismernünk kívánt elem pozícióját, azaz indexét, elegendő fejben tartanunk az elem nevét. Vegyük példaként tanulók matematika versenyen elért pontszámait tartalmazó vektort.Látható, hogy kívánt elem eléréséhez, például Bori matematika teljesítményéhez nem kell ismernünk Bori pontszámának pozícióját, elegendő névre emlékeznünk.","code":"\nx <- c('Peti'=35, 'Bori'=37, 'Éva'=33)\nx[\"Bori\"]                              # x \"Bori\" nevű eleme\n#> Bori \n#>   37\nx[c(\"Peti\", \"Éva\")]                    # x \"Peti\" és \"Éva\" nevű eleme\n#> Peti  Éva \n#>   35   33\nx[c(\"Peti\", \"Éva\")] <- c(36, 34)       # x fenti 2 elemének módosítása\nx\n#> Peti Bori  Éva \n#>   36   37   34"},{"path":"az-r-nyelv.html","id":"indexelés-logikai-vektorokkal","chapter":"5 Az R nyelv","heading":"5.3.3.8.3 Indexelés logikai vektorokkal","text":"Vektorok indexeléséhez logikai vektorokat használhatunk. Első pillanatban kényelmetlennek, sőt feleslegesnek tűnik ez lehetőség, de következő fejezetben, vektorok szűrésénél, magunk meggyőződhetünk e módszer káprázatos erejérőlA logikai indexvektor működése nagyon egyszerű. Hossza az indexelendő vektor hosszával egyenlő, és TRUE logikai értékkel jelezzük, hogy az adott pozíción lévő elemet el akarjuk érni, FALSE értékkel pedig azt, hogy nincs szükség arra az elemre.fenti példában TRUE szerepel az 1., 3. és 4. pozícióban, így az x vektor 1., 3. és 4. elemeit érhetjük el.Az indexelésre használt logikai vektor elemszáma kisebb lehet, mint az indexelt vektor hossza, ekkor az R az indexvektor ismétlésével kapja meg kívánt hosszt.c(T, F) vektor két elemű, az indexelendő x viszont 5 hosszú, így az R ismétléssel előállítja c(T, F, T, F, T) öt elemű vektort, és ezt használja az x indexeléséhez. Ha csupa TRUE értékű vektorral indexelünk, akkor az x vektor összes elemét megkapjuk, ha pedig csupa FALSE értékkel, akkor az üres vektort kapjuk. Az integer(0) az üres integer vektort jelöli.logikai vektorral indexelt vektorelemeket ugyanúgy módosíthatjuk, mint korábban numerikus és karakteres indexvektorok esetén.","code":"\nx <- 11:15\nx[c(T, F, T, T, F)]    # x vektor 1., 3., és 4. eleme    \n#> [1] 11 13 14\nx <- 11:15\nx[c(T, F)]      # x vektor 1., 3. és 5. eleme\n#> [1] 11 13 15\nx[T]            # x vektor összes eleme\n#> [1] 11 12 13 14 15\nx[F]            # x vektor egyik eleme sem\n#> integer(0)\nx <- 11:15\nx[c(T, F)] <- 0                    # x vektor 1., 3. és 5. elemét módosítjuk\nx[c(F, T, F, T, F)] <- c(120, 140) # x vektor 2. és 4. elemét módosítjuk\nx\n#> [1]   0 120   0 140   0"},{"path":"az-r-nyelv.html","id":"indexelesspecna","chapter":"5 Az R nyelv","heading":"5.3.3.8.4 Indexelés speciális értékekkel","text":"Az indexelésnek van néhány speciális esete, amelyet érdemes ismernünk. Vektorok indexelése során az indexoperátor üresen maradhat, ekkor vektor összes elemét elérhetjük, vagyis az x és x[] kifejezések ugyanazt az outputot adják.fenti példákból kiolvasható, hogy NaN és NA indexként való használata egyetlen NA-t, vagy az x hosszának megfelelő számú hiányzó értéket szolgáltat.Legyünk óvatosak, ha az indexvektor tartalmaz NA értéket, akkor az eredménybe azon pozíción szintén NA fog bekerülni.Kerüljük az értékadást NA-t tartalmazó indexvektor használata esetén. fenti példában az értékadás ugyan nem jelez hibát, és ellenőrizhetjük, hogy valóban megtörtént az első két vektorelem módosítása. Azonban az értékadás jobb oldalán több elemű vektor már nem engedélyezett, például az x[c(1, NA, 2)] <- c(100, 200) értékadás hibaüzenethez vezet. Összefoglalva, minden esetben ellenőrizzük, hogy az indexvektorunk tartalmaz-e NA hiányzó értéket.","code":"\nx <- 11:15\nx[]           # x minden eleme\n#> [1] 11 12 13 14 15\nx[NaN]        # egyetlen NA\n#> [1] NA\nx[NA]         # x elemszámának megfelelő NA   \n#> [1] NA NA NA NA NA\nx <- 11:15\nx[c(1, NA, 2)]          # x 1. eleme, NA és x 2. eleme\n#> [1] 11 NA 12\nx[c(1, NA, 2)] <- 100   # x 1. és 2. elemének módosítása\nx\n#> [1] 100 100  13  14  15"},{"path":"az-r-nyelv.html","id":"vektor-szűrése","chapter":"5 Az R nyelv","heading":"5.3.3.9 Vektor szűrése","text":"Eddig vektorok elemeit pozíciójuk alapján értük el. Akár sorszámot, elemnevet vagy megfelelő pozícióban lévő logikai igaz/hamis értéket használtunk indexelésre, végső soron az számított, hogy az adott elem hol található vektorelemek egydimenziós sorában. Ebben fejezetben egy teljes más kiinduló pontot használunk vektorelemek elérésére és ez vektor tartalma lesz, vagyis vektorelem konkrét értéke (és nem pozíciója).Bővítsük ki matematika pontszámokat tartalmazó vektorunkat, rögzítsük hat tanuló eredményét.Ha arra vagyunk kíváncsiak, hogy kik értek el 36 pontnál többet versenyen és milyen pontszámokkal, akkor rövid áttekintés után megadhatjuk választ, sőt pozíció alapján könnyen elvégezhetjük az alábbi indexeléseket .fenti sorok az eddigiekhez képest semmilyen újdonságot nem tartalmaznak, lényegében összefoglalják pozíció alapú indexelésről tanultakat. Felmerülhet bennünk kérdés, ha x nem hat elemű, hanem 60 vagy esetleg 600, akkor mennyi esélyünk lenne az indexelt kifejezések előállítására. Nem sok.Adódik azonban egy másik lehetőség, amely közvetlenül abból indul ki, hogy 36 pontnál nagyobb vektorelemeket keressük. Logikai művelettel ezt következőképp fogalmazhatjuk meg.Korábban láttuk, hogy ez művelet vektoraritmetikai szabályainak engedelmeskedve két lépésben értelmezhető: (1) mivel különböző elemhosszú két vektor, x hat elemű, 36 egy elemű, először jobb oldal hat elemű lesz (c(36, 36, 36, 36, 36, 36)), majd (2) koordinátánként relációs művelet végrehajtásra kerül, azaz x minden eleméről döntés születik, hogy nagyobb-e, mint 36. relációs művelet eredménye egy hat elemű logikai vektor, amely pontosan ott TRUE, ahol az illető x elem nagyobb 36-nál, minden más helyen pedig FALSE. Esetünkben Bori és Ili elemeknél jelenik meg TRUE, vagyis 2. és 6. pozícióban. Vegyük észre, hogy ez pontosan az logikai vektor, mint amit korábban hoztunk létre pozíció alapú indexelés egyik példájaként (x[c(F, T, F, F, F, T)]).relációs művelet eredményét, mint logikai vektort, kiválóan fel tudjuk használni az indexelésben 36 pontnál nagyobb vektorelemek eléréséhez.fenti sor az első példa szűrésre. szűrés lényegében logikai vektorral való indexelés, ahol logikai indexvektort egy olyan logikai kifejezés állítja elő, amely hivatkozik vektor tartalmára. definíciót értelmezve példára: logikai vektor, amely alapján az indexelés történik c(F, T, F, F, F, T), logikai kifejezés, amely ezt előállítja az x>36, vektor tartalmára pedig természetesen az x objektumnévvel utalunk logikai kifejezésen belül.szűrés nagyszerűen kezeli vektorhosszal kapcsolatban korábban felvetett problémánkat. Ha az x nem hat, hanem 60 vagy 600 elemű, akkor az x[x>36] végzi 36-nál nagyobb elemek leválogatását.Próbáljuk ki szűrést nagyobb elemszám esetén . Generáljunk 60 véletlen értékeket 0-40 értéktartományból, úgy mintha 60 tanuló matematika pontszáma állna rendelkezésre. sample() függvény az x= argumentumában megadott értékekből, size=-ban megadott darabszámnyit állít elő. replace=T argumentummal gondoskodunk arról, hogy egy érték többször szerepelhessen az eredményvektorban.pontszamok vektor 60 elemű, az első 10 értékét képernyőn láthatjuk. 36-nál nagyobb elemek megjelenítését szűréssel végeztük. Látható, hogy szűrés nem lett bonyolultabb vektor hosszának növekedésével.Más relációs operátorokat (5.6. táblázat) használhatunk szűrésben, sőt logikai operátorok (5.7. táblázat) segítségével tetszőleges természetes nyelven megfogalmazott feltételt át tudunk fordítani R logikai kifejezésbe. logikai operátorokat tartalmazó logikai kifejezéseket összetett logikai kifejezéseknek nevezzük. Írassuk ki pontszámokat 36 és 39 között, majd 3 és 6 között, és végül mindezeket együtt.Időnként szükségünk lehet arra az információra, hogy vektorban melyik pozícióban vannak feltételnek eleget tevő vektorelemek. Erre feladatra () függvényt használhatjuk. () függvény bemenő paraméterként egy logikai vektort vár, visszatérési értéke pedig TRUE logikai értékek indexe lesz.Térjünk vissza matematika pontszámokhoz.Az outputokban nem látjuk tanulók pontszámát, tehát nem szűrés () célja, azoknak vektorelemeknek az indexét látjuk, amelyek az egyszerű vagy összetett logikai kifejezéseknek eleget tesznek.Végezetül tekintsük át szűrés és az értékadás kapcsolatát. Az adatelemzés során előfordulhat, hogy bizonyos feltételnek eleget tevő elemeket módosítani szeretnénk. Például, ha egy vektorban előzetesen hiányzó értékeket 99-cel jelöljük, akkor későbbi hibamentes elemzéshez NA-ra kell módosítanunk ezeket az értékeket.Az x így már helyes módon tartalmazza hiányzó értékeket. Ha esetleg később kiderül ezeknek az elemeknek tényleges értéke, akkor az NA-t kell helyettesítenünk új értékekkel. Vigyázzunk, az x == NA kifejezés helytelen hiányzó értékek tesztelésére, erre az .na() függvényt kell használnunk.Az x vektorban két hiányzó érték volt, így fenti értékadás jobb oldalán két elemű vektort használunk. Ha mindkét hiányzó értéket azonos számmal szeretnénk felülírni, akkor elegendő lenne x[.na(x)] <- 7 kifejezés .Korábban már említettük (5.3.3.8.4. alfejezetben, hogy kerüljük az értékadást NA-t tartalmazó indexvektor használata esetén. Azonban nem minden esetben tudunk kitérni az ilyen esetek elől. Növeljük meg hiányzó értékeket tartalmazó x vektor azon elemeit 1-gyel, amelyek 36-nál kisebbek! nyilvánvalónak látszó x[x < 36] <- x[x < 36] + 1 parancs helytelen, hibaüzenetet ad. Az értékadás mindkét oldalán logikai kifejezésekhez fűzzük hozzá & !.na(x) kifejezést, így tudjuk az NA értékeket eltávolítani az értékadás mindkét oldaláról.","code":"\nx <- c('Peti'=35, 'Bori'=37, 'Éva'=33, 'Pál'=21, 'Gergő'=34, 'Ili'=40)\nx\n#>  Peti  Bori   Éva   Pál Gergő   Ili \n#>    35    37    33    21    34    40\nx[c(2, 6)]               # indexelés numerikus vektorral\n#> Bori  Ili \n#>   37   40\nx[c(\"Bori\", \"Ili\")]      # indexelés karakteres vektorral\n#> Bori  Ili \n#>   37   40\nx[c(F, T, F, F, F, T)]   # indexelés logikai vektorral\n#> Bori  Ili \n#>   37   40\nx > 36        # relációs művelet, logikai vektort eredményez\n#>  Peti  Bori   Éva   Pál Gergő   Ili \n#> FALSE  TRUE FALSE FALSE FALSE  TRUE\nx[x > 36]       # x vektor szűrése (36-nál nagyobb elemek leválogatása)\n#> Bori  Ili \n#>   37   40\npontszamok <- sample(x = 0:40, size = 60, replace = T) # véletlen értékek\npontszamok[1:10]               # vektor első 10 eleme\n#>  [1]  7 37 22  1 20 16  6 36 20 26\npontszamok[pontszamok > 36]    # vektor szűrése\n#> [1] 37 39 37 37 40 38 39 37\npontszamok[pontszamok>=36 & pontszamok<=39]\n#> [1] 37 36 39 37 37 38 39 37\npontszamok[pontszamok>=3 & pontszamok<=6]\n#> [1] 6 3 3 6\npontszamok[(pontszamok>=36 & pontszamok<=39) | (pontszamok>=3 & pontszamok<=6)]\n#>  [1] 37  6 36 39 37  3  3 37  6 38 39 37\nx <- c('Peti'=35, 'Bori'=37, 'Éva'=33, 'Pál'=21, 'Gergő'=34, 'Ili'=40)\nwhich(x > 36)             # hol vannak 36-nál nagyobb elemek\n#> Bori  Ili \n#>    2    6\nwhich(36 <= x & x <= 39)  # hol vannak 36-39 közötti elemek\n#> Bori \n#>    2\nwhich(x == 21)            # hol van a 21-es elem\n#> Pál \n#>   4\nwhich(x != 21)            # hol van nem 21-es elem\n#>  Peti  Bori   Éva Gergő   Ili \n#>     1     2     3     5     6\nx <- c(11, 3, 99, 4, 99)   # nyers vektor, a 99 jelentése hiányzó érték\nx[x == 99] <- NA           # 99 átírása NA-ra\nx\n#> [1] 11  3 NA  4 NA\nx[is.na(x)] <- c(5, 7)    # hiányzó értékek módosítása\nx\n#> [1] 11  3  5  4  7\nx <- c(33, NA, 32, 38, NA, 37)\nx[x < 36 & !is.na(x)] <- x[x < 36 & !is.na(x)] + 1"},{"path":"az-r-nyelv.html","id":"vektor-rendezése","chapter":"5 Az R nyelv","heading":"5.3.3.10 Vektor rendezése","text":"Egy vektor elemeit növekvő vagy csökkenő sorrendbe rendezhetjük. Az R-ben vektor elemeit sort() vagy az order() függvénnyel rendezhetjük.sort() függvény alapértelmezés szerint növekvő sorrendbe rendezi bemeneti vektort, ha azonban decreasing= paramétert TRUE-ra állítjuk, csökkenő rendezést kapunk. rev() függvénnyel, amely bementi vektor elemeit fordított sorrendben sorolja fel, szintén elérhetjük csökkenő rendezettséget.Ha sort() függvénnyel átrendezett vektort továbbiakban fel szeretnénk használni, akkor azt érdemes új objektumban tárolni (x.2 <- sort(x)).vektor rendezésének másik módja az order() függvényhez kapcsolódik. visszatérési érték ekkor egy numerikus indexvektor, amellyel bemenő vektort indexelve rendezett vektort kapunk.Az order() függvény esetében használhatjuk decreasing= paramétert, amellyel csökkenő sorrendbe rendezhetjük vektorunkat.numerikus vektorokon túl karakteres és logikai vektorokat sorba rendezhetjük sort() és order() függvényekkel.","code":"\nx <- c(1:5, 5:3); x\n#> [1] 1 2 3 4 5 5 4 3\nsort(x)               # x elemei növekvő sorrendben\n#> [1] 1 2 3 3 4 4 5 5\nsort(x, decreasing=T) # x elemei csökkenő sorrendben, vagy: rev(sort(x))\n#> [1] 5 5 4 4 3 3 2 1\nx <- c(1:5, 5:3); x\n#> [1] 1 2 3 4 5 5 4 3\norder(x)                    # indexekkel tér vissza\n#> [1] 1 2 3 8 4 7 5 6\nx[order(x)]                 # azonos a sort(x)-szel\n#> [1] 1 2 3 3 4 4 5 5\nx[order(x, decreasing=T)]   # azonos a sort(x, decreasing=T)-val\n#> [1] 5 5 4 4 3 3 2 1"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-5-summary","chapter":"5 Az R nyelv","heading":"5.3.3.11 Összefoglalás","text":"\nGratulálunk! Maratoni alfejezetünk végigolvasásával jelentős lépést\ntett meg az Olvasó magabiztos R ismeretek megszerzéséhez. vektor\nminden adatelemzési munka alapja, biztos kezelése kulcsfontosságú.\nTetszőleges vektor létrehozásához c() függvényt\nhasználhatjuk, és az elemeket akár nevesíthetjük . Szabályos vektort \nseq(), seq_along(), rep() és \npaste() függvénnyel, vagy kettőspont (:)\noperátorral készíthetünk. Megbeszéltük vektorok közötti műveletek\nvégrehajtásának fő szabályát: ismétléssel hozzuk azonos hosszra \nvektorokat ha szükséges, majd koordinátánként végezzük el kívánt\nműveletet. vektorokat támogatják matematikai függvények , minden\nvektorelemre meghívódik függvény. statisztikai függvények szintén\nvektort várnak, de többnyire egy értéket szolgáltatnak. vektorok\ntípusának tesztelése az .(), konvertálása pedig az\n.() függvényekkel történik. vektorok indexelésével\n(vektor[indexvektor]) vektor elemeit pozíció alapján, \nvektorok szűrésével (vektor[logikai-indexvektor]) vektor\nelemeit érték alapján érhetjük el vagy módosíthatjuk. vektorok\nrendezését sort() és az order() függvénnyel\nelvégezhetjük.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-5-exercise","chapter":"5 Az R nyelv","heading":"5.3.3.12 Feladatok","text":"Hozzuk létre következő numerikus vektort: 12, 14, 17.Hozzuk létre következő karakteres vektort: “Vác”, “Eger”, “Pécs”.Hozzuk létre következő logikai vektort: TRUE, FALSE, FALSE.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és különbség 1.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 102, az utolsó 8 és különbség -1.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és különbség 2.Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, különbség 3 és vektor 25 elemű.Hozzuk létre azt numerikus vektort, amely 12 elemű, és minden elemének -2 az értéke!Hozzuk létre azt karakteres vektort, amely 7 elemű, és minden elemének “Péntek” az értéke!Hozzuk létre azt logikai vektort, amely 7 elemű, és minden elemének TRUE az értéke!Hozzuk létre azt numerikus vektort, amely 2, 3, 5 elemeket háromszor egymás után megismétli! Hány elemű az így létrejött vektor?Hozzuk létre azt numerikus vektort, amely 2, 3, 5 elemeket háromszor helyben megismétli! Hány elemű az így létrejött vektor?Hozzuk létre azt numerikus vektort, amely 2, 3, 5 elemeket helyben megismétli úgy, hogy 2-őt 4-szer, 3-5-ször és az 5-öt 7-szer ismétli meg! Hány elemű az így létrejött vektor?Szabályos vektorok létrehozásának van egy korábban még nem említett módja: sequence() függvény. Ismerjük meg súgóból ezt függvényt, és értelmezzük sequence(4) és sequence(c(4,5)) függvényhívásokat!Vektorok létrehozásának számos módját megismertük ebben fejezetben, de elemek megadása nélkül, vagy akár nulla hosszúsággal létrehozhatunk vektort. double(), integer(), character() és logical() függvények közvetlenül az adott típusnak megfelelő vektort hozzák létre. súgó tanulmányozásával állítsunk elő 0 és 10 elemű vektor objektumokat mind négy típus esetén.Próbáljuk ki az 5.9. táblázatban szereplő példákat.Hozzuk létre 'Peti'=5, 'Bori'=NA, 'Éva'=3, 'Pál'=NA, 'Gergő'=5, 'Ili'=4 adatokat tartalmazó vektort, majd rendezzük, indexeljük az első és az utolsó elemét, válogassuk le az 5-ös értékeket, csökkentsük mindegyik értéket 1-gyel, csak az 5-öket csökkentsük 1-gyel.fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"mátrix","chapter":"5 Az R nyelv","heading":"5.3.4 Mátrix","text":"mátrix adatszerkezet egyetlen lényeges dologban különbözik vektortól: mátrix kétdimenziós, sorokba és oszlopokba szervezi az elemeket, míg vektor egydimenziós (érdemes visszalapozni 5.1. ábrához). mátrix ugyanúgy homogén, mint vektor, ennek megfelelően beszélünk double, integer, karakteres és logikai mátrixokról.","code":""},{"path":"az-r-nyelv.html","id":"mátrix-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.4.1 Mátrix létrehozása","text":"Mátrix létrehozásához matrix() függvényt használjuk, amely egy kiinduló vektor elemeit használja fel mátrix feltöltéséhez. data= argumentumban kell megadnunk kiinduló vektort, majd az nrow= és/vagy ncol= argumentumokban közöljük sorok és oszlopok számát.fenti példában 20 elemű vektort 4 sorban rendezi el matrix() függvény, ennek megfelelően 5 oszlopos lesz az x mátrix. matrix() függvényben az ncol= paraméter használható.Az ncol=5 szerepeltetése nem jelent változást az előző példához képest, az x mátrix 4 sort és 5 oszlopot fog tartalmazni, rövidebben 4 \\(\\times\\) 5-ös. következő sorban az ncol=10 argumentum már egy 40 elemű mátrix létrehozását kezdeményezi (4 \\(\\times\\) 10-es), így az 1:20 vektor ismétlésével állnak elő szükséges elemek. (Figyelmeztetést kapunk, ha szükséges mátrixelemszám eléréséhez nem egész számszor kell ismételni kiinduló vektort, de mátrix ebben az esetben létre fog jönni.)fenti példában azt megfigyelhetjük, hogy 20 elemű vektorból oszlop-folytonosan jön létre mátrix, vagyis először az első oszlop töltődik fel vektorelemekkel, majd második, és így tovább. Ha sor-folytonosan szeretnénk bemenő vektor elemeiből mátrixot képezni, akkor byrow= paramétert igazra kell állítanunk.Mátrixot karakteres vagy logikai értékekből építhetünk.Az előző fejezetben láttuk, hogy vektorok elemeinek nevet adhatunk, így olvashatóbbá tehetjük rögzített adatainkat. matrix() függvény dimnames= argumentumában az egyes sorok és oszlopok elnevezéséről, valamint két dimenzió nevéről gondoskodhatunk.dimnames= argumentum dimenzió-, sor- és oszlopneveket listába rendezve várja. listákról 5.3.6. fejezetben olvashatunk. sor- és oszlopnevek megadásánál tartsuk az objektumok elnevezésével kapcsolatos szabályokat, azaz betűvel kezdjünk, kerüljük szóközt és egyéb írásjeleket, tagolásra pontot használjuk.Létező mátrix esetén rownames() és colnames() függvényekkel tudjuk sor- és oszlopneveket lekérdezni, illetve módosítani. Az egyes dimenziónevek módosítására names(dimnames(x)) konstrukciót használhatjuk.","code":"\nx <- matrix(data=1:20, nrow=4)        # 4x5-ös integer mátrix\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nx <- matrix(data=1:20, nrow=4, ncol=5)        # 4x5-ös integer mátrix\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nx <- matrix(data=1:20, nrow=4, ncol=10)       # 4x10-es integer mátrix\nx\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17    1    5    9   13    17\n#> [2,]    2    6   10   14   18    2    6   10   14    18\n#> [3,]    3    7   11   15   19    3    7   11   15    19\n#> [4,]    4    8   12   16   20    4    8   12   16    20\nx <- matrix(1:12, nrow=3, byrow=T)  # 3x4-es integer mátrix, sor-folytonosan\nx\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    2    3    4\n#> [2,]    5    6    7    8\n#> [3,]    9   10   11   12\nmatrix(c(\"az\",\"egy\"), nrow=2, ncol=3, byrow=T) # 2x3-as karakteres mátrix\n#>      [,1]  [,2]  [,3] \n#> [1,] \"az\"  \"egy\" \"az\" \n#> [2,] \"egy\" \"az\"  \"egy\"\nmatrix(c(T,F,T), nrow=2, ncol=6, byrow=T)      # 2x6-os logikai mátrix   \n#>      [,1]  [,2] [,3] [,4]  [,5] [,6]\n#> [1,] TRUE FALSE TRUE TRUE FALSE TRUE\n#> [2,] TRUE FALSE TRUE TRUE FALSE TRUE\nx <- matrix(0, nrow = 2, ncol = 3, \n      dimnames = list('1. dim. neve'=c(\"sor.1\", \"sor.2\"),\n                      '2. dim. neve'=c(\"oszl.1\", \"oszl.2\", \"oszl.3\")))\nx\n#>             2. dim. neve\n#> 1. dim. neve oszl.1 oszl.2 oszl.3\n#>        sor.1      0      0      0\n#>        sor.2      0      0      0\nrownames(x)                           # sornevek lekérdezése\n#> [1] \"sor.1\" \"sor.2\"\ncolnames(x)                           # oszlopnevek lekérdezése\n#> [1] \"oszl.1\" \"oszl.2\" \"oszl.3\"\nrownames(x) <- c(\"eset.1\", \"eset.2\")  # sornevek módosítása\ncolnames(x) <- c(\"o.1\", \"o.2\", \"o.3\") # oszlopnevek módosítása\nx\n#>             2. dim. neve\n#> 1. dim. neve o.1 o.2 o.3\n#>       eset.1   0   0   0\n#>       eset.2   0   0   0\nnames(dimnames(x)) <- c(\"esetek\", \"oszlopok\") # dimenziónevek módosítása\nx\n#>         oszlopok\n#> esetek   o.1 o.2 o.3\n#>   eset.1   0   0   0\n#>   eset.2   0   0   0"},{"path":"az-r-nyelv.html","id":"mátrix-indexelése","chapter":"5 Az R nyelv","heading":"5.3.4.2 Mátrix indexelése","text":"mátrixok indexelése nagyon hasonló vektorok indexeléséhez. Itt az index operátort ([]) kell használnunk, de két dimenzió miatt vesszővel választjuk el sorra és az oszlopra vonatkozó indexeket. Mátrix indexelésének általános alakja:sor-indexvektorra és az oszlop-indexvektorra ugyanazok szabályok érvényesek, mint vektor esetén az indexvektorra. Használhatunk numerikus, karakteres és logikai egy vagy több elemű vektort, numerikus indexeknél negatív értéket, és természetesen el hagyhatjuk az egyes dimenziók indexvektorait. Nézzünk ezekre néhány példát.mátrix indexelése során kapott új adatszerkezetek elveszthetik kétdimenziós jellegüket és így mátrix helyett vektor lehet az indexelés eredménye. Ha ezt el akarjuk kerülni, használjuk drop=FALSE paramétert az indexben, ekkor minden esetben mátrix lesz az eredmény.Amennyiben mátrixunk sor- és oszlopnevekkel rendelkezik, akkor ezeket felhasználhatjuk az indexelés során.","code":"# mátrix indexelése, az eredmény egy mátrix vagy egy vektor\nmátrix[sor-indexvektor, oszlop-indexvektor]\nx <- matrix(1:10, nrow=2, ncol=5, byrow=T)\nx\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    6    7    8    9   10\nx[2, 3]                 # 1 elem elérése, vektor output\n#> [1] 8\nx[2, c(1,4)]            # 2 elem elérése, vektor output\n#> [1] 6 9\nx[, c(1,4)]             # 4 elem elérése, 2x2-es mátrix output\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    6    9\nx[, -c(1,4)]            # 6 elem elérése, 2x3-as mátrix output\n#>      [,1] [,2] [,3]\n#> [1,]    2    3    5\n#> [2,]    7    8   10\nx[1, ]                  # 5 elem elérése, vektor output\n#> [1] 1 2 3 4 5\nx[c(2, 1), c(T, F, T)]  # 6 elem elérése, 2x3-as mátrix output\n#>      [,1] [,2] [,3]\n#> [1,]    6    8    9\n#> [2,]    1    3    4\nx[2, 3, drop=F]             # 1 elem elérése, 1x1-es mátrix output\n#>      [,1]\n#> [1,]    8\nx[2, c(1,4), drop=F]        # 2 elem elérése, 1x2-es mátrix output\n#>      [,1] [,2]\n#> [1,]    6    9\nx[2, , drop=F]              # 5 elem elérése, 1x5-ös mátrix output\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    6    7    8    9   10\nx[, 3, drop=F]              # 2 elem elérése, 2x1-es mátrix output\n#>      [,1]\n#> [1,]    3\n#> [2,]    8\nx <- matrix(1:10, nrow=2, ncol=5, byrow=T)\nrownames(x) <- c(\"eset1\", \"eset2\")\ncolnames(x) <- paste(\"v\", 1:5, sep=\".\")\nx\n#>       v.1 v.2 v.3 v.4 v.5\n#> eset1   1   2   3   4   5\n#> eset2   6   7   8   9  10\nx[\"eset1\", c(\"v.2\", \"v.1\")]           # 2 elem elérése, vektor output\n#> v.2 v.1 \n#>   2   1\nx[1:2, c(\"v.2\", \"v.1\")]               # 4 elem elérése, 2x2-es mátrix\n#>       v.2 v.1\n#> eset1   2   1\n#> eset2   7   6\nx[\"eset2\", paste(\"v\", 1:3, sep=\".\")]  # 3 elem elérése, vektor\n#> v.1 v.2 v.3 \n#>   6   7   8\nx[\"eset1\", c(T,F), drop=F]            # 3 elem elérése, 1x3-as mátrix\n#>       v.1 v.3 v.5\n#> eset1   1   3   5"},{"path":"az-r-nyelv.html","id":"számítások-a-mátrix-soraiban-és-oszlopaiban","chapter":"5 Az R nyelv","heading":"5.3.4.3 Számítások a mátrix soraiban és oszlopaiban","text":"Az előző részben említettük, ha üresen hagyjuk mátrix sor vagy oszlop pozícióját az indexelés során, akkor mátrix teljes oszlopára vagy sorára tudunk hivatkozni, vagyis alapesetben vektort kapunk. Az így kapott vektorokkal tetszőleges műveleteket hajthatunk végre. Hozzunk létre egy 3 \\(\\times\\) 4-es mátrixot, amely 3 tanuló átlagát tartalmazza 4 tantárgyból.Négy speciális függvénnyel az oszlopok és sorok összegét és átlagát számíthatjuk ki.Általánosabb megoldás, ha az apply() függvényt használjuk, amelyben mátrix soraira vagy oszlopaira vonatkozó függvényt mi határozzuk meg, így az összegzésen és az átlagszámításon kívül más függvényeket elérhetünk. Az apply() első paramétere maga mátrix, második helyen pedig 1 vagy 2 áll, attól függően, hogy mátrix soraira (1) vagy oszlopaira (2) akarjuk harmadik paraméterben szereplő függvényt alkalmazni.Hiányzó értékek esetén fenti függvények NA értéket adnak eredményül, így itt szükséges az na.rm=T argumentum szerepeltetése.","code":"\nx <- matrix(c(3.7, 5.3, 5.1, 4.2, 4.4, 3.8, 2.9, 4.2, 5.1, 4, 3, 5), \n            nrow=3, ncol=4, byrow=T, \n            dimnames = list(c(\"Pál\", \"Ili\", \"Éva\"),\n                            c(\"matek\", \"magyar\", \"angol\", \"ének\")))\nx\n#>     matek magyar angol ének\n#> Pál   3.7    5.3   5.1  4.2\n#> Ili   4.4    3.8   2.9  4.2\n#> Éva   5.1    4.0   3.0  5.0\nmean(x[1,])      # Pál féléves átlaga    \n#> [1] 4.575\nsd(x[,4])        # énekből a csoport átlaga \n#> [1] 0.4618802\nrowSums(x)      # sorösszegek, a tanulók jegyeinek összege\n#>  Pál  Ili  Éva \n#> 18.3 15.3 17.1\nrowMeans(x)     # sorátlagok, a tanulók félév végi átlaga\n#>   Pál   Ili   Éva \n#> 4.575 3.825 4.275\ncolSums(x)      # oszlopösszegek, a tantárgyak jegyeinek összege\n#>  matek magyar  angol   ének \n#>   13.2   13.1   11.0   13.4\ncolMeans(x)     # oszlopátlagok, a tantárgyak átlaga\n#>    matek   magyar    angol     ének \n#> 4.400000 4.366667 3.666667 4.466667\napply(x, 1, mean)    # sorátlagok, a tanulók félév végi átlaga\n#>   Pál   Ili   Éva \n#> 4.575 3.825 4.275\napply(x, 1, sd)      # soronkénti szórások\n#>       Pál       Ili       Éva \n#> 0.7544314 0.6652067 0.9844626\napply(x, 1, min)     # soronkénti minimumok\n#> Pál Ili Éva \n#> 3.7 2.9 3.0\napply(x, 2, mean)    # oszlopátlagok, a tantárgyak átlaga\n#>    matek   magyar    angol     ének \n#> 4.400000 4.366667 3.666667 4.466667\napply(x, 2, sd)      # oszloponkénti szórások\n#>     matek    magyar     angol      ének \n#> 0.7000000 0.8144528 1.2423097 0.4618802\napply(x, 2, min)     # oszloponkénti minimumok\n#>  matek magyar  angol   ének \n#>    3.7    3.8    2.9    4.2\nx[\"Pál\", \"matek\"] <- NA     # módosítjuk Pál matek jegyét hiányzóra\nrowMeans(x)                 # Pálnál NA lesz   \n#>   Pál   Ili   Éva \n#>    NA 3.825 4.275\napply(x, 1, mean)           # Pálnál NA lesz   \n#>   Pál   Ili   Éva \n#>    NA 3.825 4.275\nrowMeans(x, na.rm=T)        # így jó Pálnál is   \n#>      Pál      Ili      Éva \n#> 4.866667 3.825000 4.275000\napply(x, 1, mean, na.rm=T)  # így jó Pálnál is\n#>      Pál      Ili      Éva \n#> 4.866667 3.825000 4.275000"},{"path":"az-r-nyelv.html","id":"sorok-és-oszlopok-kezelése","chapter":"5 Az R nyelv","heading":"5.3.4.4 Sorok és oszlopok kezelése","text":"Mátrixokat az rbind() és cbind() függvényekkel építhetünk.Vektor paraméterek esetén, felsorolt vektorok fogják alkotni az új mátrix oszlopait (cbind() esetén), illetve sorait (rbind() esetén), rövidebb vektor, ha van ilyen, ismétlődni fog.Új oszloppal vagy új sorral kiegészíthetjük már létező mátrixunkat.Tetszőleges pozícióba beszúrhatunk egy oszlopot vagy egy sort. Ehhez első lépésben létező x mátrixhoz hozzáillesztjük az új oszlopot vagy sort, majd indexeléssel átrendezzük az oszlopokat vagy sorokat.Hasznos lehetőség összesítő sorok vagy oszlopok mátrixhoz fűzése és elnevezése:sorok vagy oszlopok sorrendjét megcserélhetjük mátrixban, valamint ezek törlésére van lehetőségünk:","code":"\ncbind(1, 1:2, 1:4)    # mátrix létrehozása oszlopvektorokból\n#>      [,1] [,2] [,3]\n#> [1,]    1    1    1\n#> [2,]    1    2    2\n#> [3,]    1    1    3\n#> [4,]    1    2    4\nrbind(1, 1:2, 1:4)    # mátrix létrehozása sorvektorokból\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    1    1    1\n#> [2,]    1    2    1    2\n#> [3,]    1    2    3    4\nx <- matrix(1:12, nrow=4, ncol=3); x\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]    4    8   12\ncbind(-3:0, x, 13:16)  # oszlopvektorok hozzáfűzése x elé és mögé\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   -3    1    5    9   13\n#> [2,]   -2    2    6   10   14\n#> [3,]   -1    3    7   11   15\n#> [4,]    0    4    8   12   16\nrbind(-1, x, 1)        # sorvektorok hozzáfűzése x fölé és alá      \n#>      [,1] [,2] [,3]\n#> [1,]   -1   -1   -1\n#> [2,]    1    5    9\n#> [3,]    2    6   10\n#> [4,]    3    7   11\n#> [5,]    4    8   12\n#> [6,]    1    1    1\ncbind(x, 13:16)[, c(1,2,4,3)]   # oszlopvektor hozzáfűzése, majd oszlopok indexelése\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    5   13    9\n#> [2,]    2    6   14   10\n#> [3,]    3    7   15   11\n#> [4,]    4    8   16   12\nrbind(x, -1)[c(1, 2, 3, 5, 4),] # sorvektor hozzáfűzése, majd sorok indexelése\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]   -1   -1   -1\n#> [5,]    4    8   12\nx <- matrix(1:12, nrow=4, ncol=3); x\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]    4    8   12\nx <- rbind(x,apply(x,2,mean))  # átlag sor hozzáfűzése\nrownames(x) <- c(1:4,\"átlag\")  # az új sor nevének átírása\nx\n#>       [,1] [,2] [,3]\n#> 1      1.0  5.0  9.0\n#> 2      2.0  6.0 10.0\n#> 3      3.0  7.0 11.0\n#> 4      4.0  8.0 12.0\n#> átlag  2.5  6.5 10.5\nx <- matrix(1:12, nrow=4, ncol=3); x\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]    4    8   12\ny <- x[, c(2, 3, 1)]          # oszlopcsere\ny <- x[c(3, 2, 4, 1), ]       # sorcsere\ny <- x[, c(1, 3)]             # a 2. oszlop törlése\ny <- x[c(1, 3), ]             # az 2. és a 4. sor törlése"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-6-summary","chapter":"5 Az R nyelv","heading":"5.3.4.5 Összefoglalás","text":"\nmátrix homogén kétdimenziós adatszerkezet, és többnyire \nmatrix() függvénnyel hozzuk létre, de használhatjuk \ncbind() és rbind() függvényeket . Mátrix\nindexelése [,] operátorral történik, ahol sor- és\noszlopindex megadásra van lehetőségünk. mátrix sorain vagy oszlopain\nkülön-külön tudunk műveleteket végezni az apply()\nfüggvénnyel, sor- és oszlopneveket rownames() és \ncolnames() függvénnyel kezelhetjük.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-6-exercise","chapter":"5 Az R nyelv","heading":"5.3.4.6 Feladatok","text":"Hozzunk létre egy csupa 1-ből álló mátrixot, amelynek 3 sora és 2 oszlopa van!Hozzunk létre egy 3 \\(\\times\\) 4-es karakteres mátrixot, amely 12 különbüző keresztnevet tartalmaz!Hozzunk létre egy 3 \\(\\times\\) 4-es logikai mátrixot, amelynek 1. és 3. sora TURE 2. sora pedig FALSE értékeket tartalmaz!Mátrixok indexelésére olyan speciális indexmátrix használható, amelynek két oszlopa van, és az elérendő elemek sor- és oszlopkoordinátáit tartalmazza. Mutassunk példát erre mátrix[indexmátrix] alakú mátrixindexelésre!fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"faktor","chapter":"5 Az R nyelv","heading":"5.3.5 Faktor","text":"faktor adattípus nagyon hasonló vektorhoz, ugyanis minden faktor egy speciális integer vektor, faktor tehát homogén és egydimenziós adatszerkezet. Faktorokat elsősorban kategorikus változók értékeinek tárolására használjuk, ilyen például személyek neme vagy iskolai végzettsége. faktor egy lényeges ponton több mint egy egyszerű integer vektor. faktor karbantart egy összerendelést az 1-gyel kezdődő numerikus egészek és faktor lehetséges karakteres értékei, címkék között (az 5.1. ábrán ezt egy piros kis téglalappal jelöltük). Egy faktorelem értéke csak ezekből címkékből kerülhet ki, ami nagy fokú védelmet jelent számunkra az adatkezelés során. Ha például létrehozunk egy faktort az (1-\"férfi\", 2-\"nő\") összerendeléssel, akkor egy faktorelem csak \"férfi\" vagy \"nő\" címkéket veheti fel, más értéket nem (az NA hiányzó érték természetesen lehet faktorelem értéke ). munka során mindig címkékkel találkozunk, háttérben lévő numerikus egészek csak ritkán kapnak szerepet.","code":""},{"path":"az-r-nyelv.html","id":"faktor-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.5.1 Faktor létrehozása","text":"faktorokat jellemzően karakteres vagy numerikus vektorokból hozzuk létre factor() függvénnyel. faktor létrehozásánál mindig gondoskodjunk faktor lehetséges értékeinek, vagyis faktor címkéiknek megadásáról. címkéket néha (faktor)szinteknek (levels) nevezzük. Mivel kategorikus változóink lehetséges értékei többnyire ismertek az adatkezelés elején, faktorszintek felsorolása nem okozhat nehézséget. hozzunk létre egy faktort, amely öt személy nemét tartalmazza.Az x.f faktort az x karakteres vektorból hoztuk létre, így x.f ugyanúgy 5 hosszú, mint az x. Az x.f outputjában olvasható Levels: férfi nő rész azt közli velünk, hogy háttérben az 1 numerikus értéknek \"férfi\" címke, míg 2-nek \"nő\" címke felel meg. belső integer kódok feltárulnak az unclass(x.f) outputjában. szám-címke összerendelést magunk szabályozhatjuk, ha factor() függvény levels= argumentumában módosítunk sorrenden.fenti x.f faktor ugyanannak az 5 személynek nemét tartalmazza, de az összerendelést levels=c(\"nő\", \"férfi\") paraméterrel (1-\"nő\", 2-\"férfi\")-re változtattuk. Láthatjuk, címkék sorrendje faktor értékeitől független, mégis fontos szerepet kap majd táblázatok és ábrák megjelenítésénél, tehát érdemes rá odafigyelni.levels= argumentum szerepeltetése factor() függvényben sok kellemetlenségtől kímélhet meg minket. Ha elhagyjuk, akkor factor() függvény karakteres vektorban aktuálisan rendelkezésre álló értékekből konstruálja meg faktort. Nézzünk erre három esetet.Az első esetben faktor létrehozásához használt karakteres vektor megegyezik korábban látottakhoz, azaz helyesen tartalmazza mind \"férfi\", mind \"nő\" címkéket, így az x.f.1 faktor címkék lexikografikus rendezése alapján az (1-\"férfi\", 2-\"nő\") összerendeléssel jön létre. második esetben karakteres vektorunk elgépelés miatt egy \"Férfi\" címkét tartalmaz, ami az x.f.2 faktor szintjei között meg fog jelenni. harmadik esetben az okozza problémát, hogy 5 azonos nemű személy került mintába, így \"férfi\" címke egyáltalán nem jelenik meg az x.f.3 faktor szintjei között. Az x.f.2 és az x.f.3 faktorok tehát más-más okok miatt, de hibásan tartalmazzák faktorszinteket, és ez későbbi működést alapvetően befolyásolja. Az x.f.2 három különböző nemet ismer, az x.f.3 pedig mindössze egyet. fenti hibák levels= szerepeltetésével könnyen kiküszöbölhetők.fenti példákban látható, hogy \"Férfi\" címke helyére hiányzó érték került, az x.f.3 faktor pedig már \"férfi\" értéket fel tud venni jövőben.Numerikus vektorokból készíthetünk faktorokat. Például könnyebb rögzíthetőség miatt öt személy nemét numerikus vektorban hoztuk létre azzal szabállyal, hogy 0 jelentése nő, az 1 jelentése férfi. faktor létrehozása során ekkor levels= szerepe lehetséges numerikus értékek felsorolása lesz, és plusz paraméterként szereplő labels= segít faktorszintek beszédes elnevezésében. Az elnevezés levels=-ben lévő numerikus értékek sorrendjében történik, ezért nagyon fontos, hogy labels= címkéi kövessék ezt sorrendet.fenti példában látható, hogy levels= értékeinek sorrendje vezérli az elnevezést, 0 mindkét esetben \"nő\", az 1 \"férfi\" címkéhez fog vezetni. Az x.f.1 és x.f.2 faktorok mindössze háttérben lévő összerendelésben különböznek, első esetben az (1-\"nő\", 2-\"férfi\"), míg második esetben az (1-\"férfi\", 2-\"nő\") lesz faktorszintek sorrendje. Vegyük észre, hogy az eredeti 0 (nő) és 1 (férfi) értékek faktorban már eltűnnek, szerepüket címkék veszik át (nő, férfi) és az azok alapját jelentő 1-től sorszámozott integer vektorok.","code":"\nx <- c(\"férfi\", \"férfi\", \"nő\", \"férfi\", \"nő\")  # karakteres vektor létrehozása\nx.f <- factor(x, levels=c(\"férfi\", \"nő\"))      # faktor létrehozása\nx.f                                            # faktor kiíratása\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: férfi nő\nunclass(x.f)                                   # integer kódok a háttérben\n#> [1] 1 1 2 1 2\n#> attr(,\"levels\")\n#> [1] \"férfi\" \"nő\"\nx.f <- factor(x, levels=c(\"nő\", \"férfi\"))      # faktor létrehozása\nx.f\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: nő férfi\n(x.f.1 <- factor(c(\"férfi\", \"férfi\", \"nő\", \"férfi\", \"nő\")))\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: férfi nő\n(x.f.2 <- factor(c(\"férfi\", \"Férfi\", \"nő\", \"férfi\", \"nő\")))\n#> [1] férfi Férfi nő    férfi nő   \n#> Levels: férfi Férfi nő\n(x.f.3 <- factor(c(\"nő\", \"nő\", \"nő\", \"nő\", \"nő\")))\n#> [1] nő nő nő nő nő\n#> Levels: nő\n(x.f.2 <- factor(c(\"férfi\", \"Férfi\", \"nő\", \"férfi\", \"nő\"),\n                 levels=c(\"férfi\", \"nő\")))   \n#> [1] férfi <NA>  nő    férfi nő   \n#> Levels: férfi nő\n(x.f.3 <- factor(c(\"nő\", \"nő\", \"nő\", \"nő\", \"nő\"),\n                 levels=c(\"férfi\", \"nő\")))\n#> [1] nő nő nő nő nő\n#> Levels: férfi nő\nx <- c(1, 1, 0, 1, 0)     # numerikus vektor létrehozása, 0-nő, 1-férfi\n(x.f.1 <- factor(x, levels=c(0, 1), \n                    labels=c(\"nő\", \"férfi\")))\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: nő férfi\n(x.f.2 <- factor(x, levels=c(1, 0), \n                    labels=c(\"férfi\", \"nő\")))\n#> [1] férfi férfi nő    férfi nő   \n#> Levels: férfi nő"},{"path":"az-r-nyelv.html","id":"rendezett-faktor","chapter":"5 Az R nyelv","heading":"5.3.5.2 Rendezett faktor","text":"kategorikus változók két csoportját különböztetjük meg, nominális változókat – ilyen volt az eddig látott nem változó –, és az ordinális változókat. Ez utóbbira példa az iskolai végzettség, mert ennek lehetséges értékei (alap, közép és felső értékekkel) sorba rendezhetők. Ha változó szintjei közötti rendezettséget szeretnénk az R-ben kifejezni, akkor rendezett faktort érdemes használni. Az eddigi factor() függvény alkalmas az ordered = T argumentum használatával, de az ordered() függvényt használhatjuk rendezett faktor létrehozására.Az ordered() függvénnyel létrehozott rendezett faktor outputjában szintek között rendezettséget kisebb (<) jelek teszik hangsúlyossá, de függvény használata nem tér el korábban látott factor() függvénytől.","code":"\n# rendezett faktor létrehozása\nx <- c(\"felső\", \"közép\", \"alap\", \"közép\", \"felső\")\nx.f <- ordered(x = x, levels=c(\"alap\", \"közép\", \"felső\"))\nx.f\n#> [1] felső közép alap  közép felső\n#> Levels: alap < közép < felső"},{"path":"az-r-nyelv.html","id":"szabályos-faktor-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.5.3 Szabályos faktor létrehozása","text":"Ismétlést tartalmazó faktorokat gl() függvénnyel létrehozhatunk. Tipikusan szintek (n=) számát, az ismétlések számát (k=) és címkéket (labels=) szoktuk megadni. Rendezett faktort az ordered = T argumentummal készíthetünk.","code":"\n(x.f <- gl(n = 3, k = 2))\n#> [1] 1 1 2 2 3 3\n#> Levels: 1 2 3\n(x.f <- gl(n = 3, k = 2, labels=c(\"alap\", \"közép\", \"felső\")))\n#> [1] alap  alap  közép közép felső felső\n#> Levels: alap közép felső\n(x.f <- gl(n = 3, k = 2, labels=c(\"alap\", \"közép\", \"felső\"), ordered=T))\n#> [1] alap  alap  közép közép felső felső\n#> Levels: alap < közép < felső"},{"path":"az-r-nyelv.html","id":"faktor-indexelése-és-szűrése","chapter":"5 Az R nyelv","heading":"5.3.5.4 Faktor indexelése és szűrése","text":"Faktor indexelése [] operátorral történik. Indexvektorként numerikus, karakteres és logikai vektorokat használhatunk. Faktor indexelésének általános alakja:Hozzunk létre egy faktort, amely hat személy dohányzási szokását tartalmazza (D-dohányzik, ND-nem dohányzik).Az indexelés eredménye minden esetben egy faktor lesz, amelynek szintjei alapesetben megegyeznek az eredeti faktor szintjeivel. drop=T argumentum nem használt címkéket eltávolítja faktorszintek közül. Logika kifejezéseket használhatunk az indexelés során, azaz szűrést végezhetünk.Indexelt faktor természetesen érékadás bal oldalán szerepelhet. faktor adatszerkezet megvéd minket az értékadások során, hiszen egy faktorelem csak faktorszintekben szereplő értékek egyikét veheti fel.Mivel \"nem dohányzik\" címke nem szerepel faktorszintek között, az x.f faktor 2. eleme NA lesz, egy figyelmeztető üzenet kíséretében.","code":"faktor[indexvektor]     # az eredmény egy faktor\n(x.f <- factor(c(\"D\", \"D\", \"ND\", \"D\", \"ND\", \"ND\"), levels = c(\"ND\", \"D\")))\n#> [1] D  D  ND D  ND ND\n#> Levels: ND D\nx.f[1]             # az x faktor 1. eleme (faktorszintek változatlanok)\n#> [1] D\n#> Levels: ND D\nx.f[1, drop=T]     # az x faktor 1. eleme (faktorszintek változtak)\n#> [1] D\n#> Levels: D\nx.f[1:3]           # az x faktor 1., 2. és 3. eleme\n#> [1] D  D  ND\n#> Levels: ND D\nx.f[c(T, F)]       # az x faktor 1, 3. és 5. eleme\n#> [1] D  ND ND\n#> Levels: ND D\nx.f[x.f == \"D\"]    # x szűrése (a dohányzók)\n#> [1] D D D\n#> Levels: ND D\nx.f[x.f != \"D\"]    # x szűrése (a nem dohányzók)\n#> [1] ND ND ND\n#> Levels: ND D\nx.f                        # az x.f faktor kiírása\n#> [1] D  D  ND D  ND ND\n#> Levels: ND D\nx.f[1] <- \"ND\"             # az x.f faktor 1. eleme legális értéket kap\nx.f[2] <- \"nem dohányzik\"  # az x.f faktor 2. eleme NA lesz\nx.f\n#> [1] ND   <NA> ND   D    ND   ND  \n#> Levels: ND D"},{"path":"az-r-nyelv.html","id":"faktorok-kezelése","chapter":"5 Az R nyelv","heading":"5.3.5.5 Faktorok kezelése","text":"faktorok kényelmes használatát két további függvény segíti. Az nlevels() függvénnyel faktorszintek számát ismerhetjük meg, levels() függvénnyel pedig lekérdezhetők és módosíthatók faktorszintek. Nézzünk egy példát az iskolai végzettséggel kapcsolatban. Összesen 7 személyről tudjuk, hogy alap-, közép- vagy felsőfokú végzettségű, de az egyszerűbb rögzítés miatt indulásként ezt az információt számokkal kódoltuk (1-alap, 2-közép, 3-felső).Az isk.vegz.f faktort az \"1\", \"2\" és \"3\" címkékkel hoztuk létre, de később levels() függvénnyel beszédesebb faktorszinteket hoztunk létre.","code":"\n# numerikus vektor létrehozása\nisk.vegz   <- c(1, 1, 2, 1, 3, 3, 2)\n# faktor létrehozása\nisk.vegz.f <- factor(isk.vegz, levels=c(\"1\", \"2\", \"3\")) \nisk.vegz.f                              # a faktor értéke\n#> [1] 1 1 2 1 3 3 2\n#> Levels: 1 2 3\nnlevels(isk.vegz.f)                     # a faktor szintjeinek száma\n#> [1] 3\nlevels(isk.vegz.f)                      # a faktor szintjei\n#> [1] \"1\" \"2\" \"3\"\n# a faktor szintjeinek módosítása\nlevels(isk.vegz.f) <- c(\"alap\", \"közép\", \"felső\") \nisk.vegz.f                              # a faktor értéke\n#> [1] alap  alap  közép alap  felső felső közép\n#> Levels: alap közép felső"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-7-summary","chapter":"5 Az R nyelv","heading":"5.3.5.6 Összefoglalás","text":"\nfaktor olyan integer vektor, amely az 1-től sorszámozott\nértékeihez egy-egy karakteres címkét rendel. Ezek címkék alkotják \nfaktorelemek lehetséges értékeit, amelyeket más néven faktorszinteknek\nneveznek. faktor létrehozásához factor() függvényt\nhasználjuk és karakteres vektor konstansaiból vagy numerikus vektor\ncímkeként kezelt számértékeiből jönnek létre faktor lehetséges\nértékei. Rendezett faktorok szintjei között létezik egy természetes\nrendezettség, létrehozásukhoz az ordered() függvényt\nhasználjuk. Az nlevels() függvény faktorszintek számát\nadja meg, míg levels() szintek nevének lekérdezését és\nmódosítását szolgálja.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-7-exercise","chapter":"5 Az R nyelv","heading":"5.3.5.7 Feladatok","text":"Hozzuk létre azt karakteres vektort, amely férfi, nő karakteres konstansokat, úgy helyezi el egymás mellett, hogy 7 darab férfi érték után 13 db nő címke következik! Hány elemű az így létrejött vektor?Egy vizsgálatban az első 10 személy neme férfi, többi 8 neme nő volt. Hozzuk létre azt faktort, amely leírja neme változót!Egy vizsgálatban városi (“V”) és falusi (“F”) fiatalok vettek részt! megkérdezettek településtípusa rendre következő volt: F, F, V, F, V, V, V, F. Hozzuk létre azt faktort, amely leírja településtípus változót!Egy vizsgálatban dohányzási szokást egy kétértékű skálán mérték: 0-nem dohányzik; 1-dohányzik. megkérdezettek dohányzási szokása következő volt: 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0. Hozzuk létre azt faktort, amely leírja dohányzási szokás változót!fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"listadefalf","chapter":"5 Az R nyelv","heading":"5.3.6 Lista","text":"Az eddig megismert vektor, mátrix és faktor adatszerkezet mindegyike homogén volt, csak azonos típusú értékek tárolására használhatjuk őket. lista típusú adatokban különböző adatszerkezetű elemeket felsorolhatunk, de sem típusra, sem méretre nincs korlátozás. Egy listaelem lehet vektor, mátrix, faktor, adattábla vagy akár egy másik lista (5.1. ábra). Látható, hogy lista az R legszabadabb adatszerkezete, egydimenziós, és fő célja logikailag összetartozó, de szerkezetileg különböző adatok tárolása.","code":""},{"path":"az-r-nyelv.html","id":"lista-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.6.1 Lista létrehozása","text":"list() függvénnyel hozhatunk létre legegyszerűbben listákat, itt vesszővel elválasztva kell megadnunk lista elemeit.fenti példában x egy 3 elemű lista, az első eleme egy 10 elemű numerikus vektor, második eleme egy 2 elemű karakteres vektor, harmadik eleme pedig egy 1 elemű logikai vektor. harmadik elemnek c nevet adtuk, de bármelyik elemet elnevezhettük volna ezzel módszerrel. Ha lista értékét megjelenítjük képernyőn, akkor listaelemek egymás alatt jelennek meg. Az első két esetben kettős szögletes zárójelben ([[]]) lévő sorszám azonosítja lista elemeit, harmadik esetben pedig listaelem általunk megadott neve dollárjel ($) után.listaelemek nevét names() függvénnyel kérdezhetjük le és állíthatjuk .","code":"\nx <- list(1:10, c(\"A\",\"B\"), c=T)    # 3 elemű lista\nx\n#> [[1]]\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> [[2]]\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] TRUE\nnames(x)                       # az x lista elemeinek neve\n#> [1] \"\"  \"\"  \"c\"\nnames(x)[c(1,2)] <- c(\"a\",\"b\") # az x 1. és 2. elemének elnevezése\nnames(x)\n#> [1] \"a\" \"b\" \"c\"\nx\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> $b\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] TRUE"},{"path":"az-r-nyelv.html","id":"lista-indexelése","chapter":"5 Az R nyelv","heading":"5.3.6.2 Lista indexelése","text":"Egy lista indexelése már megszokott [] indexoperátorral történik, amelyben továbbra lehetőségünk van numerikus, karakteres és logikai indexvektor megadására .[] operátorral kapott eredmény minden esetben lista, még akkor , ha lista egyetlen elemét érjük el. Nagyon fontos ettől megkülönböztetni [[]] operátor eredményét, amely lista valamelyik (egyetlen) elemével, annak az értékével tér vissza. Itt nincs mód több listaelem elérésére, és szokás szerint numerikus vagy karakteres értékkel indexelünk.[[]] operátor alkalmazása helyett rövidebb dollár ($) operátort használhatjuk azoknak listaelemeknek az elérésére, amelyeket korábban elneveztünk. lista nevét és az elem nevét fűzzük össze $ operátorral.Ha lista elemét valamelyik módszer segítségével elértük, akkor további indexelés segítségével az elem összetevőit lekérdezhetjük vagy módosíthatjuk.lista indexelésére tehát következő lehetőségek állnak rendelkezésre:","code":"\nx[1]           # az x lista 1. elemét tartalmazó 1 elemű lista\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx[c(2, 3)]     # az x lista 2. és 3. elemét tartalmazó 2 elemű lista\n#> $b\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] TRUE\nx[\"a\"]         # az x lista 1. elemét tartalmazó 1 elemű lista\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx[c(T, F, T)]  # az x lista 1. és 3. elemét tartalmazó 1 elemű lista\n#> $a\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> $c\n#> [1] TRUE\nx[[1]]     # az x lista 1. eleme\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx[[\"b\"]]   # az x lista 2. eleme\n#> [1] \"A\" \"B\"\nx[[3]]     # az x lista 3. eleme\n#> [1] TRUE\nx$a        # az x lista 1. eleme\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx$b        # az x lista 2. eleme\n#> [1] \"A\" \"B\"\nx$c        # az x lista 3. eleme\n#> [1] TRUE\nx[[\"a\"]][3:4]       # az x lista 1. elemének 3. és 4. eleme \n#> [1] 3 4\nx$a[4:5] <- 0       # az x lista 1. elemének 4. és 5. eleme 0 lesz\nx$c <- 1:2          # az x lista 3. elemének módosítása    \nx\n#> $a\n#>  [1]  1  2  3  0  0  6  7  8  9 10\n#> \n#> $b\n#> [1] \"A\" \"B\"\n#> \n#> $c\n#> [1] 1 2lista[indexvektor]     # az eredmény egy lista\nlista[[index]]         # az eredmény a lista egy eleme\nlista$elemnév          # az eredmény a lista egy eleme  "},{"path":"az-r-nyelv.html","id":"művelet-a-listaelemekkel","chapter":"5 Az R nyelv","heading":"5.3.6.3 Művelet a listaelemekkel","text":"Egy lista minden elemével az lapply() vagy az sapply() függvény segítségével hajthatunk végre műveletet.Az lapply() bemenő lista elemszámával egyező méretű listával tér vissza, melynek értékei az második paraméterben szereplő függvény visszatérési értékei. Az sapply() hasonlóan jár el, de visszatérési értéke egy vektor.","code":"\nlapply(X=x, FUN=length) # az x lista minden elemének a hossza egy listába\n#> $a\n#> [1] 10\n#> \n#> $b\n#> [1] 2\n#> \n#> $c\n#> [1] 2\nsapply(X=x, FUN=length) # az x lista minden elemének a hossza egy vektorba\n#>  a  b  c \n#> 10  2  2"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-8-summary","chapter":"5 Az R nyelv","heading":"5.3.6.4 Összefoglalás","text":"\nlista az R legszabadabb adatszerkezete, egydimenziós és inhomogén.\nListát list() függvénnyel hozhatunk létre, melynek\nargumentumában tetszőleges adatszerkezetű objektumokat felsorolhatunk,\nezek alkotják lista egyes elemeit. Lista indexelése [],\n[[]] és $ operátorokkal lehetséges.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-8-exercise","chapter":"5 Az R nyelv","heading":"5.3.6.5 Feladatok","text":"Hozzunk létre egy háromelemű listát TRUE, 12, és “Verseny” konstansokból!Hozzunk létre egy háromelemű listát TRUE, 12, és “Verseny” konstansokból, de gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve”, “indulok” és “leiras”!Hozzunk létre egy háromelemű listát TRUE, 12 és “Verseny” konstansokból, valamint az induló versenyzők végső pontszámaiból, amelyek rendre: 89, 78, 23, 67, 99, 69, 85, 77, 58, 72, 48, 81. Gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve”, “indulok”, “leiras” és “pontszam”!fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"adattábla","chapter":"5 Az R nyelv","heading":"5.3.7 Adattábla","text":"Az adattábla (data frame) az R legfontosabb adatszerkezete, központi szerepet játszik az adatfeldolgozásban, lényegében minden statisztikai munka kiindulópontja. Inhomogén, kétdimenziós szerkezet, sorok és oszlopok alkotják, alapvetően azonos hosszúságú vektorokból és faktorokból épül fel (5.1. ábra). Az adattábla egyesíti mátrix és lista adatszerkezet előnyeit. Az adattábla kétdimenziós, mint mátrix, és inhomogén, mint lista. Ha mátrixként tekintünk az adattáblára, akkor sorokból és oszlopokból áll, ha listaként, akkor azonos hosszúságú (oszlop)vektorok/faktorok egydimenziós sorozata.","code":""},{"path":"az-r-nyelv.html","id":"adattábla-létrehozása","chapter":"5 Az R nyelv","heading":"5.3.7.1 Adattábla létrehozása","text":"Adattáblát legegyszerűbben data.frame() függvénnyel hozhatunk létre, amely azonos hosszú vektorokat vagy faktorokat vár az argumentumában. data.frame() tehát listaszerűen konstruálja az adattáblát.fenti df adattáblát egy 3 elemű karakteres vektorból, és egy 3 elemű numerikus vektorból hoztuk létre. data.frame() függvénynek ezt két vektort adtuk meg, ennek megfelelően két oszlopa lesz az adattáblának. Mindkét vektor 3 elemű, így 3 sor lesz df-ben. Adattáblánk így 3 \\(\\times\\) 2-es. Mindkét argumentumot elneveztük (nev, pont), ezekből oszlopnevek lesznek. Az oszlopok elnevezéséhez az objektumneveknél használt szabályokat vegyük figyelembe (5.1.2.3. fejezet), és ne használjunk ékezetes karaktereket és szóközt. fenti outputból kiolvasható, hogy az adattábla sornevekkel rendelkezik, ezek automatikusan jönnek létre 1-től kezdődő sorszámmal.Ha data.frame() függvényben paraméterek hossza nem azonos, akkor rövidebb vektorok és faktorok ismétléssel kiegészülnek leghosszabb oszlop hosszára. Az ismétlés azonban csak egész számszor lehetséges, egyébként hibaüzenetet kapunk.példában egy 6 sorból és 3 oszlopból álló adattáblát készítettünk (df2 6 \\(\\times\\) 3-). data.frame() függvényben nem azonos tipus faktor és két numerikus vektor (x, y) hossza, így ismétléssel kapjuk meg fenti eredményt. Továbbá, ha elhagyjuk az argumentum nevét, akkor az oszlopnév megfelelő objektum neve alapján jön létre. Így kapta az első oszlop tipus nevet.","code":"\ndf <- data.frame(\n  nev  = c(\"Péter\", \"Éva\", \"Lajos\"),\n  pont = c(34, 32, 29)\n) \ndf      # adattábla kiírása\n#>     nev pont\n#> 1 Péter   34\n#> 2   Éva   32\n#> 3 Lajos   29\ntipus <- factor(c('A','B')); x <- 6:8; y <- 1:6\ndf2 <- data.frame(\n   tipus, \n   pont.1=x, \n   pont.2=y\n)\ndf2\n#>   tipus pont.1 pont.2\n#> 1     A      6      1\n#> 2     B      7      2\n#> 3     A      8      3\n#> 4     B      6      4\n#> 5     A      7      5\n#> 6     B      8      6"},{"path":"az-r-nyelv.html","id":"adattábla-felépítése","chapter":"5 Az R nyelv","heading":"5.3.7.2 Adattábla felépítése","text":"Adattábláink ritkán olyan kicsik, mint fenti df vagy df2. Sokszor több tucat sorból és oszlopból állnak, így az adattábla áttekintésére nem az adattáblát tároló objektum értékének képernyőre írása legszerencsésebb. Kényelmesebb, ha az RStudio adatbázis ablakában jelenítjük meg az adattábla tartalmát, amit Környezet panel megfelelő adatbázisnevén való kattintással és vagy View() paranccsal kezdeményezhetünk. Próbáljuk ki View(df) és View(df2) függvényhívásokat.Hasznos információ szolgáltat az str() függvény , amely az adattábla szerkezetéről ad felvilágosítást.Láthatjuk, hogy df adattáblánk 3 sort (megfigyelést) és 2 oszlopot (változót) tartalmaz, valamint leolvashatjuk az egyes oszlopok típusát . Megfigyelhetjük, hogy nev oszlop karakteres, pont pedig numerikus vektor.Láttuk korábban, hogy az adattábla sorai és oszlopai névvel rendelkeznek.rownames() sorok nevét, colnames() és names() az oszlopok nevét írja ki, de segítségükkel ezeket módosíthatjuk . sorok és oszlopok nevének meghatározásánál ügyeljünk arra, hogy azok minden esetben legyenek egyediek. Két azonos sornév létrehozása hibaüzenethez vezet, de az azonos oszlopnevek használatát kerüljük.length() függvény az oszlopok számával tér vissza. Az nrow() és az ncol() sor és oszlopok számával tér vissza.","code":"\nstr(df)     # a df adattábla szerkezete\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ nev : chr  \"Péter\" \"Éva\" \"Lajos\"\n#>  $ pont: num  34 32 29\nnames(df); colnames(df)  # oszlopnevek\n#> [1] \"nev\"  \"pont\"\n#> [1] \"nev\"  \"pont\"\nrownames(df)             # sornevek\n#> [1] \"1\" \"2\" \"3\"\nrownames(df) <- paste0(1:3, \".szemely\")   # sornevek módosítása\nnames(df) <- c(\"X\",\"Y\")                   # oszlopnevek módosítása\ndf\n#>               X  Y\n#> 1.szemely Péter 34\n#> 2.szemely   Éva 32\n#> 3.szemely Lajos 29\nlength(df); ncol(df)   # oszlopok száma\n#> [1] 2\n#> [1] 2\nnrow(df)               # sorok száma\n#> [1] 3"},{"path":"az-r-nyelv.html","id":"adattábla-indexelése","chapter":"5 Az R nyelv","heading":"5.3.7.3 Adattábla indexelése","text":"Az adattáblák indexelése mátrixok és listáknál megtanult indexelési formákat jelentik. Az általános indexelése formák következők:mátrixokhoz hasonlóan indexelhetjük sorokat és az oszlopokat, hiszen az adattábla kétdimenziós. [] operátorban szerepel egy vessző, amely sor- és oszlopkoordinátákat választja el egymástól. Használhatjuk következő hivatkozásokat:Numerikus indexvektorok mellett használhatunk karakteres és logikai vektorokat indexelésre.Karakteres vektorok tipikusan oszlopindexekben fordulnak elő, logikai vektorok pedig, később látjuk, az adattábla szűrésénél kapnak fontos szerepet.Ha az adattáblára listaként tekintünk, akkor [] operátorban egyetlen indexvektort szerepeltethetünk, amely az adattábla oszlopait indexeli, és minden esetben adattáblát szolgáltat, még akkor , ha az adattábla egyetlen oszlopát érjük el.Az adattábla egyes oszlopai $ operátorral elérhetők, amely az adattábla nevét és az oszlop nevét választja el egymástól. Az eredmény minden esetben vektor vagy faktor lesz.Az adattábla indexelése után kapott adatszerkezetek tovább indexelhetők. Attól függően, hogy kiinduló adattábla indexelésével kapott adatszerkezet egy- vagy kétdimenziós használhatjuk [] és $ operátorokat .Ne felejtsük el, hogy adattábla indexelése során lekért elemek módosítására lehetőségünk van, és vektoraritmetika szabályai továbbra teljesülnek.","code":"adattábla[sorindexvektor, oszlopindexvektor] # adattábla, vektor vagy faktor \nadattábla[oszlopindexvektor]                 # adattábla\nadattábla$oszlopnév                          # vektor vagy faktor                    \ndf2               # a df2 adattábla kiírása\n#>   tipus pont.1 pont.2\n#> 1     A      6      1\n#> 2     B      7      2\n#> 3     A      8      3\n#> 4     B      6      4\n#> 5     A      7      5\n#> 6     B      8      6\ndf2[2, 3]         # a df2 2. sorában a 3. oszlop adata, vektor eredmény\n#> [1] 2\ndf2[c(2, 3), 3]   # a df2 2. és 3. sorában a 3. oszlop adata, vektor\n#> [1] 2 3\ndf2[c(2, 3), 1:2] # a df2 2. és 3. sorában a 1. és 2. oszlop adata, adattábla\n#>   tipus pont.1\n#> 2     B      7\n#> 3     A      8\ndf2[c(2, 3), ]    # a df2 2. és 3. sora, adattábla\n#>   tipus pont.1 pont.2\n#> 2     B      7      2\n#> 3     A      8      3\ndf2[2, ]          # a df2 2. sora, adattábla\n#>   tipus pont.1 pont.2\n#> 2     B      7      2\ndf2[, 3]          # a df2 3. oszlopa, vektor\n#> [1] 1 2 3 4 5 6\ndf2[, 3, drop=F]  # a df2 3. oszlopa, adattábla\n#>   pont.2\n#> 1      1\n#> 2      2\n#> 3      3\n#> 4      4\n#> 5      5\n#> 6      6\ndf2[, 1:2]        # a df2 1. és 2. oszlopa, adattábla\n#>   tipus pont.1\n#> 1     A      6\n#> 2     B      7\n#> 3     A      8\n#> 4     B      6\n#> 5     A      7\n#> 6     B      8\ndf2[, c(\"tipus\", \"pont.1\")]         # minden sor, 1. és 2. oszlop\n#>   tipus pont.1\n#> 1     A      6\n#> 2     B      7\n#> 3     A      8\n#> 4     B      6\n#> 5     A      7\n#> 6     B      8\ndf2[c(T, F), c(\"tipus\", \"pont.1\")]  # páratlan sorok 1. és 2. oszlop\n#>   tipus pont.1\n#> 1     A      6\n#> 3     A      8\n#> 5     A      7\ndf2[2]                    # a df2 2. oszlopa, adattábla\n#>   pont.1\n#> 1      6\n#> 2      7\n#> 3      8\n#> 4      6\n#> 5      7\n#> 6      8\ndf2[1:2]                  # a df2 1. és 2. oszlopa, adattábla\n#>   tipus pont.1\n#> 1     A      6\n#> 2     B      7\n#> 3     A      8\n#> 4     B      6\n#> 5     A      7\n#> 6     B      8\ndf2[\"tipus\"]              # a df2 1. oszlopa, adattábla\n#>   tipus\n#> 1     A\n#> 2     B\n#> 3     A\n#> 4     B\n#> 5     A\n#> 6     B\ndf2[c(\"tipus\", \"pont.2\")] # a df2 1. és 3. oszlopa, adattábla\n#>   tipus pont.2\n#> 1     A      1\n#> 2     B      2\n#> 3     A      3\n#> 4     B      4\n#> 5     A      5\n#> 6     B      6\ndf2$tipus               # a df2 1. oszlopa, faktor\n#> [1] A B A B A B\n#> Levels: A B\ndf2$pont.1              # a df2 2. oszlopa, vektor\n#> [1] 6 7 8 6 7 8\ndf2[4:1, 1:2][2]           # df2-ből adattábla, majd adattábla\n#>   pont.1\n#> 4      6\n#> 3      8\n#> 2      7\n#> 1      6\ndf2[4:1, 1:2]$tipus        # df2-ből adattábla, majd faktor\n#> [1] B A B A\n#> Levels: A B\ndf2$pont.2[1:3]            # df2-ből vektor, majd vektor\n#> [1] 1 2 3\ndf2[2, 3] <- 200              # egyetlen érték módosítása \ndf2$pont.2 <- df2$pont.2 + 1  # teljes oszlop módosítása\ndf2                           # df2 kiírása\n#>   tipus pont.1 pont.2\n#> 1     A      6      2\n#> 2     B      7    201\n#> 3     A      8      4\n#> 4     B      6      5\n#> 5     A      7      6\n#> 6     B      8      7"},{"path":"az-r-nyelv.html","id":"adattáblák-szűrése","chapter":"5 Az R nyelv","heading":"5.3.7.4 Adattáblák szűrése","text":"Az adattábla indexelésénél logikai vektorokat használhatunk sorindexvektorban, melyek az adattábla tartalmára vonatkozó relációs kifejezések lehetnek. Ezzel módszerrel érhetjük el, hogy az adattábla sorait valamilyen szempont szerint leválogassuk, megszűrjük.Az első szűrésünk az adattábla \"\" címkékkel rendelkező sorait válogatta le, de csak képernyőn olvashatók ezek sorok. második szűrés eredményét azonban megőrizzük egy új df3 objektumban, és látható, hogy pont.1 és pont.2 numerikus vektorokra vonatkozó összetett logikai kifejezéssel végezzük.","code":"\ndf2[df2$tipus == \"A\", ]                      # az A típusú sorok leválogatása\n#>   tipus pont.1 pont.2\n#> 1     A      6      2\n#> 3     A      8      4\n#> 5     A      7      6\ndf3 <- df2[df2$pont.1<8 & df2$pont.2>2, 2:3] # összetett logikai kifejezés"},{"path":"az-r-nyelv.html","id":"adattáblák-sorainak-rendezése","chapter":"5 Az R nyelv","heading":"5.3.7.5 Adattáblák sorainak rendezése","text":"Az adattábla sorainak rendezése vektoroknál megismert order() függvény és [] operátor kombinált alkalmazásával lehetséges. Rendezzük pont.1 változó alapján df2 sorait.Az order() függvény decreasing=TRUE argumentumával csökkenő sorrendet elérhetünk. Az order() függvény több oszlopot képes fogadni, így több oszlop alapján tudunk sorokat rendezni.####Összefoglalás {#az-r-nyelv-9-summary}\nAz adattábla minden statisztikai munka kiindulópontja. Kétdimenziós,\ninhomogén szerkezet, de mivel azonos hosszú vektorok vagy faktorok\nlistájának tekinthető, oszlopaiban homogén adatszerkezet. Létrehozása\ndata.frame() függvénnyel lehetséges, ahol az\nargumentumban az oszlopokat alkotó vektorokat és faktorokat kell\nfelsorolni. Az adattábla indexelése mátrixoknál és listáknál\ntanultak alapján lehetséges.\n","code":"\ndf2[order(df2$pont.1), ] # df2 sorainak rendezése pont.1 növekvő sorrendjében\n#>   tipus pont.1 pont.2\n#> 1     A      6      2\n#> 4     B      6      5\n#> 2     B      7    201\n#> 5     A      7      6\n#> 3     A      8      4\n#> 6     B      8      7\n# df2 sorainak rendezése pont.1 és pont.2 csökkenő sorrendjében\ndf2[order(df2$pont.1, df2$pont.2, decreasing=T), ] \n#>   tipus pont.1 pont.2\n#> 6     B      8      7\n#> 3     A      8      4\n#> 2     B      7    201\n#> 5     A      7      6\n#> 4     B      6      5\n#> 1     A      6      2"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-9-exercise","chapter":"5 Az R nyelv","heading":"5.3.7.6 Feladatok","text":"Hozzunk létre egy 30 \\(\\times\\) 3-adattáblát, csoport, matematika és magyar oszlopnevekkel. csoport változó legyen egy 5., 5.b és 5.c címkéket tetszőleges sorrendben tartalmazó faktor, matematika és magyar pedig 1-5 osztályzatokat tartalmazó numerikus vektor.Írassuk ki MASS csomag survey adattáblájának 3. sorában az 5. oszlopban lévő értéket!Írassuk ki MASS csomag survey adattáblájának 3. és 6. sorában sorában az 5. oszlopban lévő értékeket! Az adattábla típus maradjon meg!Írassuk ki MASS csomag survey adattáblájának 3. és 6. sorából az összes adatértéket!Írassuk ki MASS csomag survey adattábla Pulse oszlopát háromféle módszerrel!Írassuk ki MASS csomag survey adattábla Pulse változójának első 3 elemét háromféle módszerrel!HSAUR3 csomag Forbes2000 adattáblája 2000 vállalat adatát tartalmazza! Határozzuk meg magyar cégek nevét és helyezését (country oszlop alapján)! Írassuk ki képernyőre 10 legnagyobb piaci értékkel (marketvalue oszlop) rendelkező cég nevét és piaci értékét! Határozzuk meg legkisebb profittal (profits oszlop) rendelkező 5 cég minden adatát! Határozzuk meg legnagyobb profittal (profits oszlop) rendelkező 10 amerikai vagy japán cég nevét, országát és profitját!fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"további-adatszerkezetek","chapter":"5 Az R nyelv","heading":"5.4 További adatszerkezetek","text":"Ebben fejezetben:megismerjük tömb, táblázat, dátum, idő, időtartam és tibble adatszerkezeteket,valamint munkaterület és munkakönyvtár kezelésének függvényeit.Az R legfontosabb adatszerkezetit megismertük az előző fejezetben. Az adatelemzés kiindulópontja az adattábla, amely mátrix és lista adatszerkezet előnyeit egyesíti, lényegében vektorok és faktorok egymásutánja. munka során azonban találkozhatunk három vagy több dimenzióba szervezett adatokkal (tömb és táblázat), valamint szükség lehet dátum, idő és időtartam kezelésére . Tidyverse R megújította az adattáblát, és bevezette saját tibble típusát az adatok szokásos tárolására. Definiáljuk pontosabban fenti, új adatszerkezeteket:tömb - Azonos alaptípusú értékekből 3 vagy több dimenzió mentén készítünk adatszerkezetet.táblázat - gyakorisági táblázatok R megfelelője, amelyben tipikusan integer adatokat rögzítünk, egy, két vagy több dimenzió mentén.dátum - Egyetlen double érték, amelynek jelentése az 1970-01-01 óta eltelt napok száma.dátum-idő - Egyetlen double érték, amelynek jelentése az 1970-01-01 óta eltelt másodpercek száma.időtartam - Egyetlen double érték, amelynek különböző mértékegységekben mutatja két időpont közötti különbséget.tibble - Speciális adattábla, amely Tidyverse R része, és megkönnyíti az adatok kezelését.Az 5.8. táblázatban már korábban bemutattuk az R legfontosabb adatszerkezeteit, aZ 5.10. táblázat azokat az új adatszerkezeteket sorolja fel, amelyeket ebben fejezetben mutatunk . közöljük, hogy typeof() és class() milyen outputot szolgáltat az egyes adatszerkezetek esetén.\nTÁBLÁZAT 5.10: Adatszerkezetek (folytatás)\n","code":""},{"path":"az-r-nyelv.html","id":"tömbök-és-táblázatok","chapter":"5 Az R nyelv","heading":"5.4.1 Tömbök és táblázatok","text":"tömb mátrix általánosításával nyerhető adatszerkezet. Az azonos típusú adatokat mátrix két dimenzió mentén rendezi össze. Azonban három vagy több dimenzió mentén elvégezhető ez az összerendezés. Így nyerjük három vagy több dimenziós tömböket. mátrix két dimenziós tömbnek tekinthető (vagy vektor egy egy dimenziós tömbnek). táblázat tömbökhöz nagyon hasonló adatszerkezet, de tipikusan számlálással nyert integer értékeket rögzítünk bennük. tömbökhöz hasonlóan lehetnek egy, két, vagy több dimenziósak.","code":""},{"path":"az-r-nyelv.html","id":"tömb-létrehozása-és-indexelése","chapter":"5 Az R nyelv","heading":"5.4.1.1 Tömb létrehozása és indexelése","text":"Az array() függvénnyel egyszerűen hozhatunk létre tömböt. függvény data= argumentumban megadott vektor elemeit dim= argumentumban megadott dimenzió-méretek mentén rendezi össze.háromdimenziós integer tömb 2 \\(\\times\\) 3 \\(\\times\\) 2-es, azaz 2 sorból, 3 oszlopból és 2 lapból áll. Természetesen double, karakteres és logikai tömbök hasonló módszerrel hozhatók létre, csak data= értéket kell megfelelően megválasztani.tömb kiíratása során az indexoperátorokban ([]) szereplő sorszámok segítségével igazodhatunk el az elemek között. háromdimenziós x tömb dimenziói sorok, oszlopok és lapok. 12 elemet két lapon , , 1 és , , 2 nevű lapokon, két-két sorba [1, ], [2, ] és három-három oszlopba [ ,1], [ ,2], [ ,3] rendezve sorolja fel az R. második lapon 2. sor 1. eleméhez meg kell találnunk , , 2 lapot, [2, ] sort és az [ ,1] oszlopot, ami esetünkben 8.tömbök indexelése mátrixokhoz hasonló, csak dimenziószámnak megfelelő számú indexvektort kell használhatunk. Ha x 3 dimenziós, akkor az x[1,3,2] egy lehetséges példa indexelésére, ahol az első sor harmadik oszlopában lévő elemre gondolunk, második lapról. Emlékezhetünk, hogy kétdimenziós mátrixok esetén csak sor és oszlop azonosító indexekre volt szükségünk (például x[2,3]), míg 4 vagy afeletti dimenziószámok esetén természetesen 4 vagy több, vesszővel elválasztott indexet kell megadnunk.","code":"\nx <- array(data=1:12, dim=c(2, 3, 2)) # az 1:12 vektorból 3 dimenziós tömb \nx                       \n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12"},{"path":"az-r-nyelv.html","id":"táblázat-létrehozása","chapter":"5 Az R nyelv","heading":"5.4.1.2 Táblázat létrehozása","text":"Táblázatokat table() függvénnyel hozhatunk létre, tipikusan kategorikus adatokból, vagyis faktor típusú objektumokból. MASS csomag survey adattáblája több faktor oszlopot tartalmaz, ezt használjuk továbbiakban.Egydimenziós gyakorisági táblázat létrehozásához egyetlen faktort használunk table() argumentumában. Érdemes useNA=\"ifany\" argumentumot használni, amely faktorban lévő hiányzó értékek számát adja meg, amennyiben van hiányzó érték változóban.Az output első sorában az egydimenziós táblázat (integer vektor) elemeinek nevét olvashatjuk, melyek Sex faktor lehetséges értékeit és hiányzó értékek címkéjét jelentik. táblázat második sorában lévő számok az egyes címkék előfordulási gyakoriságát jelentik faktorban. Ebben kutatásban (?survey) 118 nőt és 118 férfit kérdeztek meg, egyetlen személynek nem ismerjük nemét.Kétdimenziós gyakorisági táblázat készítéséhez két faktorra van szükség. nem (Sex) mellett kezességet (W.Hnd) bevontuk vizsgálatba:kétdimenziós gyakorisági táblázat (integer mátrix) sornevei és oszlopnevei segítenek értelmezni gyakorisági értékeket. 7 például balkezes nők számát jelenti mintában.Három vagy magasabb dimenziószámú táblázatokat hasonlóan készíthetünk: egyre több faktort vonunk table() függvénybe. Háromdimenziós gyakorisági táblázatra mutatunk példát az Exer faktor bevonásával.háromdimenziós vagy afeletti táblázatok esetében az ftable() kétdimenziós ábrázolással segíti gyakorisági adatok értelmezését.table() függvény helyett használhatjuk az xtabs() függvényt , amely támogatja kicsit kényelmesebb formula argumentumot. Az R formula olyan kifejezés, amely tartalmaz egy tilde (~) karaktert, és annak két oldalán rendszerint egy adattábla oszlopnevei jelennek meg. table() és az xtabs() általános használata következő:Az xtabs() használatára mutatunk 3 példát. Figyeljük meg, hogy hiányzó értékek megjelenítéséhez itt az addNA=T argumentumot kell használnunk. Az xtabs() függvény speciális formulájának bal oldala üres, jobb oldalán pedig faktor változók + karakterrel vannak összekapcsolva.","code":"\ndata(\"survey\", package = \"MASS\")  # a survey betöltése\nstr(survey)\n#> 'data.frame':    237 obs. of  12 variables:\n#>  $ Sex   : Factor w/ 2 levels \"Female\",\"Male\": 1 2 2 2 2 1 2 1 2 2 ...\n#>  $ Wr.Hnd: num  18.5 19.5 18 18.8 20 18 17.7 17 20 18.5 ...\n#>  $ NW.Hnd: num  18 20.5 13.3 18.9 20 17.7 17.7 17.3 19.5 18.5 ...\n#>  $ W.Hnd : Factor w/ 2 levels \"Left\",\"Right\": 2 1 2 2 2 2 2 2 2 2 ...\n#>  $ Fold  : Factor w/ 3 levels \"L on R\",\"Neither\",..: 3 3 1 3 2 1 1 3 3 3 ...\n#>  $ Pulse : int  92 104 87 NA 35 64 83 74 72 90 ...\n#>  $ Clap  : Factor w/ 3 levels \"Left\",\"Neither\",..: 1 1 2 2 3 3 3 3 3 3 ...\n#>  $ Exer  : Factor w/ 3 levels \"Freq\",\"None\",..: 3 2 2 2 3 3 1 1 3 3 ...\n#>  $ Smoke : Factor w/ 4 levels \"Heavy\",\"Never\",..: 2 4 3 2 2 2 2 2 2 2 ...\n#>  $ Height: num  173 178 NA 160 165 ...\n#>  $ M.I   : Factor w/ 2 levels \"Imperial\",\"Metric\": 2 1 NA 2 2 1 1 2 2 2 ...\n#>  $ Age   : num  18.2 17.6 16.9 20.3 23.7 ...\ntable(survey$Sex, useNA = \"ifany\")  # egydimenziós gyakorisági táblázat\n#> \n#> Female   Male   <NA> \n#>    118    118      1\n# kétdimenziós gyakorisági táblázat\ntable(survey$Sex, survey$W.Hnd, useNA = \"ifany\")\n#>         \n#>          Left Right <NA>\n#>   Female    7   110    1\n#>   Male     10   108    0\n#>   <NA>      1     0    0\n# háromdimenziós gyakorisági táblázat\ntable(survey$Sex, survey$W.Hnd, survey$Exer, useNA = \"ifany\")  \n#> , ,  = Freq\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    3    45    1\n#>   Male      3    62    0\n#>   <NA>      1     0    0\n#> \n#> , ,  = None\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    1    10    0\n#>   Male      2    11    0\n#>   <NA>      0     0    0\n#> \n#> , ,  = Some\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    3    55    0\n#>   Male      5    35    0\n#>   <NA>      0     0    0\ntab3 <- table(survey$Sex, survey$W.Hnd, survey$Exer)\nftable(tab3)  # háromdimenziós táblázat két dimenzióban\n#>               Freq None Some\n#>                             \n#> Female Left      3    1    3\n#>        Right    45   10   55\n#> Male   Left      3    2    5\n#>        Right    62   11   35\ntab4 <- table(survey$Sex, survey$W.Hnd, survey$Exer, survey$Smoke)\nftable(tab4)  # négydimenziós táblázat két dimenzióban\n#>                    Heavy Never Occas Regul\n#>                                           \n#> Female Left  Freq      0     2     1     0\n#>              None      0     1     0     0\n#>              Some      0     3     0     0\n#>        Right Freq      3    36     4     2\n#>              None      0     9     1     0\n#>              Some      2    47     3     3\n#> Male   Left  Freq      0     2     1     0\n#>              None      0     1     0     1\n#>              Some      1     3     1     0\n#>        Right Freq      4    45     6     7\n#>              None      1     7     2     0\n#>              Some      0    31     0     4table(df$változó_1, df$változó_2, ..., df$változó_n)\nxtabs(~változó_1 + változó_2 + ... + változó_n, data=df)\nxtabs(~Sex, data=survey, addNA = T)             # 1D gyakorisági táblázat\n#> Sex\n#> Female   Male   <NA> \n#>    118    118      1\nxtabs(~Sex+W.Hnd, data=survey, addNA = T)       # 2D gyakorisági táblázat\n#>         W.Hnd\n#> Sex      Left Right <NA>\n#>   Female    7   110    1\n#>   Male     10   108    0\n#>   <NA>      1     0    0\nxtabs(~Sex+W.Hnd+Exer, data=survey, addNA = T)  # 3D gyakorisági táblázat\n#> , , Exer = Freq\n#> \n#>         W.Hnd\n#> Sex      Left Right <NA>\n#>   Female    3    45    1\n#>   Male      3    62    0\n#>   <NA>      1     0    0\n#> \n#> , , Exer = None\n#> \n#>         W.Hnd\n#> Sex      Left Right <NA>\n#>   Female    1    10    0\n#>   Male      2    11    0\n#>   <NA>      0     0    0\n#> \n#> , , Exer = Some\n#> \n#>         W.Hnd\n#> Sex      Left Right <NA>\n#>   Female    3    55    0\n#>   Male      5    35    0\n#>   <NA>      0     0    0"},{"path":"az-r-nyelv.html","id":"táblázatok-átalakítása","chapter":"5 Az R nyelv","heading":"5.4.1.3 Táblázatok átalakítása","text":"Korábban megismertük az .*() kezdetű függvényeket, amelyek egyszerű típuskonverziót végeznek. gyakorisági táblázatokat gyakran szeretnénk vektor, mátrix, tömb, vagy még gyakrabban adattábla típusban rögzíteni. Ezek az átalakítások az .vector(), .matrix(), .array(), valamint az .data.frame() függvénnyel könnyen elvégezhetők.Az ellenkező irányú átalakítás érdekes lehet, vagyis amikor egy-, két- vagy háromdimenziós tömbökből gyakorisági táblázatot képezünk (.table() függvény), de főképp amikor az adattáblában létező gyakorisági adatokat táblázattá alakítjuk. Itt érdemes az xtabs(Freq~Változó_1+Változó_2+...+Változó_n, data=df) függvényhívást használni, ahol tilde (~) előtti oszlop az adattábla gyakorisági adatait tartalmazza, jobbra lévő változók pedig lényegében faktor változókat nevezik meg.Érdekes lehet egy harmadik eset , amikor gyakorisági adatok állnak rendelkezésre (táblázatos vagy adattábla formátumban) és el szeretnénk készíteni ennek nyers adatokat tartalmazó adattábla megfelelőjét. Vegyük legbonyolultabb eddig tárgyalt esetet, és legyen tab3 kiinduló pontunk, amely egy táblázat. táblázatot korábban tanult módszerrel gyakoriságokat tartalmazó adattáblává alakítjuk, majd eseteket (nyers adatokat) tartalmazó adattáblává.","code":"\ntab1 <- table(survey$Sex, useNA = \"ifany\")       # 1D gyakorisági táblázat\ntab2 <- table(survey$Sex, survey$W.Hnd, useNA = \"ifany\")              # 2D   \ntab3 <- table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = \"ifany\") # 3D  \n(vekt <- as.vector(tab1))     # 1D táblázatból vektor\n#> [1] 118 118   1\n(mat <- as.matrix(tab2))      # 2D táblázatból mátrix\n#>         \n#>          Left Right <NA>\n#>   Female    7   110    1\n#>   Male     10   108    0\n#>   <NA>      1     0    0\n(tomb <- as.array(tab3))      # 3D táblázatból 3D tömb\n#> , ,  = Freq\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    3    45    1\n#>   Male      3    62    0\n#>   <NA>      1     0    0\n#> \n#> , ,  = None\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    1    10    0\n#>   Male      2    11    0\n#>   <NA>      0     0    0\n#> \n#> , ,  = Some\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    3    55    0\n#>   Male      5    35    0\n#>   <NA>      0     0    0\n(df1 <- as.data.frame(tab1))  # 1D táblázatból adattábla\n#>     Var1 Freq\n#> 1 Female  118\n#> 2   Male  118\n#> 3   <NA>    1\n(df2 <- as.data.frame(tab2))  # 2D táblázatból adattábla\n#>     Var1  Var2 Freq\n#> 1 Female  Left    7\n#> 2   Male  Left   10\n#> 3   <NA>  Left    1\n#> 4 Female Right  110\n#> 5   Male Right  108\n#> 6   <NA> Right    0\n#> 7 Female  <NA>    1\n#> 8   Male  <NA>    0\n#> 9   <NA>  <NA>    0\n(df3 <- as.data.frame(tab3))  # 3D táblázatból adattábla\n#>      Var1  Var2 Var3 Freq\n#> 1  Female  Left Freq    3\n#> 2    Male  Left Freq    3\n#> 3    <NA>  Left Freq    1\n#> 4  Female Right Freq   45\n#> 5    Male Right Freq   62\n#> 6    <NA> Right Freq    0\n#> 7  Female  <NA> Freq    1\n#> 8    Male  <NA> Freq    0\n#> 9    <NA>  <NA> Freq    0\n#> 10 Female  Left None    1\n#> 11   Male  Left None    2\n#> 12   <NA>  Left None    0\n#> 13 Female Right None   10\n#> 14   Male Right None   11\n#> 15   <NA> Right None    0\n#> 16 Female  <NA> None    0\n#> 17   Male  <NA> None    0\n#> 18   <NA>  <NA> None    0\n#> 19 Female  Left Some    3\n#> 20   Male  Left Some    5\n#> 21   <NA>  Left Some    0\n#> 22 Female Right Some   55\n#> 23   Male Right Some   35\n#> 24   <NA> Right Some    0\n#> 25 Female  <NA> Some    0\n#> 26   Male  <NA> Some    0\n#> 27   <NA>  <NA> Some    0\nas.table(vekt) # vektorból 1D táblázat\n#>   A   B   C \n#> 118 118   1\nas.table(mat)  # mátrixból 2D táblázat\n#>         \n#>          Left Right <NA>\n#>   Female    7   110    1\n#>   Male     10   108    0\n#>   <NA>      1     0    0\nas.table(tomb) # tömbből 3D táblázat  \n#> , ,  = Freq\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    3    45    1\n#>   Male      3    62    0\n#>   <NA>      1     0    0\n#> \n#> , ,  = None\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    1    10    0\n#>   Male      2    11    0\n#>   <NA>      0     0    0\n#> \n#> , ,  = Some\n#> \n#>         \n#>          Left Right <NA>\n#>   Female    3    55    0\n#>   Male      5    35    0\n#>   <NA>      0     0    0\nxtabs(Freq~Var1, data=df1)           # adattáblából 1D táblázat\n#> Var1\n#> Female   Male \n#>    118    118\nxtabs(Freq~Var1+Var2, data=df2)      # adattáblából 2D táblázat\n#>         Var2\n#> Var1     Left Right\n#>   Female    7   110\n#>   Male     10   108\nxtabs(Freq~Var1+Var2+Var3, data=df3) # adattáblából 3D táblázat\n#> , , Var3 = Freq\n#> \n#>         Var2\n#> Var1     Left Right\n#>   Female    3    45\n#>   Male      3    62\n#> \n#> , , Var3 = None\n#> \n#>         Var2\n#> Var1     Left Right\n#>   Female    1    10\n#>   Male      2    11\n#> \n#> , , Var3 = Some\n#> \n#>         Var2\n#> Var1     Left Right\n#>   Female    3    55\n#>   Male      5    35\ntab3 <- table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = \"ifany\")  \nftable(tab3) # 3D gyakorisági táblázat kiterítve\n#>               Freq None Some\n#>                             \n#> Female Left      3    1    3\n#>        Right    45   10   55\n#>        NA        1    0    0\n#> Male   Left      3    2    5\n#>        Right    62   11   35\n#>        NA        0    0    0\n#> NA     Left      1    0    0\n#>        Right     0    0    0\n#>        NA        0    0    0\ndf3 <- as.data.frame(df3) # adattáblából 3D táblázat\ndf3\n#>      Var1  Var2 Var3 Freq\n#> 1  Female  Left Freq    3\n#> 2    Male  Left Freq    3\n#> 3    <NA>  Left Freq    1\n#> 4  Female Right Freq   45\n#> 5    Male Right Freq   62\n#> 6    <NA> Right Freq    0\n#> 7  Female  <NA> Freq    1\n#> 8    Male  <NA> Freq    0\n#> 9    <NA>  <NA> Freq    0\n#> 10 Female  Left None    1\n#> 11   Male  Left None    2\n#> 12   <NA>  Left None    0\n#> 13 Female Right None   10\n#> 14   Male Right None   11\n#> 15   <NA> Right None    0\n#> 16 Female  <NA> None    0\n#> 17   Male  <NA> None    0\n#> 18   <NA>  <NA> None    0\n#> 19 Female  Left Some    3\n#> 20   Male  Left Some    5\n#> 21   <NA>  Left Some    0\n#> 22 Female Right Some   55\n#> 23   Male Right Some   35\n#> 24   <NA> Right Some    0\n#> 25 Female  <NA> Some    0\n#> 26   Male  <NA> Some    0\n#> 27   <NA>  <NA> Some    0\n# az átalakítás 2 sora:\ndf.long <- df3[rep(row.names(df3), df3$Freq), c(\"Var1\", \"Var2\", \"Var3\")]\nrownames(df.long) <- seq_along(rownames(df.long))\nhead(df.long)  # az első 6 sor kiírása\n#>     Var1 Var2 Var3\n#> 1 Female Left Freq\n#> 2 Female Left Freq\n#> 3 Female Left Freq\n#> 4   Male Left Freq\n#> 5   Male Left Freq\n#> 6   Male Left Freq"},{"path":"az-r-nyelv.html","id":"dátum-és-idő","chapter":"5 Az R nyelv","heading":"5.4.2 Dátum és idő","text":"Az adatelemzés során dátumok kezelésének két fő oka lehet, egyrészt szűrésekben használhatjuk őket, például adott dátum vagy időpont előtti, utáni vagy közötti sorok leválogatásában, másrészt statisztikai elemzések irányulhatnak két dátum vagy időpont között eltelt időtartamra.","code":""},{"path":"az-r-nyelv.html","id":"dátum-kezelése","chapter":"5 Az R nyelv","heading":"5.4.2.1 Dátum kezelése","text":"Amennyiben le akarjuk kérdezni az aktuális dátumot, akkor Sys.Date() függvényt kell használnunk.Láthatjuk, hogy datum objektum dátum (Date) típusú annak ellenére, hogy az objektum értéke képernyőn kettős idézőjelek között jelenik meg. dátum típus alapja egy double szám van, amely az 1970. 01. 01. óta eltelt napok számát tartalmazza, ahogyan az unclass(datum) ezt számunkra meg mutatja. Világos, hogy az double érték lehet nulla vagy negatív .","code":"\ndatum <- Sys.Date()    # aktuális dátum, dátum típusú objektum\ndatum                  # datum kiírása\n#> [1] \"2022-09-09\"\ntypeof(datum)          # datum típusa\n#> [1] \"double\"\nclass(datum)           # datum típusa\n#> [1] \"Date\"\nunclass(datum)         # datum alapja\n#> [1] 19244\nunclass(as.Date(\"1980-01-01\")) # a double szám pozitív\n#> [1] 3652\nunclass(as.Date(\"1970-01-01\")) # a double szám nulla\n#> [1] 0\nunclass(as.Date(\"1960-01-01\")) # a double szám negatív\n#> [1] -3653"},{"path":"az-r-nyelv.html","id":"dátum-létrehozása-karakteres-adatból","chapter":"5 Az R nyelv","heading":"5.4.2.1.1 Dátum létrehozása karakteres adatból","text":"Dátumot legtöbb esetben karakteres konstansból hozunk létre az .Date() függvény segítségével. dátumok változatos formában jelenhetnek meg, szabványos \"2019-02-12\" (ISO 8601) alak mellett sok olyan forma létezik, amelyben elválasztó karakterként perjel vagy pont szerepel, valamint az év-hó-nap hármas sorrendje változhat. konkrét dátum értelmezéséhez az .Date() függvény format= argumentumát kell helyesen beállítani. használható kódokat 5.11. táblázat tartalmazza.TÁBLÁZAT 5.11:  Formátumkódok dátumokbanLátható, hogy szabványos esetekben nem szükséges format= argumentum használata, de formátumkódokkal tetszőleges sztringet dátum típusúvá alakíthatunk. hónapnevek megjelenése azonban nyelvfüggő, ezért itt R verziónk helyi beállításaira figyelni kell.Magyar számítógépes környezetben helyi beállítás (?locales) alapértelmezés szerint magyar, ennek megfelelően magyar hónapnevekkel dolgozik az .Date() függvény, így fenti konverziók kívánt eredményt adják. Sys.getlocale(\"LC_TIME\") paranccsal vizsgálhatjuk meg, hogy milyen környezetben dolgozunk. Sys.setlocale(\"LC_TIME\", \"C\") utasítás észak-amerikai beállításokra vált az R, az angol hónapnevek felismerésére így nyílik lehetőség:","code":"\nas.Date(\"2020-04-12\")   # szabványos, nem kell format= argumentum\n#> [1] \"2020-04-12\"\nas.Date(\"2020/04/12\")   # szabványos, nem kell format= argumentum\n#> [1] \"2020-04-12\"\nas.Date(\"04/12/2020\", format=\"%m/%d/%Y\")          # amerikai stílus\n#> [1] \"2020-04-12\"\nas.Date(\"12.04.2020\", format=\"%d.%m.%Y\")          # brit stílus\n#> [1] \"2020-04-12\"\nas.Date(\"2020. 04. 12.\", format=\"%Y. %m. %d.\")    # magyar stílus\n#> [1] \"2020-04-12\"\nSys.getlocale(\"LC_TIME\")                          # a helyi beállítás magyar?\n#> [1] \"Hungarian_Hungary.utf8\"\nas.Date(\"2020. ápr. 12.\", format=\"%Y. %b %d.\")    # rövid magyar hónapnévvel\n#> [1] \"2020-04-12\"\nas.Date(\"2020. április 12.\", format=\"%Y. %B %d.\") # magyar hónapnévvel\n#> [1] \"2020-04-12\"\nlct <- Sys.getlocale(\"LC_TIME\")                   # helyi beállítás mentése\nSys.setlocale(\"LC_TIME\", \"C\")                     # észak-amerikai beállítás \n#> [1] \"C\"\nas.Date(\"Apr 12, 2020\", format=\"%b %d, %Y\")       # rövid angol hónapnévvel\n#> [1] \"2020-04-12\"\nas.Date(\"12 April 2020\", format=\"%d %B %Y\")       # angol hónapnévvel\n#> [1] \"2020-04-12\"\nSys.setlocale(\"LC_TIME\", lct)  # magyar helyi beállítás visszatöltése  \n#> [1] \"Hungarian_Hungary.utf8\""},{"path":"az-r-nyelv.html","id":"dátum-létrehozása-numerikus-adatokból","chapter":"5 Az R nyelv","heading":"5.4.2.1.2 Dátum létrehozása numerikus adatokból","text":"Dátumot szeparáltan létező numerikus év, hónap, nap információkból létrehozhatunk. Ehhez először az ISOdate() függvénnyel időpontot állítunk elő, majd az .Date()-tel dátumot. Ezzel módszerrel egyszerre több dátumot előállíthatunk.","code":"\nas.Date(ISOdate(year = 2020, month = 4, day = 12))   # dátum előállítása\n#> [1] \"2020-04-12\"\nas.Date(ISOdate(year = 2020, month = 1:4, day = 12)) # dátumok előállítása\n#> [1] \"2020-01-12\" \"2020-02-12\" \"2020-03-12\" \"2020-04-12\""},{"path":"az-r-nyelv.html","id":"dátum-konvertálása","chapter":"5 Az R nyelv","heading":"5.4.2.1.3 Dátum konvertálása","text":"Ha már van egy dátum típusú objektumunk, akkor azt változatos módon jeleníthetjük meg format() függvény segítségével, amely egyszerű karakteres adattal tér vissza.","code":"\n(datum <- as.Date(\"04/12/2020\", format = \"%m/%d/%Y\"))\n#> [1] \"2020-04-12\"\nformat(datum, format=\"%Y. %m. %d.\") # magyar dátum\n#> [1] \"2020. 04. 12.\"\nformat(datum, format=\"%Y. %B %d.\")  # magyar dátum\n#> [1] \"2020. április 12.\"\nformat(datum, format=\"%Y. %b %d.\")  # magyar dátum\n#> [1] \"2020. ápr. 12.\"\nformat(datum, format=\"%Y-%m\")       # csak az év és a hónap\n#> [1] \"2020-04\"\nformat(datum, format=\"%Y\")          # csak az év\n#> [1] \"2020\""},{"path":"az-r-nyelv.html","id":"dátum-idő-kezelése","chapter":"5 Az R nyelv","heading":"5.4.2.2 Dátum-idő kezelése","text":"dátum-idő (POSIXct típus) olyan double érték, amelynek jelentése az 1970-01-01 óta eltelt másodpercek száma. Az aktuális dátum és idő lekérdezése Sys.time() függvénnyel lehetséges, és ez az általunk dátum-idő típusnak tekintett POSIXct objektummal tér vissza:fentiek alapján úgy tűnhet, hogy POSIXct objektum egész másodperceket tárol csupán, de ez nem így van. Az alapértelmezett megjelenítéseken módosítva láthatóvá válnak tört másodpercek :POSIXct objektumok másik érdekessége az időzóna tárolása, amely alapértelmezés szerint magyar környezetben futó R helyi beállításainak megfelelően közép-európai (CEST) időt jelent. saját rendszerünk időzónája Sys.timezone() függvénnyel kérdezhető le, lehetséges időzónákat az OlsonNames() függvény listázza. legtöbb esetben ezzel nem kell foglalkoznunk, nemzetközi kutatások esetében azonban fontos lehet ismerni az időzóna váltás lehetőségét.Egyik lehetőség, hogy eleve kívánt időzónának megfelelő időpontokkal dolgozunk. Ekkor Sys.setenv() függvénnyel beállíthatjuk kívánt időzónát, amely legtöbb esetben koordinált világidő (UTC) vagy másképp greenwichi középidő (GMT). Tudjuk, hogy magyarországi időzóna téli időszámításkor közép-európai idő (CET, UTC+1), nyáron közép-európai nyári idő (CEST, UTC+2).másik lehetőség, hogy már egy létező POSIXct objektumon végzünk időzóna konverziót, amely így az objektum óra (vagy egyéb) részét érintheti.","code":"\nido <- Sys.time()     # pontos dátum-idő, POSIXct típusú objektum\nido                   # ido kírása\n#> [1] \"2022-09-09 20:23:11 CEST\"\ntypeof(ido)           # ido típusa\n#> [1] \"double\"\nclass(ido)            # ido típusa\n#> [1] \"POSIXct\" \"POSIXt\"\nunclass(ido)          # ido alapja\n#> [1] 1662747791\nop <- options(digits.secs = 6, digits = 16)\nido             # POSIXct kiírása változott digits.sec=6 miatt\n#> [1] \"2022-09-09 20:23:11.208062 CEST\"\nunclass(ido)    # double kiírása változott digits=6 miatt\n#> [1] 1662747791.208063\noptions(op)     # alapértelmezések visszaállítása\ntz <- Sys.timezone()  # helyi időzóna mentése\nSys.setenv(TZ=\"UTC\")  # UTC (GMT) időzóna beállítása\nSys.time()            # pontos dátum-idő lekérése UTC szerint\n#> [1] \"2022-09-09 18:23:11 UTC\"\nSys.setenv(TZ=tz)     # alapértelmezett időzóna visszaállítása\nido <- Sys.time()  # pontos dátum-idő, helyi beállításnak megfelelően\nido.utc <- as.POSIXct(format(ido, tz=\"UTC\"), tz=\"UTC\")  # konverzió UTC-re\nido        # helyi időzónával\n#> [1] \"2022-09-09 20:23:11 CEST\"\nido.utc    # UTC-vel\n#> [1] \"2022-09-09 18:23:11 UTC\""},{"path":"az-r-nyelv.html","id":"dátum-idő-létrehozása-karakteres-adatból","chapter":"5 Az R nyelv","heading":"5.4.2.2.1 Dátum-idő létrehozása karakteres adatból","text":"Amennyiben karakteres formában rendelkezésre áll egy időpont, akkor mindössze az egyes komponensek jelentését kell elmagyaráznunk az .POSIXct() függvény format= argumentumában. Szabványos idő megadása esetén ((ISO 8601)) ezt el hagyhatjuk.dátum értelmezéséhez használt kódok köre (5.11. táblázat) kibővül ??. táblázatban szereplő időre vonatkozó kódokkal, így ezeket használhatjuk POSIXct objektum létrehozása során. Teljes listát az ?strptime súgójában olvashatunk.","code":"\nas.POSIXct(\"2022-06-02 22:12:23\", tz = \"Europe/Budapest\")  # szabványos idő\n#> [1] \"2022-06-02 22:12:23 CEST\"\nas.POSIXct(\"2019.09.06. 16 34 17\", format=\"%Y.%m.%d. %H %M %S\", tz=\"UTC\")\n#> [1] \"2019-09-06 16:34:17 UTC\""},{"path":"az-r-nyelv.html","id":"dátum-idő-létrehozása-numerikus-adatokból","chapter":"5 Az R nyelv","heading":"5.4.2.2.2 Dátum-idő létrehozása numerikus adatokból","text":"Dátum-időt szeparáltan létező információkból létrehozhatunk. Ehhez az ISOdatetime() függvényt kell használni, ahol minden egyes komponens egyesével felsorolható:","code":"\n# POSIXct objektum a dátum-idő tárolására\nISOdatetime(year=2022, month=7, day=3, \n            hour=11, min=12, sec=3, tz = \"Europe/Budapest\")\n#> [1] \"2022-07-03 11:12:03 CEST\""},{"path":"az-r-nyelv.html","id":"dátum-idő-konvertálása","chapter":"5 Az R nyelv","heading":"5.4.2.2.3 Dátum-idő konvertálása","text":"POSIXct objektum dátum típusúvá konvertálható az .Date() függvénnyel, illetve format() függvény segítségével tetszőleges formájú karakteres dátumot/időt nyerhetünk ki az objektumból.","code":"\nido <- Sys.time()  # pontos dátum-idő, helyi beállításnak megfelelően\nido                # dátum-idő objektum\n#> [1] \"2022-09-09 20:23:11 CEST\"\nas.Date(ido)       # dátum objektum\n#> [1] \"2022-09-09\"\nformat(ido, format=\"%Y. %m. %d.\")              # magyar dátum\n#> [1] \"2022. 09. 09.\"\nformat(ido, format=\"%Y. %B %d. %H.%M.%S\")      # magyar dátum-idő\n#> [1] \"2022. szeptember 09. 20.23.11\"\nformat(ido, format=\"%Y. %b %d. %H:%M:%S\")      # magyar dátum-idő\n#> [1] \"2022. szept. 09. 20:23:11\"\nformat(ido, format=\"%Y. %m. %d. %H:%M:%S %Z\")  # magyar dátum-idő\n#> [1] \"2022. 09. 09. 20:23:11 CEST\""},{"path":"az-r-nyelv.html","id":"műveletek-és-az-időtartam","chapter":"5 Az R nyelv","heading":"5.4.2.3 Műveletek és az időtartam","text":"többnyire szöveges formában megjelenő dátumok és dátum-idők R objektummá alakításának legnagyobb haszna, hogy Date és POSIXct objektumokkal számos műveletet hajthatunk végre. Lehetőségünk van például különböző dátumok összehasonlítására, kivonására, léptetésére, vagy ábrákon tengelyeket címkézhetjük dátum objektumokkal. Két dátum (vagy dátum-idő) különbsége az időtartam, amelyet kivonás (-) operátorral, vagy difftime() függvénnyel előállíthatunk. Utóbbi nagyobb szabadságot ad, mert rendelkezik egy unit= argumentummal az időtartam mértékegységének megadására, így értéke lehet \"secs\", \"mins\", \"hours\", \"days\" vagy \"weeks\" .Ne feledjük, hogy az időtartam egy típus az R-ben (difftime osztály), ahogyan következő sorokban ez megfigyelhetjük:difftime() működik dátum-idővel , és természetesen két dátum vagy időpont között szokásos műveletek elvégezhetők. Google Űrlap időbélyeg oszlopából rögzítettünk két adatot és elvégeztünk néhány műveletet köztük:","code":"\nSys.Date() - as.Date(\"2001-03-17\")          # születésnap óta eltelt idő napokban\n#> Time difference of 7846 days\ndifftime(Sys.Date(), as.Date(\"2001-03-17\")) # ua.\n#> Time difference of 7846 days\ndifftime(Sys.Date(), as.Date(\"2001-03-17\"), unit=\"hours\") # órákban\n#> Time difference of 188304 hours\nas.numeric(difftime(Sys.Date(), as.Date(\"2001-03-17\"), unit=\"hours\")) # számként\n#> [1] 188304\ndifft <- difftime(Sys.Date(), as.Date(\"2001-03-17\"), unit=\"hours\")\ntypeof(difft)   # difft típusa\n#> [1] \"double\"\nclass(difft)    # difft típusa\n#> [1] \"difftime\"\nunclass(difft)  # difft alapja\n#> [1] 188304\n#> attr(,\"units\")\n#> [1] \"hours\"\nidobelyeg.1 <- as.POSIXct(\"2022.04.06. 11:11:33\", \n                          format=\"%Y.%m.%d. %H:%M:%S\", tz=\"UTC\")\nidobelyeg.2 <- as.POSIXct(\"2022.04.06. 12:06:35\", \n                          format=\"%Y.%m.%d. %H:%M:%S\", tz=\"UTC\")\nidobelyeg.1 == idobelyeg.2  # nem egyenlőek\n#> [1] FALSE\nidobelyeg.1 < idobelyeg.2   # az első időbélyeg a korábbi\n#> [1] TRUE\n# hány másodperc telt el a két válasz között\nas.numeric(difftime(idobelyeg.2, idobelyeg.1, unit=\"sec\"))\n#> [1] 3302"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-12-summary","chapter":"5 Az R nyelv","heading":"5.4.2.4 Összefoglalás","text":"\ndátumokat Date dátum-időket POSIXct objektumban\ntároljuk az R-ben, melyekkel szokásos dátumkezelő műveletek már\nkönnyen elvégezhetők. Időtartamot, vagyis két dátum vagy időpont közötti\nkülönbséget difftime() függvénnyel határozhatunk meg.\n","code":""},{"path":"az-r-nyelv.html","id":"az-r-nyelv-12-exercise","chapter":"5 Az R nyelv","heading":"5.4.2.5 Feladatok","text":"Konvertáljuk dátummá következő két sztringet: \"6November2020\", \"2013-02-29\"! Utóbbi esetben mi lehet hiba oka?seq() függvény = és = argumentuma dátum típusú objektumokkal működik. = argumentum értéke ilyenkor lehet numerikus (ekkor napokat jelent), de lehet x weeks, x months vagy x years, ahol x nullánál nagyobb egész lehet. Hozzunk létre egy dátum-vektort 2020 összes hétfőjének dátumával!Halley-üstökös utoljára 1986-ban járt Naprendszerünkben, így az előrejelzések szerint legközelebb 2061. július 26-ban tér vissza. Rögzítsük ezt dátumként, és számoljuk ki, hány napotot kell még várni az üstökös érkezésére.fenti feladatok megoldása","code":""},{"path":"az-r-nyelv.html","id":"tibble","chapter":"5 Az R nyelv","heading":"5.4.3 Tibble","text":"Tidyverse R használata során az adatainkat tibble típusú objektumban tároljuk. Használatához töltsük tidyverse csomagot.tibble objektumok alaptípusa lista, de az osztálytípusok között megjelennek tibble-re specifikus osztályok . tbl_df osztály jelenléte hozza magával azokat az új tulajdonságokat és lehetőségeket, amit Tidyverse R központi adatszerkezetévé teszi ezt az objektumtípust.tibble és data frame típusú objektumok között az átjárhatóságot az as_tibble() és az .data.frame() függvény biztosítja.tibble típus tesztelése az is_tibble() segítségével történik, de tibble típusú objektumokra az .data.frame() igaz értékkel tér vissza:Melyek data frame és tibble közötti különbségek? Már három eltérést akár észre vehettünk. Az első tibble létrehozásához kötődik. Egy tibble típusú objektum, csak azonos hosszúságú oszlopvektorokból hozható létre, így biztonságosabban konstruálható, mint az ismétlést támogató data frame típusú objektumok. Tibble esetében csak az egy hosszú vektorok ismétlése megengedett. Tehát ez konstrukció működik:második különbség, hogy tibble létrehozás során nem végez automatikus típuskonverziót. Tehát karakteres vektorokat nem alakítja át faktorokká.harmadik különbség az adatok megjelenítésében van. Tibble esetében csak az első 10 sor jelenik meg, és annyi oszlop, amennyi az aktuális képernyőre kifér. több oszlop neve alul jelenik meg. Az oszlopnevek alatt az oszlop típusa megjelenik.negyedik eltérés tibble indexeléséhez kötődik. Az [ operátor használata során minden esetben tibble típusú objektumot kapunk, nem kaphatunk vektort, azaz nem történhet dimenzióvesztés.","code":"\nlibrary(tidyverse)\nx <- rep(c('A','B'), times=4); y <- rep(6:9, times=2); z <- 1:8\ndf <- tibble(nev=x, pont.1=y, pont.2=z)\ndf\n#> # A tibble: 8 × 3\n#>   nev   pont.1 pont.2\n#>   <chr>  <int>  <int>\n#> 1 A          6      1\n#> 2 B          7      2\n#> 3 A          8      3\n#> 4 B          9      4\n#> 5 A          6      5\n#> 6 B          7      6\n#> 7 A          8      7\n#> 8 B          9      8\nattributes(df)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5 6 7 8\n#> \n#> $names\n#> [1] \"nev\"    \"pont.1\" \"pont.2\"\ntypeof(df); class(df)\n#> [1] \"list\"\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\nas_tibble(df)\n#> # A tibble: 8 × 3\n#>   nev   pont.1 pont.2\n#>   <chr>  <int>  <int>\n#> 1 A          6      1\n#> 2 B          7      2\n#> 3 A          8      3\n#> 4 B          9      4\n#> 5 A          6      5\n#> 6 B          7      6\n#> 7 A          8      7\n#> 8 B          9      8\nas.data.frame(df)\n#>   nev pont.1 pont.2\n#> 1   A      6      1\n#> 2   B      7      2\n#> 3   A      8      3\n#> 4   B      9      4\n#> 5   A      6      5\n#> 6   B      7      6\n#> 7   A      8      7\n#> 8   B      9      8\nis_tibble(df); is.data.frame(df)\n#> [1] TRUE\n#> [1] TRUE\ntibble(a=c(\"a\", \"b\", \"c\"), p=1)\n#> # A tibble: 3 × 2\n#>   a         p\n#>   <chr> <dbl>\n#> 1 a         1\n#> 2 b         1\n#> 3 c         1\nstr(df)\n#> tibble [8 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ nev   : chr [1:8] \"A\" \"B\" \"A\" \"B\" ...\n#>  $ pont.1: int [1:8] 6 7 8 9 6 7 8 9\n#>  $ pont.2: int [1:8] 1 2 3 4 5 6 7 8\ndf[, 2]\n#> # A tibble: 8 × 1\n#>   pont.1\n#>    <int>\n#> 1      6\n#> 2      7\n#> 3      8\n#> 4      9\n#> 5      6\n#> 6      7\n#> 7      8\n#> 8      9\ndf[1, ]\n#> # A tibble: 1 × 3\n#>   nev   pont.1 pont.2\n#>   <chr>  <int>  <int>\n#> 1 A          6      1\ndf[1, 2]\n#> # A tibble: 1 × 1\n#>   pont.1\n#>    <int>\n#> 1      6\ndf[1, 2, drop=T]\n#> [1] 6"},{"path":"az-r-nyelv.html","id":"a-munkaterület-függvényei","chapter":"5 Az R nyelv","heading":"5.4.4 A munkaterület függvényei","text":"Megbeszéltük, hogy munka során az objektumaink memória speciális területére, munkaterületre (workspace) kerülnek. Ha még korábban nem hoztunk létre objektumot, akkor következő három parancs, három objektumot hoz létre munkaterületen:munkaterületen létrehozott objektumok neveit az ls() függvény listázza ki:munkaterületről objektumot az rm() paranccsal távolíthatunk el, például aa fib.0 objektumot távolította el, így az ls() eredményében ez nem szerepel. Az összes munkaterület-objektum eltávolítása asegítségével történik.","code":"\nfib.0 <- 0\nfib.1 <- 1\nfib.2 <- fib.0 + fib.1\n# ls()\nrm(fib.0)         # fib.0 törlése\nls()\n#>  [1] \"a\"               \"alap\"            \"D\"               \"datum\"          \n#>  [5] \"df\"              \"df.long\"         \"df1\"             \"df2\"            \n#>  [9] \"df3\"             \"difft\"           \"egyutthato.a\"    \"egyutthato.b\"   \n#> [13] \"egyutthato.c\"    \"eset.1\"          \"eset.2\"          \"eset.3\"         \n#> [17] \"fib.1\"           \"fib.2\"           \"fiu\"             \"foglalkozas\"    \n#> [21] \"hazas\"           \"ido\"             \"ido.utc\"         \"idobelyeg.1\"    \n#> [25] \"idobelyeg.2\"     \"import_example\"  \"isk.vegz\"        \"isk.vegz.f\"     \n#> [29] \"iteletek\"        \"lakohely\"        \"lct\"             \"magassag\"       \n#> [33] \"mat\"             \"nev\"             \"nevek\"           \"obj.double\"     \n#> [37] \"obj.integer\"     \"obj.karakteres\"  \"obj.logikai\"     \"op\"             \n#> [41] \"peter.bmi\"       \"peter.magassaga\" \"peter.sulya\"     \"pontszamok\"     \n#> [45] \"pulzus.atlag\"    \"Pulzus.atlag\"    \"regi.v.1\"        \"regi.v.2\"       \n#> [49] \"survey\"          \"szamok\"          \"tab1\"            \"tab2\"           \n#> [53] \"tab3\"            \"tab4\"            \"table.kiir\"      \"tan.ido\"        \n#> [57] \"tipus\"           \"tomb\"            \"tz\"              \"uj.v\"           \n#> [61] \"v.d\"             \"v.i\"             \"v.k\"             \"v.l\"            \n#> [65] \"van.kocsija\"     \"vekt\"            \"x\"               \"x.d\"            \n#> [69] \"x.f\"             \"x.f.1\"           \"x.f.2\"           \"x.f.3\"          \n#> [73] \"y\"               \"z\"               \"z.uj\"\n# rm(list = ls())   # összes objektum törlése\n# ls()"},{"path":"az-r-nyelv.html","id":"a-munkakönyvtár-függvényei","chapter":"5 Az R nyelv","heading":"5.4.5 A munkakönyvtár függvényei","text":"Az R használata során mindig van egy kitüntetett, aktuális könyvtárunk, amelyet munkakönyvtárnak nevezünk. munkakönyvtár célja, hogy az állományok nyitása és mentése során, ha nem használunk külön könyvtárhivatkozást, akkor ez lesz az alapértelmezett könyvtár.munkakönyvtár az R-ben lekérdezhető ill. beállítható getwd() és setwd() parancsok kiadásával. Példáulparancsokkal először megismerjük az aktuális könyvtárat, majd megváltoztatjuk C:/Data/peldak könyvtárra. Figyeljük meg, hogy az elérési útban perjelet (/) használtunk.Megjegyezzük, hogy az RStudio projekt üzemmódú használata során nincs szükség munkakönyvtár beállítására setwd() paranccsal, sőt, kerüljük használatát. munkakönyvtárunk munka során végig maradjon meg az alapértelmezetten beállított könyvtár, maga projektkönyvtár.munkakönyvtár jelentőségét tovább növeli, hogy az R indításakor ebben könyvtárban 2 állomány létezését figyeli:\n* .Rhistory (visszahívható parancsokat tartalmazó szöveges állomány)\n* .RData (tárolt objektumokat tartalmazó bináris állomány).fenti állományok ugyanis betöltésre kerülnek az R indításakor, ha azokat az R megtalálja munkakönyvtárban. Így ezek után, az .Rhistory állományból jövő parancsok között válogathatunk parancssor használata során, illetve az .RData állományban tárolt objektumok azonnal elérhetőek, vagyis lesz egy induló munkaterületünk.","code":"\ngetwd()\nsetwd(\"C:/Data/peldak\")"},{"path":"az-r-nyelv.html","id":"csomagkezelő-függvények","chapter":"5 Az R nyelv","heading":"5.4.6 Csomagkezelő függvények","text":"Korábban megbeszéltük, hogy csomagok adatobjektumokat és függvényeket tartalmaznak. Az ún. egyéb csomagok (számuk kb. 17000) elsődleges célja az Alap R tudásának kiegészítése.Az R indítása után néhány csomag automatikusan betöltésre kerül standard csomagok közül. Ezeket csomagokat és egyéb ún. környezeteket listázhatunk ki search() függvénnyel.fenti eredményben package karaktersorozattal kezdődő elemek mutatják, hogy melyek az éppen betöltött csomagok. listában nem szereplő, de korábban telepített csomagok betöltéséhez használjuk library() vagy require() függvényeket.fenti példában MASS és foreign csomag betöltését és annak hatását követhetjük nyomon search() függvény outputjára. Egy csomag betöltése azt jelenti, hogy csomagban lévő függvények és objektumok memóriába kerültek, azokat parancsainkban ezután szabadon felhasználhatjuk.Egy adott csomagban (esetünkben foreign csomagban) lévő függvények és objektumok avagy aparanccsal kérdezhetők le. Betöltött csomagok esetében használhatjuk azparancsot , amely csomag adatobjektumainak és függvényeinek nevét listázza.Betöltött csomagot detach() függvénnyel távolíthatunk el memóriából:Ha használni kívánt csomag még nincs telepítve számítógépünkre, akkor az @ref(Csomagok_telepítése). fejezetben ismertetett módok egyikét válasszuk, attól függően, hogy csomag melyik tárhelyről érhető el.CRAN-ról elérhető csomagok közül telepítsük fel DescTools és psych csomagokat:számítógépünkön telepített csomagokról az installed.packages() függvény ad tájékoztatást. Amennyiben aparancsot kiadjuk az RStudio-ban, akkor csomagjainkat kényelmesen áttekinthetjük.Csomagok frissítésére használjuk már korábban említettparancsot.","code":"\nsearch()\ndetach(\"tools:rstudio\")\n## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(MASS)\nrequire(foreign)\nsearch()\n##  [1] \".GlobalEnv\"        \"package:foreign\"   \"package:MASS\"     \n##  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n##  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n## [10] \"Autoloads\"         \"package:base\"  \nlibrary(help=foreign)\nhelp(package=foreign)\nls(name=\"package:foreign\", all.names = T)\nls(name=\"package:base\", all.names = T)\ndetach(package:foreign)\ndetach(package:MASS)\ninstall.packages(\"DescTools\")\ninstall.packages(\"psych\")\ncsomagok <- installed.packages()\nView(csomagok)                    # RStudio-ban vagy RGui-ban\nupdate.packages()"},{"path":"az-r-nyelv.html","id":"az-r-nyelv-14-exercise","chapter":"5 Az R nyelv","heading":"5.4.7 Feladatok","text":"Írassuk ki munkaterület objektumait!Hozzunk létre egy pulzus nevű objektumot és újra írassuk ki munkaterület objektumneveit!Távolítsuk el pulzus objektumot munkaterületről!Határozzuk meg az aktuális munkakönyvtárat!Növeljük meg betű méretét az RGui, az R Commander és az R Studio alkalmazásokban !Vizsgáljuk meg, hogy számítógépünkön van-e telepítve DescTools csomag, ha nincs telepítsük! Derítsük ki, hogy DescTools csomagnak mi célja? Soroljunk fel három függvényt és adattáblát ebből csomagból! Távolítsuk el memóriából DescTools csomagot!Telepítsük számítógépünkre következő csomagokat: HSAUR2, psych, prettyR, descr és pastecs!","code":""},{"path":"az-r-nyelv.html","id":"haladó-nyelvi-elemek","chapter":"5 Az R nyelv","heading":"5.5 Haladó nyelvi elemek","text":"","code":""},{"path":"az-r-nyelv.html","id":"objektumok-és-típusok","chapter":"5 Az R nyelv","heading":"5.5.1 Objektumok és típusok","text":"Az R-ben használható objektumok név-érték párok, vagyis minden objektumnak van neve és értéke. Objektumok alatt ebben könyvben az adatobjektumokat értjük, bár már említettünk, hogy valójában függvények objektumoknak tekinthetők az R-ben, hiszen függvénynek van neve, és értéke, az utóbbi pedig utasítások sorozata. Az R-ben minden objektum, például az eddig vizsgált vektorok, attribútumokkal rendelkezhetnek. Az attribútumok név-értek párok, amelyek speciális tulajdonságokkal ruházzák fel az objektumunkat. Például names nevű attribútummal vektor egyes elemeit nevezhetjük el. Későbbiekben látjuk dim, dimnames, level és class attribútumok jelentőségét .Egy objektum összes attribútuma az attributes() függvénnyel kérdezhetők le. Ha names attribútumra vagyunk kíváncsiak names() függvényt használhatjuk. Ha létrehozunk egy x numerikus vektort, akkorAz x numerikus vektornak nincsenek attribútumai. NULL az általános, elem nélküli vektort jelenti. fenti outputban szereplő két NULL esetünkben azt jelzi, hogy nem állítottunk semmilyen attribútumot, így names attribútumot sem.names attribútum beállítható names() függvénnyel .names attribútum értéke karakteres vektor lehet, amely az outputokban megjelenik és indexelésben felhasználhatjuk.Rögzítsük (0, 1, 2) értékek előfordulási gyakoriságait (18, 12, 20) elemeket tartalmazó vektorban. Az elemek nevei karakteres konstansok lesznek, az automatikus konverzióról az R gondoskodik.Az y vektor indexelésénél fontos, hogy megkülönböztessük numerikus és karakteres indexeket, az utóbbiaknál mindig idézőjelet kell használnunk.Egyetlen attribútum lekérdezésére és beállítására az attr() függvényt használhatjuk. Az attr() függvényben meg kell adnunk az elérendő attribútum nevét .Attribútumok törlésére NULL értéket használjuk.dim argumentumAmennyibenOsztályokA faktor ennek megfelelően tartalmaz egy levels attribútumot, amely faktor különböző értékeit (szintjeit) sorolja fel. faktorok class attribútumának értéke pedig factor.class() függvény az objektum class argumentumával tér vissza. Azok az objektumok, amelyek nem rendelkeznek class argumentummal, class() visszatérési értéke\"numeric\", ha az objektum integer vagy double vektor\"array\" és/vagy \"matrix\", ha az objektum rendelkezik dim attributummalmás esetben typeof() visszatérési értékével.Az unclass() visszatérési értéke az az objektum, amelynek class attribűtumát eltávolították.korábban tárgyat típusok mindegyike osztály: Date, difftime, POSIXct, POSIXlt, table.listaelemek nevét x lis names attribútuma tartalmazza, segítségével többi elemnek adhatunk értéket:","code":"\nx <- 1:5        # integer vektor\nattributes(x)   # x attribútumainak kiírása \n#> NULL\nnames(x)        # x name attribútumának kiírása\n#> NULL\n\nx <- numeric(0)\nmode(x) <- \"list\"\nclass(x)\n#> [1] \"list\"\nlength(x)\n#> [1] 0\n\nattr(x, \"length\") <- \"integer\"\nx <- c(\"a\"=1, \"b\"=2, \"c\"=3, \"d\"=4, \"e\"=5) # integer vektor\nattributes(x)                  # x attribútumainak kiírása \n#> $names\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\"\nnames(x)                       # x name attribútumának kiírása\n#> [1] \"a\" \"b\" \"c\" \"d\" \"e\"\nnames(x) <- c(\"elégtelen\", \"elégséges\", \"közepes\", \"jó\", \"jeles\")\nattributes(x)                  # x attribútumainak kiírása \n#> $names\n#> [1] \"elégtelen\" \"elégséges\" \"közepes\"   \"jó\"        \"jeles\"\nnames(x)                       # x name attribútumának kiírása\n#> [1] \"elégtelen\" \"elégséges\" \"közepes\"   \"jó\"        \"jeles\"\nx\n#> elégtelen elégséges   közepes        jó     jeles \n#>         1         2         3         4         5\nx[c(\"közepes\", \"jó\")]\n#> közepes      jó \n#>       3       4\ny <- c(18, 12, 20)\nnames(y) <- 0:2\ny\n#>  0  1  2 \n#> 18 12 20\nnames(y)\n#> [1] \"0\" \"1\" \"2\"\nx[1]\n#> elégtelen \n#>         1\nx[\"1\"]\n#> <NA> \n#>   NA\nx[c(1,3)]; x[c(\"0\", \"2\")]\n#> elégtelen   közepes \n#>         1         3\n#> <NA> <NA> \n#>   NA   NA\nattr(x, \"names\") <- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nattr(x, \"names\")\n#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nattributes(x)\n#> $names\n#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nnames(x) <- NULL             # names attribútum törlése\nattr(x, \"names\") <- NULL     # names attribútum törlése\nattributes(x) <- NULL        # az összes attribútum törlése\nx <- 1:12                      # integer vektor\nx\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12\nattr(x, \"dim\") <- c(2,6)       # integer mátrix (2x6-os)       \nattributes(x)\n#> $dim\n#> [1] 2 6\nx\n#>      [,1] [,2] [,3] [,4] [,5] [,6]\n#> [1,]    1    3    5    7    9   11\n#> [2,]    2    4    6    8   10   12\nattr(x, \"dim\") <- c(2, 3, 2)   # integer tömb (2x3x2-es)\nattributes(x)\n#> $dim\n#> [1] 2 3 2\nx\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\nx <- 1:12                      # integer vektor\nattr(x, \"dim\") <- c(2,6)       # integer mátrix (2x6-os)       \ndimnames(x) <- list(nem=c(\"férfi\", \"nő\"), osztaly=LETTERS[1:6])        \nx\n#>        osztaly\n#> nem     A B C D  E  F\n#>   férfi 1 3 5 7  9 11\n#>   nő    2 4 6 8 10 12\nattributes(x)\n#> $dim\n#> [1] 2 6\n#> \n#> $dimnames\n#> $dimnames$nem\n#> [1] \"férfi\" \"nő\"   \n#> \n#> $dimnames$osztaly\n#> [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\nf <- factor(c(\"a\", \"b\", \"a\"))\nattributes(f)\n#> $levels\n#> [1] \"a\" \"b\"\n#> \n#> $class\n#> [1] \"factor\"\nlevels(f)\n#> [1] \"a\" \"b\"\nclass(f)\n#> [1] \"factor\"\nclass(f) <- NULL\n#attributes(f)<- NULL\n#f\nunclass(f)\n#> [1] 1 2 1\n#> attr(,\"levels\")\n#> [1] \"a\" \"b\"\nx <- as.Date(\"2020-03-12\")\nattributes(x)\n#> $class\n#> [1] \"Date\"\nclass(x)\n#> [1] \"Date\"\n\nx <- Sys.Date()-as.Date(\"2020-03-12\")\nx\n#> Time difference of 911 days\nattributes(x)\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"days\"\nclass(x)\n#> [1] \"difftime\"\n\nx <- ISOdate(year = 2020, month = 12, day = 2)\nx\n#> [1] \"2020-12-02 12:00:00 GMT\"\nattributes(x)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"GMT\"\nclass(x)\n#> [1] \"POSIXct\" \"POSIXt\"\n\nx <- as.POSIXlt(x)\nx\n#> [1] \"2020-12-02 12:00:00 GMT\"\nattributes(x)\n#> $names\n#> [1] \"sec\"   \"min\"   \"hour\"  \"mday\"  \"mon\"   \"year\"  \"wday\"  \"yday\"  \"isdst\"\n#> \n#> $class\n#> [1] \"POSIXlt\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"GMT\"\nclass(x)\n#> [1] \"POSIXlt\" \"POSIXt\"\n\nx <- table(sample(LETTERS[1:3], 100, replace = T))\nx\n#> \n#>  A  B  C \n#> 37 32 31\nattributes(x)\n#> $dim\n#> [1] 3\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"A\" \"B\" \"C\"\n#> \n#> \n#> $class\n#> [1] \"table\"\nclass(x)\n#> [1] \"table\"\nnames(x)\n#> [1] \"A\" \"B\" \"C\"\nnames(x)[c(1,2)] <- c(\"a\",\"b\")\nnames(x)\n#> [1] \"a\" \"b\" \"C\"\nx\n#>  a  b  C \n#> 37 32 31"},{"path":"az-r-nyelv.html","id":"értékek-kizárása","chapter":"5 Az R nyelv","heading":"5.5.1.1 Értékek kizárása","text":"faktor létrehozásánál gondoskodhatunk bizonyos értékek kizárásáról, olyan értékekről, amelyeket nem szeretnénk faktorban felsorolni:Alapértelmezés szerint az NA értéket zárjuk ki faktor szintjeiből, de ezt megváltoztathatjuk az exclude= paraméter használatával:Ahogy látjuk fenti példában, akár az NA értéket bevonhatjuk faktor szintjeibe, akár más értékeket kizárhatunk az NA-n kívül.Nézzük, hogyan tekint az R az adattáblára.Az adattáblák alaptípusa list, osztálytípusa pedig data.frame hossza pedig az alkotó (oszlop)vektorok/faktorok száma. Az adattáblára tehát tekinthetünk úgy, mint egy listára, melynek elemei az adattábla oszlopai lesznek.Feladat234\n(23)4\n2(34)","code":"\nfactor(c(1:5, NA, 3:6))\n#>  [1] 1    2    3    4    5    <NA> 3    4    5    6   \n#> Levels: 1 2 3 4 5 6\nfactor(c(1:5, NA, 3:6), exclude=NULL)\n#>  [1] 1    2    3    4    5    <NA> 3    4    5    6   \n#> Levels: 1 2 3 4 5 6 <NA>\nfactor(c(1:5, NA, 3:6), exclude=c(4, NA))\n#>  [1] 1    2    3    <NA> 5    <NA> 3    <NA> 5    6   \n#> Levels: 1 2 3 5 6\n#typeof(df); class(df); length(df)\n#is.list(df); is.matrix(df); is.data.frame(df)"},{"path":"beolvasas.html","id":"beolvasas","chapter":"6 Beolvasás","heading":"6 Beolvasás","text":"","code":""},{"path":"beolvasas.html","id":"beolvas-alapveto","chapter":"6 Beolvasás","heading":"6.1 Alapvető formátumok","text":"Ebben fejezetben áttekintjük:táblázatkezelők állományainak beolvasását,tagolt szöveges állományok fogalmát ésazok beolvasását az Alap R-ben.Az R-ben adatokkal dolgozunk, amelyek beolvasására és kiírására az R számos eljárást kínál. Adatokat beolvashatunk billentyűzetről, vágóasztalról és külső adatforrásból, állományból vagy adatbázisból . Az R-ben feldolgozott adatokat vágóasztalra, adatbázisba vagy állományba írhatjuk ki. Ebben fejezetben csak két legtermészetesebb beolvasási módszert ismertetjük, az adatok beolvasást táblázatkezelők (pl. Microsoft Excel, LibreOffice Calc) állományaiból és tagolt szöveges állományokból.","code":""},{"path":"beolvasas.html","id":"táblázatkezelők","chapter":"6 Beolvasás","heading":"6.1.1 Táblázatkezelők","text":"táblázatkezelők saját állományai (pl. .xlsx és .ods) kezelhetők legkényelmesebben az adatelemzés során. Az adatbevitel és rögzített adatok karbantartása, későbbi módosítása ebben formátumban legegyszerűbb, ráadásul számítógépes tesztek sokszor ilyen típusú állományokba írják válaszokat. Ezek az állományok (munkafüzetek) munkalapokból állnak, így akár több adatbázist tárolhatunk egyetlen munkafüzetben. Egy Excel vagy LibreOffice Calc adatbázis esetén tudnunk kell, hogy az melyik munkalapon helyezkedik el, ritkábban pedig azt , melyik tartományban foglal helyet beolvasandó adatbázis.Az Excel és LibreOffice Calc adatbázisok beolvasást rio csomag import() függvényével végezzük, melynek egyetlen kötelező argumentuma fájl elérési útja (file=).Előkészítettünk egy 4 munkalapos Excel és LibreOffice Calc adatbázist (agatha_christie_m.xlsx, agatha_christie_m.ods), amelynek mindegyik munkalapján ugyanazt az adatbázist találjuk meg, de egyre zajosabb környezetben.Az 1. munkalapon nincsenek zavaró cellák, csupán adatbázisunk értékes adatcellái az A1 cellától kezdődően.. Ebben az esetben nincs szükség más argumentumra, csak az állomány elérési útjára.2. munkalapon már nem az A1 cellában kezdődik az adatbázis, de továbbra sincs zavaró egyéb cella. Az import() megtalálja az adatbázist munkalapon az Excel adatbázis esetében, de LibreOffice Calc adatbázis beolvasásához pontosítani kell az adatbázis helyét. tartomány közvetlen megadásával (range=\"F7:I52\") utasítjuk az import() függvényt, hogy honnan olvassa az adatbázisunkat. Természetesen megadott cellatartomány az oszlopneveket tartalmazza annak első sorában.Az XLSX és az ODS beolvasása közötti eltérés rávilágít az import() függvényünk működésére. Nem maga az import() végzi közvetlen beolvasást, hanem okosan kiválasztja beolvasandó állomány kiterjesztése alapján, hogy melyik csomag, melyik konkrét függvényét hívja. Az Excel állományokat Tidyverse R readxl csomag read_excel() függvénye fogja beolvasni, LibreOffice Calc állományokat readODS csomag read_ods() függvénye, amelyek hívását már az import() végzi. Mivel két különböző függvény dolgozik háttérben, így az XLSX és az ODS állományokat beolvasó parancs paraméterezése eltérhet, és esetünkben el tér. file= argumentum közös, és természetesen munkalap sorszámát meg kell adnunk, amely mindkét esetben sheet=2-vel történik.3. munkalapon már az első 6 sor zavaró, nem az adatbázishoz tartozó adatokat tartalmaz, így azokat elegendő kihagyni (skip=6) beolvasásból az Excel esetében, míg az ODS-hez tartomány pontos megadása szükséges sikeres beolvasásához.4. munkalapon már rendkívül terhelt az adatbázisunk környező zavaró celláktól, így közvetlenül tartomány megadásával (range=\"F7:I52\") utasítjuk az import() függvényt Excel esetében , hogy honnan olvassa az adatbázisunkat.Jegyezzük meg, ha csak tehetjük, adatainkat táblázatkezelő programmal hozzuk létre és annak saját formátumában (XLSX vagy ODS) tároljuk.","code":"\nlibrary(rio)\nac.1 <- import(file = \"adat/agatha_christie_m.xlsx\") # MS Excel\nhead(ac.1[1:3], n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\nac.1 <- import(file = \"adat/agatha_christie_m.ods\")  # LibreOffice Calc\nhead(ac.1[1:3], n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\nac.2 <- import(file = \"adat/agatha_christie_m.xlsx\", sheet=2)\nhead(ac.2, n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\n#>      szereplo\n#> 1 Miss Marple\n#> 2 Miss Marple\n#> 3 Miss Marple\nac.2 <- import(file = \"adat/agatha_christie_m.ods\", sheet=2, range=\"F7:I52\")\nhead(ac.2, n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\n#>      szereplo\n#> 1 Miss Marple\n#> 2 Miss Marple\n#> 3 Miss Marple\nac.3 <- import(file = \"adat/agatha_christie_m.xlsx\", sheet=3, skip=6)\nhead(ac.3, n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\n#>      szereplo\n#> 1 Miss Marple\n#> 2 Miss Marple\n#> 3 Miss Marple\nac.3 <- import(file = \"adat/agatha_christie_m.ods\", sheet=3, range=\"F7:I52\")\nhead(ac.3, n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\n#>      szereplo\n#> 1 Miss Marple\n#> 2 Miss Marple\n#> 3 Miss Marple\nac.4 <- import(file = \"adat/agatha_christie_m.xlsx\", sheet=4, range=\"F7:I52\")\nhead(ac.4, n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\n#>      szereplo\n#> 1 Miss Marple\n#> 2 Miss Marple\n#> 3 Miss Marple\nac.4 <- import(file = \"adat/agatha_christie_m.ods\", sheet=4, range=\"F7:I52\")\nhead(ac.4, n=3)\n#>   megjelenes.eve                  cim.magyar                  cim.angol\n#> 1           1930      Gyilkosság a paplakban The Murder at the Vicarage\n#> 2           1942 Holttest a könyvtárszobában    The Body in the Library\n#> 3           1942           A láthatatlan kéz          The Moving Finger\n#>      szereplo\n#> 1 Miss Marple\n#> 2 Miss Marple\n#> 3 Miss Marple"},{"path":"beolvasas.html","id":"tagolt-szöveges-állományok","chapter":"6 Beolvasás","heading":"6.1.2 Tagolt szöveges állományok","text":"tagolt szöveges állományok kitüntetett szerepet játszanak statisztikai adatfeldolgozásban, ugyanis minden statisztikai programcsomag és táblázatkezelő tud olvasni ilyen formátumú állományokat, és ki tud exportálni ilyen formátumba. tagolt szöveges állományok létrehozásához pedig egy jegyzettömbszerű szövegszerkesztő elegendő, tehát ez formátum elég nagy szabadságot ad az adataink kezeléshez.","code":""},{"path":"beolvasas.html","id":"tagolt-szöveges-állomány-létrehozása","chapter":"6 Beolvasás","heading":"6.1.2.1 Tagolt szöveges állomány létrehozása","text":"tagolt szöveges állomány egy egyszerű, formázást nem tartalmazó szöveges állomány, amelyet azonos szerkezetű sorok alkotnak. sorokat az operációs rendszernek megfelelő sorvége karakterek zárják. Jegyzettömbszerű szövegszerkesztő használata során, az ENTER leütésével ezek sorvége karakterek kerülnek fizikailag szöveges állományba. Linux és macOS operációs rendszer alatt az LF karakter, Windows platformon CR és LF karakterek. Ezeket sorvége karaktereknek hívjuk, az LF soremelés (\\n), CR kocsi vissza (\\r) karakter. Annak ellenére, hogy különböző platformokon más-más jelzi sorvégét, beolvasó függvények felismerik ezeket, és helyesen értelmezik. Ezzel nekünk nem kell külön foglalkoznunk.Minden tagolt szöveges állományban van egy kitüntetett karakter, tagoló karakter. Ez tipikusan pontosvessző (;), szóköz (), tabulátor (\\t) vagy vessző (,) karakter. tagolt szöveges állomány minden sorában ezek egyikét használjuk az adatértékek elválasztására, ráadásul minden sorban azonos számú adatértéknek kell szerepelni, ennek megfelelően minden sorban azonos számú tagoló karakter van.Nézzünk példát pontosvesszővel tagolt szöveges állományra:Összesen 4 sora van, soronként 3 adatértékkel, és 2 pontosvesszővel. Látható, hogy az első sor kitüntetett, azaz igazából nem méréssel kapott adatokat tartalmaz, hanem megnevezi azokat. Gyakori, hogy tagolt szöveges állományok első sora ilyen speciális fejlécsor, amely tehát oszlopneveket tartalmaz. Ez nem kötelező, elképzelhető, hogy az első sorban már közvetlenül adatértékek vannak.Nézzünk egy szóközzel tagolt szöveges állományt:Ez tagolt szöveges állomány 4 sort, soronként 4 adatértéket és 3 elválasztó szóközt tartalmaz. Az első sora fejlécsor. Látható, hogy tizedes törtek szerepelnek az állományban, tizedesvesszőt valóban vesszővel jelöltük. Ez nem minden esetben van így, tizedes pont elválaszthatná az egész és tört részt.Tekintsünk egy elsőre kicsit rendezetlen szöveges állományt:Az állomány második felében valóban felfedezhetjük rendezettséget, fejlécet 4 oszlopnévvel, és alatta sorokat 4-4 adatértékkel. Ez rész olyan, mint egy vesszővel elválasztott szöveges állomány, ahol tizedes törtekben pontot használunk az egész és tört rész elválasztására.Az állomány eleje azonban egyáltalán nem hasonlít tagolt szöveges állományokra, és ráadásul kettős kereszttel (#), vagyis megjegyzésnek szánt szövegekkel tarkított soraink vannak. Az ilyen szabadabb stílusú állományok beolvashatók az R-, csupán meg kell adnunk, hogy az elejéről hány sort hagyjon figyelmen kívül (3 sort), és mit tekintsen megjegyzésnek (kettős keresztet) beolvasását végző eljárás. Ebben az esetben fejlécen kívül még 2 adatsor lesz beolvasott adattáblában.Melyek tagolt szöveges állományok fontos jellemzői:tagoló karakter,decimális elválasztó,van-e fejlécsor,hány sort lépjünk át az elejéről,mi megjegyzés karakter,milyen kódolású az állomány.Ahogyan említettük tagolt szöveges állományt egy jegyzettömbszerű szövegszerkesztővel mi létrehozhatunk, de ha módunk van rá, akkor minél kényelmesebb adatbevitel miatt, használjunk táblázatkezelőt, és az abban elkészült táblázatos formában lévő adatokat exportáljuk ki tagolt szöveges állományba. Például magyar Excel esetén választhatjuk CSV (pontosvesszővel tagolt), vagy Szöveges (tabulátorral tagolt) formátumot. Érdemes minden esetben megőrizni táblázatkezelő saját formátumában az adatokat, mert kényelmes szerkesztés miatt továbbra abban érdemes az adatokat módosítani, de változtatások után, utolsó lépésként, végezzük el az exportot tagolt szöveges állományba.","code":"nem;kor;pulzus\nfiú;12;71\nfiú;11;69\nlány;14;70nem kor pulzus atlag\nfiú 12 71 3,92\nfiú 11 69 4,12\nlány 14 70 5,00Általános iskolai felmérés\n2019.03.02.\n\n#2.b\nnem,kor,pulzus,atlag\nfiú,12,71,3.92\n#fiú,11,69,4.12\nlány,14,70,5.00 # ellenőrizni"},{"path":"beolvasas.html","id":"a-read.table-család","chapter":"6 Beolvasás","heading":"6.1.2.2 A read.table() család","text":"Tagolt szöveges állományok beolvasásának hagyományos módja read.table() függvénycsalád használata. Azért nevezzük függvénycsaládnak, mert valójában több függvényt használhatunk, amelyek csak paraméterek alapértelmezett értékében térnek el egymástól:read.table(sep=\"\", dec=\".\"),read.csv(sep=\",\", dec=\".\"),read.csv2(sep=\";\", dec=\",\"),read.delim(sep=\"\\t\", dec=\".\"),read.delim2(sep=\"\\t\", dec=\",\").Érdemes fenti függvénynevek megtanulása helyett egyetlen függvényt, read.table()-t használni, és inkább lehetséges paraméterek jelentését tanuljuk meg:file=\nbeolvasandó állomány elérési útja.sep=\nAz elválasztó karakter beolvasandó állományban. Tipikus értékei: sep=\";\", sep=\" \", sep=\",\", és tabulátor elválasztó esetén sep=\"\\t\".dec=\ndecimális elválasztó, vagyis tizedesvessző alakja az állományban. Tipikusan dec=\",\" beállítást kell használnunk, de előfordulhat, hogy pont tizedes elválasztó, így dec=\".\"-ra van szükségünk.header=\nHa van fejléc szöveges állományban, akkor header=TRUE, egyébként header=FALSE beállítást használjuk.na.strings=\nhiányzó érték jelölése szöveges állományban. Az alapértelmezett beállítás legtöbb esetben megfelelő, hiszen \"\" (semmi) és az \"NA\" jelölésből alapértelmezés szerint hiányzó érték lesz.comment.char=\ntipikus megjegyzés karakter #, de meg tudjuk változtatni, ha szükséges.skip=\nszöveges állomány első néhány sorát figyelmen kívül hagyhatjuk.stringsAsFactors=\nstringsAsFactors=TRUE beállítással elérhetjük karakteres oszlopok automatikus faktorrá konvertálását.fileEncoding=\nszöveges állományt alkotó karakterek kódolási szabványát adhatjuk meg. Tipikusan az UTF-8 kódolású szöveges állományok beolvasása során kell használnunk (fileEncoding=\"UTF-8\"), de magyar környezetben készült szöveges állományok esetében rögzíthetjük kódolási szabványt (fileEncoding=\"latin2\").strip.white=\nfelesleges szóközök és tabulátorok eltávolítása az adatok elejéről és végéről.quote=\nszöveges állományban lévő adatvédő idézőjelek alakja.Végezzük el az egyetem.csv tagolt szöveges állomány beolvasását, amelynek első néhány sora következő:beolvasandó állományunk egy első sorában oszlopneveket tartalmazó szöveges állomány, amelynek tartalmát következő parancsok egy d.df adattáblában helyezik el. Az állományban az adatokat (és az oszlopneveket ) pontosvessző (;) választja el, numerikus értékekben pedig tizedesvessző szerepel.","code":"hallgato;Height;neme;lefekves;felkeles;Drink\n1;67;female;-2,5;5,5;víz\n2;64;female;1,5;8;üdítő\n3;61;female;-1,5;7,5;tej\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv\"\nd.df <- read.table(file = data.file, header=T, \n                                     sep=\";\", \n                                     dec=\",\", \n                                     strip.white = T, \n                                     stringsAsFactors = F, \n                                     fileEncoding = \"latin2\")\nstr(d.df)\n#> 'data.frame':    657 obs. of  6 variables:\n#>  $ hallgato: int  1 2 3 4 5 6 7 8 9 10 ...\n#>  $ Height  : num  67 64 61 61 70 63 61 64 66 65 ...\n#>  $ neme    : chr  \"female\" \"female\" \"female\" \"female\" ...\n#>  $ lefekves: num  -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ...\n#>  $ felkeles: num  5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ...\n#>  $ Drink   : chr  \"víz\" \"üdítő\" \"tej\" \"víz\" ..."},{"path":"beolvasas.html","id":"beolvasas-1-summary","chapter":"6 Beolvasás","heading":"6.1.3 Összefoglalás","text":"\nstatisztikai munka első lépése az adatbázisok, adatmátrixok\nbeolvasása. Adatainkat legkényelmesebb Excel vagy LibreOffice Calc\ntáblázatkezelők saját formátumú adatállományiban tárolni\n(XLSX, ODS), de néha nem kerülhetjük el \ntagolt szöveges állományok használatát. táblázatkezelők\nadatállományait rio csomag import()\nfüggvényével olvashatjuk , tagolt szöveges állományokat \nread.table() függvénnyel.\n","code":""},{"path":"beolvasas.html","id":"beolvasas-1-exercise","chapter":"6 Beolvasás","heading":"6.1.4 Feladatok","text":"Olvassuk https://onlinestatbook.com/2/case_studies/data/leniency.xls Excel állományt, állapítsuk meg hány sora és oszlopa van.Olvassuk https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv tagolt szöveges állományt, állapítsuk meg hány sora és oszlopa van.fenti feladatok megoldása","code":""},{"path":"beolvasas.html","id":"a-tidyverse-r-és-az-inline-beolvasás","chapter":"6 Beolvasás","heading":"6.2 A Tidyverse R és az inline beolvasás","text":"Ebben fejezetben áttekintjükaz inline beolvasás eseteit ésaz inline beolvasás eseteit ésa tagolt szöveges állományok Tidyverse R beolvasását.\ntagolt szöveges állományok Tidyverse R beolvasását.","code":""},{"path":"beolvasas.html","id":"a-read_delim-függvénycsalád","chapter":"6 Beolvasás","heading":"6.2.1 A read_delim() függvénycsalád","text":"Tidyverse R képes tagolt szöveges állományok beolvasására, és rendszerint gyorsabb, jobban paraméterezhető lehetőséget nyújt. Lényeges különbség az előző részben látott read.table() családhoz képest, hogy minden esetben tibble típusú adattábla beolvasás eredménye.read_delim() család tagjai:read_delim(),read_csv,read_csv2,read_tsv.Minden esetben használjuk read_delim() függvényt, amely nagyon hasonló paraméterekkel rendelkezik, mint read.table():file=\nUgyanaz, mint read.table() függvénynél.delim=\nUgyanaz, mint read.table() függvénynél sep= argumentum.locale=\ndecimális elválasztó és kódolási szabvány beállításához locale() függvényt használjuk. Ha szokásos vessző tizedes vessző alakja, akkor locale = locale(decimal_mark = \",\"), egyébként locale = locale(decimal_mark = \".\") beállítást használjuk. Ha kódolási szabványt szeretnénk állítani vessző decimális elválasztó mellett, akkor locale = locale(decimal_mark = \".\", encoding = \"UTF-8\") beállításra van szükségünk az UTF-8 beállításához.col_names=\nUgyanaz, mint read.table() függvénynél header= argumentum.na=\nUgyanaz, mint read.table() függvénynél na.strings= argumentum.comment=\nUgyanaz, mint read.table() függvénynél comment.char= argumentum.skip=\nUgyanaz, mint read.table() függvénynél.trim_ws\nUgyanaz, mint read.table() függvénynél strip.white= argumentum.quote\nUgyanaz, mint read.table() függvénynél.Végezzük el már korábban megismert egyetem.csv tagolt szöveges állomány beolvasását Tidyverse R segítségével:","code":"\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv\"\nlibrary(tidyverse)\nd.tbl <- read_delim(file = data.file, col_names=T, \n                                      delim=\";\", \n                                      locale=locale(decimal_mark=\",\", encoding = \"latin2\"), \n                                      trim_ws= T)\nstr(d.tbl)\n#> spec_tbl_df [657 × 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n#>  $ hallgato: num [1:657] 1 2 3 4 5 6 7 8 9 10 ...\n#>  $ Height  : num [1:657] 67 64 61 61 70 63 61 64 66 65 ...\n#>  $ neme    : chr [1:657] \"female\" \"female\" \"female\" \"female\" ...\n#>  $ lefekves: num [1:657] -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ...\n#>  $ felkeles: num [1:657] 5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ...\n#>  $ Drink   : chr [1:657] \"víz\" \"üdítő\" \"tej\" \"víz\" ...\n#>  - attr(*, \"spec\")=\n#>   .. cols(\n#>   ..   hallgato = col_double(),\n#>   ..   Height = col_double(),\n#>   ..   neme = col_character(),\n#>   ..   lefekves = col_double(),\n#>   ..   felkeles = col_double(),\n#>   ..   Drink = col_character()\n#>   .. )\n#>  - attr(*, \"problems\")=<externalptr>"},{"path":"beolvasas.html","id":"inline-beolvasás","chapter":"6 Beolvasás","heading":"6.2.2 Inline beolvasás","text":"Ebben könyvben külső adatállományokból való beolvasás mellet az inline adatbeolvasást részletesen bemutatjuk. Kisebb adatbázisok, egyszerűbb adatfeldolgozás esetén az adatokat közvetlenül parancsállományokban elhelyezhetjük, ezt nevezzük sorok közötti, vagy más néven inline adatbeolvasásának. szokásos eset azonban külső adatállományból való adatbeolvasás.Az adatok inline beolvasása azt jelenti, hogy nem külső állományból, hanem az R parancsállományba gépelt adatokból indulunk ki. Felhasználjuk c(), factor() és data.frame() függvényeket az Alap R-ből, valamint tibble() vagy tribble() függvényeket Tidyverse R-ből. Esetleg használhatjuk az állományok beolvasását végző, megismert read.table() (Alap R) és read_delim() (Tidyverse R) függvénycsaládokat .legegyszerűbb adatfeldolgozási feladatok egyetlen változót érintenek, ezek pedig numerikus vektorban vagy faktorban tárolhatók az R-ben. Ez az inline beolvasás legegyszerűbb esete.Több változó tárolása esetén adattábla (data frame) vagy tibble típusú objektumot hozunk létre korábban már megismert data.frame() és tibble() függvények segítségével. Előkészítő lépésként természetesen az oszlopokat alkotó vektorokra szükség van.létrehozott adattáblák nagyon hasonlítanak egymásra, és felhasználásuk azonos módon történik:Nem kell feltétlenül az adattáblát alkotó oszlopokat külön numerikus vagy faktor oszlopokban előzőleg elkészíteni, ezeket data.frame() vagy tibble() argumentumába közvetlenül beírhatjuk:Tibble létrehozásának másik módja tribble() függvény, amelynek argumentumába táblázatos formában adhatjuk meg az adatokat. változóneveket ~ karakter vezeti , minden adatértéket és oszlopnevet vessző választ el egymástól tribble() argumentumában.Vegyük észre, hogy nem oszlop fenti példában karakteres vektor, faktorrá alakításáról factor() függvénnyel gondoskodnunk kell.read.table() és read_delim() függvénycsaládokat használhatjuk inline beolvasásra. Mindkét esetben egy inline, szóközzel tagolt szöveges állományt illesztettünk kódba, ennek megfelelően állítottuk az elválasztó karaktereket. read.table() esetében körbevettük textConnection() függvénnyel beillesztett adatokat, erre Tidyverse R read_delim()-jénél már nincs szükség. nem faktorrá konvertálásáról se felejtkezzünk el.","code":"\n# 4 óvodás testmagassága cm-ben\nmagassag <- c(132, 143, 129, 145)\nmean(magassag)  # testmagasság átlaga\n#> [1] 137.2\n# a 4 óvodás neme\nnem <- factor(c(\"fiú\", \"lány\", \"lány\", \"fiú\"), levels=c(\"fiú\", \"lány\")) \ntable(nem, useNA = \"ifany\")  # gyakorisági táblázat a nemre\n#> nem\n#>  fiú lány \n#>    2    2\nlibrary(tidyverse)\nmagassag <- c(132, 143, 129, 145)\nnem <- factor(c(\"fiú\", \"lány\", \"lány\", \"fiú\"), levels=c(\"fiú\", \"lány\")) \nd.df  <- data.frame(magassag, nem) # data frame létrehozása\nd.tbl <- tibble(magassag, nem)     # tibble létrehozása\nd.df    # data frame\n#>   magassag  nem\n#> 1      132  fiú\n#> 2      143 lány\n#> 3      129 lány\n#> 4      145  fiú\nd.tbl   # tibble\n#> # A tibble: 4 × 2\n#>   magassag nem  \n#>      <dbl> <fct>\n#> 1      132 fiú  \n#> 2      143 lány \n#> 3      129 lány \n#> 4      145 fiú\nmean(d.df$magassag)                # testmagasság átlaga\n#> [1] 137.2\nmean(d.tbl$magassag)               # testmagasság átlaga\n#> [1] 137.2\ntable(d.df$nem, useNA = \"ifany\")   # gyakorisági táblázat a nemre\n#> \n#>  fiú lány \n#>    2    2\ntable(d.tbl$nem, useNA = \"ifany\")  # gyakorisági táblázat a nemre\n#> \n#>  fiú lány \n#>    2    2\nd.df <- data.frame(\n  magassag = c(132, 143, 129, 145),\n  nem = factor(c(\"fiú\", \"lány\", \"lány\", \"fiú\"), levels=c(\"fiú\", \"lány\")) \n)\n\nd.tbl <- tibble(\n  magassag = c(132, 143, 129, 145),\n  nem = factor(c(\"fiú\", \"lány\", \"lány\", \"fiú\"), levels=c(\"fiú\", \"lány\")) \n)\nd.tbl <- tribble(\n  ~magassag,  ~nem,\n  132, \"fiú\",\n  143, \"lány\",\n  129, \"lány\",\n  145, \"fiú\"\n)\nd.tbl\n#> # A tibble: 4 × 2\n#>   magassag nem  \n#>      <dbl> <chr>\n#> 1      132 fiú  \n#> 2      143 lány \n#> 3      129 lány \n#> 4      145 fiú\nd.tbl$nem <- factor(d.tbl$nem, levels=c(\"fiú\", \"lány\")) \nd.tbl\n#> # A tibble: 4 × 2\n#>   magassag nem  \n#>      <dbl> <fct>\n#> 1      132 fiú  \n#> 2      143 lány \n#> 3      129 lány \n#> 4      145 fiú\nd.df <- read.table(file = textConnection(\"\nmagassag nem\n132 fiú\n143 lány\n129 lány\n145 fiú\n\"), header=T, sep=\" \")\nd.df$nem <- factor(d.df$nem, levels=c(\"fiú\", \"lány\")) \nd.df\n#>   magassag  nem\n#> 1      132  fiú\n#> 2      143 lány\n#> 3      129 lány\n#> 4      145  fiú\nd.tbl <- read_delim(\"\nmagassag nem\n132 fiú\n143 lány\n129 lány\n145 fiú\n\", col_names=T, delim=\" \")\nd.tbl$nem <- factor(d.tbl$nem, levels=c(\"fiú\", \"lány\")) \nd.tbl\n#> # A tibble: 4 × 2\n#>   magassag nem  \n#>      <dbl> <fct>\n#> 1      132 fiú  \n#> 2      143 lány \n#> 3      129 lány \n#> 4      145 fiú"},{"path":"beolvasas.html","id":"beolvasas-2-summary","chapter":"6 Beolvasás","heading":"6.2.3 Összefoglalás","text":"\nswwwww\n","code":""},{"path":"beolvasas.html","id":"beolvasas-2-exercise","chapter":"6 Beolvasás","heading":"6.2.4 Feladatok","text":"sadadasdaA fenti feladatok megoldása","code":""},{"path":"beolvasas.html","id":"kiírás-és-más-lehetőségek","chapter":"6 Beolvasás","heading":"6.3 Kiírás és más lehetőségek","text":"Ebben fejezetben áttekintjüka tagolt szöveges állományok kiírásáta tagolt szöveges állományok kiírásátobjektumok olvasását és írását bináris állományokba,objektumok olvasását és írását bináris állományokba,más statisztikai programcsomagok adatállományainak olvasását és írását, ésmás statisztikai programcsomagok adatállományainak olvasását és írását, ésa fix széles mezővel rendelkező állományok olvasását.\nfix széles mezővel rendelkező állományok olvasását.","code":""},{"path":"beolvasas.html","id":"tagolt-szöveges-állomány-kiírása","chapter":"6 Beolvasás","heading":"6.3.1 Tagolt szöveges állomány kiírása","text":"Adattáblák és mátrixok kiírására write.table() függvényt használhatjuk az Alap R-ből és write_delim() függvényt Tidyverse R-ből. Mindkét függvény egy-egy függvénycsalád reprezentánsa, de az Alap R-ből elegendő ismerni az említett tagot, Tidyverse R-ből pedig az említetten kívül write_csv2() függvényt. Néhány új argumentummal kell megismerkednünk, korábban tanult argumentumok jelentését még egyszer nem soroljuk fel.write.table() mátrixok és adattáblák kiírására alkalmas, míg write_delim() és write_csv2() csak az adattáblákat rögzíti. Az első paraméter (x=) kiírandó objektum neve mindhárom függvény esetében.Az első példában write.table() függvénnyel egy mátrixot és korábban létrehozott d.df adattáblát írjuk ki. row.names= és col.names= logikai paraméterek szabályozzák, hogy sor és oszlopnevek szerepeljenek-e kimeneti állományban. Ezek alapértelmezett értéke TRUE.Tidyverse kiíró függvényei UTF-8 kódolású állományt hoznak létre minden esetben, és decimális elválasztó alakja write_delim() esetében pont, write_csv2() esetében pedig vessző. sornevek soha nem íródnak ki, az oszlopnevek kiírását col_names= argumentummal szabályozhatjuk.","code":"\nx.mat <- matrix(1:12, nrow=3)                              # mátrix létrehozása\nwrite.table(x.mat, \"output/adat/x_mat.txt\", col.names=F, row.names=F) # kiírása\n# adattábla kiírása\nwrite.table(x = d.df, file = \"output/adat/df_out.txt\", sep = \"\\t\", quote = F,            \n            dec = \",\", row.names = F, col.names = T, fileEncoding = \"UTF-8\")\nlibrary(tidyverse)\n# tabulátorral tagolt szöveges állomány létrehozása\nwrite_delim(x = d.tbl, file = \"output/adat/tbl_out.txt\", delim = \"\\t\", col_names = T)\n# pontosvesszővel tagolt szöveges állomány létrehozása\nwrite_csv2(x = d.tbl, file = \"output/adat/tbl_out.csv\", col_names = T)"},{"path":"beolvasas.html","id":"r-objektumok-írása-és-olvasása","chapter":"6 Beolvasás","heading":"6.3.2 R objektumok írása és olvasása","text":"Az R-rel való munka során sok objektummal dolgozunk, többségük külső állományok beolvasásával jön létre, melyeket aztán munka során változatos módon manipulálunk. Az adattábla és tibble típusú objektumok képezik statisztikai munka kiinduló pontját. Egyéb objektumok mentéséről eddig nem beszéltünk, pedig munka során ezek mentése és beolvasása érdekes lehet.Egy objektum értékét eltárolhatjuk szöveges állományban dput() függvénnyel, és visszaolvashatjuk dget()-tel:Igazán gyors kiírást és visszaolvasást nem várhatunk szöveges állományoktól, így nagyobb adatbázisok esetében () érdemes az objektumok bináris mentését és visszaállítását választani. saveRDS() és readRDS() Alap R függvényekkel tudjuk megoldani, hogy az R saját RDS formátumú bináris állományába tudjunk lementeni és visszatölteni egy objektumot.Tidyverse R write_rds() és read_rds() függvényei ugyanezt tevékenységet végzik, de alapértelmezés szerint nem tömörítenek, így némileg gyorsabb működést biztosítanak:Egyszerre több objektumok tárolását elvégezhetjük az R másik saját bináris formátuma, az RData segítségével. save() függvényben felsoroljuk tárolni kívánt objektumok nevét, és megadunk egy .RData kiterjesztésű állományt. visszaolvasás load() segítségével történik. Figyeljük meg, hogy load() használata során nincs szükség az értékadás (<-) operátorra, mert az RData állomány tartalmazza az objektumneveket , így ezekkel nevekkel jönnek létre munkaterületen bináris állományban eltárolt objektumok. Az azonos nevű, már létező objektumokat figyelmeztetés nélkül felülírja load(), így legyünk óvatosak függvény használatával.Az összes objektum, amely pillanatnyilag munkaterületen tartózkodik, elmenthető save.image() segítségével. Visszatöltés szintén load()-dal lehetséges.","code":"\nlibrary(MASS)\ndput(x = survey, file = \"output/adat/dput_out.txt\")  # survey kiírása txt-be         \nd.df <- dget(file = \"output/adat/dput_out.txt\")      # survey beolvasása txt-ből        \n# survey kiírása bináris állományba\nsaveRDS(object = survey, file = \"output/adat/survey.rds\") \n# survey beolvasása bináris állományból\nd.df <- readRDS(file = \"output/adat/survey.rds\")          \nlibrary(tidyverse)\n# survey kiírása bináris állományba\nwrite_rds(x = survey, file = \"output/adat/survey_2.rds\")\n# survey beolvasása bináris állományból\nd.df <- read_rds(file = \"output/adat/survey_2.rds\")\n# survey és Animals kiírása bináris állományba\nsave(survey, Animals, file = \"output/adat/MASS_2.RData\")\n# survey és Animals beolvasása bináris állományból\nload(file = \"output/adat/MASS_2.RData\")\n# minden objektum mentése bináris állományba a munkaterületről\nsave.image(file = \"output/adat/osszes_obj.RData\")\n# az objektumok beolvasása a munkaterületre\nload(file = \"output/adat/osszes_obj.RData\")"},{"path":"beolvasas.html","id":"más-típusú-adatállományok","chapter":"6 Beolvasás","heading":"6.3.3 Más típusú adatállományok","text":"Az R számos más formátumú adatállomány beolvasását támogatja az eddig tanultakon kívül. Például az Alap R foreign csomagja DBF, Stata, Minitab, SPSS, SAS és Epi adatállományokat tud olvasni. Tidyverse R haven csomagja SPSS, Stata, és SAS fájlokat, readxl csomagja pedig Excel .xls és .xlsx állományokat . Json állományokat olvashatunk jsonlite, XML állományokat az xml2 csomaggal.rio csomag különleges pozícióban van, ugyanis minden eddig felsorolt adatállomány beolvasását támogatja egyetlen parancs, az import() segítségével. beolvasandó állomány kiterjesztéséből tudni fogja, hogy pontosan milyen módon (melyik csomag megfelelő függvénye segítségével) olvassa az adatállományt. Az import() támogatja az adattábla és tibble létrehozását setclass= argumentuma segítségével.Példaképp pontosvesszővel tagolt szöveges, SPSS és XLSX állományokat olvasunk :rio csomag univerzális állománykiíró függvénye az export(). Szintén kiírandó állomány kiterjesztése dönti el, hogy pontosan melyik konkrét függvényt fogja működtetni az export(), ennek megfelelően háttérben lévő függvény argumentumaival esetlegesen mi bővíthetjük az export() argumentumlistáját. következő példákban pontosvesszővel tagolt, SPSS, SAS, XLSX és RDS adatállományokat hozunk létre:","code":"\nlibrary(rio)\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv\"\nd.df <- import(file = data.file, sep=\";\", header=T, dec=\",\")\nstr(d.df)\n#> 'data.frame':    657 obs. of  6 variables:\n#>  $ hallgato: int  1 2 3 4 5 6 7 8 9 10 ...\n#>  $ Height  : num  67 64 61 61 70 63 61 64 66 65 ...\n#>  $ neme    : chr  \"female\" \"female\" \"female\" \"female\" ...\n#>  $ lefekves: num  -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ...\n#>  $ felkeles: num  5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ...\n#>  $ Drink   : chr  \"v\\xedz\" \"\\xfcd\\xedt\\xf5\" \"tej\" \"v\\xedz\" ...\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/nepesseg.sav\"\nd.df <- import(file = data.file)\nstr(d.df)\n#> 'data.frame':    12 obs. of  4 variables:\n#>  $ HONAP   : num  1 2 3 4 5 6 7 8 9 10 ...\n#>   ..- attr(*, \"label\")= chr \"Hónap 1994-ben\"\n#>   ..- attr(*, \"format.spss\")= chr \"F5.0\"\n#>   ..- attr(*, \"display_width\")= int 12\n#>   ..- attr(*, \"labels\")= Named num [1:12] 1 2 3 4 5 6 7 8 9 10 ...\n#>   .. ..- attr(*, \"names\")= chr [1:12] \"január\" \"február\" \"március\" \"április\" ...\n#>  $ NEPESSEG: num  10273 10270 10267 10265 10262 ...\n#>   ..- attr(*, \"label\")= chr \"Népesség száma hó végén\"\n#>   ..- attr(*, \"format.spss\")= chr \"F5.0\"\n#>  $ ELVESZUL: num  10238 9285 10105 9617 9548 ...\n#>   ..- attr(*, \"label\")= chr \"Élveszületések száma\"\n#>   ..- attr(*, \"format.spss\")= chr \"F5.0\"\n#>  $ HALAL   : num  13888 12825 12516 11753 12328 ...\n#>   ..- attr(*, \"label\")= chr \"Halálozások száma\"\n#>   ..- attr(*, \"format.spss\")= chr \"F5.0\"\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/pothoff2.xlsx\"\nd.tbl <- import(file = data.file, setclass = \"tibble\")\nstr(d.tbl)\n#> tibble [108 × 5] (S3: tbl_df/tbl/data.frame)\n#>  $ person: num [1:108] 1 1 1 1 2 2 2 2 3 3 ...\n#>  $ sex   : chr [1:108] \"F\" \"F\" \"F\" \"F\" ...\n#>  $ age   : num [1:108] 8 10 12 14 8 10 12 14 8 10 ...\n#>  $ y     : num [1:108] 21 20 21.5 23 21 21.5 24 25.5 20.5 24 ...\n#>  $ agefac: num [1:108] 8 10 12 14 8 10 12 14 8 10 ...\nexport(x = d.df, file = \"output/adat/rio_out.csv\", dec=\",\", sep=\";\") # CSV\nexport(x = d.df, file = \"output/adat/rio_out.sav\")                  # SPSS\nexport(x = d.df, file = \"output/adat/rio_out.sas7bdat\")              # SAS\nexport(x = d.df, file = \"output/adat/rio_out.xlsx\")                # Excel   \nexport(x = d.df, file = \"output/adat/rio_out.ods\")      # LibreOffice Calc\nexport(x = d.df, file = \"output/adat/rio_out.RDS\")                   # RDS"},{"path":"beolvasas.html","id":"adatok-csomagokban","chapter":"6 Beolvasás","heading":"6.3.4 Adatok csomagokban","text":"Az adatelemzési munkánk R-ben az adattáblák létrehozásával kezdődik. Az adatokat külső adatállományból többféle módszerrel beolvashatjuk, illetve inline módon létrehozhatjuk (lásd @ref(#beolvas-alapveto) fejezet). Azonban számos csomag tartalmaz saját adattáblát, amelyeket használhatunk az R megismerése során . csomagokban elérhető adattáblák nevét és rövid leírását data() függvény segítségével ismerhetjük meg.Amennyiben egy adattáblára szükségünk van egy csomagból, akkor csomag betöltése nélkül elérhetjük az adattáblát:szokásos eljárás azonban csomag betöltése, amely után az adattábla nevét szabadon használhatjuk:Ha az adattábla részletesebb leírására vagyunk kíváncsiak egy betöltött csomagból, akkor ? operátort vagy help() függvényt használhatjuk:","code":"\ndata(package=\"MASS\")                            # a MASS csomagban lévő adattáblák\ndata()                                          # betöltött csomagokban lévő adattáblák\ndata(package = .packages(all.available = TRUE)) # a telepített csomagokban lévő adattáblák\ndata(survey, package=\"MASS\")\nhead(survey)\n#>      Sex Wr.Hnd NW.Hnd W.Hnd    Fold Pulse    Clap Exer Smoke Height      M.I\n#> 1 Female   18.5   18.0 Right  R on L    92    Left Some Never  173.0   Metric\n#> 2   Male   19.5   20.5  Left  R on L   104    Left None Regul  177.8 Imperial\n#> 3   Male   18.0   13.3 Right  L on R    87 Neither None Occas     NA     <NA>\n#> 4   Male   18.8   18.9 Right  R on L    NA Neither None Never  160.0   Metric\n#> 5   Male   20.0   20.0 Right Neither    35   Right Some Never  165.0   Metric\n#> 6 Female   18.0   17.7 Right  L on R    64   Right Some Never  172.7 Imperial\n#>     Age\n#> 1 18.25\n#> 2 17.58\n#> 3 16.92\n#> 4 20.33\n#> 5 23.67\n#> 6 21.00\nlibrary(tidyr)\nsmiths\n#> # A tibble: 2 × 5\n#>   subject     time   age weight height\n#>   <chr>      <dbl> <dbl>  <dbl>  <dbl>\n#> 1 John Smith     1    33     90   1.87\n#> 2 Mary Smith     1    NA     NA   1.54\n?survey                        # a survey leírása (MASS be van töltve)\nhelp(topic = \"smiths\")         # a smiths leírása (tidyr be van töltve)\nhelp(smiths, package=\"tidyr\")  # a smiths leírása (tidyr nincs betöltve)"},{"path":"beolvasas.html","id":"fix-széles-mezők","chapter":"6 Beolvasás","heading":"6.3.5 Fix széles mezők","text":"Ritkábban szükség lehet fix széles mezőket tartalmazó szöveges állományok beolvasására . read.fwf() (Alap R) és read_fwf() (Tidyverse R) függvények gondoskodnak arról, hogy az egyes mezőkben lévő adatokat úgy tudjuk azonosítani, hogy az állományban minden sorban azonos, rögzített szélességükkel hivatkozunk rájuk.Tekintsük következő fix mezőszélességekkel rendelkező állományt:Az állomány tartalmaz egy fejlécsort, ami az oszlopok elnevezését segíti, és pontosvesszővel tagolt. Ez sor még nem tartozik fix széles adatmezőkhöz. következő három sorban azonban 7 pozíción nevet, 12 pozíción telefonszámot, 3 pozíción az egy tizedesre pontos életkort soroljuk fel.Ideiglenesen hozzuk létre ezt az állományt magunk cat() függvénnyel. tempfile() függvényt használjuk egy rendszerünkben érvényes ideiglenes állomány nevének meghatározására. cat() függvénnyel egy 4 soros szöveges állományt hozunk létre. Az első sor pontosvesszővel elválasztott oszlopneveket tartalmaz, következő három sor pedig 3 fix széles adatmezőt.beolvasást az Alap R read.fwf() függvényével végezzük el először. width= paraméterében kell megadnunk az egyes mezők hosszát. függvény megadott mezőhossz értékek alapján egy ideiglenes, tabulátorral elválasztott szöveges állományt hoz létre, amely read.table() függvénnyel kerül ténylegesen feldolgozásra. header=TRUE paraméterrel jelezzük, hogy az első sor oszlopneveket tartalmaz, sep= paraméter pedig az első sorban használt elválasztó karaktert jelöli. sep= paraméterre csak akkor van szükség, ha oszlopneveket tartalmazó sort akarunk olvasni. Láthatjuk, hogy függvény által visszaadott adattábla 3 sort és 3 oszlopot tartalmaz.Tidyverse R read_fwf() függvénye nagyon hasonlóan működik. Nem támogatja az oszlopnevek kiolvasását az állományból, így az első sort átlépjük (skip=1) és az oszlopneveket col_names= argumentumban soroljuk fel, szélességek megadására használt fwf_width() függvényben. Az oszlopok típusát itt megadjuk col_types= argumentumban.","code":"nev;telefon;kor\n    Ági+3630459785921,2\n Zoltán+3630459785942,4\n    Bea+3630459785938,6\nfile <- tempfile()  # ideiglenes állománynév\ncat(file = file, \"nev;telefon;kor\",\n                 \"    Ági+3630459785921,2\",\n                 \" Zoltán+3630459785942,4\", \n                 \"    Bea+3630459785938,6\", sep=\"\\n\")\nd.df <- read.fwf(file = file, widths=c(7,12,4), header=T, sep=\";\", dec=\",\", \n                 colClasses=c(\"character\", \"character\", \"double\"), \n                 fileEncoding = \"UTF-8\")\nd.df\n#>       nev      telefon  kor\n#> 1     Ági +36304597859 21.2\n#> 2  Zoltán +36304597859 42.4\n#> 3     Bea +36304597859 38.6\nlibrary(tidyverse)\nd.tbl <- read_fwf(file = file, skip=1, \n                  col_positions = fwf_widths(widths = c(7, 12, 4), \n                                             col_names = \n                                               c(\"nev\", \"telefon\", \"kor\")), \n                  locale=locale(decimal_mark=\",\", encoding = \"UTF-8\"), \n                  col_types = \"ccd\")\nd.tbl\n#> # A tibble: 3 × 3\n#>   nev   telefon        kor\n#>   <chr> <chr>        <dbl>\n#> 1 Ág    i+3630459785 921  \n#> 2 Zoltá n+3630459785 942  \n#> 3 Bea   +36304597859  38.6"},{"path":"beolvasas.html","id":"beolvasas-3-summary","chapter":"6 Beolvasás","heading":"6.3.6 Összefoglalás","text":"\nasdasd\n","code":""},{"path":"beolvasas.html","id":"beolvasas-3-exercise","chapter":"6 Beolvasás","heading":"6.3.7 Feladatok","text":"fenti feladatok megoldása","code":""},{"path":"adatmanipulacio.html","id":"adatmanipulacio","chapter":"7 Adatmanipuláció","heading":"7 Adatmanipuláció","text":"","code":""},{"path":"adatmanipulacio.html","id":"adatkezelés-az-alap-r-ben","chapter":"7 Adatmanipuláció","heading":"7.1 Adatkezelés az Alap R-ben","text":"Ebben fejezetben az adattáblák manipulációját tekintjük át, melyek az adatkezelés szempontjából legfontosabb R objektumok. Mint korábban láttuk, mátrixhoz hasonlóan sorokat és oszlopokat tartalmaz, illetve listához hasonlóan elemekből, méghozzá azonos hosszúságú oszlopvektorokból épül fel (5.1. ábra). Az adattábla kettős eredete jelentősen megkönnyíti az ilyen adatok kezelését.Az adattábla sorai egyedekre (személyek, tárgyak, dolgok stb.) vonatkozó megfigyelések, az oszlopok pedig megfigyelt tulajdonságok. statisztikához közelebbi fogalmakkal, az adattáblában az adatmátrixunkat/többdimenziós mintánkat rögzíthetjük, sorok mintaelemek, az oszlopok megfigyelt változók.Az adattábla inhomogén adatszerkezet, oszlopai különböző típusú adatokat tartalmazhatnak. Jellemzően kvalitatív (nominális és ordinális skálán mért) adatok tárolására faktort használjuk, kvantitatív (intervallum és arányskálán mért) adatok tárolására numerikus vektort. Természetesen adattáblában karakteres és logikai vektorok szerepelhetnek, sőt dátumokat és időpontokat kezelhetünk az adattáblában.","code":""},{"path":"adatmanipulacio.html","id":"információ-megtekintése","chapter":"7 Adatmanipuláció","heading":"7.1.1 Információ megtekintése","text":"Az adatbázis beolvasása (@ref(#beolvasas)) után következik az információk begyűjtése beolvasott adatokról. legfontosabb információkérő függvényeket 7.1 táblázat tartalmazza. Az információ megszerzésének célja az egyszerű tájékozódáson kívül beolvasás helyességének ellenőrzése: rendelkezésre áll-e kívánt sor- és oszlopszám, az oszlopnevek rendben vannak-e, numerikusnak szánt változók valóban számokat tartalmaznak-e és karakteres oszlopokban az esetleges magyar ékezetek rendben megjelennek-e.\nTÁBLÁZAT 7.1: Információt kérő függvények\nAz adatelemzési munkánk során beolvasás előtt már sok ismeretünk összegyűlt az adatbázisról, de tegyünk úgy, mintha egy ismeretlen flow.xlsx adatbázist kellene felfedeznünk.fenti sorok után világossá válik, hogy egy 100 sort és 25 oszlopot tartalmazó adattábla (data frame) áll rendelkezésre. Az oszlopnevek names() és colnames() függvényekkel megismerhetőkAz oszlopnevek viszonylag beszédesek, de jobban megismerhetjük ezeket változókat.Az adatbázis tetszőleges részét megjeleníthetjük konzolban szokásos indexelés segítségével:Például 4 sorból az első 5 oszlopot így tekinthetjük meg:Ne feledjük, hogy az RStudio-ban az Environment fülön megjelenik flow adatbázis sikeres beolvasás után. Kattintva neven teljes adatbázist áttekinthetjük bal felső részben (ezt View(flow) paranccsal kezdeményezhetjük), de flow előtti ikonon kattintva megjeleníthetjük az adatbázis str()-ból ismert szerkezete .További kényelmi lehetőség, ha tibble típus kényelmes megjelenítését kihasználjuk. Ehhez konvertáljuk át az adattáblánkat tibble típusúvá, és egyszerűen jelenítsük meg az objektumot:","code":"\nflow <- rio::import(file = \"adat/flow.xlsx\") # beolvasás\nstr(flow)    # a teljes szerkezet\n#> 'data.frame':    100 obs. of  25 variables:\n#>  $ alkatoi.tev    : chr  \"Igen\" \"Igen\" \"Nem\" \"Nem\" ...\n#>  $ kor            : num  26 20 22 21 21 25 53 21 22 21 ...\n#>  $ nem            : chr  \"Férfi\" \"Nő\" \"Nő\" \"Férfi\" ...\n#>  $ csaladi.allapot: chr  \"Egyedülálló\" \"Egyedülálló\" \"Élettársi kapcsolatban él\" \"Egyedülálló\" ...\n#>  $ isk.vegz       : chr  \"Egyetem\" \"Gimnázium\" \"Gimnázium\" \"Gimnázium\" ...\n#>  $ flow.1         : num  2 4 4 3 5 5 5 4 5 5 ...\n#>  $ flow.2         : num  4 4 4 4 5 5 5 4 4 5 ...\n#>  $ flow.3         : num  5 5 3 3 5 5 3 4 4 5 ...\n#>  $ flow.4         : num  5 5 4 4 2 5 3 4 5 5 ...\n#>  $ flow.5         : num  5 5 5 3 3 5 5 5 5 5 ...\n#>  $ flow.6         : num  1 4 2 3 4 1 3 2 2 4 ...\n#>  $ flow.7         : num  2 4 1 4 4 3 5 3 5 5 ...\n#>  $ flow.8         : num  4 5 4 4 4 5 4 4 5 5 ...\n#>  $ flow.9         : num  5 5 3 4 5 5 3 4 5 5 ...\n#>  $ flow.10        : num  4 5 4 3 5 5 5 4 4 5 ...\n#>  $ flow.11        : num  4 5 2 3 5 5 3 3 5 5 ...\n#>  $ flow.12        : num  4 4 1 3 4 5 5 4 5 5 ...\n#>  $ flow.13        : num  5 4 2 4 5 3 5 4 5 5 ...\n#>  $ flow.14        : num  3 4 2 4 5 5 3 3 5 5 ...\n#>  $ flow.15        : num  3 5 3 4 4 5 5 4 5 5 ...\n#>  $ flow.16        : num  3 3 3 3 4 2 4 2 3 5 ...\n#>  $ flow.17        : num  4 5 3 4 3 2 4 4 5 5 ...\n#>  $ flow.18        : num  5 5 4 4 2 5 5 5 5 5 ...\n#>  $ flow.19        : num  4 5 4 2 5 5 5 2 5 5 ...\n#>  $ flow.20        : num  3 4 1 2 4 5 1 2 3 5 ...\nclass(flow)  # típus                \n#> [1] \"data.frame\"\ndim(flow)    # sor- és oszlopszám\n#> [1] 100  25\nnames(flow)[1:4]    # az első 4 oszlop neve\n#> [1] \"alkatoi.tev\"     \"kor\"             \"nem\"             \"csaladi.allapot\"\ncolnames(flow)[5:8] # a következő 4 oszlop neve\n#> [1] \"isk.vegz\" \"flow.1\"   \"flow.2\"   \"flow.3\"\nclass(flow$alkatoi.tev)   # az alkotoi.tev változó típusa\n#> [1] \"character\"\nunique(flow$alkatoi.tev)  # egyedi értékei\n#> [1] \"Igen\" \"Nem\"\ntable(flow$alkatoi.tev, useNA = \"ifany\") # gyakorisági táblázata\n#> \n#> Igen  Nem \n#>   39   61\nclass(flow$kor)                          # a kor változó típusa\n#> [1] \"numeric\"\ntable(flow$kor, useNA = \"ifany\")         # gyakorisági táblázata\n#> \n#> 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 36 39 40 42 43 45 50 51 52 53 \n#>  1  2  2  4 22 18  4  4  3  5  4  1  2  1  1  1  1  1  2  1  1  3  3  4  5  3 \n#> 69 \n#>  1d.df[sorindex, oszlopindex]\nflow[c(1:2, 50:51), 1:5]\n#>    alkatoi.tev kor   nem csaladi.allapot  isk.vegz\n#> 1         Igen  26 Férfi     Egyedülálló   Egyetem\n#> 2         Igen  20    Nő     Egyedülálló Gimnázium\n#> 50         Nem  22    Nő     Egyedülálló Gimnázium\n#> 51        Igen  39    Nő           Házas   Egyetem\nlibrary(tidyverse)\nflow.tbl <- as_tibble(flow) # tibble típusú adatbázis létrehozása\nflow.tbl                    # kényelmes megjelenítés\n#> # A tibble: 100 × 25\n#>    alkat…¹   kor nem   csala…² isk.v…³ flow.1 flow.2 flow.3 flow.4 flow.5 flow.6\n#>    <chr>   <dbl> <chr> <chr>   <chr>    <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n#>  1 Igen       26 Férfi Egyedü… Egyetem      2      4      5      5      5      1\n#>  2 Igen       20 Nő    Egyedü… Gimnáz…      4      4      5      5      5      4\n#>  3 Nem        22 Nő    Élettá… Gimnáz…      4      4      3      4      5      2\n#>  4 Nem        21 Férfi Egyedü… Gimnáz…      3      4      3      4      3      3\n#>  5 Igen       21 Nő    Egyedü… Gimnáz…      5      5      5      2      3      4\n#>  6 Igen       25 Nő    Elvált  Egyetem      5      5      5      5      5      1\n#>  7 Nem        53 Nő    Özvegy  Gimnáz…      5      5      3      3      5      3\n#>  8 Nem        21 Nő    Egyedü… Gimnáz…      4      4      4      4      5      2\n#>  9 Nem        22 Nő    Élettá… Gimnáz…      5      4      4      5      5      2\n#> 10 Nem        21 Nő    Egyedü… Gimnáz…      5      5      5      5      5      4\n#> # … with 90 more rows, 14 more variables: flow.7 <dbl>, flow.8 <dbl>,\n#> #   flow.9 <dbl>, flow.10 <dbl>, flow.11 <dbl>, flow.12 <dbl>, flow.13 <dbl>,\n#> #   flow.14 <dbl>, flow.15 <dbl>, flow.16 <dbl>, flow.17 <dbl>, flow.18 <dbl>,\n#> #   flow.19 <dbl>, flow.20 <dbl>, and abbreviated variable names ¹​alkatoi.tev,\n#> #   ²​csaladi.allapot, ³​isk.vegz\n#> # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names"},{"path":"adatmanipulacio.html","id":"oszlopok-kezelése","chapter":"7 Adatmanipuláció","heading":"7.1.2 Oszlopok kezelése","text":"","code":""},{"path":"adatmanipulacio.html","id":"oszlopnevek-módosítása","chapter":"7 Adatmanipuláció","heading":"7.1.2.1 Oszlopnevek módosítása","text":"sikeres beolvasás és szükséges tájékozódás után az oszlopnevek áttekintése és esetleges módosítása következő lépés. Ez kulcsfontosságú további munka szempontjából, ugyanis jól megválasztott változónevek jelentősen meggyorsíthatják további munkát, és fordítva, kevésbe beszédes, következetlen, túl rövid vagy túl hosszú változónevek akadályozhatják sikeres adatelemzést. változónevek mindig legyenek beszédesek, csak az angol ábécé kisbetűit és számjegyeket használjunk, több részből álló neveket aláhúzással (_) esetleg ponttal (.) tagoljuk (R kódolási stílus).Egy adattábla oszlopait names() vagy colnames(), sorait rownames() függvény használatával kérdezhetjük le és nevezhetjük át. sornevek egymástól különböző, karakteres vagy numerikus egész értékek lehetnek, míg az oszlopnevek csak karakteres adatok.Az oszlopnevek módosításának több oka lehet. Példánkban magyar változónevekre váltunk, de sokszor rövidítjük vagy beszédesebbé tesszük az oszlopaink nevét.","code":"\nbandak <- rio::import(file = \"adat/metal_bandak.xlsx\")\nbandak\n#>       banda  fan formed split      origin\n#> 1     Kiuas  106   2000  2013  Finnország\n#> 2    Accept  681   1968  <NA> Németország\n#> 3 Metallica 4122   1981  <NA>         USA\n#> 4    Zonata   23   1998  2003  Svédország\n#> 5   Therion 1266   1987  <NA>  Svédország\nnames(bandak)                     # az összes oszlop neve \n#> [1] \"banda\"  \"fan\"    \"formed\" \"split\"  \"origin\"\nnames(bandak)[2] <- \"rajongo\"     # 2. oszlop nevének átírása\nnames(bandak)[3:5] <- c(\"alakulas\",\"felbomlas\",\"orszag\") # 3-5. oszlopok átnevezése\nnames(bandak)[names(bandak)==\"banda\"] <- \"nev\" # a \"banda\" nevű oszlop átnevezése\nbandak\n#>         nev rajongo alakulas felbomlas      orszag\n#> 1     Kiuas     106     2000      2013  Finnország\n#> 2    Accept     681     1968      <NA> Németország\n#> 3 Metallica    4122     1981      <NA>         USA\n#> 4    Zonata      23     1998      2003  Svédország\n#> 5   Therion    1266     1987      <NA>  Svédország"},{"path":"adatmanipulacio.html","id":"oszlop-indexelése","chapter":"7 Adatmanipuláció","heading":"7.1.2.2 Oszlop indexelése","text":"Az Alap R-ben az oszlopok indexelése [ vagy [[ operátor segítségével történhet. Mivel az adattáblák örökölték kétdimenziós mátrix és az egydimenziós lista adatszerkezet indexelési lehetőségeit, így az oszlopokra négyféle módon hivatkozhatunk:Az fenti példa első sorában mátrixszerűen, második sorában listaszerűen indexelünk. továbbiakban mátrixszerű, azaz vesszőt tartalmazó hivatkozást használjuk. Az oszlopindex lehet numerikus vektor pozitív vagy negatív értékekkel, karakteres vektor, vagy akár logikai vektor . Ha csak egyetlen oszlopra vagyunk kíváncsiak, akkor [[ vagy még gyakrabban $ operátort használjuk az oszlop nevének megadásával.Az oszlopok elérése mindennapos statisztikai munka során, így ezeket az indexelési formákat ismernünk kell.Ne feledjük, hogy mátrixszerű indexelés során kaphatunk egydimenziós eredményt, hiszen ha egyetlen oszlopra hivatkozunk, akkor [ operátor automatikusan az egydimenziós vektorra vált kétdimenziós adattábla helyett. Ezt drop=F használatával akadályozhatjuk meg.","code":"adattábla[,oszlopindex]  # hivatkozás egy vagy több oszlopra\nadattábla[oszlopindex]   # hivatkozás egy vagy több oszlopra\nadattábla[[oszlopnév]]   # hivatkozás egyetlen oszlopra\nadattábla$oszlopnév      # hivatkozás egyetlen oszlopra\nmean(flow$kor, na.rm=T)           # kor átlaga\n#> [1] 29.26\nsummary(flow[c(\"kor\", \"flow.1\")]) # kor és flow.1 leíró statisztikai adatai\n#>       kor           flow.1    \n#>  Min.   :17.0   Min.   :1.00  \n#>  1st Qu.:21.0   1st Qu.:3.00  \n#>  Median :23.0   Median :4.00  \n#>  Mean   :29.3   Mean   :4.01  \n#>  3rd Qu.:33.0   3rd Qu.:5.00  \n#>  Max.   :69.0   Max.   :5.00\n# \"flow\" szót tartalmazó oszlopok száma\nncol(flow[grepl(pattern = \"flow\", names(flow))]) \n#> [1] 20\nflow[1:3, c(\"kor\", \"nem\")] # két oszlop, nincs dimenzióvesztés\n#>   kor   nem\n#> 1  26 Férfi\n#> 2  20    Nő\n#> 3  22    Nő\nflow[1:3, \"kor\"]           # egy oszlop, dimenzióvesztés\n#> [1] 26 20 22\nflow[1:3, \"kor\", drop=F]   # egy oszlop, nincs dimenzióvesztés\n#>   kor\n#> 1  26\n#> 2  20\n#> 3  22"},{"path":"adatmanipulacio.html","id":"oszlopok-sorrendje","chapter":"7 Adatmanipuláció","heading":"7.1.2.3 Oszlopok sorrendje","text":"Ha már jól ismerjük az oszlopok indexelését, akkor számos további műveletre nyílik lehetőség. Ezek közül legegyszerűbb az oszlopok sorrendjének megváltoztatása. Ha az oszlopindex hivatkozásai az eredeti oszlopsorrendtől eltérnek, akkor máris új oszlopsorrendet határoztunk meg.Természetesen oszlopsorszámok helyett változóneveket használhatunk.","code":"\n# a korábbi 1. oszlop (alkotoi.tev) átkerül a 3. oszlopba\nflow <- flow[, c(2, 3, 1, 4:25)] \nflow[1:2, 1:3]\n#>   kor   nem alkatoi.tev\n#> 1  26 Férfi        Igen\n#> 2  20    Nő        Igen\nbandak\n#>         nev rajongo alakulas felbomlas      orszag\n#> 1     Kiuas     106     2000      2013  Finnország\n#> 2    Accept     681     1968      <NA> Németország\n#> 3 Metallica    4122     1981      <NA>         USA\n#> 4    Zonata      23     1998      2003  Svédország\n#> 5   Therion    1266     1987      <NA>  Svédország\n# a rajongo oszlop a végére kerül\nbandak <- bandak[,c(\"nev\", \"alakulas\", \"felbomlas\", \"orszag\", \"rajongo\")]\nbandak\n#>         nev alakulas felbomlas      orszag rajongo\n#> 1     Kiuas     2000      2013  Finnország     106\n#> 2    Accept     1968      <NA> Németország     681\n#> 3 Metallica     1981      <NA>         USA    4122\n#> 4    Zonata     1998      2003  Svédország      23\n#> 5   Therion     1987      <NA>  Svédország    1266"},{"path":"adatmanipulacio.html","id":"oszlopok-létrehozása-és-törlése","chapter":"7 Adatmanipuláció","heading":"7.1.2.4 Oszlopok létrehozása és törlése","text":"Láttuk korábban, hogy cbind() segítségével oszlopokat adhatunk meglévő adatbázisunkhoz. Például meglévő bandak adatbázishoz adjunk hozzá egy kétoszlopos új adatbázist, amely bandák Wikipédia oldalának címét, és egy szubjektív rangsort tartalmaz.Egyetlen oszlop beszúrására van lehetőségünk, és hasonlóan törölhetünk egyetlen oszlopot :Szúrjuk rangsor változót az eredeti bandak adatbázisba, majd távolítsuk el.","code":"\nbandak.kieg <- data.frame(wikipedia=c(\"https://en.wikipedia.org/wiki/Kiuas\",\n                                      \"https://hu.wikipedia.org/wiki/Accept\",\n                                      \"https://hu.wikipedia.org/wiki/Metallica\",\n                                      \"https://en.wikipedia.org/wiki/Zonata\",\n                                      \"https://en.wikipedia.org/wiki/Therion_(band)\"),\n                          rangsor=c(2,4,1,3,5))\nbandak.2 <- cbind(bandak, bandak.kieg)\nstr(bandak.2)adattábla$új.oszlopnév       # új oszlop beszúrása a dataframe végére\nadattábla$oszlopnév <- NULL  # oszlop törlése\nbandak$rangsor <- c(2,4,1,3,5)  # új oszlop beszúrása\nbandak$rangsor <- NULL          # oszlop törlése"},{"path":"adatmanipulacio.html","id":"típuskonverzió","chapter":"7 Adatmanipuláció","heading":"7.1.2.5 Típuskonverzió","text":"Az oszlopok nevének és sorrendjének optimális beállítása után meg kell vizsgálnunk, hogy az oszlopaink típusa megfelel-e az általa reprezentált statisztikai változók mérési skálájának. Nem léphetünk tovább az elemzés felé, amíg ez az összefüggés nem teljesül.nominálisnumerikusból faktorkarakteresből faktorfactor(x)ordinálisnumerikusból faktor (rendezett)karakteresből faktor (rendezett)ordered(x)intervallumaránykarakteresből numerikusfaktorból numerikusas.numeric(x).numeric(.character(x))típuskonverzió két leggyakoribb esetével foglalkozunk itt. Az egyik faktorrá konvertálás teszi típuskonverziók legnagyobb részét. Ezt factor() függvénnyel végezzük el. kiinduló változónk lehet numerikus vagy karakteres.Mindkét esetben előfordulhat, hogy kiinduló változóban lévő egyedi numerikus értékekA numerikus típuskonverzió kevésbé gyakori, de előfordulhat.Például","code":"\nfactor(c(1, 1, 2, 1, 1, 1, 2))\n#> [1] 1 1 2 1 1 1 2\n#> Levels: 1 2\nfactor(c(\"Dohányzik\", \"Dohányzik\", \"Nem dohányzik\"))\n#> [1] Dohányzik     Dohányzik     Nem dohányzik\n#> Levels: Dohányzik Nem dohányzik\nkor <- c(44, 39, \"55 év\", 38)\nkor[3] <- \"55\"\nas.numeric(kor)\n#> [1] 44 39 55 38"},{"path":"adatmanipulacio.html","id":"transzformáció","chapter":"7 Adatmanipuláció","heading":"7.1.2.6 Transzformáció","text":"Számos esetben szükség lehet az adattábla oszlopaiban lévő értéke átalakítására (transzformálására). Az értékeket vagy helyben (ugyanabban az oszlopban) változtatjuk meg, vagy új oszlopként szúrjuk az adattáblába.\nAdatok transzformálásához tekintsük women adattáblát, amely weight változójában font-ban mért értékeket tartalmaz. Ezt alakítsuk át kg-ban mért adatokká egy új oszlopban:Ugyanezt az eredményt transform() függvény segítségével elérhetjük, ahol subset()-hez hasonlóan némileg egyszerűbben hivatkozhatunk az adattábla változóira. alakítsuk át height változót inch-ről cm-re.Amennyiben fenti példákban nem új változónevek az átalakítás célpontjai, hanem már létező oszlopok, akkor helyben végezzük transzformációt:változók átalakításának másik gyakori esete, amikor az eredetileg folytonos változót kategórikus változóvá alakítjuk. cut() függvény segítségével numerikus vektorból faktort állíthatunk elő.fenti példában 10 elemű bemenő vektortból 3 szintű faktort hoztunk létre. Ha az intervallumok határát magunk szeretnénk megadni, akkor második (breaks) argumentumban egy vektort kell megadnunk:létrejövő faktor szintjei az intervallumok leírásaiból állnak, természetesen ezeket megvaáltoztathatjuk, csak labels= paramétert kell használnunk:Adattáblák esetében cut() függvény használatára láthatunk egy példát:car csomag recode() függvénye","code":"\ndata(women); women\n#>    height weight\n#> 1      58    115\n#> 2      59    117\n#> 3      60    120\n#> 4      61    123\n#> 5      62    126\n#> 6      63    129\n#> 7      64    132\n#> 8      65    135\n#> 9      66    139\n#> 10     67    142\n#> 11     68    146\n#> 12     69    150\n#> 13     70    154\n#> 14     71    159\n#> 15     72    164\nwomen$suly<-round(women$weight*0.45)\nwomen\n#>    height weight suly\n#> 1      58    115   52\n#> 2      59    117   53\n#> 3      60    120   54\n#> 4      61    123   55\n#> 5      62    126   57\n#> 6      63    129   58\n#> 7      64    132   59\n#> 8      65    135   61\n#> 9      66    139   63\n#> 10     67    142   64\n#> 11     68    146   66\n#> 12     69    150   68\n#> 13     70    154   69\n#> 14     71    159   72\n#> 15     72    164   74\ntransform(women, magassag=round(height*2.45))\n#>    height weight suly magassag\n#> 1      58    115   52      142\n#> 2      59    117   53      145\n#> 3      60    120   54      147\n#> 4      61    123   55      149\n#> 5      62    126   57      152\n#> 6      63    129   58      154\n#> 7      64    132   59      157\n#> 8      65    135   61      159\n#> 9      66    139   63      162\n#> 10     67    142   64      164\n#> 11     68    146   66      167\n#> 12     69    150   68      169\n#> 13     70    154   69      172\n#> 14     71    159   72      174\n#> 15     72    164   74      176\ntransform(women, height=height-10)\n#>    height weight suly\n#> 1      48    115   52\n#> 2      49    117   53\n#> 3      50    120   54\n#> 4      51    123   55\n#> 5      52    126   57\n#> 6      53    129   58\n#> 7      54    132   59\n#> 8      55    135   61\n#> 9      56    139   63\n#> 10     57    142   64\n#> 11     58    146   66\n#> 12     59    150   68\n#> 13     60    154   69\n#> 14     61    159   72\n#> 15     62    164   74\ncut(1:10,3)\n#>  [1] (0.991,4] (0.991,4] (0.991,4] (0.991,4] (4,7]     (4,7]     (4,7]    \n#>  [8] (7,10]    (7,10]    (7,10]   \n#> Levels: (0.991,4] (4,7] (7,10]\ncut(1:10,breaks=c(0,2,10))\n#>  [1] (0,2]  (0,2]  (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10]\n#> Levels: (0,2] (2,10]\ncut(1:10,breaks=c(0,2,7,10),label=c(\"gyenge\",\"közepes\",\"erős\"))\n#>  [1] gyenge  gyenge  közepes közepes közepes közepes közepes erős    erős   \n#> [10] erős   \n#> Levels: gyenge közepes erős\ntransform(women,height=cut(height,breaks=c(0,60,70,100),labels=c(\"alacsony\",\"közepes\",\"magas\")))\n#>      height weight suly\n#> 1  alacsony    115   52\n#> 2  alacsony    117   53\n#> 3  alacsony    120   54\n#> 4   közepes    123   55\n#> 5   közepes    126   57\n#> 6   közepes    129   58\n#> 7   közepes    132   59\n#> 8   közepes    135   61\n#> 9   közepes    139   63\n#> 10  közepes    142   64\n#> 11  közepes    146   66\n#> 12  közepes    150   68\n#> 13  közepes    154   69\n#> 14    magas    159   72\n#> 15    magas    164   74"},{"path":"adatmanipulacio.html","id":"faktor-változó-összefoglalás","chapter":"7 Adatmanipuláció","heading":"7.1.2.7 Faktor változó összefoglalás","text":"","code":""},{"path":"adatmanipulacio.html","id":"numerikus-változó-összefoglalás","chapter":"7 Adatmanipuláció","heading":"7.1.2.8 Numerikus változó összefoglalás","text":"","code":""},{"path":"adatmanipulacio.html","id":"sorok-kezelése","chapter":"7 Adatmanipuláció","heading":"7.1.3 Sorok kezelése","text":"Sokszor előfordul, hogy egy adattábla valamely változójának értékeivel szeretnénk sorokat elnevezni, illetve fordítva, az adattábla sorneveit oszlopvektorban szeretnénk látni. fivethirtyeight csomag unisex_names adattáblája adattábla állományból történő beolvasása során read.table() függvényben ”row.names=n” argumentum megadásával szöveges állomány n. oszlopából nyerjük sorok neveit.\nAz mtcars adattábla sorneveit következő parancs segítségével vihetjük változóba:fordított irányhoz következő parancsot kell használnunk:","code":"\ndata(unisex_names, package = \"fivethirtyeight\")\nhead(unisex_names)\n#> # A tibble: 6 × 5\n#>   name     total male_share female_share    gap\n#>   <chr>    <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Casey  176544.      0.584        0.416 0.169 \n#> 2 Riley  154861.      0.508        0.492 0.0153\n#> 3 Jessie 136382.      0.478        0.522 0.0443\n#> 4 Jackie 132929.      0.421        0.579 0.158 \n#> 5 Avery  121797.      0.335        0.665 0.330 \n#> 6 Jaime  109870.      0.562        0.438 0.124\nrownames(unisex_names) <- unisex_names$name\nhead(unisex_names)\n#> # A tibble: 6 × 5\n#>   name     total male_share female_share    gap\n#>   <chr>    <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Casey  176544.      0.584        0.416 0.169 \n#> 2 Riley  154861.      0.508        0.492 0.0153\n#> 3 Jessie 136382.      0.478        0.522 0.0443\n#> 4 Jackie 132929.      0.421        0.579 0.158 \n#> 5 Avery  121797.      0.335        0.665 0.330 \n#> 6 Jaime  109870.      0.562        0.438 0.124\nmtcars2<-data.frame(name=rownames(mtcars),mtcars,row.names=1:32)\nmtcars2[1:10,]\n#>                 name  mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> 1          Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#> 2      Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#> 3         Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> 4     Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#> 5  Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#> 6            Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> 7         Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> 8          Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> 9           Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> 10          Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nmtcars3<-mtcars2                  # új adattábla\nrownames(mtcars3)<-mtcars3$name   # sornevek meghatározása\nmtcars3<-mtcars3[2:11]            # a felesleges első oszlop törlése\nmtcars3[1:10,]\n#>                    mpg cyl  disp  hp drat    wt  qsec vs am gear\n#> Mazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4\n#> Mazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4\n#> Datsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4\n#> Hornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3\n#> Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3\n#> Valiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3\n#> Duster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3\n#> Merc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4\n#> Merc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4\n#> Merc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4"},{"path":"adatmanipulacio.html","id":"rendezés","chapter":"7 Adatmanipuláció","heading":"7.1.3.1 Rendezés","text":"vektorok rendezésénél már megismertük az order() függvényt (3.1.8. fejezet), amelyet adattáblák rendezésére használhatunk. Az mtcars adattábla sorait fogyasztási adatok (mpg változó) alapján növekvő sorrendbe rendezhetjük, ha sorok indexelésére az order() függvény visszatérési értékét használjuk:fenti indexeket sorkoordináta helyére írva, megkapjuk rendezett adattáblát (helytakarékosságból az első 10 sorát írjuk ki):Rendezési szempontnak sorneveket használhatjuk:Rendezésnél egynél több változót figyelembe vehetünk, ekkor az order() függvényben több változónevet kell felsorolnunk vesszővel elválasztva:Csökkenő sorrendű rendezéshez használhatjuk az order() függvény ”decreasing=TRUE” argumentumát, vagy rev() függvényt. Több rendezési szempont esetén ha keverni szeretnénk rendezési irányokatt, akkor numerikus oszlopvektorok előtt mínusz (-) jellel fordíthatjuk meg rendezés irányát csökkenőre.","code":"\norder(mtcars$mpg)\n#>  [1] 15 16 24  7 17 31 14 23 22 29 12 13 11  6  5 10 25 30  1  2  4 32 21  3  9\n#> [26]  8 27 26 19 28 18 20\nmtcars[order(mtcars$mpg)[1:10],]\n#>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#> Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#> Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#> Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#> Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#> AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#> Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#> Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nmtcars[order(rownames(mtcars))[1:10],]\n#>                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> AMC Javelin        15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#> Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#> Camaro Z28         13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#> Chrysler Imperial  14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#> Datsun 710         22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Dodge Challenger   15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#> Duster 360         14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> Ferrari Dino       19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#> Fiat 128           32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Fiat X1-9          27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nmtcars[order(mtcars$mpg,mtcars$disp)[1:10],c(\"mpg\",\"disp\")]\n#>                      mpg  disp\n#> Lincoln Continental 10.4 460.0\n#> Cadillac Fleetwood  10.4 472.0\n#> Camaro Z28          13.3 350.0\n#> Duster 360          14.3 360.0\n#> Chrysler Imperial   14.7 440.0\n#> Maserati Bora       15.0 301.0\n#> Merc 450SLC         15.2 275.8\n#> AMC Javelin         15.2 304.0\n#> Dodge Challenger    15.5 318.0\n#> Ford Pantera L      15.8 351.0\nmtcars[order(mtcars$mpg,-mtcars$disp)[1:10],c(\"mpg\",\"disp\")]\n#>                      mpg  disp\n#> Cadillac Fleetwood  10.4 472.0\n#> Lincoln Continental 10.4 460.0\n#> Camaro Z28          13.3 350.0\n#> Duster 360          14.3 360.0\n#> Chrysler Imperial   14.7 440.0\n#> Maserati Bora       15.0 301.0\n#> AMC Javelin         15.2 304.0\n#> Merc 450SLC         15.2 275.8\n#> Dodge Challenger    15.5 318.0\n#> Ford Pantera L      15.8 351.0"},{"path":"adatmanipulacio.html","id":"adattábla-szűrése","chapter":"7 Adatmanipuláció","heading":"7.1.4 Adattábla szűrése","text":"Sokszor előfordul, hogy az adattábla sorait egy vagy több változó (oszlop) értéke szerint szeretnénk leválogatni. Az adattábla indexelése során sorkoordináta helyén logikai kifejezést szerepeltetünk. Ha például le szeretnénk kérdezni, azokat sorokat, amelyekben fogyásztás értéke kisebb mint 15 mérföld/gallon, akkor következő logikai kifejezést használhatjuk:fenti logikai vekorban pontosan azokban pozíciókban szerepel TRUE érték, amelyik sorban fogyásztás értéke kisebb mint 15 mérföld/gallon. Ha ezt szerpeltetjük sorkoordináta helyén, kívánt sorokhoz jutunk:Több váltózón alapuló feltétel megadásához összetett logikai kifejezést kell írnunk:Adattáblák szűrését egyszerűsíti subset() függvény, amely az első paraméterében egy adattáblát, második paraméterében pedig szűrést jelentő logikai kifejezést várja. fenti szűrés subset() függvény használatával:subset() függvény egy select argumentumot tartalmazhat, melynek sgítségével szűrés eredményében megjelenő oszlopokat határozhatjuk meg:","code":"\nmtcars$mpg<15\n#>  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n#> [13] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n#> [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\nmtcars[mtcars$mpg<15,]\n#>                      mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#> Duster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4\n#> Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\n#> Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\n#> Camaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4\nmtcars[mtcars$mpg<15 & mtcars$disp>400,]\n#>                      mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#> Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\n#> Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\nsubset(mtcars, mpg<15 & disp>400)\n#>                      mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#> Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\n#> Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\nsubset(mtcars, mpg<15 & disp>400, select=c(\"mpg\",\"disp\"))\n#>                      mpg disp\n#> Cadillac Fleetwood  10.4  472\n#> Lincoln Continental 10.4  460\n#> Chrysler Imperial   14.7  440"},{"path":"adatmanipulacio.html","id":"hiányzó-értékeket-tatalmazó-sorok-eltávolítása","chapter":"7 Adatmanipuláció","heading":"7.1.5 Hiányzó értékeket tatalmazó sorok eltávolítása","text":"Az NA értéket tartalmazó adattáblánkból az na.omit() függvény használatával távolíthatjuk el azokat sorokat, amelyekben hiányzó érték előfordul.","code":"\ndata(mtcars)\nmtcars[c(2,5,7),1]<-NA\nmtcars[1:10,]\n#>                    mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#> Mazda RX4 Wag       NA   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#> Datsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#> Hornet Sportabout   NA   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#> Valiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> Duster 360          NA   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> Merc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Merc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nna.omit(mtcars)[1:10,]\n#>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#> Valiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Merc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#> Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#> Merc 450SE     16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#> Merc 450SL     17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3"},{"path":"adatmanipulacio.html","id":"adattáblák-indexelése","chapter":"7 Adatmanipuláció","heading":"7.1.6 Adattáblák indexelése","text":"Az adattáblák indexelésére mátrixok és listák indexelési eljárásait használhatjuk. 3.5. fejezetben már áttekintettük az Alap R lehetőségeit.","code":"\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/metacritic_games.csv\"\nlibrary(tidyverse)\nd.tbl <- read_delim(file = data.file, delim = \",\")\nd.tbl\n#> # A tibble: 5,699 × 15\n#>    game     platf…¹ devel…² genre numbe…³ rating relea…⁴ posit…⁵ neutr…⁶ negat…⁷\n#>    <chr>    <chr>   <chr>   <chr> <chr>   <chr>  <chr>     <dbl>   <dbl>   <dbl>\n#>  1 Portal 2 PC      Valve … Acti… <NA>    E10+   Apr 18…      51       1       0\n#>  2 The Eld… PC      Bethes… Role… No Onl… M      Nov 10…      32       0       0\n#>  3 The Leg… 3DS     GREZZO  Misc… No Onl… E10+   Jun 19…      84       1       0\n#>  4 Batman:… PC      Rockst… Acti… <NA>    T      Nov 21…      27       0       0\n#>  5 Super M… 3DS     Ninten… Acti… No Onl… E      Nov 13…      81       1       0\n#>  6 Deus Ex… PC      Nixxes… Acti… No Onl… M      Aug 23…      52       0       0\n#>  7 Pushmo   3DS     Intell… Misc… 1 Play… E      Dec  8…      31       0       0\n#>  8 Total W… PC      Creati… Stra… Online… T      Mar 15…      62       0       0\n#>  9 FIFA So… PC      Electr… Spor… <NA>    E      Sep 27…      14       0       0\n#> 10 Battlef… PC      EA DICE Acti… <NA>    M      Oct 25…      60       1       0\n#> # … with 5,689 more rows, 5 more variables: positive_users <dbl>,\n#> #   neutral_users <dbl>, negative_users <dbl>, metascore <dbl>,\n#> #   user_score <dbl>, and abbreviated variable names ¹​platform, ²​developer,\n#> #   ³​number_players, ⁴​release_date, ⁵​positive_critics, ⁶​neutral_critics,\n#> #   ⁷​negative_critics\nd.df <- as.data.frame(d.tbl)\nhead(d.df)\n#>                                      game platform             developer\n#> 1                                Portal 2       PC        Valve Software\n#> 2             The Elder Scrolls V: Skyrim       PC Bethesda Game Studios\n#> 3 The Legend of Zelda: Ocarina of Time 3D      3DS                GREZZO\n#> 4                     Batman: Arkham City       PC    Rocksteady Studios\n#> 5                     Super Mario 3D Land      3DS              Nintendo\n#> 6               Deus Ex: Human Revolution       PC       Nixxes Software\n#>              genre        number_players rating release_date positive_critics\n#> 1           Action                  <NA>   E10+ Apr 18, 2011               51\n#> 2     Role-Playing No Online Multiplayer      M Nov 10, 2011               32\n#> 3    Miscellaneous No Online Multiplayer   E10+ Jun 19, 2011               84\n#> 4 Action Adventure                  <NA>      T Nov 21, 2011               27\n#> 5           Action No Online Multiplayer      E Nov 13, 2011               81\n#> 6           Action No Online Multiplayer      M Aug 23, 2011               52\n#>   neutral_critics negative_critics positive_users neutral_users negative_users\n#> 1               1                0           1700           107             19\n#> 2               0                0           1616           322            451\n#> 3               1                0            283            20              5\n#> 4               0                0            240            34             27\n#> 5               1                0            251            39             11\n#> 6               0                0            520           112             78\n#>   metascore user_score\n#> 1        95         90\n#> 2        94         82\n#> 3        94         90\n#> 4        91         87\n#> 5        90         84\n#> 6        90         85"},{"path":"adatmanipulacio.html","id":"válogatás-az-sorokból","chapter":"7 Adatmanipuláció","heading":"7.1.7 Válogatás az sorokból","text":"sorok leválogatatása nagyon fontos eszköz kezünben ahhoz, hogy az elemzésünket kívánt mintaelemekkel folytathassuk.","code":""},{"path":"adatmanipulacio.html","id":"sorok-indexelése-és-a-szűrés-alap-r-ben","chapter":"7 Adatmanipuláció","heading":"7.1.7.1 Sorok indexelése és a szűrés Alap R-ben","text":"sorok indexelésére [ operátort használhatjuk, vessző előtti részbe, sorkoordintátákba írhatunk neumerikus vektort, pozitív és negatív értékekkel, logikai vektort és karakteres vektort, bár ez utóbbi használta nagyon ritkkán fordul elő.példákhoz fivethirtyeight csomag unisex_names adattáblájából indulunk ki, amely amerikában használt uniszex neveket tartalmaz.sorkoordinátákba írjuk sorok válogatását biztosító lehetőségeket:head() és tail() függvény sorokból válogat, az első 6, illetve utolsó 3 sort így kaphatjuk meg:Bizonyos esetekben szükség lehet az adattábla soraiból véletlen módon néhányat kiválasztani. Ekkor sample() függvényt használjuk:sample() függvény alapértelmezés szerint visszatevés nélküli választ véletlen értékeket az első paraméterből (esetünkben 919 számból 10-et), de ha replace=TRUE argumentumot használjuk, akkor visszatevéssel fog választani:sample() függvény fenti paraméterezése mellett biztosan előfordul sorismétlés az új d.tbl adattáblában.\nAz sorismétléseket tartalmazó adattáblák kezelésére duplicated() és unique() függvényeket használhatjuk. sorismétlések felderítésére duplicated() függvényt használjuk:sorismétlések eltávolítására unique() függvényt használhatjuk:Ha sorkoordítátákba logikai vektort írunk, akkor szűrést valósítunk meg:","code":"\ndata(\"unisex_names\", package = \"fivethirtyeight\")\nunisex_names\n#> # A tibble: 919 × 5\n#>    name      total male_share female_share    gap\n#>    <chr>     <dbl>      <dbl>        <dbl>  <dbl>\n#>  1 Casey   176544.      0.584        0.416 0.169 \n#>  2 Riley   154861.      0.508        0.492 0.0153\n#>  3 Jessie  136382.      0.478        0.522 0.0443\n#>  4 Jackie  132929.      0.421        0.579 0.158 \n#>  5 Avery   121797.      0.335        0.665 0.330 \n#>  6 Jaime   109870.      0.562        0.438 0.124 \n#>  7 Peyton   94896.      0.434        0.566 0.133 \n#>  8 Kerry    88964.      0.484        0.516 0.0321\n#>  9 Jody     80401.      0.352        0.648 0.296 \n#> 10 Kendall  79211.      0.372        0.628 0.255 \n#> # … with 909 more rows\nunisex_names[2, ]\n#> # A tibble: 1 × 5\n#>   name    total male_share female_share    gap\n#>   <chr>   <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Riley 154861.      0.508        0.492 0.0153\nunisex_names[1:3, ]\n#> # A tibble: 3 × 5\n#>   name     total male_share female_share    gap\n#>   <chr>    <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Casey  176544.      0.584        0.416 0.169 \n#> 2 Riley  154861.      0.508        0.492 0.0153\n#> 3 Jessie 136382.      0.478        0.522 0.0443\nunisex_names[-(1:3), ]\n#> # A tibble: 916 × 5\n#>    name      total male_share female_share    gap\n#>    <chr>     <dbl>      <dbl>        <dbl>  <dbl>\n#>  1 Jackie  132929.      0.421        0.579 0.158 \n#>  2 Avery   121797.      0.335        0.665 0.330 \n#>  3 Jaime   109870.      0.562        0.438 0.124 \n#>  4 Peyton   94896.      0.434        0.566 0.133 \n#>  5 Kerry    88964.      0.484        0.516 0.0321\n#>  6 Jody     80401.      0.352        0.648 0.296 \n#>  7 Kendall  79211.      0.372        0.628 0.255 \n#>  8 Payton   64152.      0.334        0.666 0.331 \n#>  9 Skyler   53486.      0.646        0.354 0.292 \n#> 10 Frankie  51288.      0.624        0.376 0.247 \n#> # … with 906 more rows\nhead(unisex_names, n = 6)\n#> # A tibble: 6 × 5\n#>   name     total male_share female_share    gap\n#>   <chr>    <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Casey  176544.      0.584        0.416 0.169 \n#> 2 Riley  154861.      0.508        0.492 0.0153\n#> 3 Jessie 136382.      0.478        0.522 0.0443\n#> 4 Jackie 132929.      0.421        0.579 0.158 \n#> 5 Avery  121797.      0.335        0.665 0.330 \n#> 6 Jaime  109870.      0.562        0.438 0.124\ntail(unisex_names, n = 3)\n#> # A tibble: 3 × 5\n#>   name   total male_share female_share    gap\n#>   <chr>  <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Gwin    101.      0.562        0.438 0.124 \n#> 2 Yacine  100.      0.545        0.455 0.0892\n#> 3 Aeon    100.      0.465        0.535 0.0703\nunisex_names[sample(x = 1:nrow(unisex_names), size = 10), ]\n#> # A tibble: 10 × 5\n#>    name    total male_share female_share    gap\n#>    <chr>   <dbl>      <dbl>        <dbl>  <dbl>\n#>  1 Amarri   438.      0.515        0.485 0.0292\n#>  2 Wisdom   910.      0.464        0.536 0.0719\n#>  3 Lennie  3533.      0.554        0.446 0.108 \n#>  4 Hadyn    926.      0.545        0.455 0.0910\n#>  5 Mell     197.      0.639        0.361 0.278 \n#>  6 Toryn    442.      0.485        0.515 0.0304\n#>  7 Schylar  327.      0.336        0.664 0.329 \n#>  8 Child    130.      0.595        0.405 0.190 \n#>  9 Laramie 1595.      0.564        0.436 0.129 \n#> 10 Kadian   125.      0.349        0.651 0.302\nd.tbl <- unisex_names[sample(x = 11:14, size = 5, replace = T), ]\nd.tbl\n#> # A tibble: 5 × 5\n#>   name     total male_share female_share   gap\n#>   <chr>    <dbl>      <dbl>        <dbl> <dbl>\n#> 1 Frankie 51288.      0.624        0.376 0.247\n#> 2 Skyler  53486.      0.646        0.354 0.292\n#> 3 Frankie 51288.      0.624        0.376 0.247\n#> 4 Pat     44782.      0.369        0.631 0.262\n#> 5 Skyler  53486.      0.646        0.354 0.292\nduplicated(d.tbl)\n#> [1] FALSE FALSE  TRUE FALSE  TRUE\nd.tbl[duplicated(d.tbl), ]\n#> # A tibble: 2 × 5\n#>   name     total male_share female_share   gap\n#>   <chr>    <dbl>      <dbl>        <dbl> <dbl>\n#> 1 Frankie 51288.      0.624        0.376 0.247\n#> 2 Skyler  53486.      0.646        0.354 0.292\nunique(d.tbl)\n#> # A tibble: 3 × 5\n#>   name     total male_share female_share   gap\n#>   <chr>    <dbl>      <dbl>        <dbl> <dbl>\n#> 1 Frankie 51288.      0.624        0.376 0.247\n#> 2 Skyler  53486.      0.646        0.354 0.292\n#> 3 Pat     44782.      0.369        0.631 0.262\nunisex_names[unisex_names$gap < 0.003, ]\n#> # A tibble: 10 × 5\n#>    name      total male_share female_share       gap\n#>    <chr>     <dbl>      <dbl>        <dbl>     <dbl>\n#>  1 Kris     24956.      0.499        0.501 0.00275  \n#>  2 Camdyn    3275.      0.500        0.500 0.000154 \n#>  3 Christan  2685.      0.501        0.499 0.00227  \n#>  4 Kam        729.      0.501        0.499 0.00235  \n#>  5 Jonel      613.      0.499        0.501 0.00237  \n#>  6 Kodee      533.      0.500        0.500 0.000316 \n#>  7 Callaway   292.      0.500        0.500 0.000455 \n#>  8 Bless      280.      0.500        0.500 0.0000717\n#>  9 Nike       206.      0.500        0.500 0.000782 \n#> 10 Tkai       143.      0.500        0.500 0.000570"},{"path":"adatmanipulacio.html","id":"adatkezelés-tidyverse-r-ben","chapter":"7 Adatmanipuláció","heading":"7.2 Adatkezelés Tidyverse R-ben","text":"","code":""},{"path":"adatmanipulacio.html","id":"a-operátor","chapter":"7 Adatmanipuláció","heading":"7.2.1 A %>% operátor","text":"Egy probléma megoldása több lépésben történik. survey adatbázisból keressük ki lányok testmagasságának az át gyakran függvényeket kell egymásba ágyaznunk. Ha például az 1, 2 és 3 számok természetes alapú logaritmusának az összegét szeretnénk kiszámolni, akkor következő sorokat írhatjuk:részeredmények tárolására az objektumot használtuk fel. köztes eredmények tárolása azonos vagy eltérő nevek alatt szokásos gyakorlat hagyományos R használata során.fenti lehetőség mellett választhatjuk függvények egymásba ágyazását :fenti példa jóval tömörebb és nem szükséges köztes objektumok létrehozása, hagyományos R-ben nagyon gyakori összetett függvényhívásokkal (rész)problémák megoldása.magrittr csomag kínál egy harmadik lehetőséget, pipe operátor (%>%) használatával. Az operátor egyben Tidyverse R része .fenti sor olvasható úgy, hogy induljunk ki az x adatobjektumból, azután vegyük 2-es alapú logaritmusát, azután vegyük az értékek összegét. %>% pipe operátor az azután lehetőséget kínálja, és egyben egy rendkívül jól olvasható és karbantarható kód létrehozását teszi lehetővé. fentebb látott függvények egymásba ágyazásánál sokkal könyebben javítható ez kód, az azt megelőző, köztes objektumokkal dolgozó esetnél pedig jóval egyszerűbb és elegánsabb. pipe operátort használó parancsok tipikusan adatobjektummal, vagy az azt létrehozó függvénnyel indítanak, majd azoknak tevékenységeknek felsorolása történik függvényhívások egymásutánjának megadásával, amelyeket felsorolás sorrendjében az adatokkal tenni szeretnénk. Az adat rész ezekből függvényhívásokból hiányzik, ugyanis pipe operátor biztosítja, hogy mindegyik függvény első argumentumába megkapja azt.fenti példában, látható, hogyan gondoskodik pipe oprátor arról, hogy log() függvény első argumentuma (x=) megkapja szükséges értékét. Néhány függvény esetében előfordul, hogy kiinduló adat apaértelmezés szerint nem az első paraméter. Ekkor pont . helyörző segítségével expliciten jelezzük, hogy hová kerül pipe operátor bal oldaláról eérkező adat. Például karakterstring cserére használatos sub() függvény x= argumentuma alapértelmezés szerint harmadik:következő függvényhívás az argumentumok nevesítése miatt szintén működőképes, az pipe-ban x=letters argumentumhívás valósul meg.Azonban ha nem használunk argumentumneveket, akkor ez hívás már nem kívánt eredményre vezet, mert alapértelmezés szerint az első argumentumba kerül az adat, amelyik sub() esetében pattern= argumentum.Ha tehát nem az első argumentumban szeretnénk szerepeltetni pipe bal oldaláról érkező adatot, akkor . helyörzőt kell használnunk:","code":"\nx <- c(1, 2, 3)       # vektor előállítása\nout <- log(x)         # természetes alapú logaritmus kiszámolása  \nout <- sum(out)       # átlag kiszámolása\nout                   # eredmény kírása\n#> [1] 1.792\nx   <- c(1, 2, 3)     # vektor előállítása\nsum(log(x))           # eredmény kiírása\n#> [1] 1.792\nlibrary(tidyverse)\nx   <- c(1, 2, 3)     # vektor előállítása\nx %>% log() %>% sum() # eredmény kiírása\n#> [1] 1.792\n10 %>% log()                 # ekvivalens alak: log(x=10)\n#> [1] 2.303\nc(10, 100) %>% log()         # ekvivalens alak: log(x=c(10, 100))\n#> [1] 2.303 4.605\nc(10, 100) %>% log(base=10)  # ekvivalens alak: log(x=c(10, 100), base=10)\n#> [1] 1 2\nsub(pattern = \"s\", replacement = \"z\", x = letters)  # s cseréje z-re\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"z\"\n#> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\nletters %>% sub(pattern = \"s\", replacement = \"z\")\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"z\"\n#> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\nletters %>% sub(\"s\", \"z\") # Nem ezt akartuk. Valójában ez hívódik: sub(pattern=letters, replacement=\"s\", x=\"z\") \n#> [1] \"z\"\nletters %>% sub(\"s\", \"z\", .) # letters %>% sub(pattern = \"s\", replacement = \"z\", x=letters)\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"z\"\n#> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\nunisex_names %>% slice(1:3)  \n#> # A tibble: 3 × 5\n#>   name     total male_share female_share    gap\n#>   <chr>    <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Casey  176544.      0.584        0.416 0.169 \n#> 2 Riley  154861.      0.508        0.492 0.0153\n#> 3 Jessie 136382.      0.478        0.522 0.0443\nunisex_names %>% slice(n())         # csak az utolsó sor \n#> # A tibble: 1 × 5\n#>   name  total male_share female_share    gap\n#>   <chr> <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Aeon   100.      0.465        0.535 0.0703\nunisex_names %>% slice((n()-4):n()) # utolsó 5 sor\n#> # A tibble: 5 × 5\n#>   name     total male_share female_share    gap\n#>   <chr>    <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Eaden     102.      0.573        0.427 0.146 \n#> 2 Inioluwa  101.      0.353        0.647 0.295 \n#> 3 Gwin      101.      0.562        0.438 0.124 \n#> 4 Yacine    100.      0.545        0.455 0.0892\n#> 5 Aeon      100.      0.465        0.535 0.0703\nunisex_names %>% slice(sample(1:n(), size=4)) # véletlen 4 sor\n#> # A tibble: 4 × 5\n#>   name   total male_share female_share    gap\n#>   <chr>  <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Adisa   151.      0.413        0.587 0.174 \n#> 2 Armoni 1707.      0.395        0.605 0.211 \n#> 3 Kalani 4012.      0.411        0.589 0.178 \n#> 4 Riyan   528.      0.509        0.491 0.0179\nd.tbl <- unisex_names %>% slice(sample(21:24, size=5, replace = T )) # véletlen 4 sor\nd.tbl\n#> # A tibble: 5 × 5\n#>   name     total male_share female_share     gap\n#>   <chr>    <dbl>      <dbl>        <dbl>   <dbl>\n#> 1 Carey   24790.      0.523        0.477 0.0465 \n#> 2 Kris    24956.      0.499        0.501 0.00275\n#> 3 Blair   23160.      0.490        0.510 0.0195 \n#> 4 Emerson 24167.      0.526        0.474 0.0511 \n#> 5 Kris    24956.      0.499        0.501 0.00275\n\nd.tbl %>% distinct()   # a sorok egyedivé tétele\n#> # A tibble: 4 × 5\n#>   name     total male_share female_share     gap\n#>   <chr>    <dbl>      <dbl>        <dbl>   <dbl>\n#> 1 Carey   24790.      0.523        0.477 0.0465 \n#> 2 Kris    24956.      0.499        0.501 0.00275\n#> 3 Blair   23160.      0.490        0.510 0.0195 \n#> 4 Emerson 24167.      0.526        0.474 0.0511\n\n\nunisex_names %>% sample_n(3)        # véletlen 3 sor\n#> # A tibble: 3 × 5\n#>   name    total male_share female_share    gap\n#>   <chr>   <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Lashaun 1978.      0.379        0.621 0.243 \n#> 2 Ardell  2327.      0.523        0.477 0.0458\n#> 3 Audi     149.      0.408        0.592 0.183\nunisex_names %>% sample_frac(0.01)  # véletlen 1%-nyi sor\n#> # A tibble: 9 × 5\n#>   name   total male_share female_share    gap\n#>   <chr>  <dbl>      <dbl>        <dbl>  <dbl>\n#> 1 Areon   126.      0.646        0.354 0.291 \n#> 2 Hudsyn  262.      0.409        0.591 0.182 \n#> 3 Jari    448.      0.351        0.649 0.299 \n#> 4 Danyl   126.      0.545        0.455 0.0891\n#> 5 Currie  155.      0.661        0.339 0.322 \n#> 6 Vail    106.      0.380        0.620 0.241 \n#> 7 Raymie  265.      0.380        0.620 0.240 \n#> 8 Shalom 2061.      0.659        0.341 0.318 \n#> 9 Jahdai  113.      0.377        0.623 0.247\nunisex_names %>% filter(gap<0.003, grepl(pattern = \"^C\", x = name) | grepl(pattern = \"^K\", x = name))\n#> # A tibble: 6 × 5\n#>   name      total male_share female_share      gap\n#>   <chr>     <dbl>      <dbl>        <dbl>    <dbl>\n#> 1 Kris     24956.      0.499        0.501 0.00275 \n#> 2 Camdyn    3275.      0.500        0.500 0.000154\n#> 3 Christan  2685.      0.501        0.499 0.00227 \n#> 4 Kam        729.      0.501        0.499 0.00235 \n#> 5 Kodee      533.      0.500        0.500 0.000316\n#> 6 Callaway   292.      0.500        0.500 0.000455\nunisex_names %>% filter_all(any_vars(.>0.4))\n#> # A tibble: 919 × 5\n#>    name      total male_share female_share    gap\n#>    <chr>     <dbl>      <dbl>        <dbl>  <dbl>\n#>  1 Casey   176544.      0.584        0.416 0.169 \n#>  2 Riley   154861.      0.508        0.492 0.0153\n#>  3 Jessie  136382.      0.478        0.522 0.0443\n#>  4 Jackie  132929.      0.421        0.579 0.158 \n#>  5 Avery   121797.      0.335        0.665 0.330 \n#>  6 Jaime   109870.      0.562        0.438 0.124 \n#>  7 Peyton   94896.      0.434        0.566 0.133 \n#>  8 Kerry    88964.      0.484        0.516 0.0321\n#>  9 Jody     80401.      0.352        0.648 0.296 \n#> 10 Kendall  79211.      0.372        0.628 0.255 \n#> # … with 909 more rows\nsmiths %>% select(kor=age, suly=weight)\n#> # A tibble: 2 × 2\n#>     kor  suly\n#>   <dbl> <dbl>\n#> 1    33    90\n#> 2    NA    NA\nsmiths %>% rename(kor=age, suly=weight)\n#> # A tibble: 2 × 5\n#>   subject     time   kor  suly height\n#>   <chr>      <dbl> <dbl> <dbl>  <dbl>\n#> 1 John Smith     1    33    90   1.87\n#> 2 Mary Smith     1    NA    NA   1.54\nlibrary(fivethirtyeight)"},{"path":"adatmanipulacio.html","id":"oszlopok-válogatása-a-tidyverse-r-ben","chapter":"7 Adatmanipuláció","heading":"7.2.1.1 Oszlopok válogatása a Tidyverse R-ben","text":"Tidyverse R select() függvényt kínálja az oszlopok indexelése. select() függvény argumentumába az Alap R-ben látott fenti lehetőség mindegyikét használhatjuk, némi könnyítéssel:Láthatjuk select() elbírja pozitív vagy negatív indexek közvetlen megadását, nem kell vektorban felsorolni őket, illetve az oszlopneveket idézőjel nélkül megadhatjuk.\nTovábbi lehetőség, hogy az oszlopneveket úgy ishasználhatjuk, mintha számok lennének, kettőspont operátor és negtív előjel használható velük:Az oszlopok között az oszlopnevek alapján lehet válogatni, ehhez Tidyverse R számos függvényt ajánl:Válogathatunk az oszlopok közül az oszlop adataira vonatkozó logikai értéket szolgáltató függvények segítségével. Erre select_if() ad lehetőséget.","code":"\n# library(tidyverse)\n# smiths.tbl %>% select(1:3)\n# smiths.tbl %>% select(1, 3, 5)\n# smiths.tbl %>% select(-1, -3, -5)\n# smiths.tbl %>% select(subject, height)\n# smiths.tbl %>% select(subject:age)\n# smiths.tbl %>% select(-subject, -age)\n# smiths.tbl %>% select(-(subject:age))\n# smiths.tbl %>% select(starts_with(\"ti\"))\n# smiths.tbl %>% select(ends_with(\"t\"))\n# smiths.tbl %>% select(contains(\"ei\"))\n# d.df <- data.frame(id=1, kerd.1=10, kerd.2=20, kerd.3=30)\n# d.df\n# d.df %>% select(num_range(\"kerd.\",1:3))\n# smiths.tbl %>% select_if(is.numeric)\n# smiths.tbl %>% select_if(is.character)"},{"path":"adatmanipulacio.html","id":"haladó-adatkezelés","chapter":"7 Adatmanipuláció","heading":"7.3 Haladó adatkezelés","text":"Ebben fejezetben:","code":""},{"path":"mutatok-tablazatok.html","id":"mutatok-tablazatok","chapter":"8 Mutatók és táblázatok","heading":"8 Mutatók és táblázatok","text":"","code":""},{"path":"mutatok-tablazatok.html","id":"alap-r-lehetőségei","chapter":"8 Mutatók és táblázatok","heading":"8.1 Alap R lehetőségei","text":"Ebben fejezetben áttekintjükaz Alap R mutatószámoló éstáblázat készítő függvényeitA leíró statisztika célja az adatstruktúrába való elsődleges betekintés, az adatok eloszlásának felderítése. leíró statisztika eszközei statisztikai mérőszámok (mutatók), táblázatok és grafikonok. Ebben fejezetben mutatókkal és táblázatokkal foglalkozunk, az ábrák készítése következő fejezet témája lesz.","code":""},{"path":"mutatok-tablazatok.html","id":"mutatók","chapter":"8 Mutatók és táblázatok","heading":"8.1.1 Mutatók","text":"","code":""},{"path":"mutatok-tablazatok.html","id":"egy-változó-egy-mutató","chapter":"8 Mutatók és táblázatok","heading":"8.1.1.1 Egy változó, egy mutató","text":"statisztikai mérőszámok vagy mutatók mintából számolt statisztikai függvények. két legfontosabb mintaátlag és minta szórása. MASS csomag survey adattáblája például 237 egyetemista testmagasságát tartalmazza Height oszlopában. Számoljuk ki ezt két fontos mutatót:Az na.rm=T argumentum megadására szükség van, mivel Height változó tartalmaz hiányzó értékeket, csak így kapjuk meg mintaátlagot és minta szórását.Természetesen további mutatók számolhatók:","code":"\ndata(survey, package = \"MASS\") # survey betöltése\nmean(survey$Height, na.rm = T) # testmagasság átlaga\n#> [1] 172.4\nsd(survey$Height, na.rm = T) # testmagasság szórása\n#> [1] 9.848\nmedian(survey$Height, na.rm = T) # medián\n#> [1] 171\nvar(survey$Height, na.rm = T) # variancia\n#> [1] 96.97\nmin(survey$Height, na.rm = T) # minimum\n#> [1] 150\nmax(survey$Height, na.rm = T) # maximum\n#> [1] 200\nrange(survey$Height, na.rm = T) # minimum és maximum\n#> [1] 150 200\ndiff(range(survey$Height, na.rm = T)) # terjedelem\n#> [1] 50\nIQR(survey$Height, na.rm = T) # interkvartilis-eltérés\n#> [1] 15\nquantile(survey$Height, na.rm = T) # kvantilisek\n#>   0%  25%  50%  75% 100% \n#>  150  165  171  180  200\nmoments::skewness(survey$Height, na.rm = T) # ferdeség\n#> [1] 0.2174\nmoments::kurtosis(survey$Height, na.rm = T) # csúcsosság\n#> [1] 2.587"},{"path":"mutatok-tablazatok.html","id":"több-változó-egy-mutató","chapter":"8 Mutatók és táblázatok","heading":"8.1.1.2 Több változó, egy mutató","text":"Sokszor, egyszerre több numerikus változó statisztikai mutatóit szeretnénk meghatározni, ehhez az apply(MARGIN=2) vagy az sapply() függvényt használhatjuk. Az apply() általánosabb, így MARGIN=2 segítségével tudjuk az oszloponkénti függvényvégrehajtására utasítani, míg az sapply() esetében ez működés lényege. három numerikus változó (kézméret, testmagasság és életkor) legfontosabb statisztikai mutatóit írtajuk ki:","code":"\n# mutatók 3 változóra: apply()\napply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], MARGIN = 2, FUN = mean, na.rm = T)\n#> Wr.Hnd Height    Age \n#>  18.67 172.38  20.37\napply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], MARGIN = 2, FUN = sd, na.rm = T)\n#> Wr.Hnd Height    Age \n#>  1.879  9.848  6.474\napply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], MARGIN = 2, FUN = range, na.rm = T)\n#>      Wr.Hnd Height   Age\n#> [1,]   13.0    150 16.75\n#> [2,]   23.2    200 73.00\napply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], MARGIN = 2, FUN = quantile, na.rm = T)\n#>      Wr.Hnd Height   Age\n#> 0%     13.0    150 16.75\n#> 25%    17.5    165 17.67\n#> 50%    18.5    171 18.58\n#> 75%    19.8    180 20.17\n#> 100%   23.2    200 73.00\n\n# mutatók 3 változóra: sapply()\nsapply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], FUN = mean, na.rm = T)\n#> Wr.Hnd Height    Age \n#>  18.67 172.38  20.37\nsapply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], FUN = sd, na.rm = T)\n#> Wr.Hnd Height    Age \n#>  1.879  9.848  6.474\nsapply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], FUN = range, na.rm = T)\n#>      Wr.Hnd Height   Age\n#> [1,]   13.0    150 16.75\n#> [2,]   23.2    200 73.00\nsapply(survey[, c(\"Wr.Hnd\", \"Height\", \"Age\")], FUN = quantile, na.rm = T)\n#>      Wr.Hnd Height   Age\n#> 0%     13.0    150 16.75\n#> 25%    17.5    165 17.67\n#> 50%    18.5    171 18.58\n#> 75%    19.8    180 20.17\n#> 100%   23.2    200 73.00"},{"path":"mutatok-tablazatok.html","id":"egy-változó-több-mutató","chapter":"8 Mutatók és táblázatok","heading":"8.1.1.3 Egy változó, több mutató","text":"Amennyiben egyszerre több statisztikai mutatóra van szükségünk, akkor az Alap R lehetőségei közül summary() függvény az első lehetőség.","code":"\nsummary(survey$Wr.Hnd)  # kézméret mutatói\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n#>    13.0    17.5    18.5    18.7    19.8    23.2       1\nsummary(survey$Height)  # testmagasság mutatói\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n#>     150     165     171     172     180     200      28\nsummary(survey$Age)     # életkor mutatói\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    16.8    17.7    18.6    20.4    20.2    73.0"},{"path":"mutatok-tablazatok.html","id":"mutatók-csoportokra","chapter":"8 Mutatók és táblázatok","heading":"8.1.1.4 Mutatók csoportokra","text":"Nagyon fontos lehetőség mutatók meghatározása különböző csoportokban. Csoportok alatt faktor által meghatározott, adott faktorszinthez tartozó mintaelemeket értjük. Például survey adattábla nem (Sex) faktora két csoportra osztja 237 elemű mintát.nem szerint meghatározott két csoport azonos elemszámú, 118 személy tartozik nők csoportjába, és 118 férfiak csoportjába . Egy másik faktor, dohányzási szokás (Smoke) már nem mutat egyenletes eloszlást:Az erős dohányosok mindössze 11-en vannak, míg legtöbben nem dohányzók táborába tartoznak (189 fő).faktor által meghatározott csoportok nagyon fontosak lehetnek az adatelemzés során. Például kíváncsiak lehetünk nem faktor két csoportjában (nők és férfiak) testmagasság átlagára. Az Alap R az ilyen jellegű kérdések megválaszolására 3 függvényt nyújt számunkra: tapply(), aggregate() és ().tapply() egyetlen numerikus változó egy faktor egy vagy több csoportjában képes statisztikai mutató meghatározására. Fontos, hogy statisztikai mutató egyetlen értékkel térjen vissza (pl. mean() vagy sd()), mert táblázatos elrendezés az outputban csak így lehetséges, tehát range() és quantile() nem használható.tapply() függvényt tipikusan egy vagy két faktor esetén használjuk, táblázatos output kényelmes áttekintést ad az egyes csoportok statisztikai mutatóiról. legnagyobb szabadságot az aggregate() és () nyújtja számunkra, ezek használatát érdemes elsajátítani. Paraméterezésük megegyezik (az argumentumok neve nem), csak az outputban térnek el. Az aggregate() visszatérési értéke egy adattábla típusú objektum, amelyet később kényelmesen felhasználhatunk, () egy egyszerűbb szöveges listával tér vissza.Az aggregate() legnagyobb előnye, hogy több numerikus változót megadhatunk az első paraméterükben, () esetében pedig olyan függvényeket alkalmazhatunk az egyes csoportokra, amelyek nem egyetlen értékkel térnek vissza.","code":"\ntable(survey$Sex, useNA = \"ifany\")  # nem faktor eloszlása\n#> \n#> Female   Male   <NA> \n#>    118    118      1\ntable(survey$Smoke, useNA = \"ifany\")  # dohányzási szokás faktor eloszlása\n#> \n#> Heavy Never Occas Regul  <NA> \n#>    11   189    19    17     1\n# mintaátlag csoportokra\ntapply(survey$Wr.Hnd, INDEX = survey$Sex, FUN = mean, na.rm=T)\n#> Female   Male \n#>  17.60  19.74\ntapply(survey$Wr.Hnd, INDEX = survey[,c(\"Sex\", \"Smoke\")], FUN = mean, na.rm=T)\n#>         Smoke\n#> Sex      Heavy Never Occas Regul\n#>   Female 17.90 17.66 16.82 17.48\n#>   Male   20.32 19.61 19.83 20.27\ntapply(survey$Wr.Hnd, INDEX = survey[,c(\"Sex\", \"Smoke\", \"Exer\")], FUN = mean, na.rm=T)\n#> , , Exer = Freq\n#> \n#>         Smoke\n#> Sex      Heavy Never Occas Regul\n#>   Female 17.73 17.53 15.92 19.55\n#>   Male   18.93 19.75 20.27 20.86\n#> \n#> , , Exer = None\n#> \n#>         Smoke\n#> Sex      Heavy Never Occas Regul\n#>   Female    NA 17.59 18.50    NA\n#>   Male    23.2 19.29 17.95  19.5\n#> \n#> , , Exer = Some\n#> \n#>         Smoke\n#> Sex      Heavy Never Occas Regul\n#>   Female 18.15 17.77 17.77 16.10\n#>   Male   23.00 19.47 20.50 19.45\n# mintaátlag csoportokra\naggregate(survey[, \"Wr.Hnd\"], by=survey[, \"Sex\", drop=F], FUN = mean, na.rm=T)\n#>      Sex     x\n#> 1 Female 17.60\n#> 2   Male 19.74\nby(survey[, \"Wr.Hnd\"], INDICES = survey[, \"Sex\", drop=F], FUN = mean, na.rm=T)\n#> Sex: Female\n#> [1] 17.6\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> [1] 19.74\naggregate(survey[, \"Wr.Hnd\"], by=survey[, c(\"Sex\", \"Smoke\")], FUN = mean, na.rm=T)\n#>      Sex Smoke     x\n#> 1 Female Heavy 17.90\n#> 2   Male Heavy 20.32\n#> 3 Female Never 17.66\n#> 4   Male Never 19.61\n#> 5 Female Occas 16.82\n#> 6   Male Occas 19.83\n#> 7 Female Regul 17.48\n#> 8   Male Regul 20.27\nby(survey[, \"Wr.Hnd\"], INDICES = survey[, c(\"Sex\", \"Smoke\")], FUN = mean, na.rm=T)\n#> Sex: Female\n#> Smoke: Heavy\n#> [1] 17.9\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Heavy\n#> [1] 20.32\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Never\n#> [1] 17.66\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Never\n#> [1] 19.61\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Occas\n#> [1] 16.82\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Occas\n#> [1] 19.83\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Regul\n#> [1] 17.48\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Regul\n#> [1] 20.27\naggregate(survey[, \"Wr.Hnd\"], by=survey[, c(\"Sex\", \"Smoke\", \"Exer\")], FUN = mean, na.rm=T)\n#>       Sex Smoke Exer     x\n#> 1  Female Heavy Freq 17.73\n#> 2    Male Heavy Freq 18.93\n#> 3  Female Never Freq 17.53\n#> 4    Male Never Freq 19.75\n#> 5  Female Occas Freq 15.92\n#> 6    Male Occas Freq 20.27\n#> 7  Female Regul Freq 19.55\n#> 8    Male Regul Freq 20.86\n#> 9    Male Heavy None 23.20\n#> 10 Female Never None 17.59\n#> 11   Male Never None 19.29\n#> 12 Female Occas None 18.50\n#> 13   Male Occas None 17.95\n#> 14   Male Regul None 19.50\n#> 15 Female Heavy Some 18.15\n#> 16   Male Heavy Some 23.00\n#> 17 Female Never Some 17.77\n#> 18   Male Never Some 19.47\n#> 19 Female Occas Some 17.77\n#> 20   Male Occas Some 20.50\n#> 21 Female Regul Some 16.10\n#> 22   Male Regul Some 19.45\nby(survey[, \"Wr.Hnd\"], INDICES = survey[, c(\"Sex\", \"Smoke\", \"Exer\")], FUN = mean, na.rm=T)\n#> Sex: Female\n#> Smoke: Heavy\n#> Exer: Freq\n#> [1] 17.73\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Heavy\n#> Exer: Freq\n#> [1] 18.93\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Never\n#> Exer: Freq\n#> [1] 17.53\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Never\n#> Exer: Freq\n#> [1] 19.75\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Occas\n#> Exer: Freq\n#> [1] 15.92\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Occas\n#> Exer: Freq\n#> [1] 20.27\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Regul\n#> Exer: Freq\n#> [1] 19.55\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Regul\n#> Exer: Freq\n#> [1] 20.86\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Heavy\n#> Exer: None\n#> [1] NA\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Heavy\n#> Exer: None\n#> [1] 23.2\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Never\n#> Exer: None\n#> [1] 17.59\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Never\n#> Exer: None\n#> [1] 19.29\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Occas\n#> Exer: None\n#> [1] 18.5\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Occas\n#> Exer: None\n#> [1] 17.95\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Regul\n#> Exer: None\n#> [1] NA\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Regul\n#> Exer: None\n#> [1] 19.5\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Heavy\n#> Exer: Some\n#> [1] 18.15\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Heavy\n#> Exer: Some\n#> [1] 23\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Never\n#> Exer: Some\n#> [1] 17.77\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Never\n#> Exer: Some\n#> [1] 19.47\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Occas\n#> Exer: Some\n#> [1] 17.77\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Occas\n#> Exer: Some\n#> [1] 20.5\n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Regul\n#> Exer: Some\n#> [1] 16.1\n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Regul\n#> Exer: Some\n#> [1] 19.45\n# mintaátlag csoportokra\naggregate(survey[,  c(\"Wr.Hnd\", \"Height\", \"Age\")], by=survey[, \"Sex\", drop=F], FUN = mean, na.rm=T)\n#>      Sex Wr.Hnd Height   Age\n#> 1 Female  17.60  165.7 20.41\n#> 2   Male  19.74  178.8 20.33\naggregate(survey[,  c(\"Wr.Hnd\", \"Height\", \"Age\")], by=survey[, c(\"Sex\", \"Smoke\")], FUN = mean, na.rm=T)\n#>      Sex Smoke Wr.Hnd Height   Age\n#> 1 Female Heavy  17.90  166.9 22.73\n#> 2   Male Heavy  20.32  180.6 20.28\n#> 3 Female Never  17.66  165.7 20.03\n#> 4   Male Never  19.61  178.3 20.51\n#> 5 Female Occas  16.82  167.4 21.91\n#> 6   Male Occas  19.83  178.6 18.93\n#> 7 Female Regul  17.48  159.8 22.87\n#> 8   Male Regul  20.27  182.2 20.40\naggregate(survey[,  c(\"Wr.Hnd\", \"Height\", \"Age\")], by=survey[, c(\"Sex\", \"Smoke\", \"Exer\")], FUN = mean, na.rm=T)\n#>       Sex Smoke Exer Wr.Hnd Height   Age\n#> 1  Female Heavy Freq  17.73  167.2 25.86\n#> 2    Male Heavy Freq  18.93  179.7 20.46\n#> 3  Female Never Freq  17.53  167.2 19.73\n#> 4    Male Never Freq  19.75  180.3 20.47\n#> 5  Female Occas Freq  15.92  166.9 19.75\n#> 6    Male Occas Freq  20.27  178.4 19.26\n#> 7  Female Regul Freq  19.55  167.0 19.79\n#> 8    Male Regul Freq  20.86  182.6 21.99\n#> 9    Male Heavy None  23.20  171.0 20.92\n#> 10 Female Never None  17.59  163.0 20.40\n#> 11   Male Never None  19.29  173.6 22.15\n#> 12 Female Occas None  18.50    NaN 41.58\n#> 13   Male Occas None  17.95  176.0 17.92\n#> 14   Male Regul None  19.50  177.8 17.58\n#> 15 Female Heavy Some  18.15  166.6 18.04\n#> 16   Male Heavy Some  23.00  193.0 18.92\n#> 17 Female Never Some  17.77  164.9 20.19\n#> 18   Male Never Some  19.47  176.7 20.17\n#> 19 Female Occas Some  17.77  168.3 18.94\n#> 20   Male Occas Some  20.50  182.9 18.67\n#> 21 Female Regul Some  16.10  156.2 24.92\n#> 22   Male Regul Some  19.45  182.8 18.33\n\nby(survey[,  \"Wr.Hnd\"], INDICES = survey[, c(\"Sex\", \"Smoke\")], FUN = shapiro.test)\n#> Sex: Female\n#> Smoke: Heavy\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.86, p-value = 0.2\n#> \n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Heavy\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.84, p-value = 0.1\n#> \n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Never\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.95, p-value = 5e-04\n#> \n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Never\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.99, p-value = 0.5\n#> \n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Occas\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.97, p-value = 0.9\n#> \n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Occas\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.92, p-value = 0.3\n#> \n#> ------------------------------------------------------------ \n#> Sex: Female\n#> Smoke: Regul\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.9, p-value = 0.4\n#> \n#> ------------------------------------------------------------ \n#> Sex: Male\n#> Smoke: Regul\n#> \n#>  Shapiro-Wilk normality test\n#> \n#> data:  dd[x, ]\n#> W = 0.93, p-value = 0.3\nby(survey[,  c(\"Wr.Hnd\", \"Height\", \"Age\")], INDICES = survey[, \"Sex\", drop=F], FUN = summary, na.rm=T)\n#> Sex: Female\n#>      Wr.Hnd         Height         Age      \n#>  Min.   :13.0   Min.   :150   Min.   :16.9  \n#>  1st Qu.:17.0   1st Qu.:163   1st Qu.:17.5  \n#>  Median :17.5   Median :167   Median :18.4  \n#>  Mean   :17.6   Mean   :166   Mean   :20.4  \n#>  3rd Qu.:18.5   3rd Qu.:170   3rd Qu.:20.0  \n#>  Max.   :20.8   Max.   :180   Max.   :73.0  \n#>                 NA's   :16                  \n#> ------------------------------------------------------------ \n#> Sex: Male\n#>      Wr.Hnd         Height         Age      \n#>  Min.   :14.0   Min.   :155   Min.   :16.8  \n#>  1st Qu.:18.5   1st Qu.:173   1st Qu.:17.9  \n#>  Median :19.5   Median :180   Median :18.9  \n#>  Mean   :19.7   Mean   :179   Mean   :20.3  \n#>  3rd Qu.:21.0   3rd Qu.:185   3rd Qu.:20.3  \n#>  Max.   :23.2   Max.   :200   Max.   :70.4  \n#>  NA's   :1      NA's   :12"},{"path":"mutatok-tablazatok.html","id":"táblázatok","chapter":"8 Mutatók és táblázatok","heading":"8.1.2 Táblázatok","text":"","code":""},{"path":"mutatok-tablazatok.html","id":"abszolút-gyakoriság","chapter":"8 Mutatók és táblázatok","heading":"8.1.2.1 Abszolút gyakoriság","text":"Az eddig látott mutatók numerikus változók leíró statisztikai leírására szolgáltak. gyakorisági táblázatokat többnyire faktor típusú változók jellemzésére használjuk. Az Alap R korábban megismert függvényei, table(), xtabs() és ftable() már biztosítják számunkra nyers, ún. abszolút gyakorisági táblázatok kiírását.Egydimenziós táblázatot, az ún. gyakorisági táblázatot summary() függvénnyel létrehozhatunk. Ha hívásban faktor argumentumot adunk meg, akkor gyakorisági táblázatot kapunk, amely az egyes faktorszintek mintabeli előfordulási számát adja:Láthatjuk, hogy 237 megkérdezett hallgatóból 18 balkezes, 218 jobbkazes, egy diáknak pedig nem jegyezték fel kezességét. Hasonló eredményt kapunk, ha táblázatok létrehozásra szánt table() függvényt használjuk, de itt hiányzó értékek megjelenítéséről már külön gondoskodnunk kell:már korábban megismert apply() vagy sapply() segítségével több faktor gyakorisági táblázatát kiírhatjuk:fenti outputból kiemeljük Smoke változót, amely hallgatók dohányzási szokását tartalmazza. változó 4 szintű faktor, melynek értékei: Never-nem dohányzik, Occas-ritkán dohányzik, Regul-rendszeresen dohányzik, Heavy-sokat dohányzik. Láthatjuk, hogy 237 megkérdezett hallgatóból 189 diák nem dohányzik és csak 11 erős dohányos.table() függvényt numerikus argumentum esetén használhatjuk, ekkor különböző számok előfordulási gyakoriságát kapjuk. folytonos kvantitatív változóink, jellemzően, minden mérésnél más és más értéket adnak, így legtöbbször table() hívásnak nincs értelme folytonos numerikus vektor esetén. Azonban diszkrét numerikus változók esetén hasznos lehet gyakorisági táblázat megjelenítése, mert ezek értékei sokszor ismétlődnek, de ez természetesen változó jellegétől nagy mértékben függ. diákok pulzusára (Pulse) hívjuk meg table() függvényt:Leolvashatjuk, hogy leggyakoribb pulzus 80, hiszen az 18-szor fordul elő, valamint 45 személynek nem ismerjük pulzusát. fenti táblázatot áttekinthetőbbé tehetjük, ha az előfordulási értékek szerint rendezzük cellákat. rendezésre használjuk sort(decreasing=T) függvényt:Láthatjuk, hogy fenti outputból már könnyen kiolvashatók legnagyobb és legkisebb gyakoriságú értékek.Többdimenziós táblázatokat szokásos módon, több faktor felsorolásával adhatunk meg:","code":"\nsummary(survey$W.Hnd)\n#>  Left Right  NA's \n#>    18   218     1\ntable(survey$W.Hnd, useNA = \"ifany\")  # kezesség gyakorisági táblázata (1D)\n#> \n#>  Left Right  <NA> \n#>    18   218     1\nxtabs(~W.Hnd, data = survey, addNA = T)\n#> W.Hnd\n#>  Left Right  <NA> \n#>    18   218     1\nsapply(survey[,c(\"Sex\",\"W.Hnd\",\"Exer\",\"Smoke\")], FUN = table, useNA=\"ifany\")\n#> $Sex\n#> \n#> Female   Male   <NA> \n#>    118    118      1 \n#> \n#> $W.Hnd\n#> \n#>  Left Right  <NA> \n#>    18   218     1 \n#> \n#> $Exer\n#> \n#> Freq None Some \n#>  115   24   98 \n#> \n#> $Smoke\n#> \n#> Heavy Never Occas Regul  <NA> \n#>    11   189    19    17     1\ntable(survey$Pulse, useNA = \"ifany\")\n#> \n#>   35   40   48   50   54   55   56   59   60   61   62   63   64   65   66   67 \n#>    1    1    2    2    1    1    1    1   12    1    4    1    9    6    6    1 \n#>   68   69   70   71   72   73   74   75   76   78   79   80   81   83   84   85 \n#>   16    1   13    2   14    1    5    5   13    4    3   18    1    4    5    4 \n#>   86   87   88   89   90   92   96   97   98  100  104 <NA> \n#>    3    2    4    1    8    6    3    1    1    2    2   45\nxtabs(~Pulse, data = survey, addNA = T)\n#> Pulse\n#>   35   40   48   50   54   55   56   59   60   61   62   63   64   65   66   67 \n#>    1    1    2    2    1    1    1    1   12    1    4    1    9    6    6    1 \n#>   68   69   70   71   72   73   74   75   76   78   79   80   81   83   84   85 \n#>   16    1   13    2   14    1    5    5   13    4    3   18    1    4    5    4 \n#>   86   87   88   89   90   92   96   97   98  100  104 <NA> \n#>    3    2    4    1    8    6    3    1    1    2    2   45\nsort(table(survey$Pulse, useNA = \"ifany\"), decreasing = T)\n#> \n#> <NA>   80   68   72   70   76   60   64   90   65   66   92   74   75   84   62 \n#>   45   18   16   14   13   13   12    9    8    6    6    6    5    5    5    4 \n#>   78   83   85   88   79   86   96   48   50   71   87  100  104   35   40   54 \n#>    4    4    4    4    3    3    3    2    2    2    2    2    2    1    1    1 \n#>   55   56   59   61   63   67   69   73   81   89   97   98 \n#>    1    1    1    1    1    1    1    1    1    1    1    1\ntable(survey$Sex, survey$W.Hnd, useNA = \"ifany\")  # kezesség gyakorisági táblázata (2D)\n#>         \n#>          Left Right <NA>\n#>   Female    7   110    1\n#>   Male     10   108    0\n#>   <NA>      1     0    0\nftable(table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = \"ifany\"))  # kezesség gyakorisági táblázata (3D)\n#>               Freq None Some\n#>                             \n#> Female Left      3    1    3\n#>        Right    45   10   55\n#>        NA        1    0    0\n#> Male   Left      3    2    5\n#>        Right    62   11   35\n#>        NA        0    0    0\n#> NA     Left      1    0    0\n#>        Right     0    0    0\n#>        NA        0    0    0"},{"path":"mutatok-tablazatok.html","id":"táblázat-összesített-adatokból","chapter":"8 Mutatók és táblázatok","heading":"8.1.2.2 Táblázat összesített adatokból","text":"Egydimenziós táblázatokat összesített gyakorisági adatok alapján létrehozhatunk c() függvény és az .table() segítségével. Tegyük fel, hogy rendelkezésre áll az az információ fenti 237 hallgatóról, hogy közülük 137 fővárosi és 100 vidéki.következő táblázat 3888 szülés előtt lévő hölgy koffein fogyasztásáról és családi állapotáról tartalmaz gyakorisági adatokat. Készítsünk egy mátrixot majd táblázatot fenti adatokból.matrix() függvényt használjuk, az adatokat pedig sor folytonosan adjuk meg az első argumentumban. könnyebb áttekinthetőség kedvéért, adjunk nevet soroknak és az oszlopoknak.példában szereplő gyakorisági adatokat sikeresen rögzítettük egy numerikus mátrixba. Azonban akkor lesz belőle R-beli táblázat, ha az .table() függvénnyel átalakítjuk mátrixunkat.","code":"\nlakhely <- as.table(c(főváros=137, vidék=100))\nlakhely\n#> főváros   vidék \n#>     137     100\nas.data.frame(lakhely)\n#>      Var1 Freq\n#> 1 főváros  137\n#> 2   vidék  100\nm <- matrix(c(652,1537,598,242,36,46,38,21,218, 327,106,67), nrow=3,byrow=T)\nrownames(m) <- c(\"Házas\",\"Házas.volt\",\"Egyedül.él\")\ncolnames(m) <- c(\"0\",\"1-150\",\"151-300\",\">300\")\nm\n#>              0 1-150 151-300 >300\n#> Házas      652  1537     598  242\n#> Házas.volt  36    46      38   21\n#> Egyedül.él 218   327     106   67\nkoff.csalad <- as.table(m)\nkoff.csalad\n#>               0 1-150 151-300 >300\n#> Házas       652  1537     598  242\n#> Házas.volt   36    46      38   21\n#> Egyedül.él  218   327     106   67\nas.data.frame((koff.csalad))\n#>          Var1    Var2 Freq\n#> 1       Házas       0  652\n#> 2  Házas.volt       0   36\n#> 3  Egyedül.él       0  218\n#> 4       Házas   1-150 1537\n#> 5  Házas.volt   1-150   46\n#> 6  Egyedül.él   1-150  327\n#> 7       Házas 151-300  598\n#> 8  Házas.volt 151-300   38\n#> 9  Egyedül.él 151-300  106\n#> 10      Házas    >300  242\n#> 11 Házas.volt    >300   21\n#> 12 Egyedül.él    >300   67"},{"path":"mutatok-tablazatok.html","id":"relatív-gyakoriság","chapter":"8 Mutatók és táblázatok","heading":"8.1.2.3 Relatív gyakoriság","text":"Az (abszolút) gyakorisági táblázatok mellett relatív gyakorisági, illetve százalékos relatív gyakorisági táblázatra szükségünk lehet. Ezek létrehozásához prob.table() függvényt használhatjuk.könnyebb értelmezhetőség kedvéért használjuk round(digits=1) függvényt:Kereszttáblák (2D táblázatok) esetén teljes, soronkénti és az oszloponkénti eloszlás számítására lehetőséget ad prob.table() függvény.soronkénti relatív gyakorisághoz margin=1, az oszloponkéntihez margin=2 argumentumot használjuk. példában százalékos relatív gyakorisági táblázatot használunk.Kétdimenziós táblázatok esetén, marginális eloszlások számítására van lehetőségünk. Használhatjuk az apply(FUN=sum) függvényt, de direkt erre célra létrehozott margin.table() függvényt .","code":"\nkezesseg <- table(survey$W.Hnd)\nprop.table(kezesseg)\n#> \n#>    Left   Right \n#> 0.07627 0.92373\n100*prop.table(kezesseg)\n#> \n#>   Left  Right \n#>  7.627 92.373\nround(100*prop.table(kezesseg), digits = 1)\n#> \n#>  Left Right \n#>   7.6  92.4\ntab <- table(survey$Sex, survey$W.Hnd, useNA = \"ifany\")\nround(100*prop.table(tab), digits=1)              # teljes\n#>         \n#>          Left Right <NA>\n#>   Female  3.0  46.4  0.4\n#>   Male    4.2  45.6  0.0\n#>   <NA>    0.4   0.0  0.0\nround(100*prop.table(tab, margin = 1), digits=1)  # soronkénti\n#>         \n#>           Left Right  <NA>\n#>   Female   5.9  93.2   0.8\n#>   Male     8.5  91.5   0.0\n#>   <NA>   100.0   0.0   0.0\nround(100*prop.table(tab, margin = 2), digits=1)  # oszloponkénti\n#>         \n#>           Left Right  <NA>\n#>   Female  38.9  50.5 100.0\n#>   Male    55.6  49.5   0.0\n#>   <NA>     5.6   0.0   0.0\napply(koff.csalad, MARGIN=1, FUN=sum)\n#>      Házas Házas.volt Egyedül.él \n#>       3029        141        718\napply(koff.csalad, MARGIN=2, FUN=sum)\n#>       0   1-150 151-300    >300 \n#>     906    1910     742     330\nmargin.table(koff.csalad, margin=1)\n#>      Házas Házas.volt Egyedül.él \n#>       3029        141        718\nmargin.table(koff.csalad, margin=2)\n#>       0   1-150 151-300    >300 \n#>     906    1910     742     330"},{"path":"mutatok-tablazatok.html","id":"kumulált-gyakorisági-táblázatok","chapter":"8 Mutatók és táblázatok","heading":"8.1.2.4 Kumulált gyakorisági táblázatok","text":"relatív gyakorisági táblázatok mellett kumulált relatív gyakorisági táblázatokat megjelenítését kérhetjük egydimenziós esetben. Természetesen, ekkor változónk legalább ordinális skálán mért. kumulált értékek meghatározására cumsum() függvényt használjuk:","code":"\nsurvey$Smoke <- ordered(survey$Smoke, levels=c(\"Never\", \"Occas\", \"Regul\", \"Heavy\"))\ndohanyzas <- table(survey$Smoke)\ncumsum(round(100*prop.table(dohanyzas), digits=0))\n#> Never Occas Regul Heavy \n#>    80    88    95   100"},{"path":"mutatok-tablazatok.html","id":"tidyverse-r-lehetőségei","chapter":"8 Mutatók és táblázatok","heading":"8.2 Tidyverse R lehetőségei","text":"Ebben fejezetben áttekintjüka Tidyverse R mutatószámoló éstáblázat készítő lehetőségeitAz R-ben létezik egy |> operátor, amely jelentősen megkönnyíti kód olvasását.","code":"\n10 |> sqrt()  # sqrt(10)\n#> [1] 3.162\n\nsurvey %>%\n  group_by(Sex) %>%\n  summarise(mean_height = mean(Height, na.rm = TRUE))\n#> # A tibble: 3 × 2\n#>   Sex    mean_height\n#>   <fct>        <dbl>\n#> 1 Female        166.\n#> 2 Male          179.\n#> 3 <NA>          172"},{"path":"mutatok-tablazatok.html","id":"haladó-lehetőségek","chapter":"8 Mutatók és táblázatok","heading":"8.3 Haladó lehetőségek","text":"Ebben fejezetben áttekintjüka mutatók és táblázatok kiírásának kényelmes lehetőségeit\nmutatók és táblázatok kiírásának kényelmes lehetőségeitEbben fejezetben psych, DescTools és summarytools lehetőségeit tekintjük át. Mindhárom csomag rendkívül kényelmessé teszi mutatók és gyakorisági táblázatok kiírását. Mindhárom csomag képes több változót kezelni, több faktorra csoportosítva több statisztikai mutatót megjeleníteni, tehát legnagyobb szabadságot adják kutató kezébe.","code":""},{"path":"mutatok-tablazatok.html","id":"mutatók-1","chapter":"8 Mutatók és táblázatok","heading":"8.3.1 Mutatók","text":"","code":""},{"path":"mutatok-tablazatok.html","id":"a-teljes-adattábla-leírása","chapter":"8 Mutatók és táblázatok","heading":"8.3.1.1 A teljes adattábla leírása","text":"","code":"\nlibrary(tidyverse)\nsurvey %>% psych::describe(fast = T)\n#>        vars   n   mean    sd    min   max range   se\n#> Sex       1 236    NaN    NA    Inf  -Inf  -Inf   NA\n#> Wr.Hnd    2 236  18.67  1.88  13.00  23.2 10.20 0.12\n#> NW.Hnd    3 236  18.58  1.97  12.50  23.5 11.00 0.13\n#> W.Hnd     4 236    NaN    NA    Inf  -Inf  -Inf   NA\n#> Fold      5 237    NaN    NA    Inf  -Inf  -Inf   NA\n#> Pulse     6 192  74.15 11.69  35.00 104.0 69.00 0.84\n#> Clap      7 236    NaN    NA    Inf  -Inf  -Inf   NA\n#> Exer      8 237    NaN    NA    Inf  -Inf  -Inf   NA\n#> Smoke     9 236    NaN    NA    Inf  -Inf  -Inf   NA\n#> Height   10 209 172.38  9.85 150.00 200.0 50.00 0.68\n#> M.I      11 209    NaN    NA    Inf  -Inf  -Inf   NA\n#> Age      12 237  20.37  6.47  16.75  73.0 56.25 0.42\nDescTools::DescToolsOptions(digits=2)\nsurvey %>% DescTools::Desc(plotit = F)\n#> ------------------------------------------------------------------------------ \n#> Describe . (data.frame):\n#> \n#> data frame:  237 obs. of  12 variables\n#>      168 complete cases (70.9%)\n#> \n#>   Nr  ColName  Class            NAs         Levels                       \n#>   1   Sex      factor            1 (0.4%)   (2): 1-Female, 2-Male        \n#>   2   Wr.Hnd   numeric           1 (0.4%)                                \n#>   3   NW.Hnd   numeric           1 (0.4%)                                \n#>   4   W.Hnd    factor            1 (0.4%)   (2): 1-Left, 2-Right         \n#>   5   Fold     factor            .          (3): 1-L on R, 2-Neither, 3-R\n#>                                             on L                         \n#>   6   Pulse    integer          45 (19.0%)                               \n#>   7   Clap     factor            1 (0.4%)   (3): 1-Left, 2-Neither,      \n#>                                             3-Right                      \n#>   8   Exer     factor            .          (3): 1-Freq, 2-None, 3-Some  \n#>   9   Smoke    ordered, factor   1 (0.4%)   (4): 1-Never, 2-Occas,       \n#>                                             3-Regul, 4-Heavy             \n#>   10  Height   numeric          28 (11.8%)                               \n#>   11  M.I      factor           28 (11.8%)  (2): 1-Imperial, 2-Metric    \n#>   12  Age      numeric           .                                       \n#> \n#> \n#> ------------------------------------------------------------------------------ \n#> 1 - Sex (factor - dichotomous)\n#> \n#>   length      n    NAs unique\n#>      237    236      1      2\n#>           99.6%   0.4%       \n#> \n#>         freq   perc  lci.95  uci.95'\n#> Female   118  50.0%   43.7%   56.3%\n#> Male     118  50.0%   43.7%   56.3%\n#> \n#> ' 95%-CI (Wilson)\n#> \n#> ------------------------------------------------------------------------------ \n#> 2 - Wr.Hnd (numeric)\n#> \n#>   length      n    NAs  unique     0s   mean  meanCI'\n#>      237    236      1      60      0  18.67   18.43\n#>           99.6%   0.4%           0.0%          18.91\n#>                                                     \n#>      .05    .10    .25  median    .75    .90     .95\n#>    16.00  16.50  17.50   18.50  19.80  21.15   22.05\n#>                                                     \n#>    range     sd  vcoef     mad    IQR   skew    kurt\n#>    10.20   1.88   0.10    1.48   2.30   0.18    0.30\n#>                                                     \n#> lowest : 13.0 (2), 14.0 (2), 15.0, 15.4, 15.5 (2)\n#> highest: 22.5 (4), 22.8, 23.0 (2), 23.1, 23.2 (3)\n#> \n#> heap(?): remarkable frequency (9.7%) for the mode(s) (= 17.5)\n#> \n#> ' 95%-CI (classic)\n#> \n#> ------------------------------------------------------------------------------ \n#> 3 - NW.Hnd (numeric)\n#> \n#>   length      n    NAs  unique     0s   mean  meanCI'\n#>      237    236      1      68      0  18.58   18.33\n#>           99.6%   0.4%           0.0%          18.83\n#>                                                     \n#>      .05    .10    .25  median    .75    .90     .95\n#>    15.50  16.30  17.50   18.50  19.72  21.00   22.22\n#>                                                     \n#>    range     sd  vcoef     mad    IQR   skew    kurt\n#>    11.00   1.97   0.11    1.63   2.22   0.02    0.44\n#>                                                     \n#> lowest : 12.5, 13.0 (2), 13.3, 13.5, 15.0\n#> highest: 22.7, 23.0, 23.2 (2), 23.3, 23.5\n#> \n#> heap(?): remarkable frequency (8.9%) for the mode(s) (= 18)\n#> \n#> ' 95%-CI (classic)\n#> \n#> ------------------------------------------------------------------------------ \n#> 4 - W.Hnd (factor - dichotomous)\n#> \n#>   length      n    NAs unique\n#>      237    236      1      2\n#>           99.6%   0.4%       \n#> \n#>        freq   perc  lci.95  uci.95'\n#> Left     18   7.6%    4.9%   11.7%\n#> Right   218  92.4%   88.3%   95.1%\n#> \n#> ' 95%-CI (Wilson)\n#> \n#> ------------------------------------------------------------------------------ \n#> 5 - Fold (factor)\n#> \n#>   length      n    NAs unique levels  dupes\n#>      237    237      0      3      3      y\n#>          100.0%   0.0%                     \n#> \n#>      level  freq   perc  cumfreq  cumperc\n#> 1   R on L   120  50.6%      120    50.6%\n#> 2   L on R    99  41.8%      219    92.4%\n#> 3  Neither    18   7.6%      237   100.0%\n#> \n#> ------------------------------------------------------------------------------ \n#> 6 - Pulse (integer)\n#> \n#>   length      n    NAs  unique     0s   mean  meanCI'\n#>      237    192     45      43      0  74.15   72.49\n#>           81.0%  19.0%           0.0%          75.81\n#>                                                     \n#>      .05    .10    .25  median    .75    .90     .95\n#>    59.55  60.00  66.00   72.50  80.00  90.00   92.00\n#>                                                     \n#>    range     sd  vcoef     mad    IQR   skew    kurt\n#>    69.00  11.69   0.16   11.12  14.00  -0.02    0.33\n#>                                                     \n#> lowest : 35, 40, 48 (2), 50 (2), 54\n#> highest: 96 (3), 97, 98, 100 (2), 104 (2)\n#> \n#> heap(?): remarkable frequency (9.4%) for the mode(s) (= 80)\n#> \n#> ' 95%-CI (classic)\n#> \n#> ------------------------------------------------------------------------------ \n#> 7 - Clap (factor)\n#> \n#>   length      n    NAs unique levels  dupes\n#>      237    236      1      3      3      y\n#>           99.6%   0.4%                     \n#> \n#>      level  freq   perc  cumfreq  cumperc\n#> 1    Right   147  62.3%      147    62.3%\n#> 2  Neither    50  21.2%      197    83.5%\n#> 3     Left    39  16.5%      236   100.0%\n#> \n#> ------------------------------------------------------------------------------ \n#> 8 - Exer (factor)\n#> \n#>   length      n    NAs unique levels  dupes\n#>      237    237      0      3      3      y\n#>          100.0%   0.0%                     \n#> \n#>    level  freq   perc  cumfreq  cumperc\n#> 1   Freq   115  48.5%      115    48.5%\n#> 2   Some    98  41.4%      213    89.9%\n#> 3   None    24  10.1%      237   100.0%\n#> \n#> ------------------------------------------------------------------------------ \n#> 9 - Smoke (ordered, factor)\n#> \n#>   length      n    NAs unique levels  dupes\n#>      237    236      1      4      4      y\n#>           99.6%   0.4%                     \n#> \n#>    level  freq   perc  cumfreq  cumperc\n#> 1  Never   189  80.1%      189    80.1%\n#> 2  Occas    19   8.1%      208    88.1%\n#> 3  Regul    17   7.2%      225    95.3%\n#> 4  Heavy    11   4.7%      236   100.0%\n#> \n#> ------------------------------------------------------------------------------ \n#> 10 - Height (numeric)\n#> \n#>   length       n     NAs  unique      0s    mean  meanCI'\n#>      237     209      28      67       0  172.38  171.04\n#>            88.2%   11.8%            0.0%          173.72\n#>                                                         \n#>      .05     .10     .25  median     .75     .90     .95\n#>   157.00  160.00  165.00  171.00  180.00  185.42  189.60\n#>                                                         \n#>    range      sd   vcoef     mad     IQR    skew    kurt\n#>    50.00    9.85    0.06   10.08   15.00    0.22   -0.44\n#>                                                         \n#> lowest : 150.0, 152.0, 152.4, 153.5, 154.94 (2)\n#> highest: 191.8, 193.04, 195.0, 196.0, 200.0\n#> \n#> ' 95%-CI (classic)\n#> \n#> ------------------------------------------------------------------------------ \n#> 11 - M.I (factor - dichotomous)\n#> \n#>   length      n    NAs unique\n#>      237    209     28      2\n#>           88.2%  11.8%       \n#> \n#>           freq   perc  lci.95  uci.95'\n#> Imperial    68  32.5%   26.5%   39.2%\n#> Metric     141  67.5%   60.8%   73.5%\n#> \n#> ' 95%-CI (Wilson)\n#> \n#> ------------------------------------------------------------------------------ \n#> 12 - Age (numeric)\n#> \n#>   length       n    NAs  unique     0s   mean  meanCI'\n#>      237     237      0      88      0  20.37   19.55\n#>           100.0%   0.0%           0.0%          21.20\n#>                                                      \n#>      .05     .10    .25  median    .75    .90     .95\n#>    17.08   17.22  17.67   18.58  20.17  23.58   30.68\n#>                                                      \n#>    range      sd  vcoef     mad    IQR   skew    kurt\n#>    56.25    6.47   0.32    1.61   2.50   5.16   33.47\n#>                                                      \n#> lowest : 16.75, 16.92 (3), 17.0 (2), 17.08 (7), 17.17 (11)\n#> highest: 41.58, 43.83, 44.25, 70.42, 73.0\n#> \n#> ' 95%-CI (classic)\nsurvey %>% summarytools::dfSummary()\n#> Data Frame Summary  \n#> survey  \n#> Dimensions: 237 x 12  \n#> Duplicates: 0  \n#> \n#> ------------------------------------------------------------------------------------------------------------------\n#> No   Variable            Stats / Values            Freqs (% of Valid)   Graph                 Valid      Missing  \n#> ---- ------------------- ------------------------- -------------------- --------------------- ---------- ---------\n#> 1    Sex                 1. Female                 118 (50.0%)          IIIIIIIIII            236        1        \n#>      [factor]            2. Male                   118 (50.0%)          IIIIIIIIII            (99.6%)    (0.4%)   \n#> \n#> 2    Wr.Hnd              Mean (sd) : 18.7 (1.9)    60 distinct values           : .           236        1        \n#>      [numeric]           min < med < max:                                       : : .         (99.6%)    (0.4%)   \n#>                          13 < 18.5 < 23.2                                     . : : :                             \n#>                          IQR (CV) : 2.3 (0.1)                                 : : : : :                           \n#>                                                                         .   : : : : : : : :                       \n#> \n#> 3    NW.Hnd              Mean (sd) : 18.6 (2)      68 distinct values           :             236        1        \n#>      [numeric]           min < med < max:                                       : .           (99.6%)    (0.4%)   \n#>                          12.5 < 18.5 < 23.5                                     : : :                             \n#>                          IQR (CV) : 2.2 (0.1)                                 . : : : .                           \n#>                                                                         .   . : : : : : : :                       \n#> \n#> 4    W.Hnd               1. Left                    18 ( 7.6%)          I                     236        1        \n#>      [factor]            2. Right                  218 (92.4%)          IIIIIIIIIIIIIIIIII    (99.6%)    (0.4%)   \n#> \n#> 5    Fold                1. L on R                  99 (41.8%)          IIIIIIII              237        0        \n#>      [factor]            2. Neither                 18 ( 7.6%)          I                     (100.0%)   (0.0%)   \n#>                          3. R on L                 120 (50.6%)          IIIIIIIIII                                \n#> \n#> 6    Pulse               Mean (sd) : 74.2 (11.7)   43 distinct values         . :             192        45       \n#>      [integer]           min < med < max:                                     : :             (81.0%)    (19.0%)  \n#>                          35 < 72.5 < 104                                      : : .                               \n#>                          IQR (CV) : 14 (0.2)                                  : : :                               \n#>                                                                           . : : : : :                             \n#> \n#> 7    Clap                1. Left                    39 (16.5%)          III                   236        1        \n#>      [factor]            2. Neither                 50 (21.2%)          IIII                  (99.6%)    (0.4%)   \n#>                          3. Right                  147 (62.3%)          IIIIIIIIIIII                              \n#> \n#> 8    Exer                1. Freq                   115 (48.5%)          IIIIIIIII             237        0        \n#>      [factor]            2. None                    24 (10.1%)          II                    (100.0%)   (0.0%)   \n#>                          3. Some                    98 (41.4%)          IIIIIIII                                  \n#> \n#> 9    Smoke               1. Never                  189 (80.1%)          IIIIIIIIIIIIIIII      236        1        \n#>      [ordered, factor]   2. Occas                   19 ( 8.1%)          I                     (99.6%)    (0.4%)   \n#>                          3. Regul                   17 ( 7.2%)          I                                         \n#>                          4. Heavy                   11 ( 4.7%)                                                    \n#> \n#> 10   Height              Mean (sd) : 172.4 (9.8)   67 distinct values         :               209        28       \n#>      [numeric]           min < med < max:                                     : . .           (88.2%)    (11.8%)  \n#>                          150 < 171 < 200                                    : : : : :                             \n#>                          IQR (CV) : 15 (0.1)                              : : : : : : .                           \n#>                                                                         : : : : : : : : .                         \n#> \n#> 11   M.I                 1. Imperial                68 (32.5%)          IIIIII                209        28       \n#>      [factor]            2. Metric                 141 (67.5%)          IIIIIIIIIIIII         (88.2%)    (11.8%)  \n#> \n#> 12   Age                 Mean (sd) : 20.4 (6.5)    88 distinct values   :                     237        0        \n#>      [numeric]           min < med < max:                               :                     (100.0%)   (0.0%)   \n#>                          16.8 < 18.6 < 73                               :                                         \n#>                          IQR (CV) : 2.5 (0.3)                           :                                         \n#>                                                                         : .                                       \n#> ------------------------------------------------------------------------------------------------------------------"},{"path":"mutatok-tablazatok.html","id":"több-numerikus-változó","chapter":"8 Mutatók és táblázatok","heading":"8.3.1.2 Több numerikus változó","text":"","code":"\nnum.valtozok <- survey[, c(\"Wr.Hnd\", \"NW.Hnd\", \"Height\")]\nnum.valtozok %>% psych::describe()\n#>        vars   n   mean   sd median trimmed   mad   min   max range skew\n#> Wr.Hnd    1 236  18.67 1.88   18.5   18.61  1.48  13.0  23.2  10.2 0.18\n#> NW.Hnd    2 236  18.58 1.97   18.5   18.55  1.63  12.5  23.5  11.0 0.02\n#> Height    3 209 172.38 9.85  171.0  172.19 10.08 150.0 200.0  50.0 0.22\n#>        kurtosis   se\n#> Wr.Hnd     0.30 0.12\n#> NW.Hnd     0.44 0.13\n#> Height    -0.44 0.68\nnum.valtozok %>% DescTools::Desc(plotit = F)\n#> ------------------------------------------------------------------------------ \n#> Describe . (data.frame):\n#> \n#> data frame:  237 obs. of  3 variables\n#>      208 complete cases (87.8%)\n#> \n#>   Nr  ColName  Class    NAs         Levels\n#>   1   Wr.Hnd   numeric   1 (0.4%)         \n#>   2   NW.Hnd   numeric   1 (0.4%)         \n#>   3   Height   numeric  28 (11.8%)        \n#> \n#> \n#> ------------------------------------------------------------------------------ \n#> 1 - Wr.Hnd (numeric)\n#> \n#>   length      n    NAs  unique     0s   mean  meanCI'\n#>      237    236      1      60      0  18.67   18.43\n#>           99.6%   0.4%           0.0%          18.91\n#>                                                     \n#>      .05    .10    .25  median    .75    .90     .95\n#>    16.00  16.50  17.50   18.50  19.80  21.15   22.05\n#>                                                     \n#>    range     sd  vcoef     mad    IQR   skew    kurt\n#>    10.20   1.88   0.10    1.48   2.30   0.18    0.30\n#>                                                     \n#> lowest : 13.0 (2), 14.0 (2), 15.0, 15.4, 15.5 (2)\n#> highest: 22.5 (4), 22.8, 23.0 (2), 23.1, 23.2 (3)\n#> \n#> heap(?): remarkable frequency (9.7%) for the mode(s) (= 17.5)\n#> \n#> ' 95%-CI (classic)\n#> \n#> ------------------------------------------------------------------------------ \n#> 2 - NW.Hnd (numeric)\n#> \n#>   length      n    NAs  unique     0s   mean  meanCI'\n#>      237    236      1      68      0  18.58   18.33\n#>           99.6%   0.4%           0.0%          18.83\n#>                                                     \n#>      .05    .10    .25  median    .75    .90     .95\n#>    15.50  16.30  17.50   18.50  19.72  21.00   22.22\n#>                                                     \n#>    range     sd  vcoef     mad    IQR   skew    kurt\n#>    11.00   1.97   0.11    1.63   2.22   0.02    0.44\n#>                                                     \n#> lowest : 12.5, 13.0 (2), 13.3, 13.5, 15.0\n#> highest: 22.7, 23.0, 23.2 (2), 23.3, 23.5\n#> \n#> heap(?): remarkable frequency (8.9%) for the mode(s) (= 18)\n#> \n#> ' 95%-CI (classic)\n#> \n#> ------------------------------------------------------------------------------ \n#> 3 - Height (numeric)\n#> \n#>   length       n     NAs  unique      0s    mean  meanCI'\n#>      237     209      28      67       0  172.38  171.04\n#>            88.2%   11.8%            0.0%          173.72\n#>                                                         \n#>      .05     .10     .25  median     .75     .90     .95\n#>   157.00  160.00  165.00  171.00  180.00  185.42  189.60\n#>                                                         \n#>    range      sd   vcoef     mad     IQR    skew    kurt\n#>    50.00    9.85    0.06   10.08   15.00    0.22   -0.44\n#>                                                         \n#> lowest : 150.0, 152.0, 152.4, 153.5, 154.94 (2)\n#> highest: 191.8, 193.04, 195.0, 196.0, 200.0\n#> \n#> ' 95%-CI (classic)\nnum.valtozok %>% summarytools::descr()\n#> Descriptive Statistics  \n#> num.valtozok  \n#> N: 237  \n#> \n#>                     Height   NW.Hnd   Wr.Hnd\n#> ----------------- -------- -------- --------\n#>              Mean   172.38    18.58    18.67\n#>           Std.Dev     9.85     1.97     1.88\n#>               Min   150.00    12.50    13.00\n#>                Q1   165.00    17.50    17.50\n#>            Median   171.00    18.50    18.50\n#>                Q3   180.00    19.75    19.80\n#>               Max   200.00    23.50    23.20\n#>               MAD    10.08     1.63     1.48\n#>               IQR    15.00     2.22     2.30\n#>                CV     0.06     0.11     0.10\n#>          Skewness     0.22     0.02     0.18\n#>       SE.Skewness     0.17     0.16     0.16\n#>          Kurtosis    -0.44     0.44     0.30\n#>           N.Valid   209.00   236.00   236.00\n#>         Pct.Valid    88.19    99.58    99.58"},{"path":"mutatok-tablazatok.html","id":"táblázatok-1","chapter":"8 Mutatók és táblázatok","heading":"8.3.2 Táblázatok","text":"Egydimenziós táblázatokKétdimenziós táblázatok","code":"\n# faktor\nsurvey$W.Hnd %>%  DescTools::Desc(plotit = F)\n#> ------------------------------------------------------------------------------ \n#> . (factor - dichotomous)\n#> \n#>   length      n    NAs unique\n#>      237    236      1      2\n#>           99.6%   0.4%       \n#> \n#>        freq   perc  lci.95  uci.95'\n#> Left     18   7.6%    4.9%   11.7%\n#> Right   218  92.4%   88.3%   95.1%\n#> \n#> ' 95%-CI (Wilson)\nsurvey$W.Hnd %>%  summarytools::freq()\n#> Frequencies  \n#> survey$W.Hnd  \n#> Type: Factor  \n#> \n#>               Freq   % Valid   % Valid Cum.   % Total   % Total Cum.\n#> ----------- ------ --------- -------------- --------- --------------\n#>        Left     18      7.63           7.63      7.59           7.59\n#>       Right    218     92.37         100.00     91.98          99.58\n#>        <NA>      1                               0.42         100.00\n#>       Total    237    100.00         100.00    100.00         100.00\n# rendezett faktor\nsurvey$Smoke %>%  DescTools::Desc(plotit = F)\n#> ------------------------------------------------------------------------------ \n#> . (ordered, factor)\n#> \n#>   length      n    NAs unique levels  dupes\n#>      237    236      1      4      4      y\n#>           99.6%   0.4%                     \n#> \n#>    level  freq   perc  cumfreq  cumperc\n#> 1  Never   189  80.1%      189    80.1%\n#> 2  Occas    19   8.1%      208    88.1%\n#> 3  Regul    17   7.2%      225    95.3%\n#> 4  Heavy    11   4.7%      236   100.0%\nsurvey$Smoke %>%  summarytools::freq()\n#> Frequencies  \n#> survey$Smoke  \n#> Type: Ordered Factor  \n#> \n#>               Freq   % Valid   % Valid Cum.   % Total   % Total Cum.\n#> ----------- ------ --------- -------------- --------- --------------\n#>       Never    189     80.08          80.08     79.75          79.75\n#>       Occas     19      8.05          88.14      8.02          87.76\n#>       Regul     17      7.20          95.34      7.17          94.94\n#>       Heavy     11      4.66         100.00      4.64          99.58\n#>        <NA>      1                               0.42         100.00\n#>       Total    237    100.00         100.00    100.00         100.00\n# faktor\nlibrary(magrittr)\nsurvey %>%  DescTools::Desc(Sex~W.Hnd, data=., plotit = F)\n#> ------------------------------------------------------------------------------ \n#> Sex ~ W.Hnd (.)\n#> \n#> Summary: \n#> n: 235, rows: 2, columns: 2\n#> \n#> Pearson's Chi-squared test (cont. adj):\n#>   X-squared = 0.24, df = 1, p-value = 0.6\n#> Fisher's exact test p-value = 0.6\n#> McNemar's chi-squared = 82, df = 1, p-value <2e-16\n#> \n#>                     estimate lwr.ci upr.ci'\n#>                                           \n#> odds ratio             0.687  0.252  1.871\n#> rel. risk (col1)       0.706  0.278  1.792\n#> rel. risk (col2)       1.027  0.956  1.103\n#> \n#> \n#> Contingency Coeff.     0.048\n#> Cramer's V             0.048\n#> Kendall Tau-b          -0.048\n#> \n#>                                     \n#>          W.Hnd   Left   Right    Sum\n#> Sex                                 \n#>                                     \n#> Female   freq       7     110    117\n#>          perc    3.0%   46.8%  49.8%\n#>          p.row   6.0%   94.0%      .\n#>          p.col  41.2%   50.5%      .\n#>                                     \n#> Male     freq      10     108    118\n#>          perc    4.3%   46.0%  50.2%\n#>          p.row   8.5%   91.5%      .\n#>          p.col  58.8%   49.5%      .\n#>                                     \n#> Sum      freq      17     218    235\n#>          perc    7.2%   92.8% 100.0%\n#>          p.row      .       .      .\n#>          p.col      .       .      .\n#>                                     \n#> \n#> ----------\n#> ' 95% conf. level\nsurvey %$%  summarytools::ctable(x = Sex, y = W.Hnd)\n#> Cross-Tabulation, Row Proportions  \n#> Sex * W.Hnd  \n#> Data Frame: survey  \n#> \n#> -------- ------- ------------- ------------- ---------- --------------\n#>            W.Hnd          Left         Right       <NA>          Total\n#>      Sex                                                              \n#>   Female            7 (  5.9%)   110 (93.2%)   1 (0.8%)   118 (100.0%)\n#>     Male           10 (  8.5%)   108 (91.5%)   0 (0.0%)   118 (100.0%)\n#>     <NA>            1 (100.0%)     0 ( 0.0%)   0 (0.0%)     1 (100.0%)\n#>    Total           18 (  7.6%)   218 (92.0%)   1 (0.4%)   237 (100.0%)\n#> -------- ------- ------------- ------------- ---------- --------------"},{"path":"mutatok-tablazatok.html","id":"mutatók-csoportokra-1","chapter":"8 Mutatók és táblázatok","heading":"8.3.2.1 Mutatók csoportokra","text":"FeladatokRcmdrMisc - numSummary\njmv - descriptives","code":"\nsurvey$Height %>% psych::describeBy(x = ., g = survey[,c(\"Sex\", \"W.Hnd\")], mat=T)\n#>     item group1 group2 vars  n  mean     sd median trimmed   mad   min max\n#> X11    1 Female   Left    1  6 167.7  4.920  170.0   167.7 2.224 160.0 172\n#> X12    2   Male   Left    1  9 180.5 11.070  180.0   180.5 7.028 165.0 200\n#> X13    3 Female  Right    1 95 165.4  6.063  166.4   165.7 5.337 150.0 178\n#> X14    4   Male  Right    1 97 178.7  8.142  180.0   179.0 7.413 154.9 196\n#>     range    skew kurtosis     se\n#> X11 11.98 -0.5684  -1.7387 2.0085\n#> X12 35.00  0.2830  -1.1371 3.6899\n#> X13 28.00 -0.3992  -0.4297 0.6221\n#> X14 41.06 -0.3472  -0.1779 0.8267\nnum.valtozok %>% psych::describeBy(x = ., g = survey[,c(\"Sex\", \"W.Hnd\")], mat=T)\n#>         item group1 group2 vars   n   mean      sd median trimmed    mad   min\n#> Wr.Hnd1    1 Female   Left    1   7  18.16  1.4478  18.50   18.16 0.7413  15.4\n#> Wr.Hnd2    2   Male   Left    1  10  19.99  1.6455  19.65   19.93 1.3343  17.5\n#> Wr.Hnd3    3 Female  Right    1 110  17.60  1.2353  17.50   17.63 1.1119  13.0\n#> Wr.Hnd4    4   Male  Right    1 107  19.72  1.7658  19.50   19.71 1.4826  14.0\n#> NW.Hnd1    5 Female   Left    2   7  17.94  0.9467  18.00   17.94 0.7413  16.4\n#> NW.Hnd2    6   Male   Left    2  10  19.84  1.5138  19.75   19.93 1.4826  17.0\n#> NW.Hnd3    7 Female  Right    2 110  17.47  1.3714  17.55   17.51 1.0378  12.5\n#> NW.Hnd4    8   Male  Right    2 107  19.70  1.8351  19.50   19.72 1.4826  13.3\n#> Height1    9 Female   Left    3   6 167.67  4.9199 170.00  167.67 2.2239 160.0\n#> Height2   10   Male   Left    3   9 180.54 11.0697 180.00  180.54 7.0275 165.0\n#> Height3   11 Female  Right    3  95 165.41  6.0631 166.40  165.65 5.3374 150.0\n#> Height4   12   Male  Right    3  97 178.67  8.1425 180.00  178.96 7.4130 154.9\n#>           max range     skew kurtosis     se\n#> Wr.Hnd1  20.0  4.60 -0.66791 -0.72047 0.5472\n#> Wr.Hnd2  23.0  5.50  0.29434 -0.95330 0.5204\n#> Wr.Hnd3  20.8  7.80 -0.43157  1.34878 0.1178\n#> Wr.Hnd4  23.2  9.20 -0.06857  0.01661 0.1707\n#> NW.Hnd1  19.5  3.10  0.02948 -0.92181 0.3578\n#> NW.Hnd2  22.0  5.00 -0.32153 -1.02247 0.4787\n#> NW.Hnd3  20.7  8.20 -0.64755  1.83733 0.1308\n#> NW.Hnd4  23.5 10.20 -0.27990  0.67647 0.1774\n#> Height1 172.0 11.98 -0.56840 -1.73871 2.0085\n#> Height2 200.0 35.00  0.28304 -1.13707 3.6899\n#> Height3 178.0 28.00 -0.39916 -0.42966 0.6221\n#> Height4 196.0 41.06 -0.34723 -0.17790 0.8267\nsurvey %>%  DescTools::Desc(Height ~ Sex * W.Hnd, data=., plotit = F)\n#> ------------------------------------------------------------------------------ \n#> Height ~ Sex (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 208 (87.8%), missings: 29 (12.2%), groups: 2\n#> \n#>                       \n#>         Female    Male\n#> mean    165.69  178.83\n#> median  166.75  180.00\n#> sd        6.15    8.38\n#> IQR       7.44   12.21\n#> n          102     106\n#> np      49.04%  50.96%\n#> NAs         16      12\n#> 0s           0       0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 97, df = 1, p-value <2e-16\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 1 NAs (0.422%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Height ~ W.Hnd (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 208 (87.8%), missings: 29 (12.2%), groups: 2\n#> \n#>                       \n#>           Left   Right\n#> mean    175.18  172.11\n#> median  172.00  170.59\n#> sd       10.67    9.78\n#> IQR      11.22   15.00\n#> n           16     192\n#> np       7.69%  92.31%\n#> NAs          2      26\n#> 0s           0       0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 0.89, df = 1, p-value = 0.3\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 1 NAs (0.422%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Height ~ Sex:W.Hnd (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 207 (87.3%), missings: 30 (12.7%), groups: 4\n#> \n#>                                                               \n#>          Female:Left     Male:Left  Female:Right    Male:Right\n#> mean          167.67        180.54        165.41        178.67\n#> median        170.00        180.00        166.40        180.00\n#> sd              4.92         11.07          6.06          8.14\n#> IQR             6.00          7.62          7.47         12.28\n#> n                  6             9            95            97\n#> np             2.90%         4.35%        45.89%        46.86%\n#> NAs                1             1            15            11\n#> 0s                 0             0             0             0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 99, df = 3, p-value <2e-16\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 2 NAs (0.844%).\nsurvey %>%  DescTools::Desc(Height + Age ~ Sex * W.Hnd, data=., plotit = F)\n#> ------------------------------------------------------------------------------ \n#> Height ~ Sex (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 208 (87.8%), missings: 29 (12.2%), groups: 2\n#> \n#>                       \n#>         Female    Male\n#> mean    165.69  178.83\n#> median  166.75  180.00\n#> sd        6.15    8.38\n#> IQR       7.44   12.21\n#> n          102     106\n#> np      49.04%  50.96%\n#> NAs         16      12\n#> 0s           0       0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 97, df = 1, p-value <2e-16\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 1 NAs (0.422%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Height ~ W.Hnd (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 208 (87.8%), missings: 29 (12.2%), groups: 2\n#> \n#>                       \n#>           Left   Right\n#> mean    175.18  172.11\n#> median  172.00  170.59\n#> sd       10.67    9.78\n#> IQR      11.22   15.00\n#> n           16     192\n#> np       7.69%  92.31%\n#> NAs          2      26\n#> 0s           0       0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 0.89, df = 1, p-value = 0.3\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 1 NAs (0.422%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Height ~ Sex:W.Hnd (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 207 (87.3%), missings: 30 (12.7%), groups: 4\n#> \n#>                                                               \n#>          Female:Left     Male:Left  Female:Right    Male:Right\n#> mean          167.67        180.54        165.41        178.67\n#> median        170.00        180.00        166.40        180.00\n#> sd              4.92         11.07          6.06          8.14\n#> IQR             6.00          7.62          7.47         12.28\n#> n                  6             9            95            97\n#> np             2.90%         4.35%        45.89%        46.86%\n#> NAs                1             1            15            11\n#> 0s                 0             0             0             0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 99, df = 3, p-value <2e-16\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 2 NAs (0.844%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Age ~ Sex (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 236 (99.6%), missings: 1 (0.4%), groups: 2\n#> \n#>                       \n#>         Female    Male\n#> mean     20.41   20.33\n#> median   18.42   18.88\n#> sd        6.91    6.07\n#> IQR       2.48    2.37\n#> n          118     118\n#> np      50.00%  50.00%\n#> NAs          0       0\n#> 0s           0       0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 4.3, df = 1, p-value = 0.04\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 1 NAs (0.422%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Age ~ W.Hnd (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 236 (99.6%), missings: 1 (0.4%), groups: 2\n#> \n#>                       \n#>           Left   Right\n#> mean     18.63   20.53\n#> median   18.50   18.58\n#> sd        1.29    6.72\n#> IQR       1.52    2.62\n#> n           18     218\n#> np       7.63%  92.37%\n#> NAs          0       0\n#> 0s           0       0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 0.72, df = 1, p-value = 0.4\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 1 NAs (0.422%).\n#> \n#> ------------------------------------------------------------------------------ \n#> Age ~ Sex:W.Hnd (.)\n#> \n#> Summary: \n#> n pairs: 237, valid: 235 (99.2%), missings: 2 (0.8%), groups: 4\n#> \n#>                                                               \n#>          Female:Left     Male:Left  Female:Right    Male:Right\n#> mean           18.36         18.53         20.57         20.50\n#> median         18.50         18.46         18.42         18.92\n#> sd              1.02          1.22          7.12          6.31\n#> IQR             1.63          1.08          2.67          2.42\n#> n                  7            10           110           108\n#> np             2.98%         4.26%        46.81%        45.96%\n#> NAs                0             0             0             0\n#> 0s                 0             0             0             0\n#> \n#> Kruskal-Wallis rank sum test:\n#>   Kruskal-Wallis chi-squared = 5.7, df = 3, p-value = 0.1\n#> \n#> \n#> Warning:\n#>   Grouping variable contains 2 NAs (0.844%).\nnum.valtozok %>% summarytools::stby(\n  data = .,\n  INDICES = survey[, c(\"W.Hnd\", \"Sex\")], \n  FUN = summarytools::descr, \n  stats = \"common\" \n)\n#> Descriptive Statistics  \n#> num.valtozok  \n#> N: 7  \n#> \n#>                   Height   NW.Hnd   Wr.Hnd\n#> --------------- -------- -------- --------\n#>            Mean   167.67    17.94    18.16\n#>         Std.Dev     4.92     0.95     1.45\n#>             Min   160.02    16.40    15.40\n#>          Median   170.00    18.00    18.50\n#>             Max   172.00    19.50    20.00\n#>         N.Valid     6.00     7.00     7.00\n#>       Pct.Valid    85.71   100.00   100.00\n#> \n#> N: 110  \n#> \n#>                   Height   NW.Hnd   Wr.Hnd\n#> --------------- -------- -------- --------\n#>            Mean   165.41    17.47    17.60\n#>         Std.Dev     6.06     1.37     1.24\n#>             Min   150.00    12.50    13.00\n#>          Median   166.40    17.55    17.50\n#>             Max   178.00    20.70    20.80\n#>         N.Valid    95.00   110.00   110.00\n#>       Pct.Valid    86.36   100.00   100.00\n#> \n#> N: 10  \n#> \n#>                   Height   NW.Hnd   Wr.Hnd\n#> --------------- -------- -------- --------\n#>            Mean   180.54    19.84    19.99\n#>         Std.Dev    11.07     1.51     1.65\n#>             Min   165.00    17.00    17.50\n#>          Median   180.00    19.75    19.65\n#>             Max   200.00    22.00    23.00\n#>         N.Valid     9.00    10.00    10.00\n#>       Pct.Valid    90.00   100.00   100.00\n#> \n#> N: 108  \n#> \n#>                   Height   NW.Hnd   Wr.Hnd\n#> --------------- -------- -------- --------\n#>            Mean   178.67    19.70    19.72\n#>         Std.Dev     8.14     1.84     1.77\n#>             Min   154.94    13.30    14.00\n#>          Median   180.00    19.50    19.50\n#>             Max   196.00    23.50    23.20\n#>         N.Valid    97.00   107.00   107.00\n#>       Pct.Valid    89.81    99.07    99.07"},{"path":"grafika-az-r-ben.html","id":"grafika-az-r-ben","chapter":"9 Grafika az R-ben","heading":"9 Grafika az R-ben","text":"Ebben fejezetben áttekintjük:az R grafikus rendszereia hagyományos grafika alapfogalmaimagasszintű és alacsonyszintű rajzfüggvények hagyományos grafikábana ggplot2 rendszer alapelveábrák létrehozása ggplot2-benábrák mentése háttértárraAz R-ben több grafikus rendszer közül választhatunk, amikor az ábráink rajzolásához kezdünk. hagyományos grafikus rendszer mellett elérhető az ún. grid grafikus rendszer, trellis/lattice rendszer és ggplot2 rendszer . Az egyes rendszerek eltérő megközelítést használnak az ábrák létrehozásához, és természetesen különböző csomagok különböző függvényeit használják.hagyományos grafikus rendszer az S nyelv grafikus rendszerének implementációja. magasszintű grafikus függvények komplett ábrák létrehozásért felelősek, az alacsony szintű függvényekkel pedig kisebb-nagyobb grafikus elemeket helyezhetünk meglévő ábrára. Mindig “rárajzolunk” meglévő elemekre, későbbi módosításra vagy törlésre nincs lehetőségünk.hagyományos grafikus rendszer az S nyelv grafikus rendszerének implementációja. magasszintű grafikus függvények komplett ábrák létrehozásért felelősek, az alacsony szintű függvényekkel pedig kisebb-nagyobb grafikus elemeket helyezhetünk meglévő ábrára. Mindig “rárajzolunk” meglévő elemekre, későbbi módosításra vagy törlésre nincs lehetőségünk.grid csomagból elérhető grafikus rendszer grafikus primitívek rendkívül gazdag tárháza. Segítségükkel grafikus objektumokat építhetünk, amelyek az ábrától független reprezentációval rendelkeznek, így azok később módosíthatók. saját koorditáta-rendszerrel rendelkező viewport-ok rendszere tetszőlegesen bonyolult ábrák létrehozását segíti. grid rendszer maga nem tartalmaz statisztikai rajzfüggvényeket, de számos, grid csomagra épülő rendszer igen (pl. lattice és ggplot2).grid csomagból elérhető grafikus rendszer grafikus primitívek rendkívül gazdag tárháza. Segítségükkel grafikus objektumokat építhetünk, amelyek az ábrától független reprezentációval rendelkeznek, így azok később módosíthatók. saját koorditáta-rendszerrel rendelkező viewport-ok rendszere tetszőlegesen bonyolult ábrák létrehozását segíti. grid rendszer maga nem tartalmaz statisztikai rajzfüggvényeket, de számos, grid csomagra épülő rendszer igen (pl. lattice és ggplot2).lattice csomag grafikus rendszere az ún. trellis grafikus rendszer megvalósítása R-ben. hagyományos grafikus rendszerhez képest rendkívül sok fejlesztést tartalmaz. grid grafikus rendszerre épül, így hordozza annak rugalmasságát.lattice csomag grafikus rendszere az ún. trellis grafikus rendszer megvalósítása R-ben. hagyományos grafikus rendszerhez képest rendkívül sok fejlesztést tartalmaz. grid grafikus rendszerre épül, így hordozza annak rugalmasságát.ggplot2 csomag grafikus rendszere kísérletet tesz arra, hogy hagyományos és lattice grafikus rendszer előnyös tulajdonságait ötvözze. Szintén grid rendszerre épül. ggplot2 csomag Tidyverse R része, így modern R grafikus megjelenítőjének tekinthetjük. többi felsorolt grafikus rendszer az Alap R része.ggplot2 csomag grafikus rendszere kísérletet tesz arra, hogy hagyományos és lattice grafikus rendszer előnyös tulajdonságait ötvözze. Szintén grid rendszerre épül. ggplot2 csomag Tidyverse R része, így modern R grafikus megjelenítőjének tekinthetjük. többi felsorolt grafikus rendszer az Alap R része.Jelen könyvben csak ggplot2 grafikus rendszert ismertetjük.","code":""},{"path":"grafika-az-r-ben.html","id":"a-modern-grafika-ggplot2","chapter":"9 Grafika az R-ben","heading":"9.1 A modern grafika (ggplot2)","text":"ggplot2 grafika teljesen más megközelítést használ az ábrák létrehozásához, mint az Alap R garfikus rendszerei. Nevét Leland Wilkinson Grammar Graphics könyve után kapta,amely grafika általános formális és strukturált leírására tett kísérletet. ggplot2 grafika Hadley Wickham által készített ggplot2 csomaggal érhető el. ggplot2 ábrák létrehozása némi tanulás után átlátható és következetes lesz, maguk az elkészült grafikák gyönyörűek és alkalmasak azonnali publikására.Egy ggplot2 grafika három összetevőn alapul:adat: megjelenítés egy adattáblában alapul (tibble vagy data frame). Az adatoszlopok ennek megfelelően többnyire numerikus vektorok vagy faktorok.megjelenés: Az ábrán megjelenő elemek lehetséges paraméterei, például pont esetén az x és y koordináta, szín, méret vagy alak, oszlopok esetén például magasság és kitöltő szín.ábra elem: Az ábrán megjelenő elemek, például pont, oszlop vagy vonal. Ezek határozzák meg végső soron az ábra típusát, így létrehozhatunk például pontdiagramot, oszlopdiagramot vagy hisztogramot, és vonal diagramot, de ezekből egy ábrán akár többet felhasználhatunk.Nézzünk egy egyszerű példát! Hozzunk létre egy pontdiagramot következő paranccsal:legtöbb ggplot2 ábra létrehozása ggplot() függvénnyel indul, ahol data= argumentum az adat részt tartalmazza, mapping= argumentum pedig megjelenés paramétereit sorolja fel. Ehhez az aes() függvénnyt használjuk, amely adatoszlopok és megjelenéshez tartozó paraméterek közötti kapcsolatot megadja egyben. Az ábra elemeit + operátorral adjuk hozzá ggplot() függvényhez, ez pontelemeket létrehozó geom_point().fenti parancs adat része egy 3 sorból és 4 oszlopból álló adattábla, amely egy karakteres (csoport) és három numerikus oszlopot (pont.1, pont.2, pont.3) tartalmaz.Az ábra létrehozásához ggplot() függvényt és pontelemek hozzáadásához geom_point() függvényt használjuk, az utóbbiban nincs szükség argzmentumok megadására. ggplot() első argumentuma data=d.tbl, amely az adatösszetevőt tisztázza, mapping= argumentumban az aes() függvényben az x és y megjelenítési paraméterekről gondoskodunk, pont.1 és pont.2 oszlopok megadásával. Az x és y megjelenési paraméterek természetesen hozzáadott pontok x és y koordinátáira vonatkoznak.Természetesen pontelemek helyett használhatunk oszlopelemeket geom_col() segítségével, itt az x és y megjelenítési paraméterek az oszlop x koordinátáját és az oszlop magasságát jelentik.Ha geom_line() ábraelemeket adjuk az ábrához, akkor az x és y paraméterek vonalak létrehozásához használt pontok x és y koordinátái.Egyetlen ábrán akár mindhárom ábraelem (pont, oszlop, vonal) megjelenhet:Az eddigiek alapján világos, hogy megjelenési paraméterekMás megjelenési paraméterekre lehetünk hatással. Ha szín és pontméret jellemzőket akarjuk állítani, akkor az aes() függvényben colour= és size= argumentumoknak az adattábla egy-egy oszlopát kell megadnunk. Ilyen esetkben jelmagyarázat megjelenik, amelynek az alapértelmezett pozícióját expliciten kiírtuk: theme(legend.position = \"right\").Oszlopdiagram esetén használhatjuk fill= vagy az alpha= argumentumokat, amelyekkel az egyes oszlopok kitöltőszínét és átlátszóságát tudjuk beállítani:Néhány ábraelem esetében azonban nem ilyen egyértelmű az aes() függvényben megadott oszlopvektorok és ábraelem megjelenési paramétere közötti összefüggés.Tekintsük például dobozdiagramot, amelyben fenti táblázat szerint geom_boxplot() ábraelem ígényli az˛x, lower, middle, upper, ymax, ymin megjelenési paraméterek beállítását. Azonban lenti árákat sokkal egyszerűbb aes() paraméterezéssel hoztuk létre, szó sincs benne fent felsoroltak megadásáról.kötelező megjelenési paramétereket geom_boxlot() által meghívott stat_boxplot() függvény biztosítja, így nekünk ezekről nem kell gondoskodni, elegendő egyetlen numerikus vektort (y=user_score) vagy egy kategorikus és egy numerikus vektort (x=rating, y=user_score) megadni az aes() függvényben.Léteznek tehát olyan grafikus elemek, amelyek változtatás nélkül képesek bemenő adatok alapján megjelenítési paramétereket beállítani, és léteznek olyanok , amelyek bemenő adatokat áttranszformálják egy köztes adattáblába, és megjelnési paraméterek konkrét értékét innen veszik. következő táblázat ezeket statisztikai transzformációkat foglalja össze, csak azokat az ábraelemeket soroljuk fel, ahol történik transzformáció:következő példákhoz következő csomagok betöltésére van szükség:","code":"\nggplot(data=d.tbl, mapping=aes(x=pont.1, y=pont.2)) + geom_point()\nlibrary(tibble)\nd.tbl <- tribble(\n  ~csoport, ~pont.1, ~pont.2, ~pont.3,\n  \"AA\", 15, 42, 12, \n  \"BB\", 20, 28, 18,\n  \"CC\", 35, 12, 21\n)\nggplot(data=d.tbl, mapping=aes(x=pont.1, y=pont.2)) + geom_col()\nggplot(data=d.tbl, mapping=aes(x=pont.1, y=pont.2)) + geom_line()\nggplot(data=d.tbl, mapping=aes(x=pont.1, y=pont.2)) + geom_point() + geom_col() + geom_line()\nlibrary(ggpubr)\n# Load data\ndata(\"ToothGrowth\")\ndf <- ToothGrowth\n\n# Basic plot with summary statistics: mean_se\n# +++++++++++++++++++++++++++\n# Change point shapes by groups: \"dose\"\nggstripchart(df, x = \"dose\", y = \"len\",\n   shape = \"dose\", size = 3,\n   add = \"mean_se\")\n\n# Use mean_sd\n# Change error.plot to \"crossbar\"\nggstripchart(df, x = \"dose\", y = \"len\",\n   shape = \"dose\", size = 3,\n   add = \"mean_sd\", add.params = list(width = 0.5),\n   error.plot = \"crossbar\")\n\n\n\n# Add summary statistics\n# ++++++++++++++++++++++++++\n\n# Add box plot\nggstripchart(df, x = \"dose\", y = \"len\",\n shape = \"dose\", add = \"boxplot\")\n\n# Add violin + mean_sd\nggstripchart(df, x = \"dose\", y = \"len\",\n shape = \"dose\", add = c(\"violin\", \"mean_sd\"))\n\n\n# Change colors\n# +++++++++++++++++++++++++++\n# Change colors by groups: dose\n# Use custom color palette\n ggstripchart(df, \"dose\", \"len\",  shape = \"dose\",\n   color = \"dose\", palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n   add = \"mean_sd\")\n\n\n\n# Plot with multiple groups\n# +++++++++++++++++++++\n# Change shape and color by a second group : \"supp\"\nggstripchart(df, \"dose\", \"len\", shape = \"supp\",\n  color = \"supp\", palette = c(\"#00AFBB\", \"#E7B800\"))\n\n# Adjust point position\nggstripchart(df, \"dose\", \"len\", shape = \"supp\",\n  color = \"supp\", palette = c(\"#00AFBB\", \"#E7B800\"),\n  position = position_dodge(0.8) )\n\n# You can also use position_jitterdodge()\n# but fill aesthetic is required\nggstripchart(df, \"dose\", \"len\",  shape = \"supp\",\n   color = \"supp\", palette = c(\"#00AFBB\", \"#E7B800\"),\n   position = position_jitterdodge() )\n\n# Add boxplot\nggstripchart(df, \"dose\", \"len\", shape = \"supp\",\n color = \"supp\", palette = c(\"#00AFBB\", \"#E7B800\"),\n add = \"boxplot\", add.params = list(color = \"black\") )\nlibrary(ggplot2)\nlibrary(gridExtra)\np1 <- ggplot(d.tbl, aes(x=pont.1, y=pont.2, colour=csoport)) + geom_point() + theme(legend.position = \"right\")\np2 <- ggplot(d.tbl, aes(x=pont.1, y=pont.2, colour=csoport, size=pont.3)) + geom_point() + theme(legend.position = \"right\")\ngrid.arrange(p1, p2, ncol=2)\np1 <- ggplot(d.tbl, aes(x=csoport, y=pont.2, fill=csoport)) + geom_col()\np2 <- ggplot(d.tbl, aes(x=csoport, y=pont.2, fill=csoport, alpha=pont.3)) + geom_col()\ngrid.arrange(p1, p2, ncol=2)\ndata(survey, package = \"MASS\")\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/metacritic_games.csv\"\n\nd.tbl <- read_delim(file = data.file, delim = \",\")\nd.tbl <- d.tbl %>% select(game, platform, genre, rating, metascore, user_score)\nd.tbl\n#> # A tibble: 5,699 × 6\n#>    game                                    platform genre rating metas…¹ user_…²\n#>    <chr>                                   <chr>    <chr> <chr>    <dbl>   <dbl>\n#>  1 Portal 2                                PC       Acti… E10+        95      90\n#>  2 The Elder Scrolls V: Skyrim             PC       Role… M           94      82\n#>  3 The Legend of Zelda: Ocarina of Time 3D 3DS      Misc… E10+        94      90\n#>  4 Batman: Arkham City                     PC       Acti… T           91      87\n#>  5 Super Mario 3D Land                     3DS      Acti… E           90      84\n#>  6 Deus Ex: Human Revolution               PC       Acti… M           90      85\n#>  7 Pushmo                                  3DS      Misc… E           90      83\n#>  8 Total War: Shogun 2                     PC       Stra… T           90      84\n#>  9 FIFA Soccer 12                          PC       Spor… E           89      71\n#> 10 Battlefield 3                           PC       Acti… M           89      76\n#> # … with 5,689 more rows, and abbreviated variable names ¹​metascore,\n#> #   ²​user_score\n\np1 <- ggplot(d.tbl, aes(y=user_score)) + geom_boxplot() \np2 <- ggplot(na.omit(d.tbl), aes(x=rating, y=user_score)) + geom_boxplot()\np3 <- ggplot(na.omit(d.tbl), aes(x=rating, y=user_score, fill=platform)) + geom_boxplot(outlier.shape = NA) + theme(legend.position = \"top\")\ngrid.arrange(p1, p2, p3, ncol=3)\n# egyezes <- d.tbl$platform\n# tbl <- data.frame(egyezes=egyezes)\n# ggplot(tbl, aes(x=egyezes, group=1)) + geom_bar(aes(y = ..count..)) +\n#   geom_text(aes( label = scales::percent(..prop..), y= ..prop.. ), stat= \"count\",  vjust = -.5) +\n#   scale_y_continuous(labels = scales::percent) +\n#   coord_cartesian(ylim = c(0, 1101)) + labs(x=\"Egyező gének száma\", y=\"Előfordulás\")\n# \n# \n# ggplot(d.tbl, aes(x=factor(platform), y=user_score)) + geom_boxplot() +\n#   geom_text(aes(label = scales::percent(..lower..)), stat= \"boxplot\",  vjust = -.5) \n\nlibrary(\"ggpubr\")\nlibrary(ggthemes)\n# Load data\ndata(\"mtcars\")\ndf <- mtcars\ndf$cyl <- as.factor(df$cyl)\nhead(df[, c(\"wt\", \"mpg\", \"cyl\")], 3)\n#>                  wt  mpg cyl\n#> Mazda RX4     2.620 21.0   6\n#> Mazda RX4 Wag 2.875 21.0   6\n#> Datsun 710    2.320 22.8   4\n\n\n\n\n\n\n# +++++++++++++++++++++++++++++++\n\ndf <- data.frame(\n group = c(\"Male\", \"Female\", \"Child\"),\n  value = c(25, 25, 50))\n\nhead(df)\n#>    group value\n#> 1   Male    25\n#> 2 Female    25\n#> 3  Child    50\n\n\n# Basic pie charts\n# ++++++++++++++++++++++++++++++++\n\nggpie(df, \"value\", label = \"group\")\n\n\n# Change color\n# ++++++++++++++++++++++++++++++++\n\n# Change fill color by group\n# set line color to white\n# Use custom color palette\n ggpie(df, \"value\", label = \"group\",\n      fill = \"group\", color = \"white\",\n       palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\") )\n\n\n# Change label\n# ++++++++++++++++++++++++++++++++\n\n# Show group names and value as labels\nlabs <- paste0(df$group, \" (\", df$value, \"%)\")\nggpie(df, \"value\", label = labs,\n   fill = \"group\", color = \"white\",\n   palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"))\n\n# Change the position and font color of labels\nggpie(df, \"value\", label = labs,\n   lab.pos = \"in\", lab.font = \"white\",\n   fill = \"group\", color = \"white\",\n   palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"))\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(ggthemes)\nlibrary(RColorBrewer)"},{"path":"grafika-az-r-ben.html","id":"dobozdiagram","chapter":"9 Grafika az R-ben","heading":"9.1.1 Dobozdiagram","text":"feladat. Hisztogram.\nRajzoljunk hisztogramot MASS csomag survey adattáblájának Height oszlopára! Vessük össze normális eloszlás sűrűségfüggvényével !","code":"\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/metacritic_games.csv\"\n\nd.tbl <- read_delim(file = data.file, delim = \",\")\nd.tbl <- d.tbl %>% select(game, platform, genre, rating, metascore, user_score)\nd.tbl\n#> # A tibble: 5,699 × 6\n#>    game                                    platform genre rating metas…¹ user_…²\n#>    <chr>                                   <chr>    <chr> <chr>    <dbl>   <dbl>\n#>  1 Portal 2                                PC       Acti… E10+        95      90\n#>  2 The Elder Scrolls V: Skyrim             PC       Role… M           94      82\n#>  3 The Legend of Zelda: Ocarina of Time 3D 3DS      Misc… E10+        94      90\n#>  4 Batman: Arkham City                     PC       Acti… T           91      87\n#>  5 Super Mario 3D Land                     3DS      Acti… E           90      84\n#>  6 Deus Ex: Human Revolution               PC       Acti… M           90      85\n#>  7 Pushmo                                  3DS      Misc… E           90      83\n#>  8 Total War: Shogun 2                     PC       Stra… T           90      84\n#>  9 FIFA Soccer 12                          PC       Spor… E           89      71\n#> 10 Battlefield 3                           PC       Acti… M           89      76\n#> # … with 5,689 more rows, and abbreviated variable names ¹​metascore,\n#> #   ²​user_score\n\np1 <- ggplot(d.tbl, aes(x=platform, y=user_score)) + geom_boxplot()\np2 <- ggplot(d.tbl, aes(x=platform, y=user_score, fill=platform)) + geom_boxplot() + theme(legend.position = \"none\")\np3 <- ggplot(na.omit(d.tbl), aes(x=platform, y=user_score, fill=rating)) + geom_boxplot(outlier.size = 0) + theme(legend.position = \"top\")\ngrid.arrange(p1, p2, p3, ncol=3)\nlibrary(gcookbook)  # Load gcookbook for the pg_mean data set\nggplot(pg_mean, aes(x = group, y = weight)) +\n  geom_col()\ndata.file <- \"https://github.com/abarik/rdata/raw/master/r_alapok/metacritic_games.csv\"\n\nd.tbl <- read_delim(file = data.file, delim = \",\")\nd.tbl <- d.tbl %>% select(game, platform, genre, metascore, user_score)\nd.tbl\n#> # A tibble: 5,699 × 5\n#>    game                                    platform genre        metas…¹ user_…²\n#>    <chr>                                   <chr>    <chr>          <dbl>   <dbl>\n#>  1 Portal 2                                PC       Action            95      90\n#>  2 The Elder Scrolls V: Skyrim             PC       Role-Playing      94      82\n#>  3 The Legend of Zelda: Ocarina of Time 3D 3DS      Miscellaneo…      94      90\n#>  4 Batman: Arkham City                     PC       Action Adve…      91      87\n#>  5 Super Mario 3D Land                     3DS      Action            90      84\n#>  6 Deus Ex: Human Revolution               PC       Action            90      85\n#>  7 Pushmo                                  3DS      Miscellaneo…      90      83\n#>  8 Total War: Shogun 2                     PC       Strategy          90      84\n#>  9 FIFA Soccer 12                          PC       Sports            89      71\n#> 10 Battlefield 3                           PC       Action            89      76\n#> # … with 5,689 more rows, and abbreviated variable names ¹​metascore,\n#> #   ²​user_score\n\n\nggplot(data=d.tbl, aes(x=1, y=user_score)) + geom_point()\nggplot(data=d.tbl, aes(x=1, y=user_score)) + geom_jitter() \n\n\nggplot(data=d.tbl, aes(x=metascore, y=user_score)) + geom_point()\nggplot(data=d.tbl, aes(x=platform, y=user_score)) + geom_jitter() \nggplot(data=d.tbl, aes(x=platform, y=user_score)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.8, col=\"red\") \nlibrary(fivethirtyeight)\nggplot(hate_crimes, aes(x = share_vote_trump, y = hate_crimes_per_100k_splc)) +\n  geom_text(aes(label = state_abbrev)) +\n  geom_smooth(se = FALSE, method = \"lm\") +\n  labs(x = \"Proportion of votes for Donald Trump\",\n       y = \"Hate crimes per 100k during Nov 9-18, 2016 (SPLC)\",\n       title = \"Relationship between Trump support & hate crimes\")"},{"path":"grafika-az-r-ben.html","id":"hisztogram-rajzolása","chapter":"9 Grafika az R-ben","heading":"9.1.2 Hisztogram rajzolása","text":"","code":"\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - alapértelmezett hisztogram \np1 <- ggplot(data=survey, aes(x=Height)) + geom_histogram()\n\n# p2 - hisztogram: binwidth=2\np2 <- ggplot(data=survey, aes(x=Height)) + geom_histogram(binwidth=2)\n\n# p3 - hisztogram: binwidth=4 és színek beállítása\np3 <- ggplot(data=survey, aes(x=Height)) + \n        geom_histogram( binwidth=4, colour = \"blue\", fill = \"white\")\n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)"},{"path":"grafika-az-r-ben.html","id":"gyakorisági-poligon-simított-hisztogram-és-összevetés-a-normális-eloszlás-sűrűségfüggvényével","chapter":"9 Grafika az R-ben","heading":"9.1.3 Gyakorisági poligon, simított hisztogram és összevetés a normális eloszlás sűrűségfüggvényével","text":"feladat. Hisztogram csoportokra.\nRajzoljunk hisztogramot MASS csomag survey adattáblájának Height oszlopára az Exer különböző csoportjaiban!","code":"\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - hisztogram és gyakorisági poligon\np1 <- ggplot(data=survey, aes(x=Height)) + \n        geom_histogram(colour = \"blue\", fill = \"white\", binwidth=4) + \n        geom_freqpoly(binwidth = 4, size=1, colour=\"blue\")\n\n# p2 - hisztogram és a normális eloszlás sűrűségfüggvénye\np2 <- ggplot(data=survey, aes(x=Height)) + \n        geom_histogram(aes(y = ..density..), colour=\"blue\", fill=\"white\", binwidth=4) + \n        stat_function(fun=dnorm, args = list(mean=mean(survey$Height, na.rm=T),\n                                             sd=sd(survey$Height, na.rm = T)), \n                      colour=\"red\", size=1)\n\n# p3 - simított hisztogram és a normális eloszlás sűrűségfüggvénye\np3 <- ggplot(data=survey, aes(x=Height)) + \n        geom_density(colour=\"blue\") + \n        stat_function(fun=dnorm, args = list(mean=mean(survey$Height, na.rm=T),\n                                             sd=sd(survey$Height, na.rm = T)), \n                      colour=\"red\", size=1)\n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)"},{"path":"grafika-az-r-ben.html","id":"hisztogram-csoportokra","chapter":"9 Grafika az R-ben","heading":"9.1.4 Hisztogram csoportokra","text":"","code":"\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - hisztogramok egymás alá\np1 <- ggplot(data=survey[!is.na(survey$Exer),], aes(x=Height)) + \n        geom_histogram(colour = \"blue\", fill = \"white\", binwidth=4) + \n        facet_wrap(~ Exer, nrow = 3)\n\n# p2 - hisztogramok táblázatszerűen\np2 <- ggplot(data=survey[!is.na(survey$Exer),], aes(x=Height)) + \n        geom_histogram(colour = \"blue\", fill = \"white\", binwidth=4) + \n        facet_wrap(~ Exer, nrow = 2)\n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, ncol=2)"},{"path":"grafika-az-r-ben.html","id":"gyakorisági-poligon-és-simított-hisztogram-csoportokra-de-egy-ábrán","chapter":"9 Grafika az R-ben","heading":"9.1.5 Gyakorisági poligon és simított hisztogram csoportokra, de egy ábrán","text":"feladat. Dobozdiagram.\nRajzoljunk hisztogramot MASS csomag survey adattáblájának Pulse oszlopára Smoke egyes csoportjaiban, valamint vegyük figyelembe Sex változó értékeit !feladat. Átlagok ábrázolása.\nRajzoljunk hisztogramot MASS csomag survey adattáblájának Height oszlopára!","code":"\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - gyakorisági poligonok egy ábrán\np1 <- ggplot(data=survey[!is.na(survey$Exer),], aes(x=Height, y=..density.., colour = Exer)) + \n        geom_freqpoly(binwidth = 4, size=0.7) + theme(legend.position=\"top\")\n\n# p2 - simított hisztogramok egy ábrán\np2 <- ggplot(data=survey, aes(x=Height, colour = Exer)) + geom_density(size=0.7) +\n        theme(legend.position=\"top\")\n\n# p3 - simított hisztogram kitöltéssel egy ábrán\np3 <- ggplot(data=survey, aes(x=Height, fill = Exer)) + geom_density(alpha=0.2, size=0.7) + \n        theme(legend.position=\"top\")\n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - dobozdiagram a Smoke csoportjaira\np1 <- ggplot(data=survey[!is.na(survey$Smoke),], aes(x=Smoke, y=Pulse, fill=Smoke)) + \n        geom_boxplot() + theme(legend.position=\"top\")\n\n# p2 - dobozdiagram a Smoke csoportjaira a Sex figyelembevételével\np2 <- ggplot(data=survey[!is.na(survey$Smoke) & !is.na(survey$Sex),], \n             aes(x=Smoke, y=Pulse, fill=Smoke)) + \n        geom_boxplot() + guides(fill=FALSE) + facet_wrap(~ Sex, nrow = 1)\n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, ncol=2)"},{"path":"grafika-az-r-ben.html","id":"átlagok-egy-faktor-esetén","chapter":"9 Grafika az R-ben","heading":"9.1.6 Átlagok egy faktor esetén","text":"","code":"\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - oszlopdiagram az átlagokra 95%-os konfidencia intervallummal I.\np1 <- ggplot(data=survey[!is.na(survey$Smoke),], aes(x=Smoke, y=Pulse)) + \n        stat_summary(fun.y=mean, geom=\"bar\", fill=\"white\", colour=\"black\") + \n        stat_summary(fun.data=mean_cl_normal, geom=\"pointrange\") +\n        coord_cartesian(ylim = c(0, 100)) \n\n# p2 - oszlopdiagram az átlagokra 95%-os konfidencia intervallummal II.\np2 <- ggplot(data=survey[!is.na(survey$Smoke),], aes(x=Smoke, y=Pulse)) + \n        stat_summary(fun.y=mean, geom=\"bar\", fill=\"#95b0ff\", colour=\"black\") + \n        stat_summary(fun.data=mean_cl_normal, geom=\"errorbar\", width=0.2) +\n        coord_cartesian(ylim = c(0, 100)) \n\n# p3 - vonaldiagram az átlagokra 95%-os konfidencia intervallummal\np3 <- ggplot(data=survey[!is.na(survey$Smoke),], aes(x=Smoke, y=Pulse)) + \n        stat_summary(fun.y=mean, geom=\"point\") + \n        stat_summary(fun.y=mean, geom=\"line\", aes(group=1), colour=\"blue\", linetype=\"dashed\") + \n        stat_summary(fun.data=mean_cl_normal, geom=\"errorbar\", width=0.2) +\n        coord_cartesian(ylim = c(0, 100)) \n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)"},{"path":"grafika-az-r-ben.html","id":"átlagok-két-faktor-esetén","chapter":"9 Grafika az R-ben","heading":"9.1.7 Átlagok két faktor esetén","text":"feladat. Kétdimenziós pontdiagram.\nRajzoljunk kétdimenziós pontdiagramot MASS csomag survey adattáblája alapján Height és NW.Hnd változók kapcsolatára. Vegyük figyelembe Sex változót !feladat. Egydimenziós pontdiagram.\nRajzoljunk egydimenziós pontdiagramot MASS csomag survey adattáblája alapján Height változóra. Vegyük figyelembe Sex változót !","code":"\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - oszlopdiagram az átlagokra 95%-os konfidencia intervallummal I.\np1 <- ggplot(data=survey[!is.na(survey$Exer) & !is.na(survey$Sex),], \n             aes(x=Exer, y=Pulse, fill=Sex)) + \n        stat_summary(fun.y=mean, geom=\"bar\", position=\"dodge\", colour=\"black\") + \n        stat_summary(fun.data=mean_cl_normal, geom=\"errorbar\", \n                     position=position_dodge(width=0.90), width=0.2) +\n        scale_fill_manual(\"Sex\",values = c(\"Female\"=\"#bccdff\", \"Male\"=\"#81a1ff\")) + \n        coord_cartesian(ylim = c(0, 100)) + theme_bw() + \n        theme(legend.justification=c(1,0),legend.position=c(1,0),  \n              legend.direction=\"horizontal\")  \n\n# p2 - oszlopdiagram az átlagokra 95%-os konfidencia intervallummal II.\np2 <- ggplot(data=survey[!is.na(survey$Exer) & !is.na(survey$Sex),], \n             aes(x=Exer, y=Pulse)) + \n        stat_summary(fun.y=mean, geom=\"bar\", fill=\"#95b0ff\", colour=\"black\") + \n        stat_summary(fun.data=mean_cl_normal, geom=\"errorbar\", width=0.2) +\n        coord_cartesian(ylim = c(0, 100)) +\n        facet_wrap(~ Sex, nrow = 1)\n\n# p3 - vonaldiagram az átlagokra 95%-os konfidencia intervallummal\np3 <- ggplot(data=survey[!is.na(survey$Exer) & !is.na(survey$Sex),], \n             aes(x=Exer, y=Pulse, colour=Sex)) + \n        stat_summary(fun.y=mean, geom=\"point\", size=3, shape=21, fill=\"white\") + \n        stat_summary(fun.data=mean_cl_normal, geom=\"line\", size=1, aes(group=Sex)) +\n        stat_summary(fun.data=mean_cl_normal, geom=\"errorbar\", size=1, width=0.1) +\n        coord_cartesian(ylim = c(0, 100)) + \n        theme_bw() + theme(legend.justification=c(1,0),legend.position=c(1,0))  \n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - kétdimenziós pontdiagram\np1 <- ggplot(data=survey, aes(x=Height, y=NW.Hnd)) + geom_point()\n\n# p2 - kétdimenziós pontdiagram regressziós egyenessel\np2 <- ggplot(data=survey, aes(x=Height, y=NW.Hnd)) + \n        geom_point() + geom_smooth(method = \"lm\", se=F, colour=\"red\")\n\n# p3 - kétdimenziós pontdiagram csoportonkénti regressziós egyenessel\np3 <- ggplot(data=survey, aes(x=Height, y=NW.Hnd, colour=Sex)) + \n        geom_point() + geom_smooth(method = \"lm\", se=F, aes(fill=Sex)) +\n        theme_bw() + theme(legend.justification=c(1,0),legend.position=c(1,0))  \n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)\ndata(survey, package = \"MASS\") # a survey beolvasása\n\n# p1 - egydimenziós pontdiagram\np1 <- ggplot(data = survey, aes(x = Exer, y = Height)) + geom_point()\n\n# p2 - egydimenziós pontdiagram véletlen x elmozdulással\np2 <- ggplot(data = survey, aes(x = Exer, y = Height)) + geom_point(position = \"jitter\")\n\n# p3 - egydimenziós pontdiagram véletlen x elmozdulással és csoportok jelölése\np3 <- ggplot(data = survey, aes(x = Exer, y = Height)) + \n        geom_point(aes(colour=Sex), position = \"jitter\") + \n        theme(legend.position=\"top\")\n\n# a fenti ábrák megjelenítése\ngrid.arrange(p1, p2, p3, ncol=3)"},{"path":"grafika-az-r-ben.html","id":"feladatok","chapter":"9 Grafika az R-ben","heading":"9.2 Feladatok","text":"Készítsük el következő 4 ábrát hagyományos grafikában MASS csomag survey adatbázisa alapján: ","code":""},{"path":"irodalomjegyzek.html","id":"irodalomjegyzek","chapter":"Irodalomjegyzék","heading":"Irodalomjegyzék","text":"","code":""}]
