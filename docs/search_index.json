[["index.html", "Adatkezelés és egyváltozós elemzések R-ben Üdvözöljük", " Adatkezelés és egyváltozós elemzések R-ben Abari Kálmán 2022-07-13 Üdvözöljük Ez a honlap az Adatkezelés és egyváltozós elemzések c. könyv elektronikus változatát mutatja be. A nyomtatásban megjelent könyvhöz képest számos bővítést tartalmaz: a függelék fejezetei, például a kitűzött feladatok megoldásai is itt jelennek meg, az R grafikus lehetőségeit tartalmazó fejezet bővebb a hagyományos grafika résszel. A teljes könyv, az adatbázisok és az R kódok megtalálhatók a következő címen. A könyvet Máth János lektorálta, és Friss Kinga illusztrálta. "],["eloszo.html", "Előszó", " Előszó Kedves Olvasó! Köszönjük, hogy bizalmat szavaz könyvünknek, és az R megismeréséhez ezt az utat választja. Az első lépésektől a komplett adatelemzési feladatok megoldásáig vezetjük az Olvasót, és főként kezdő vagy újrakezdő felhasználókhoz szólunk. Utunk során áttekintjük az adatfeldolgozás minden lépését: az adatok beolvasását, előkészítését, elemzését és az eredmények publikálását is. Könyvünk összesen 11 fejezetet tartalmaz. Az egyes fejezeteket alkotó alfejezeteket három különböző ikon egyikével jelöltük meg, amelyek jelzőtáblaként szolgálnak az R megismerésének útján. Az egyes ikonok jelentése a következő: Egy hegy. Az így jelölt fejezet az R alaptudás része, megismerése feltétlenül javasolt. A könyvben megfogalmazott célok ezen fejezetek megismerésével is elérhetők, azaz komplett adatelemzéseket hajthatunk végre csupán ezek végig olvasásával is. Két hegy. Kiegészítő tudást tartalmazó fejezetek. Újabb eszközök megismerését teszik lehetővé, és/vagy hozzájárulnak az egy hegy fejezetek mélyebb megértéséhez. Három hegy. Az R ismeretek további részletezése, a meglévő eszközök finomabb kezelése, vagy további beállítási lehetőségek olvashatók ezekben a fejezetekben. Elképzelhető, hogy ritkábban felmerülő problémák megoldásához kapunk itt segítséget. A fejezetek hármas tagolása azt a célt szolgálja, hogy minél hamarabb örömet és sikert okozhasson az R használata, ugyanakkor további olvasással a részletesebb ismeretek utáni vágyunkat is kielégíthessük. Könyvünk olvasását tehát az 1. fejezet egy hegy alfejezetével (1.1 Elindulás) érdemes kezdeni, ott kapunk ajánlást a folytatásra. A további fejezetek olvasási sorrendje teljes mértékben az elvégzendő feladattól, tudásunktól és kíváncsiságunktól függ. A fejezetek végén összefoglaljuk a tanultakat. Megismételjük a legfontosabb fogalmakat és felsoroljuk a megismert függvényeket. Összefoglalás. Nem csak a fejezet áttanulmányozása után, hanem időről-időre javasoljuk a fejezet végi összefoglalások áttekintését. Ezzel leellenőrizhetjük R tudásunk frissességét, eldönthetjük, hogy érdemes-e újra átolvasni a fejezetben leírtakat. És mit jegyezzünk meg az előszóból: a könyv 11 fejezetet tartalmaz, az alfejezeteket nehézségük alapján három különböző ikon egyikével jelöltük: egy hegy, két hegy vagy három hegy. Az R tanulmányozása kitartást és némi időt igényel. Nagyon fontos szerepet kap a gyakorlás, ezért minden fejezet végén találunk feladatokat. Feladatok. A fejezet végi feladatok megoldásával jelentősen hozzájárulunk a magabiztos R tudás megszerzéséhez. Találunk szórakoztató és érdekes feladatokat is. Örömmel fogadjuk Olvasóink észrevételeit az abari.kalman@gmail.com címen. "],["itt-kezdodik.html", "1 Itt kezdődik 1.1 Elindulás 1.2 A könyv felépítése 1.3 Próbák listája", " 1 Itt kezdődik 1.1 Elindulás Ebben a fejezetben: bemutatunk egy konkrét adatelemzési példát, áttekintjük a könyv tartalmát, lehetőséget adunk az előzetes R ismeretek felmérésére, és segítünk a megfelelő fejezet kiválasztására a folytatáshoz. Könyvünk elsődleges célja az R bemutatása kezdő felhasználók számára, de minden bizonnyal azok is találni fognak hasznos részeket, akik már rendelkeznek R ismeretekkel. Bevezetést nyújtunk az R által lefedett három nagy terület mindegyikébe: az adatkezelésbe, a grafikus megjelenítésbe és az adatelemzésbe is. A leírtak megértéséhez a statisztikai alapismereteken túl semmilyen előzetes tudás nem szükséges. Most egy konkrét adatelemzési példa segítségével bemutatjuk, hogy mit nyújt e könyv az Olvasó számára. A bevezető példa megoldása során az előismeretekkel rendelkező Olvasó a saját R tudását is felmérheti, és ezzel egyben segítséget kaphat a tudásához és céljaihoz legjobban illeszkedő fejezet kiválasztására, amellyel tovább folytathatja az olvasást. Bevezető példa: Két tanítási módszer összehasonlítása Egy 2020-as kutatásunkban (Csapó, Csernoch, and Abari 2020) 7. osztályos tanulóknak Excel ismereteket oktattunk két különböző megközelítésben. Az egyik csoportban hagyományos, míg a másikban modern (Sprego) tanítási módszert használtunk. A tanulási időszak az Excel ismeretek felmérésével zárult. Az összegyűjtött adatok az excel_2020.xlsx állományban állnak rendelkezésre. Nézzük az adatelemzés lépéseit és egyben könyvünk felépítését! 2. fejezet: Mi az R? A bevezető példa megoldását R-ben fogjuk elvégezni (és nem más eszközben, mint például az SPSS, jamovi, JASP, SAS stb.). Érdemes tehát ismerni az R céljait és lehetőségeit, jó ha van egy összképünk a használt statisztikai programcsomagról. Ezt az áttekintést nyújtja 2 fejezet. 3. fejezet: Az R telepítése. Adatelemzésünk konkrét lépéseinek elvégzéséhez telepített Alap R és RStudio szükséges. Ha ezek nem állnak rendelkezésre, vagy még nem is találkoztunk ezekkel az eszközökkel, akkor a 3. fejezet nekünk szól. 4. fejezet: Munka az R-ben. Az adatelemzés végrehajtásához az RStudio-t ajánljuk, és azon belül pedig a projektek használatát szorgalmazzuk. A 4. fejezetben megismerjük az RStudio legalapvetőbb funkcióit, a parancsállományok létrehozását és futtatását. A fenti előzmények után elkezdhetjük a bevezető példa megoldását: indítsuk el az RStudio-t, hozzunk létre egy új projektet, hozzunk létre egy új RMarkdown állományt, helyezzük el a lentebb szereplő R parancsokat az RMarkdown állomány egyes csonkjaiban. 5. fejezet: Az R nyelv. Az R parancsok létrehozásának vannak szabályai, amelyeket a munka során be kell tartanunk. Ismernünk kell jó néhány függvényt, és általában el kell tudnunk igazodni az R nyelvben. Az 5. fejezet ezért kulcsfontosságú, tanulmányozzuk alaposan, és lehetőleg minden kitűzött feladatát oldjuk meg. 6. fejezet: Beolvasás Minden adatelemzés első lépése az adatállomány beolvasása. Adataink változatos formában állhatnak rendelkezésre, a 6. fejezetben ezek beolvasására kapunk receptet. A bevezető példa megoldásához az RMarkdown állomány egyik csonkját bővítsük a lenti sorokkal. # install.packages(&quot;rio&quot;) # rio csomag telepítése library(rio) # rio csomag betöltése felmeres &lt;- import(file = &quot;adat/excel_2020.xlsx&quot;) # beolvasás 7. fejezet: Adatkezelés A statisztikai elemzés elkezdése előtt számos adatkezelési tevékenységre lehet szükség. Ezt a sokszor rendkívül időigényes folyamatot a 7. fejezetben részletezzük. A bevezető példa megoldásához az RMarkdown állomány egyik csonkját bővítsük a lenti sorokkal. Az adatkezelés legtöbbször a beolvasott állomány jellemzőinek lekérésével kezdődik. str(felmeres) # a dataframe szerkezete names(felmeres) # változónevek unique(felmeres$modszer) # különböző értékek A karakteres vagy numerikus vektorok faktorrá konvertálása az egyik leggyakoribb előkészítő parancs. felmeres$modszer &lt;- factor(felmeres$modszer) A táblázatok és ábrák megfelelő megjelenéséhez, végezzük el a faktorszintek sorrendbe állítását. felmeres$modszer &lt;- factor(felmeres$modszer, levels=c(&quot;modern&quot;, &quot;hagyományos&quot;)) 8. fejezet: Mutatók és táblázatok. Ha az adatainkat már megfelelő formába hoztuk, akkor továbbléphetünk az elemzés felé. A 8. fejezet a leíró statisztikai elemzésekből a mutatók és a táblázatok létrehozását mutatja be. Most a felmérés eredményeinek statisztikai mutatóit íratjuk ki a két tanítási módszert használó csoportban. # install.packages(&quot;psych&quot;) # psych csomag telepítése psych::describeBy(x = felmeres$eredmeny, group = felmeres$modszer, mat=T, fast=T, digits = 2) #&gt; item group1 vars n mean sd min max range se #&gt; X11 1 modern 1 13 0.65 0.20 0.33 0.95 0.63 0.05 #&gt; X12 2 hagyományos 1 13 0.38 0.13 0.08 0.55 0.47 0.04 9. fejezet: Grafika. A grafikus megjelenítés is a leíró statisztikai elemzés része. A 9. fejezetben részletesebben olvashatunk a publikációkész ábrák létrehozásáról. Most a numerikus változók esetén használt egyik elterjedt ábrázolási formát, a dobozdiagramot használjuk két tanítási csoport eredményének grafikus összehasonlítására. library(ggplot2) ggplot(data = felmeres, mapping = aes(x=modszer, y=eredmeny)) + geom_boxplot() 10. fejezet: Hipotézisvizsgálatok. A statisztikai hipotézisvizsgálat minden adatelemzés központi része, a gyűjtött adatokból a populációra nézve következtetést vonhatunk le. A 10. fejezetben a leggyakoribb egyváltozós elemzéseket mutatjuk be. Most Mann-Whitney-próbát hajtunk végre a két tanítási módszer eredményességének összehasonlítására. wilcox.test(eredmeny~modszer, data=felmeres) #&gt; #&gt; Wilcoxon rank sum exact test #&gt; #&gt; data: eredmeny by modszer #&gt; W = 145, p-value = 0.001 #&gt; alternative hypothesis: true location shift is not equal to 0 11. fejezet: Publikálás. Az adatelemzési folyamat utolsó lépése, az elemzés eredményének publikációkész formába öntése. A 11. fejezetben megismerjük azokat a legegyszerűbb folyamatokat, amelyekkel többnyire formanyelvtől függetlenül, publikációkész eredményközlést végezhetünk. Most a bevezető példában kapott eredmények publikálását végezzük el. A korábban használt psych::describeBy() függvény hívását úgy módosítjuk, hogy az bármely formanyelven (PDF, HTML, Docx) megfelelő eredményt adjon. Ehhez mindössze egészítsük ki a következő sorokkal a leíró statisztikai elemzést, majd a Knit nyomógomb segítségével fordítsuk le az RMarkdown állományt. A leíró statisztikai mutatók máris táblázatos, könnyen áttekinthető formában jelennek meg. options(OutDec = &quot;,&quot;) # a tizedesjel beállítása st &lt;- psych::describeBy(x = felmeres$eredmeny, group = felmeres$modszer, mat=T, fast=T, digits = 2) knitr::kable(st[-1], align = c(&quot;c&quot;, &quot;c&quot;), row.names = F) group1 vars n mean sd min max range se modern 1 13 0,65 0,20 0,33 0,95 0,63 0,05 hagyományos 1 13 0,38 0,13 0,08 0,55 0,47 0,04 Publikációnk szerves része a magyarázó ábra. A korábban rajzolt dobozdiagramunkat csinosítsuk ki a következő sorok R csonkba helyezésével. A ggsave() függvény a háttértárra rögzítésről is gondoskodik. library(ggplot2) p1 &lt;- ggplot(data = felmeres, mapping = aes(x=modszer, y=eredmeny)) + geom_boxplot() + labs(x=NULL, y=&quot;Eredmény (%)&quot;, title=&quot;7. osztályos tanulók Excel eredménye&quot;, subtitle = &quot;Két tanulási módszer összehasonlítása&quot;) + scale_y_continuous(labels = scales::percent) + theme_bw() ggsave(filename = &quot;output/kep/dd.png&quot;, plot = p1) p1 A bevezető példa megoldásához természetesen a hipotézisvizsgálat szöveges értékelés is hozzátartozik, de ezt most az alfejezet végén szereplő egyik kitűzött feladatra halasztjuk. A hangsúly a könyv vázlatos tartalomjegyzékének bemutatásán volt, részletesebb, de felsorolásszerű tartalomjegyzéket a következő két alfejezetben találunk. 1.1.1 Összefoglalás Ebben az alfejezetben egy adatelemzési példát oldottunk meg, melynek segítségével illusztrálni tudtuk a további fejezetek tartalmát. A 2. fejezetben áttekintést adunk az R-ről, a 3.-ban az Alap R és RStudio telepítését, a 4.-ben az RStudio használatát mutatjuk be. Az 5. fejezetben kellő részletességgel ismertetjük az R nyelvet. A további fejezetekben az adatelemzés szokásos lépéseit vesszük sorra, a 6. fejezetben a beolvasást, a 7. fejezetben az adatok előkészítését, a 8. és 9. fejezetben a leíró statisztikai műveleteket mutatjuk be. A 10. fejezet az egyváltozós hipotézisvizsgálatoké, az utolsó, 11. fejezet az eredmények publikálását foglalja össze. 1.1.2 Feladatok Milyen online vagy nyomtat könyvek segítik az R elsajátítását? Próbáljuk összegyűjteni a magyar nyelvű könyveket is! Térképezzük fel az online videókurzusokat is az R tanulásához! A bevezető példa (Két tanítási módszer összehasonlítása) megoldásában a hipotézisvizsgálat alapján adjunk szöveges értékelést! A fenti feladatok megoldása 1.2 A könyv felépítése Ebben a fejezetben: bemutatjuk a könyv részletes felépítését, ezzel tovább segítjük a választást a folytatáshoz. A könyv 11 fejezetből áll, és fejezetenként 3 vagy több alfejezetből. Most röviden bemutatjuk az egyes alfejezetek tartalmát. Fejezet/alfejezet Leírás 1. Itt kezdődik 1.1. Elindulás A könyv fejezeteinek bemutatása egy konkrét adatelemzésen keresztül 1.2. A könyv felépítése Jelen alfejezet, amelyben a könyv egyes alfejezeteit mutatjuk be röviden 1.3. Próbák listája A könyvben szereplő egyváltozós statisztikai eljárások listája 2. Mi az R? 2.1. Az R bemutatása A parancssoros R jellemzői, az R nyelv, az Alap R és a csomag fogalma 2.2. A modern R Megtanuljuk a Tidyverse R fogalmát, megtudjuk mi a modern R 2.3. Múlt és jelen Az R rövid története, alapelvek az R tanulásához, és az R alaptudás elemei 3. Az R telepítése 3.1. Az Alap R és az RStudio telepítése Megismerjük az Alap R és az RStudio telepítését 3.2. A Tidyverse R telepítése A tidyverse csomag(gyűjtemény) telepítése 3.3. Az R frissítése Az Alap R, az RStudio és a csomagok frissítésének módszerei 4. Munka az R-ben 4.1. Az RStudio használata Az RStudio jellemzői és felépítése, a projektek használata 4.2. Segítség az R használatához Segítségkérési lehetőségek az R-ben, a beépített súgó használata 4.3. Az Alap R használata Az Alap R konzolja, az RGui, az R Commander és a kötegelt üzemmód 5. Az R nyelv 5.1 Adatobjektumok Az objektumok fogalma és létrehozásuk, egyszerű kifejezések 5.2 Függvények A függvény fogalma, a függvényhívás módja, a kifejezés teljes fogalma 5.3 Adatszerkezetek Az R egyszerű és összetett adatszerkezetei, létrehozásuk és indexelésük 5.4 További adatszerkezetek és függvények A dátum, tömb, táblázat és tibble adatszerkezetek kezelése 5.5 Objektumok és típusok Az R objektum-orientált lehetőségei 6. Beolvasás 6.1 Excel, SPSS és RDS állományok A rio csomag lehetőségei 6.2 Tidyverse beolvasás A tidyverse csomag lehetőségei 6.3 Tagolt szöveges állományok A hagyományos R lehetőségei 7. Adatmanipuláció 8. Mutatók és táblázatok 9. Grafika 10. Hipotézisvizsgálatok 11. Publikáció 1.2.1 Összefoglalás Ebben a részben röviden bemutattuk a könyv összes alfejezetét. A későbbiekben térképként használhatja az Olvasó az itt ismertetett táblázatot. 1.2.2 Feladatok Az adatfeldolgozás 4 lépése a következő: (1) adatok beolvasása, (2) adatok előkészítése elemzésre, (3) adatok elemzése és (4) az eredmények publikálása. A könyv mely fejezetei tartoznak az adatfeldolgozás fenti lépéseihez? Az R-rel való munka általunk javasolt módja: RStudio-ban, projektmódban, R vagy RMarkdown állományokat szerkesztünk és hajtunk végre. Mely fejezetekben találunk hasznos információkat az R ezen használatával kapcsolatban? A fenti feladatok megoldása 1.3 Próbák listája Ebben a fejezetben: áttekintést adunk az egy- és kétváltozós hipotézisvizsgálatokról. A 10. fejezetben bemutatjuk az egy- és kétváltozós hipotézisvizsgálatok végrehajtását. Ebben a fejezetben felsoroljuk a legfontosabb próbákat, összesen öt táblázatban soroljuk fel őket: egy mintát vizsgáló próbák (1.1. táblázat), páros mintát vizsgáló próbák (1.2. táblázat), két független mintát vizsgáló próbák (1.3. táblázat), több összetartozó mintát vizsgáló próbák (1.4. táblázat), több független mintát vizsgáló próbák (1.5. táblázat). A táblázatokban megadjuk, hogy a vizsgálatnak mi a célja, vagyis a populációbeli változó(k) melyik paraméterére vonatkoznak a próbák, a várható értékre, a mediánra, a varianciára vagy a valószínűségre. A 10. fejezetben foglalkozunk az eloszlásvizsgálatok közül a normalitást ellenőrző próbákkal is, így a 1.1. táblázat ezeket is számba veszi. TÁBLÁZAT 1.1: Egy minta vizsgálata Cél Próba neve R függvény várható érték egymintás u-próba BSDA::z.test() egymintás t-próba t.test() medián előjel-próba BSDA::SIGN.test() Mood-féle medián-próba egymintás Wilcoxon-próba wilcox.test() variancia khí-négyzet próba chisq.test() valószínűség khí-négyzet próba chisq.test() normalitás Shapiro-Wilk próba shapiro.test() Kolmogorov-Szmirnov próba DescTools:LillieTest() TÁBLÁZAT 1.2: Páros minta vizsgálata Cél Próba neve R függvény várható érték páros t-próba t.test(paired=T) medián páros előjel-próba BSDA::SIGN.test() páros Wilcoxon-próba wilcox.test(paired=T) variancia var.test() valószínűség McNemar-próba mcnemar.test() Cohran-Q próba mcnemar.test() TÁBLÁZAT 1.3: Két független minta vizsgálata Cél Próba neve R függvény várható érték kétmintás u-próba BSDA::z.test() kétmintás t-próba t.test() Welch-féle d-próba t.test(var.equal=F) medián Mann–Whitney-próba wilcox.test() variancia F-próba var.test() valószínűség khí-négyzet próba chisq.test() Fisher-féle egzakt próba fisher.test() TÁBLÁZAT 1.4: Több összetartozó minta vizsgálata Cél Próba neve R függvény várható érték egyszempontos összetartozó mintás varianciaelemzés ez::ezANOVA() medián Friedman-próba friedman.test() TÁBLÁZAT 1.5: Több független minta vizsgálata Cél Próba neve R függvény várható érték egyszempontos varianciaelemzés aov() Welch-féle egyszempontos varianciaelemzés oneway.test(var.equal=F) medián Kruskal–Wallis-próba kruskal.test() variancia Levene-próba DescTools::LeveneTest() Bartlett-próba bartlett.test() 1.3.1 Összefoglalás Ebben a részben rövid áttekintést adtunk a könyv 10. fejezetében sorra kerülő statisztikai próbákról. Megneveztük a próbákat, R parancsokkal szemléltettük használatukat, valamint jeleztük a céljukat. A táblázatok áttekintésével képet kaphatunk arról, hogy a későbbiekben milyen jellegű statisztikai következtetéseket tudunk levonni az R használatával. 1.3.2 Feladatok Minden statisztikai próba esetében négy dolgot érdemes tudni: (1) a statisztikai próba neve, (2) null- és ellenhipotézise, (3) alkalmazási feltételei, és (4) a próba végrehajtásának módja valamely statisztikai programcsomagban. A 10. fejezetben a statisztikai próbák végrehajtását természetesen R-beli eszközökkel mutatjuk be. Ismerjük a fenti táblázatokban megnevezett próbák null- és ellenhipotézisét, valamint az alkalmazási feltételeit? Próbáljuk ezeket felidézni! Hol találunk ezekről információt? Mely próbák maradtak ki ebből a könyvből? Hol találunk ezek R-beli végrehajtására példát? A fenti feladatok megoldása Irodalomjegyzék "],["mi-az-r.html", "2 Mi az R? 2.1 Az R bemutatása 2.2 A modern R 2.3 Múlt és jelen", " 2 Mi az R? 2.1 Az R bemutatása Ebben a fejezetben: megismerjük az R jellemzőit, megtudjuk, hogy melyek a parancssoros interfész előnyei, megismerjük az Alap R fogalmát, körülhatároljuk az R nyelv, az Alap R és a csomag fogalmát. 2.1.1 Az R jellemzői Az R egy magas szintű programozási nyelv és környezet, amelynek legfontosabb felhasználása az adatelemzés és az ahhoz kapcsolódó grafikus megjelenítés. Három alapvető jellemzője kiemeli a többi statisztikai programcsomag közül: (1) az R ingyenesen telepíthető és használható; (2) az R nyílt forrású, így bárki hozzájárulhat az R fejlesztéséhez, azaz létrehozhat új csomagokat, és ezzel kiegészítheti az R tudását; és (3) az R felhasználók rendkívül aktív és befogadó online közösséget alkotnak, szinte minden felmerülő kérdésünkre azonnal választ kaphatunk. Álljon itt egy bővített lista azokról a jellemzőkről, amelyek vonzóvá tehetik számunkra az R statisztikai programcsomagot. Az R szabad szoftver, bárki ingyenesen letöltheti és használhatja. Ez egyfelől megkönnyíti az oktatási intézmények, tanszékek és oktatók munkáját, hiszen nincs szükség a kereskedelmi programok licenceléséből adódó pénzügyi vagy más természetű nehézségek kezelésére. Másrészt a hallgatók a statisztika kurzusok során tanultakat otthon vagy később a munkájukban is felhasználhatják. Az R platform-független, azaz Windows, Linux és macOS környezetben is használható. Nem kell lemondanunk a kedvenc operációs rendszerünkről, ha az R-t szeretnénk használni. Az R nemcsak egy statisztikai programcsomag önmagában, hanem egy teljes értékű programozási nyelv. Az R statisztikai módszerek szinte végtelen választékát kínálja. A R-ben felhasználható statisztikai eljárásokat statisztikusok fejlesztik folyamatosan és csomagok formájában teszik elérhetővé. Valószínű, hogy egy új statisztikai módszer leghamarabb az R-ben válik elérhetővé. Az R rendkívül gazdag grafikus lehetőségekkel rendelkezik. A statisztikai szakirodalomban és az egyetemi oktatók körében egyre elterjedtebb az R mint közös (statisztikai program)nyelv használata. Ha valamilyen statisztikai problémára keressük a megoldást, vagy csak konzultálunk egy statisztikussal, az R ismerete (akár csak olvasási szinten) rendkívüli előnyt jelenthet. Az R igen jól dokumentált, a beépített súgón kívül számos könyv és leírás érhető el. Az R parancssoros interfésszel rendelkezik, amely számos előnnyel jár. Egyrészt a szkript állományok létrehozása és végrehajtása a statisztikai elemzések megismételhetőségét biztosítják, másrészt ez az oktatók és a hallgatók könnyebb kommunikációját is lehetővé teszi. Az R az adatelemzés eredményének sokszínű publikálását is biztosítja. Az RMarkdown formanyelv segítségével HTML, PDF és Word dokumentumot, illetve prezentációs diákat vagy akár kész cikkeket hozhatunk létre. A Shiny csomag interaktív Webes alkalmazások építését teszi lehetővé. Mára az R használata szinte egyet jelent az ingyenesen elérhető RStudio használatával, amely egy kényelmes integrált fejlesztői környezetet biztosít a parancsállományok létrehozásához. Érdemes bepillantani az R árnyékosabb oldalába is. Az R egyik gyengesége, hogy nagy adatbázisok kezeléséhez erős hardverre van szüksége, de a legtöbb felhasználás során ez semmilyen problémát nem okoz. A másik gyengeség, hogy az R elsajátításához nem kevés idő és kitartás szükséges. Jelen könyv éppen ezt a folyamatot kívánja megkönnyíteni és lerövidíteni. 2.1.2 A R parancssoros Az R alapvető használata során parancsokat gépelünk be és hajtunk végre. Ez lényegesen eltér a ma megszokott felhasználói programok világától, ahol egy grafikus felhasználói felületen egérrel vagy az ujjunkkal mutogatjuk el a kívánt tevékenységet. Az R egészen más megközelítést vall, használata a kezdeti lépésektől nagyfokú figyelmet és pontosságot követel. Parancsokban kell gondolkodnunk, ám ezt végig áthatja a tudom mit csinálok elv, így némi idő elteltével érezni fogjuk, hogy az R megszelídül, már nem köt bele minden szavunkba, egyre több dologra tudjuk rávenni, és végül egy rendkívül értékes társsá válik. Jelen könyv ezen az úton szeretné végigvezetni az Olvasót. Már a tanulás elején szeretnénk tisztázni, hogy az R elsajátításához nem szükséges programozói alaptudás. Az R felhasználók többsége egyáltalán nem programozó, és a mindennapi adatelemző munka sem igényli az R nyelv programozói fokú ismeretét. Természetesen, ha rendelkezünk ilyen irányú előtanulmányokkal a tanulási folyamat néhány szakasza lerövidíthető, de könyvünk elsősorban azok számra íródott, akik programozási nyelvekkel korábban nem találkoztak, és nem is vágynak az R ilyen mélységű ismeretére. Az R nyelv elsajátítása során bevezetjük azokat az egyszerű fogalmakat, amelyeket nem nélkülözhetők az adatelemzés során, azonban az R programozásához más szakkönyveket javaslunk olvasásra. 2.1.3 Mi valójában az R? Az R nyelv fejlesztője az R Core Team. Az R nyelv egy rendkívül népszerű szkriptnyelv, több millióan használják világszerte. Elsősorban adatelemzésre, adatmodellezésre és grafikus megjelenítésre, vagyis arra, amit ma adattudományok (data science) alatt értünk. Azonban az R nyelv önmagában nem szoftver, hanem egy rendkívül rugalmas szkriptnyelv, amely például előírja, hogy milyen szintaktikai szabályok mentén fogalmazhatjuk meg az utasításainkat. Ahhoz, hogy az R nyelvet használni tudjuk, vagyis, hogy a számítógép valóban végre is hajtsa a szintaktikailag helyes utasításainkat, szükség van egy szoftveres környezetre, egy olyan futtató rendszerre, amely a kódunkat értelmezi és végrehajtja. ÁBRA 2.1: Az R környezet: Alap R és az egyéb csomagok Az R környezet három fő összetevőt tartalmaz (2.1. ábra): (1) egy konzolt, ahová a parancsainkat begépelhetjük; (2) a parancsok végrehajtásáért felelős R interpretert; (3) a csomagokokat. A konzol és az interpreter biztosítja az R nyelven írt parancsok tényleges végrehajtását. Így tudunk adatokat beolvasni, átlagot számolni, varianciaelemzést futtatni, vagy publikációkész ábrákat létrehozni. A csomagok adatokat és függvényeket tartalmaznak, például a MASS csomag 88 adatobjektumot és 78 függvényt tartalmaz. A függvények valamilyen tevékenységet hajtanak végre, és valójában ezeket a csomag-függvényeket használjuk fel a konzolban, ha bármilyen tevékenységet szeretnénk végrehajtani (például adatokat beolvasni, átlagot számolni stb.). A könyv írásának időpontjában kb. 21 ezer csomag volt érhető el az R-hez. Csomagok 3 csoportját különböztetjük meg: standard csomagok (14 db), ajánlott csomagok (15 db) és egyéb csomagok (kb. 21 ezer db). A standard csomagok fejlesztője az R Core Team. A standard csomagok: base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils. Az ajánlott csomagok: KernSmooth, MASS, Matrix, boot, class, cluster, codetools, foreign, lattice, mgcv, nlme, nnet, rpart, spatial, survival. Az ajánlott csomagok közül a foreign és az nlme fejlesztője az R Core Team, a többit más felhasználók fejlesztették, például a már említett MASS csomag fejlesztője Brian Ripley. Csomagot bárki szabadon fejleszthet és terjeszthet, az egyéb csomagok csoportját akár mi is gyarapíthatjuk. A R környezet már igazi szoftver, terjesztésének koordinálását az R Foundation végzi a CRAN infrastruktúráján keresztül. Ez biztosítja, hogy számítógépünkre telepíthessük az R környezetet. Ezt a CRAN-ról elérhető R futtatási környezetet Alap R-nek nevezzük. Fő komponensei a már említett konzol a parancsok begépelésére, az R értelmező a begépelt parancsok végrehajtására és a csomagok közül a standard és ajánlott csomagok. Az Alap R telepítése után már tudunk R parancsokat végrehajtani, és nagyon sok adatelemzési probléma megoldására nyílik módunk, sőt azt mondhatjuk, hogy tetszőleges problémát megoldhatunk kisebb-nagyobb erőfeszítéssel, mert az R egy teljes értékű nyelv. Azonban sokszor érdemesebb az egyéb csomagok közül választani, hiszen könnyen elképzelhető, hogy a számtalan csomag között találunk olyat, amely segítségünkre lehet speciális feladataink megoldása során. Valószínű, hogy létezik olyan csomag és benne olyan függvény, amely adatkezelési, adatelemzési, grafikai vagy publikálási feladatunkat jelentősen megkönnyíti. Az egyéb csomagok csoportjába tartozó csomagok forrása több tárhely is lehet, ezek közül legjelentősebb az R Foundation által karbantartott CRAN (18343 csomaggal), a Bioconductor (2140 csomaggal) és a GitHub. Az R tehát egyszerre több dolgot jelent. Az R egyrészt egy magas szintű programozási nyelv, hamarosan megtanuljuk, hogyan írjunk ezen a nyelven értelmes utasításokat. Másrészt a nyelv körüli környezetet is jelenti, amely magába foglalja a konzolt, a parancsaink értelmezésért felelős R interpretert, valamint azokat a csomagokat, amelyekkel az R tudása kiegészíthető. 2.1.4 Összefoglalás Minden statisztikai programcsomag, így az R is, alapvetően a számításigényes statisztikai eljárások kézi végrehajtásától kímél meg minket. Az R nagyon gazdag adatmanipulációs és grafikus funkciókban is, támogatja a reprodukálható adatelemzés végrehajtását. Az R ingyenes, többplatformos és egyik legfontosabb jellemzője, hogy parancsok útján bírhatjuk működésre. Az Alap R biztosítja a konzolt a parancsok begépelésére, az R interpretert a parancsok tényleges végrehajtására, és jó néhány csomagba szervezett eljárást az adatelemzési feladatok elvégzéséhez. Az Alap R mindössze néhány tucat csomagot tartalmaz, a standard csomagokat és az ajánlott csomagokat, de több tízezer további csomaggal bővíthetjük az R tudását. Az adatelemzési munka során egy R környezet vesz minket körül, amely az R nyelven megírt parancsok értelmezésére és végrehajtására képes Alap R-ből, és az ún. egyéb csomagokból áll. 2.1.5 Feladatok Keressünk weboldalakat, amelyek az R előnyeit és hátrányait listázzák! Keressük meg, hogy az R optimális futtatásához, milyen hardver követelmények szükségesek! Nézzünk utána, hogy ma kb. hány csomag érhető el az R-hez? Keressünk ábrát, amely bemutatja, hogy az évek során hány csomag volt elérhető az R-hez? Hol áll az R népszerűsége a többi programozási nyelvhez, illetve statisztikai programcsomaghoz képest? Milyen ingyenesen elérhető, grafikus felhasználói felülettel rendelkező statisztikai programcsomagok építenek az R-re? Említettük, hogy az adatelmezési munka nem igényli az R programozói fokú ismeretét, de soroljunk fel néhány könyvet, amelyből az R programozása is megtanulható! A fenti feladatok megoldása 2.2 A modern R Ebben a fejezetben: megismerjük a Tidyverse R fogalmát, megtudjuk mit értünk modern R alatt. A 2014-es év az R nyelv életében meghatározó változást hozott. Egyrészt megjelent a magrittr csomagban a pipe operátor (%&gt;%), amellyel olvashatóbb kódok írására nyílt lehetőség1, másrészt a pipe operátorra alapozva Hadley Wickham bemutatta a dplyr és tidyr csomagokat. Ezzel az R funkcionális2 oldalát úgy erősítették meg3, hogy a sokszoros egymásba ágyazás során kiküszöbölték a kerek zárójelek írásának problémáját. Az ebben a szellemben készült csomagok listája bővült az idők folyamán, és a Tidyverse nevet kapta ez a csomaggyűjtemény. Jelenleg a következő csomagok alkotják: ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats. Ezek a csomagok nem egyszerűen új funkciókkal ruházzák fel az Alap R tudását, mint általában az egyéb csomagok. A Tidyverse csomagjai konzisztens módon együttműködnek, és egy új megközelítést hoznak az adatelemzési folyamatok végrehajtásában és a kódok írásában. Rövidebb idő alatt hozhatunk létre könnyebben karbantartható kódokat, és a műveleteink végrehajtása is rendszerint gyorsabb. Amikor ebben a megközelítésben hozzuk létre és hajtjuk végre utasításainkat, akkor azt mondjuk hogy a Tidyverse R-t használjuk. A Tidyverse R nem helyettesíti az Alap R-t, és csak bizonyos feladatokra használható. Lássunk tisztán, amit elvégezhetünk Tidyverse R-ben, azt az Alap R-ben is meg tudnánk tenni, de valószínűleg több gépeléssel, lassabb és rosszabbul karbantartható kóddal. Eddig láttuk, hogy az R használatához szükséges az Alap R telepítése, majd a speciális problémánknak megfelelően kiegészíthetjük az R tudását úgy, hogy telepítünk egyet vagy többet az egyéb csomagok kategóriájából. Választhatjuk akár a Tidyverse csomagjait is telepítésre, ugyanis így lehetőségünk nyílik a Tidyverse R használatára. Utasításaink megfogalmazásának ma ez a legmodernebb módja. A modern R alatt lényegében azokat a funkciókat értjük, amelyek a Tidyverse gyűjteményben található csomagokhoz kötődnek. Ezekkel a csomagokkal, gyorsabb, olvashatóbb és könnyebben karbantartható kódokat hozhatunk létre. A Tidyverse használata tehát erősen javasolt, de ebben a könyvben a “hagyományos”, Tidyverse R előtti lehetőségeket is bemutatjuk. 2.2.1 Összefoglalás A Tidyverse R egy csomaggyűjtemény az egyéb csomagok csoportjából, amely újabb szemléletű R parancsok írására ad lehetőséget. Az így készült kódjaink rendszerint gyorsabban futnak és könnyebben karbantarthatók. A modern R a Tidyverse R csomagjaival kiegészített Alap R, de legfőképp egy új lehetőség parancsaink megfogalmazására. 2.2.2 Feladatok Ki Hadley Wickham? Mikor történt az egyik legjobb dolog az R-rel? A fenti feladatok megoldása 2.3 Múlt és jelen Ebben a fejezetben: megismerjük az R rövid történetét és annak szereplőit, majd egy szubjektív listával segítjük az R tanulását, illetve megismerjük az R alaptudás elemeit. 2.3.1 Szereplők és fogalmak Érdemes néhány szereplőt és fogalmat tisztázni az R világán belül. Az R nyelvet 1992-ben kezdte fejleszteni Ross Ihaka és Robert Gentleman, 1997-től pedig egy nagyobb csapat, az R Development Core Team vezeti a fejlesztést (rövidebben R Core Team). Ettől az évtől az R hivatalosan a GNU projekt része. Az R Core Team tagjai 2002-ben létrehozták a The R Foundation for Statistical Computing (rövidebben The R Foundation) közhasznú, nonprofit szervezetet, amelynek célja (1) az R folyamatos fejlesztésének biztosítása, és ehhez kapcsolódóan a nyílt forráskódú számítógépes statisztikai innovációk támogatása, (2) az R fejlesztői közösség (R Core Team) hivatalos hangjaként a felhasználók, intézmények és üzleti vállalkozások számára a kommunikáció biztosítása, és (3) az R program és dokumentációk szerzői jogainak kezelése. A szervezet rendszeresen konferenciákat, találkozókat szervez, referált folyóiratot, kézikönyveket és technikai leírásokat ad ki, valamint fenntart egy számítógépes infrastruktúrát (ez a CRAN, amely levelező listákat, FTP- és Webszervereket üzemeltet). Az R Foundation hivatalos oldala – egyben az R hivatalos oldala – a https://www.r-project.org/. Az R Foundation (és más önkéntesek) által üzemeltetett számítógépes hálózat neve a CRAN (Comprehensive R Archive Network), amely szabad hozzáférést nyújt az R legfrissebb verziójához, az R kiterjesztéseihez (a csomagokhoz) és a részletes dokumentációkhoz. A CRAN fő számítógépe Ausztriában található https://CRAN.R-project.org/, azonban nagyon sok naponta frissülő tükörszerver érhető el világszerte. 2.3.2 Alapelvek Az R elsődleges célja, hasonlóan más statisztikai programcsomagokhoz, a statisztikai adatelemzés, amelyet négy lépésre bonthatunk: adatok beolvasása, adatok előkészítése elemzésre, adatelemzés, eredmények publikálása. Az R mára a fenti 4 tevékenység elvégzését teljes körűen támogatja. A könyv célja ezek bemutatása. Mielőtt elkezdjük ezt az izgalmas utat – az R tanulmányozását – néhány alapelvet szeretnék megemlíteni, ami segíthet minket az utazásunk során: Magabiztosság - Az R nagyon nagy, így a teljes megismerése nem lehet célunk. Mindig lesz valaki, aki az R egyik vagy másik részét jobban, vagy kevésbé ismeri nálunk. Ez természetes, ezen soha ne csodálkozzunk. Az eltérő ismeretek azonban az R speciális területeire vonatkoznak, az R alaptudás (2.3.3. fejezet) minden R-ben jártas felhasználó számára közös. E könyv célja ennek az alaptudásnak az átadása, melynek birtokában már kellő magabiztossággal vághatunk neki az R azon részeinek elsajátításába, amelyek az éppen elénk kerülő speciális feladat megoldásához szükségesek. Hisszük, hogy e könyv elolvasásával, mind az R alaptudás, mind a kellő magabiztosság elérhetővé válik számunkra. Gyakorlás - Az R alaptudásának megszerzése némi időbe telik, ez tagadhatatlan. A motiváció megtartásához viszonylag jól kell éreznünk magunkat a tanulás és a gyakorlás során. A könyvben ezért minden fejezet végén találunk megoldandó feladatokat, amelyek között szórakoztató, érdekes és kihívást jelentő gyakorlatok is szerepelnek. Svájci bicska - A R nagyon sokféle statisztikai és nem-statisztikai probléma megoldására képes, sőt ugyanarra a problémára nagyon sok különböző eszközt kínál. Ha elsőre nem a legszebb, legoptimálisabb megoldás jut az eszünkbe, ne csüggedjünk, ez a legtöbb esetben nem jelent gondot. Azon se csodálkozzunk, ha korábban megoldott problémánkra idővel újabb és újabb megoldási lehetőségeket találunk. 2.3.3 Az R alaptudás Melyek az R-ben való munkavégzéshez nélkülözhetetlen alapismeretek? Meggyőződésünk, ha a lentebb felsorolt témakörökkel tisztában vagyunk, akkor már magabiztos R tudással rendelkezünk, és bármilyen további R témakör könnyen elsajátítható lesz. Ezekre az ismeretekre úgy gondolhatunk, mint egy ablakra, amelyen keresztül az R szinte végtelen lehetőségeinek tárháza nyílik meg előttünk. Később visszatérhetünk ehhez a listához, és ellenőrizhetjük, hány elemet tudunk már kipipálni. Az R alaptudás elemei: Az R környezet alapszintű ismerete az Alap R, az RStudio és a csomagok telepítése projektek használata és R parancsok futtatása az RStudio-ban Az R nyelv alapszintű ismerete konstansok írása objektumok kezelése egyszerű adattípusok alapvető operátorok kifejezés fogalma a függvényhívás lehetőségei összetett adattípusok, a vektoraritmetika szabályai Az alapvető függvények ismerete csomagkezelő függvények a munkaterület függvényei matematikai függvények input/output függvények indexelés, szűrés, rendezés információ kérés az objektumokról egyszerű típuskonverzió transzformáció ismétlő és összesítő függvények a hagyományos grafika néhány eleme a ggplot2 alapszintű ismerete Egyéb ismeretek szövegszerkesztési és állománykezelési ismeretek a tagolt szöveges állomány fogalma reprodukálható kutatás az RMarkdown segítségével 2.3.4 Összefoglalás Az R fejlesztését Ross Ihaka és Robert Gentleman kezdte, majd 1997-től egy nagyobb csapat, az R Development Core Team vezeti a fejlesztést. Az R Core Team tagjai 2002-ben létrehozták a The R Foundation for Statistical Computing közhasznú, nonprofit szervezetet, amelynek fő célja az R folyamatos fejlesztésének biztosítása. A szervezet fenntart egy CRAN nevű számítógépes hálózatot, amely szabad hozzáférést biztosít az R legfrissebb verziójához, a csomagokhoz és a részletes dokumentációkhoz. Az R alaptudás megszerzése elegendő magabiztosságot fog nyújtani az adatelemzési munka során, azonban vegyük figyelembe, hogy ezt csak kellő gyakorlással érhetjük el. Az R sokféle megoldást biztosít ugyanarra a problémára, legyen az statisztikai vagy bármilyen más jellegű feladat. 2.3.5 Feladatok Keressünk olyan statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet? Keressünk olyan nem-statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet? Nézzünk át néhány online elérhető R könyvet, és hasonlítsuk össze az R alaptudás egyes elemeivel! Melyek az átfedő részek, és hol vannak különbségek? Melyek a fontosabb lépcsőfokok az R fejlődősében? A fenti feladatok megoldása Más programozási nyelvekben az “objektum” helyett a “változó” elnevezést használják, de a változó fogalma már foglalt a statisztikában, így szerencsésebb a memóriában tárolt adatokra objektumként hivatkozni.↩︎ Az R egy nem túl fiatal, a funkcionális programnyelvekhez hasonlóan építkező programozási nyelv, vagyis egy probléma megoldása tipikusan sokszorosan egymásba ágyazott függvényhívások segítségével történik. Ez sok-sok nyitó és záró kerek zárójellel jár együtt, így a parancsaink áttekintése és karbantartása sokszor nehézségekbe ütközik. Ezt kiküszöbölendő az R-ben előszeretettel használnak procedurális eszközöket (például for ciklusokat), de a kód olvashatóságát és karbantartását igazán ez sem könnyíti meg.↩︎ További értékadás operátorok a -&gt;, &lt;&lt;-, -&gt;&gt; és a =. Ezeket nem használjuk ebben a könyvben.↩︎ "],["az-r-telepitese.html", "3 Az R telepítése 3.1 A fő komponensek telepítése 3.2 A Tidyverse R telepítése 3.3 Az R frissítése", " 3 Az R telepítése 3.1 A fő komponensek telepítése Ebben a fejezetben: megismerjük az Alap R, az RStudio és a csomagok telepítését. A korábbi fejezetekben megismertük az R világának néhány fogalmát és szereplőjét. Tudjuk, hogy az R nyelv használatához megfelelő szoftveres környezetre van szükség, amely magába foglalja az Alap R-t és az egyéb csomagok kategóriájából esetlegesen telepített csomagokat is. Az R már ezen eszközök birtokában is teljes körűen használható, azonban egy újabb ingyenes eszköz, az RStudio, kényelmessé és hatékonnyá teszi az adatelemzési munkát. Könyvünk legfontosabb gondolata: ma akkor tudjuk a legjobban kihasználni az R lehetőségeit, és ezzel egyidőben a legkényelmesebb módon elvégezni az adatelemzési feladatunkat, ha az Rstudio-t használjuk, projekt üzemmódban dolgozunk, és RMarkdown állományokban rögzítjük az R parancsainkat. Ezt a szemléletet következetesen képviseljük az egyes fejezetekben, és a későbbiekben részletesebben bemutatjuk, hogyan tudjuk mindezt megvalósítani (3.1. ábra). ÁBRA 3.1: Az R kényelmes használata A R kényelmes használatához a legelső lépés a szoftveres környezet egyes elemeinek telepítése. Három fő komponens telepítésére lesz szükségünk: Alap R, amely tartalmazza a konzolt, az R interpretert, illetve a standard csomagokat és az ajánlott csomagokat, RStudio, amely egy új konzollal “eltakarja” az Alap R-t, és kényelmesebb hozzáférést biztosít az Alap R interpreteréhez és a csomagjaihoz. Csomagok, amelyek az egyéb csomagok nagy halmazából származnak, és telepítésükkel újabb és újabb képességekkel ruházzuk fel az Alap R-t. 3.1.1 Az Alap R telepítése Az Alap R telepítéséhez látogassunk el az R hivatalos letöltő oldalára: https://cran.r-project.org/. Az operációs rendszerünknek megfelelő link kiválasztásával folytassuk a navigálást. A Windows felhasználók a Download R for Windows linken, majd a base linken kattintva jutnak el a telepítőprogram linkjéhez: Download R X.X.X for Windows. A sikeres letöltés után indítsuk el a telepítőt, és az alapértelmezetten felajánlott opciók nyugtázásával végezzük el a telepítést. A telepítést lehetőleg olyan Windows felhasználó alatt végezzük el, amelynek a neve sem ékezetes karaktert, sem szóközt, sem egyéb írásjelet nem tartalmaz. A macOS felhasználók a Download R for (Mac) OS X linken kattintva jutnak a telepítőhöz: R-X.X.X.pkg. A letöltés után indítsuk el a telepítőt, és a Next gombok segítségével végezzük el a telepítést. A Linux felhasználók az aktuális R verzió telepítéséhez a Download R for Linux linken keresztül jutnak el, ahol a megfelelő disztribúció (Debian, Redhat, Suse, Ubuntu) kiválasztása után konkrét információkat kapnak a telepítésről. 3.1.2 Az RStudio telepítése Az RStudio telepítéséhez az operációs rendszerünknek megfelelő telepítőt kell letöltenünk a https://www.rstudio.com/products/rstudio/download/ oldalról. Az RStudio Desktop (Open Source License) változatra lesz szükségünk, töltsük le és telepítsük ezt a számítógépünkre. A telepítés során fogadjuk el az alapértelmezett opciókat. Az RStudio automatikusan megtalálja és használja a korábban telepített Alap R példányunkat, így a későbbiekben elegendő lesz az RStudio-t használni, azon keresztül elérhetjük az Alap R minden funkcióját (3.1. ábra). 3.1.3 Csomagok telepítése A csomagok telepítésére az Alap R vagy az RStudio elindítása után van módunk. Érdemes a telepítéseket az RStudio-ból végezni. A csomag fellelési helye alapján, három különböző tárhelyről mutatjuk be a csomagok telepítését. Látni fogjuk, hogy a csomagok telepítéséhez R parancsokat fogunk használni. Ha még nem vagyunk jártasak R parancsok futtatásban, akkor a 4.1. fejezet fellapozásával segítséget kaphatunk a lenti parancsok kipróbálásához, de úgy is eljárhatunk, hogy most kihagyjuk ennek a résznek az áttekintését, és később térünk vissza, amikor valóban felmerül az igény csomagok telepítésére. Az R csomagok hivatalos helye a CRAN (The Comprehensive R Archive Network). A CRAN számítógépei tárolják a nyílt forráskódú R nyelv és környezet különböző verzióinak kódjait és dokumentációit, így az összes R csomag forráskódját is. Egy bírálási folyamat után bármely felhasználó csomagja a CRAN-ból is elérhető lehet. Az Alap R vagy az RStudio elindítása után az install.packages() függvénnyel tölthetünk le és telepíthetünk csomagot a CRAN-ról. Tetszőleges csomag telepítéséhez írjuk a csomag nevét idézőjelekben a függvény argumentumába: install.packages(&quot;csomag_neve&quot;) A psych csomagot, amely a pszichológia kutatások adatainak elemzéséhez nyújt segítséget, például így telepíthetjük: install.packages(&quot;psych&quot;) # psych csomag telepítése A csomagok másik fontos forrása a Bioconductor, ahol alaposan tesztelt és igen jól dokumentált bioinformatikai témájú csomagokat találunk. Az innen elérhető csomagokat – például most a DESeq2 csomagot az RNS-szekvenálási elemzésekhez – a következő parancsokkal telepíthetjük: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;DESeq2&quot;) A csomagok harmadik fő forrása a GitHub. A felhasználók a saját fejlesztésű csomagjaikat rendszerint először a GitHub-on keresztül teszik elérhetővé. Ha ezeket a csomagokat szeretnénk kipróbálni, akkor a felhasználó és a csomag nevének birtokában a következő parancsot kell kiadnunk: devtools::install_github(&quot;felhasznalo_neve/csomag_neve&quot;) Például a GitHub-ról telepíthető emo csomag segítségével hangulatjeleket szúrhatunk be az RMarkdown állományainkba. Ezzel a sorral telepíthetjük a csomagot: devtools::install_github(&quot;hadley/emo&quot;) Fontos tudnunk, hogy a csomagok telepítésére egy számítógépen egy adott R verzión belül csak egyszer van szükség. A telepítő parancsainkat azonban érdemes megőrizni, ugyanis egy új R verzióban könnyebben tudjuk így telepíteni a korábban használt csomagjainkat. Nagyon fontos, hogy a telepítő parancsok futtatása után, tegyük azokat megjegyzésbe, vagyis írjunk eléjük kettőskereszt (#) karaktert (részletesebb információkat a megjegyzésekről a 5.1.3. fejezetben olvashatunk). Ezzel tudjuk megvédeni ezeket a telepítő parancsokat az újbóli, véletlen, felesleges végrehajtástól. Ennek megfelelően a telepítő parancsainkat ilyen formában kell őriznünk: # install.packages(&quot;psych&quot;) # psych csomag telepítése # if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) # install.packages(&quot;BiocManager&quot;) # BiocManager::install(&quot;DESeq2&quot;) # devtools::install_github(&quot;hadley/emo&quot;) Vegyük figyelembe, hogy egy csomag telepítése során más, egyéb csomagok telepítése automatikusan is megtörténhet, tehát egy helyett valójában több csomag is felkerülhet a gépünkre. Az is előfordulhat, hogy egy csomag telepítése csak akkor lesz sikeres, ha más csomagok frissítését engedélyezzük az adott csomag telepítése során. Végül előfordulhat olyan eset is, amikor egy csomag telepítése valamilyen oknál fogva meghiúsul. Erről minden esetben hibaüzenet tájékoztat minket, és ez szinte minden esetben jó kiindulásul szolgál a hibát okozó körülmény elhárításában. A legtöbbször egy másik csomag hiánya okozza a sikertelen telepítést, ezért olvassuk ki a hibaüzenetből a hiányolt csomag nevét, és először ennek a telepítését végezzük el. Nagyon ritka esetben az is előfordulhat, hogy egy csomag telepítését az RStudio helyett az Alap R-ben kell elvégeznünk. 3.1.4 Összefoglalás Az R kényelmes használatához először telepítsük az operációs rendszerünknek megfelelő Alap R, majd az RStudio legújabb verzióját. Az R képességeit csomagok segítségével bővíthetjük, melyek három különböző tárhelyről származhatnak. A legtöbb csomagot a CRAN-ről telepíthetjük az install.packages() parancs használatával. A Bioconductor-ról vagy a GitHub-ról származó csomagok telepítéséhez más parancsokat kell használnunk. 3.1.5 Feladatok Melyik az R legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest? Melyik az RStudio legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest? Hogyan deríthető ki, hogy egy csomagban (például a MASS) csomagban, hány adatobjektum, és hány függvény található? A fenti feladatok megoldása 3.2 A Tidyverse R telepítése Ebben a fejezetben: megismerjük a Tidyverse R telepítését. A Tidyverse R az R meglévő funkcióinak új szemléletű használatát jelenti. A modern R jelenleg egyet jelent a Tidyverse R-rel, az ebben a szemléleteben készült parancsaink gyorsak, jól olvashatók és könnyen módosíthatók. A Tidyverse R funkciói összesen több csomagba (például ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats) vannak szétosztva, mindegyik csomag egy-egy témakört fed le. A fenti csomagok telepítése egyetlen gyűjtőcsomag a tidyverse nevű csomag telepítésével is elvégezhető: install.packages(&quot;tidyverse&quot;) # a Tidyverse R telepítése A Tidyverse R telepítését követően a csomagokban lévő függvények használatához a Tidyverse R betöltésére is szükség van. Hívjuk meg a library() függvényt, amely ebben az esetben igen részletes tájékoztatást ad az újonnan elérhető csomagokról. library(tidyverse) #&gt; -- Attaching packages ----------------------------- tidyverse 1.3.0 -- #&gt; &lt;U+221A&gt; ggplot2 3.3.0 &lt;U+221A&gt; purrr 0.3.3 #&gt; &lt;U+221A&gt; tibble 3.0.0 &lt;U+221A&gt; dplyr 0.8.5 #&gt; &lt;U+221A&gt; tidyr 1.0.2 &lt;U+221A&gt; stringr 1.4.0 #&gt; &lt;U+221A&gt; readr 1.3.1 &lt;U+221A&gt; forcats 0.5.0 #&gt; -- Conflicts -------------------------------- tidyverse_conflicts() -- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() A Tidyverse R csomagjait jelenleg is intenzíven fejlesztik, így gyakran jelenik meg újabb és újabb verzió. Érdemes ellenőrizni, hogy a Tidyverse R csomagjai közül a legfrissebbeket használjuk-e. Ehhez a tidyverse csomag tidyverse_update() függvényét használjuk. tidyverse::tidyverse_update() # a Tidyverse R frissítése #&gt; The following packages are out of date: #&gt; #&gt; * lubridate (1.7.4 -&gt; 1.7.8) #&gt; * purrr (0.3.3 -&gt; 0.3.4) #&gt; * xml2 (1.2.5 -&gt; 1.3.1) #&gt; #&gt; Start a clean R session then run: #&gt; install.packages(c(&quot;lubridate&quot;, &quot;purrr&quot;, &quot;xml2&quot;)) Például a fenti esetben 3 csomag frissítését javasolja a tidyverse_update() függvény, és segítséget is ad a telepítőparancs listázásával. A javaslatban szereplő munkamenet törlés (Start a clean R session) az RStudio-ban az .rs.restartR() parancs vagy a Ctrl+Shift+F10 billentyűkombináció kiadásával valósítható meg. 3.2.1 Összefoglalás A Tidyverse R használatához elegendő telepítenünk a tidyverse csomagot, amely a többi 8 csomag telepítését automatikusan elvégzi. A telepítést a install.packages(“tidyverse”) paranccsal végezzük. Időnként ellenőrizzük a tidyverse::tidyverse_update() segítségével, hogy a legfrissebb változatát használjuk-e a Tidyverse R-t alkotó csomagoknak. 3.2.2 Feladatok Keressünk rá a Tidyverse R csomagjaira, és próbáljuk kideríteni az egyes csomagok fő célját, alkalmazási területeit! Derítsük ki, hogy az R Core Team vagy Hadley Wickham több R csomag szerzője! A fenti feladatok megoldása 3.3 Az R frissítése Ebben a fejezetben: bemutatjuk az Alap R, az RStudio és a csomagok frissítését. A R ideális használata során az RStudio-ban dolgozunk, és így érjük el az Alap R és az egyes csomagok szolgáltatásait. A mai napig mindhárom komponenst intenzíven fejlesztik, újabb és újabb funkciókat építenek be, és az esetleges hibákat rendre javítják a frissebb változatokban. Az Alap R évente kb. négyszer frissül, az RStudio háromszor, és érdemes időnként azt is ellenőrizni, hogy a gyakran használt csomagjainkból nincs-e frissebb példány. 3.3.1 Az Alap R frissítése A telepített Alap R verzióját az R.version.string végrehajtásával ellenőrizhetjük. Amennyiben az R hivatalos oldalán találunk frissebb példányt, akkor legalább két módszer segítségével frissíthetjük az Alap R-t. Megjegyezzük, hogy az Alap R sikeres frissítése után az RStudio automatikusan az új példányt fogja használni. 1. módszer (csak Windows alatt) Windows operációs rendszer alatt rendelkezésre áll az installr csomag, amelynek pontosan az a feladata, hogy kényelmesen telepíthessük számítógépünkre az Alap R legfrissebb verzióját. Az installr a régebbi verzióban lévő csomagokat az új változatba is átmozgatja, és ott azok frissítését is elvégzi. A következő parancsok futtatására van szükség. # install.packages(&quot;installr&quot;) # az installr csomag telepítése library(installr) # az installr csomag betöltése updateR() # az Alap R és a csomagok frissítése 2. módszer (minden operációs rendszeren) Az Alap R frissítésének másik módja, hogy telepítünk egy új példányt a régi R mellé. Azaz a korábban látott módon letöltjük és telepítjük az Alap R legújabb változatát, pontosan úgy, mintha még nem lenne a gépünkön működő R. Ez az új verzió azonban félkarú óriás mindaddig, amíg a régi R verzióban használt összes csomagot nem telepítjük újra az új verzióban is. Ezt magunk is megtehetjük, ha korábban összegyűjtöttük a csomagtelepítő parancsainkat, legyen szó akár akár a CRAN, a Bioconductor vagy a GitHub oldaláról származó csomagokról. Ha ezek a parancsok nem állnak rendelkezésre, akkor az Alap R frissítésének általános útját három lépésben foglalhatjuk össze. Indítsuk el az RStudio-t még az új R verzió telepítése előtt, és futtassuk le a következő sorokat. A futtatás eredménye egy bináris állomány (csomagok.rds), amely a régi R összes telepített csomagjának nevét és más információkat tartalmaz. Lépjünk ki az RStudio-ból. telepitett.csomagok &lt;- installed.packages(priority=&quot;NA&quot;) saveRDS(object = telepitett.csomagok, file = &quot;csomagok.rds&quot;) Telepítsük az Alap R új verzióját. Indítsuk el az RStudio-t és futtassuk le a lenti sorokat. A folyamat több percig is eltarthat. Az RStudio már az új R verziót használja, így a csomagok az új R tudását egészítik ki. telepitett.csomagok &lt;- readRDS(file = &quot;csomagok.rds&quot;) install.packages(pkgs=telepitett.csomagok[,1]) Megjegyezzük, hogy a fenti módszer segítségével csak a CRAN csomagjait tudjuk telepíteni, a Bioconductor és a GitHub oldalakról származó csomagok telepítését magunknak kell megismételni. Tehát a nem CRAN-ről származó csomagok telepítő parancsait mindenképp érdemes megőrizni. 3.3.2 Az RStudio frissítése A telepített RStudio példányunk verziószámát a Help / About RStudio menüpont segítségével, vagy az rstudioapi::versionInfo() parancs futtatásával ellenőrizhetjük. Frissebb verzió létezéséről a Help / Check for Updates menüpont ad tájékoztatást. Amennyiben találunk újabb verziót az RStudio hivatalos honlapján, töltsük le az operációs rendszerünknek megfelelő változatot és indítsuk el a telepítőt. Szerencsére a régi RStudio beállításait örökli az új példány, és a továbbiakban csak az új példány lesz elérhető. 3.3.3 Csomagok frissítése A korábban telepített csomagokat az RStudio Tools/Check for Package Updates menüpontjával frissíthetjük. A frissíthető csomagok megjelennek egy dialógus dobozban, jelöljük ki az összes csomagot és indítsuk el a telepítési folyamatot. A következő R parancs végrehajtásával is frissíthetjük a csomagjainkat. update.packages(ask=FALSE) 3.3.4 Összefoglalás Az Alap R, az RStudio és az egyes csomagok időről-időre megújulnak, érdemes évente legalább egy-két alkalommal elvégezni ezek frissítését. Az Alap R frissítése lényegében egy új verzió telepítését jelenti, a régi R továbbra is elérhető marad. Az RStudio frissítése után csak az új verziót használhatjuk. Az Alap R és az RStudio friss verziója a hivatalos honlapokról szerezhető be. A csomagok frissítéséhez használjuk az update.packages(ask=FALSE) parancsot. 3.3.5 Feladatok Az RStudio Tools/Check for Package Updates menüpontjával tájékozódjunk a telepített csomagjaink állapotáról. Végezzük el a szükséges frissítéseket! Mit tegyünk, ha nem sikerül valamelyik csomag telepítése? Ismerjük meg a telepített csomagjaink számát és forrását (CRAN vagy Bioconductor vagy GitHub)! A fenti feladatok megoldása "],["munka-az-r-ben.html", "4 Munka az R-ben 4.1 Az RStudio használata 4.2 Segítség az R használatához 4.3 Az Alap R használata", " 4 Munka az R-ben 4.1 Az RStudio használata Ebben a fejezetben: megismerjük az RStudio jellemzőit és felépítését, a konzolos és parancsállományos használat különbségeit, a parancsállományok és az RMarkdown állományok lehetőségeit, a projekt fogalmát és használatát, és az RStudio billentyűparancsait. Miután minden szükséges szoftverkomponenst feltelepítettünk, hogyan tudjuk működésre bírni az R-t? Tegyük fel, hogy van egy nagyon egyszerű adatfeldolgozási problémánk, szeretnénk megtudni a Csillagok háborúja c. film karaktereinek átlagos testmagasságát a filmben szereplő egyes fajokra jellemzően. Ha rátalálunk egy alkalmas adatbázisra, amely tartalmazza a szereplők testmagasságait és azt, hogy melyik fajhoz tartoznak, akkor még két konkrét adatelemzési lépés vár ránk: az adatbázis megnyitása, az átlagos testmagasságok meghatározása fajonként. Korábban láttuk, hogy az R parancssoros, tehát a fenti két lépést R parancsok formájában kell megfogalmaznunk. Azonban több kérdés is felmerül ezen a ponton: hová írjuk a parancsainkat, hogyan hajthatjuk őket végre, és végül, hol jelenik meg az eredmény. Ebben a fejezetben a fenti három kérdésekre fókuszálunk, és azt a kérdést, hogy mely konkrét parancsokkal érhetjük el a célunkat a könyv további fejezeteire halasztjuk. Máris megválaszoljuk a kérdéseket. Korábban láttuk, hogy az Alap R telepítésével elérhetővé válik a konzol, ahová parancsainkat begépelve, majd ENTER-t ütve utasításokat tudunk végrehajtani. Az RStudio telepítésével is kapunk egy konzolt, amelynek működése megegyezik az Alap R konzoljával: ide is gépelhetünk parancsokat, és ENTER-rel végrehajthatjuk őket. A parancsok eredmény is itt, a konzolban fog megjelenni. A kiinduló adatelemzési feladatunk megoldásához tehát vagy az Alap R vagy az RStudio konzoljába gépeljük be a következő parancsokat, sorról-sorra, és minden egyes sor végén üssünk ENTER-t (a konzol használatához a 4.1.4. és 4.1.4. fejezetekben találunk segítséget). A #-el kezdődő részeket nem szükséges begépelnünk, azok nem az R-nek szólnak, hanem a megjegyzés szerepét töltik be. install.packages(&quot;dplyr&quot;) # a dplyr csomag telepítése install.packages(&quot;psych&quot;) # a psych csomag telepítése data(starwars, package=&quot;dplyr&quot;) # adatbázis beolvasása csomagból # testmagasság átlagok fajonként psych::describeBy(starwars$height, starwars$species, fast=T, mat=T) A konzol azonban nem a legkényelmesebb módja az R parancsok végrehajtásának. Ezzel minden bizonnyal egyet értenek azok, akik a fenti sorok begépelését és végrehajtását valóban elvégezték a konzolban. A konzolba gépelés helyett érdemes egy szöveges állományban összegyűjteni az adatfeldolgozáshoz kapcsolódó R parancsainkat, ugyanis ezeket később kényelmesen elküldhetjük a konzolba végrehajtásra, pont úgy, mintha közvetlenül a konzolba gépeltük volna be őket. Ezeknek a szöveges állományoknak két fajtáját ismerjük meg ebben a könyvben: a parancsállományokat és az RMarkdown állományokat (a 11. fejezetben az RMarkdown állományokról többet olvashatunk). A parancsállományok és az RMarkdown állományok létrehozásához is a legtöbb segítséget az RStudio nyújtja: a parancsok begépelését drámaian leegyszerűsíti, és egyben számos más kényelmi funkciót is ajánl. Hová írjuk tehát az R parancsainkat? A legjobb válasz erre a kérdésre: az RStudio parancsállományaiba vagy RMarkdown állományaiba. Mielőtt valóban elvégeznénk ezen állományok létrehozását, ismerkedjünk meg az RStudio lehetőségeivel! 4.1.1 Az RStudio jellemzői Fontos tisztázni, az RStudio használatához feltétlenül szükség van a telepített Alap R-re, nélküle nem tudunk R parancsokat futtatni. Jó gyakorlat, ha az RStudio telepítése előtt telepítjük fel az Alap R-t, de a fordított sorrend sem okoz problémát. Sőt, ha az Alap R egy új verzióját telepítjük fel, akkor a korábban telepített RStudio már az új verziójú R futtató környezetét fogja használni. Az RStudio tudása tehát a végrehajtható R parancsok tekintetében megegyezik az Alap R tudásával, hiszen minden utasítás, amelynek a végrehajtását az RStudio-ban kezdeményezzük, végső soron az Alap R-rel telepített interpreterhez kerül, és a végrehajtásáért ő felel (4.1. ábra). ÁBRA 4.1: Az R kényelmes használata Az RStudio elsősorban a parancsok írását könnyíti meg, segítségével a parancsok létrehozásához kapunk rendkívüli segítséget. Megjegyezzük, hogy az RStudio egy üzleti vállalkozás neve is egyben, amely többféle terméket fejleszt. Ezek egyike az RStudio-nak nevezett integrált fejlesztőkörnyezet, kimondottan az R programozási nyelv számára. Foglaljuk össze, hogy melyek az RStudio erősségei: Parancsok írásának könnyítése. Az R parancsok begépelését számos eszköz segíti, például a kódkiegészítés, a szintaxisnak megfelelő kódszínezés és a tippek megjelenítése. Integrált környezetben, egy felületen látjuk a munka során szükséges összes komponenst. Az adatelemzési munka nem merül ki a parancsok begépelésében és végrehajtásában. Az R parancsokat jelentő forráskódon kívül kezelnünk kell az outputot, ami lehet szöveges és ábra jellegű is, valamint el kell igazodnunk a memóriában tárolt adatok között is. Sokszor a súgót is meg kell jelenítenünk, és információval kell rendelkeznünk a telepített csomagokról is. Az RStudio nagy előnye, hogy mindezt egyetlen integrált felületen láthatjuk és ezen keresztül vezérelhetjük. Projektek használata. Az RStudio támogatja a projektek használatát is, amellyel az adott adatfeldolgozási folyamat összetevőit – az adatállományokat, parancsállományokat, RMarkdown állományokat, képállományokat és dokumentációkat –, egyetlen könyvtárba foghatjuk össze, és a forráskódból relatívan hivatkozhatunk ezekre az állományokra. Publikálás támogatása. Az RMarkdown segítségével kényelmesen és reprodukálható módon hozhatunk létre például PDF, HTML és Word formanyelvű dokumentumokat, vagy PDF, HTML és PowerPoint bemutatókat. További lehetőségek. Az RStudio támogatja a Shiny Webes alkalmazások fejlesztését, de saját csomagok létrehozásához is kapunk segítséget. Az RStudio támogatja a Git verziókezelő használatát is. Az RStudio fenti lehetőségeinek bemutatása külön könyvet igényelne, de a mindennapi munkához szükséges ismereteket most bemutatjuk. 4.1.2 Az RStudio felépítése Az RStudio indítása után egy több panelból álló alkalmazást látunk. Első indításnál három részre van osztva az alkalmazás, vagyis három panel látható, de a tipikus használat során négy panelünk van. Válasszuk ki először a File / New file / New R Script menüpontot, amely egy új parancsállomány létrehozását kezdeményezi. E lépés után már biztosan a négy-paneles, 4.2. ábrán látható elrendezést kapjuk. Az ábrán megneveztük az egyes részeket, a két bal oldali panel a Forrás és a Konzol, a jobb oldaliak a Környezet és az Ábra. Figyeljük meg, hogy a panelek tetején fülek láthatók, így az egyes paneleken különböző lapokat tudunk kiválasztani, egy panel tehát több lapot is tartalmazhat. A panelek szélessége és magassága állítható, egyrészt az elválasztó sávokat az egér segítségével mozgathatjuk, másrészt a panelek méretező gombjain (az egyes panelek jobb felső sarkában) is kattinthatunk. A méretezés során eltűnhetnek panelek, de a sávok mozgatásával vagy a View / Panes / Show All Panes menüponttal láthatóvá tehetjük az összes panelt. ÁBRA 4.2: Az RStudio tipikus képernyőképe A legtöbb időt a Forrás nevű bal felső panelben töltjük, mert alapértelmezetten itt jelennek meg a parancsállományok és az RMarkdown állományok lapjai. Az R parancsainkat tehát ide írjuk. Az RStudio első indításánál ez a panel üres, de a további indításoknál a korábban szerkesztett, de be nem zárt lapok automatikusan megnyílnak. Itt helyeztünk el korábban egy parancsállomány lapot a File / New file / New R Script segítségével. Ez a lap egy egyszerű szövegszerkesztő. Győződjünk meg erről, próbáljuk ki, mert a jövőben ebben a szövegszerkesztőben töltjük a legtöbb időt! A fejezet végi kitűzött feladatok között rákérdezünk a szövegszerkesztési ismeretekre. Oldjuk meg most azt a feladatot, majd térjünk vissza ide! A bal alsó panel a Konzol nevet viseli, vagyis ez az RStudio konzolja, melynek használata és célja megegyezik az Alap R konzoljával. Vagyis begépelhetünk parancsokat, és az ENTER-rel végrehajtjuk őket. Azonban a konzol mindössze egysoros szövegszerkesztési lehetőséget kínál, lényegében egyszerre egy parancs begépelésére és végrehajtására van lehetőségünk. Ez lényegesen eltér a Forrás panel parancsállomány vagy RMarkdown lapján lévő teljes értékű szövegszerkesztőtől, ahol több sor begépelésére és végrehajtására van lehetőségünk. A konzol azonban mégis központi szerepet kap, mert alapesetben az R csak a konzolba kerülő parancsokat tudja végrehajtani. A parancsállományok és RMarkdown állományok R parancsait is valahogyan át kell ide irányítani, úgy mintha ide gépeltük volna be őket. De a konzol nem csak a parancsainkat, azaz az inputot, hanem azok eredményét, az outputot is tartalmazza. A két jobb oldali panel többfunkciós. A jobb felső, Környezet panelben jelennek meg a munka során létrehozott objektumok nevei (Environment lap), valamint a parancsok története (History lap). Az Environment lapon megjelenő adatbázis nevén kattintva a Forrás panelben egy külön lapon megjelenik az adatbázis tartalma, így kapjuk az ún. adatbázis lapot. A jobb alsó Ábra panel tartalmazza a súgót (Help lap), a munka során rajzolt ábráinkat (Plot lap), a csomagjaink listáját (Packages lap) és a munkakönyvtárunk állományait, könyvtárait (Files lap). A két jobb oldali panel elnevezés önkényes volt, hiszen az Environment és a Plot csak egy-egy lap neve ezeken a többfunkciós paneleken. 4.1.3 Az RStudio beállításai Mielőtt elkezdjük a munkát az RStudio-ban feltétlenül módosítsunk néhány alapbeállítást. Az RStudio működését az Tools / Global Options menüpont alatt változtathatjuk meg. UTF-8 kódolás beállítása. A fenti menüpont kiválasztása után a bal oldali listából a Code, majd a fenti opciók közül a Saving opciót válasszuk. A 4.3. ábrán is látható módon, érjük el, hogy a Default text encoding alatt az UTF-8 legyen kiválasztva. Fontos, hogy minden szöveges állományunk UTF-8 kódolású legyen. ÁBRA 4.3: Az UTF-8 beállítása az RStudio-ban A munkaterület automatikus mentésének tiltása. A bal oldalon a General menüpont kiválasztása után a Basic opció alatt vegyük ki a pipát a Restore .RData into workspace at startup elől, valamint a Save workspace to .RData on exit választót állítsuk Never-re (4.4. ábra). Az RStudio projekt szemléletű használata mellett erre a mentési funkcióra nincs szükség. ÁBRA 4.4: A munkaterület automatikus mentésének tiltása az RStudio-ban Az output megjelenítésének tiltása az RMarkdown lapon. A bal oldalon az RMarkdown menüpont kiválasztása után vegyük ki a pipát a Show output inline for all R Markdown documents elől (4.5. ábra). Ez a beállítás gördülékenyebb szerkesztést biztosít az RMarkdown lapokon. ÁBRA 4.5: Az output megjelenítésének tiltása az RMarkdown lapon Opcionális lehetőségként a panelek tartalmán is változtathatunk a Tools / Global Options / Pane Layout menüpontban. Az RStudio színösszeállításán az Appearance menüpont Editor theme beállításával változtathatunk. Javasolt a Tomorrow Night Bright vagy más, sötétebb háttérszínnel rendelkező téma használata. 4.1.4 Az RStudio konzol Az RStudio konzolja a Konzol panel egyik lapján található (4.2. ábra). A konzol az RStudio kulcsfontosságú része, korábban láttuk, hogy minden R parancsot a végrehajtás előtt ide kell irányítani. Végrehajtása után a szöveges eredmények is itt jelennek meg, és a hibaüzeneteket is itt olvashatjuk. Láthatjuk tehát, hogy a konzol figyelmünk középpontjában áll a munka során. Közvetlenül azonban nagyon ritkán gépelünk parancsot a konzolba, erre a Forrás panel parancsállomány vagy RMarkdown lapját fogjuk használni. Ebben a részben mégis a konzolt mutatjuk be, ugyanis meghatározó szerepe miatt értenünk kell működését. A konzol működése nagyon egyszerű: egysoros parancsokat gépelünk be a &gt; prompt után, ENTER-t nyomunk, az R interpreter értelmezi és végrehajtja a begépelt parancsot, és megjelenik az eredmény vagy egy hibaüzenet. Ezt követően egy újabb sor begépelésére van lehetőségünk, ENTER után annak az értelmezése következhet, majd az eredmény megjelenítése jön, és így tovább. Próbáljuk ki mi is a konzolt! Bátran gépeljünk be parancsokat. Például a citation() parancs outputja fontos lehet az R-el végzett munkáink publikálásánál, hiszen megmutatja hogyan hivatkozhatunk az R statisztikai programra, vagy valamelyik csomagjára. &gt; citation() &gt; citation(package = &quot;ggplot2&quot;) Fontos információ az Alap R és az RStudio pontos verziószáma, ezt a információt az R.Version() és a RStudio.Version() függvény szolgáltatja. Gépelésnél vigyázzunk a kis- és nagybetűk helyes bevitelére, mert az R megkülönbözteti ezeket. &gt; R.Version() &gt; RStudio.Version() A konzol lehetőségeinek szisztematikus megismerését folytassuk egy egyszerű paranccsal: &gt; 1+2 [1] 3 A konzolban most is megjelent az eredmény, ahogy ezt az összes eddigi parancsunk esetében láthattuk. Azonban nem minden parancs után jelenik meg output a konzolban. Például a következő parancsnak nincs eredménysora a konzolban, de ez messze nem jelenti azt, hogy nem történt semmi (történt: létrehoztunk egy objektumot). &gt; x &lt;- 3 Sőt, az is előfordulhat, hogy az R nem talált valamit rendben a parancsban. Ekkor természetesen nem hajtja/hajthatja végre a begépelt sort, helyette hibát jelez. &gt; Ez nem lesz jó. A válasz a fenti “parancsra” az Error: unexpected symbol in \"Ez nem\" hibaüzenet lesz. Alapvető szabály, ha a válaszban megjelenik az Error szócska, akkor a parancsunkat valamilyen ok miatt nem tudta végrehajtani az R értelmező, és az Error utáni részből tájékozódhatunk a hiba okáról. Minden más esetben sikeres volt a végrehajtás. Hosszabb, bonyolult parancsok gépelésénél gyakran előfordul, hogy valamiért nem sikerül “teljessé” tenni a begépelt parancsot, valami még hiányzik belőle (például egy záró kerek zárójel). Ezt az R értelmező észreveszi és az ENTER megnyomása után egy + folytatás prompt megjelenítésével jelzi ezt számunkra. A + prompt után van lehetőségünk a hiányzó részek pótlására, majd ha készen vagyunk az ENTER billentyűvel az összes eddig még végre nem hajtott sort elküldhetjük az értelmezőnek. Gépeljük be a következő parancsot, három egymás utáni sorba, ENTER-ekkel elválasztva. &gt; paste(&quot;Ez már&quot;, + &quot;jó&quot; + ) [1] &quot;Ez már jó&quot; A paste(\"Ez már\", kerüljön az első sorba, majd nyomjunk ENTER-t. Az R nem hajtja végre a sort, de erre a nyilvánvalóan hibás, befejezetlen parancsra hibaüzenetet sem jelenít meg. Helyette felajánlja a parancs folytatását, befejezését egy új sorban, amely már a + prompttal kezdődik. A második sorba gépeljük be az \"jó\" karaktersorozatot, nyomjuk meg az ENTER-t. Sajnos még ez sem tette teljessé a parancsunkat, így további folytatásra van lehetőségünk a + után a harmadik sorban. Ide gépeljük be a hiányzó ) részt, és üssünk ENTER-t. A parancsunk teljessé vált, megkapjuk az eredményt a konzolban, pontosan úgy, mintha a három sort egyetlen sorba gépeltük volna. Legyünk nagyon óvatosak a konzol folytatás prompt funkciójával. Ha például az R nem találja a parancs hiányzó részét, akkor a konzol ezen kényelmi funkciója oda vezethet, hogy folyamatosan a + promptot kapjuk az ENTER megnyomása után. Ezt a helyzetet hivatott megoldani az ESC billentyű, mellyel megszakíthatjuk az értelmező parancsfeldolgozási kísérletét. Az ESC megnyomása után visszakapjuk a &gt; prompttal kezdődő (üres) sort, vagyis tiszta lappal, új, lehetőség szerint teljes parancs gépelésébe kezdhetünk. A parancssorba mindig teljes parancsot gépeljünk, amint megjelenik a + folytatás prompt, azonnal szakítsuk meg az ESC megnyomásával az értelmezési folyamatot. Az R konzolos használatát két funkció valóban kényelmesebbé teszi. Egyrészt a korábban végrehajtott parancsainkat visszahívhatjuk, lapozhatunk bennük előre, hátra. Erre a FEL/LE NYÍL billentyűkkel van lehetőségünk. Ezt history-nak is nevezzük, vagyis a parancsok történetének. Természetesen, az így visszahívott parancsot tetszőleges módon átszerkeszthetjük: navigálhatunk a sorban előre hátra, beszúrhatunk/törölhetünk karaktereket vagy használhatjuk a vágóasztal billentyűparancsait. A visszahívott és módosított parancsot az ENTER segítségével újra végrehajthatjuk, és ehhez még a sor végére sem kell a szövegkurzort pozicionálni, az a sorban tetszőleges helyen állhat, az R mégis a teljes sort fogja értelmezni. A másik kényelmi lehetőség a TAB billentyű használata, amellyel az elkezdett, de még be nem fejezett sorokat egészíthetjük ki. Ha egy sort többféleképpen is kiegészíthet az R, akkor egy listát kapunk a lehetőségekről, amelyet továbbgépeléssel szűkíthetünk, ha pedig csak egyetlen szóba jöhető befejezése van a begépelt karaktereknek, akkor a TAB megnyomása után ezzel a résszel kiegészül az elkezdett sorunk. Így nemcsak egyszerűen gépelést, illetve időt takaríthatunk meg, hanem például tájékozódhatunk a korábban létrehozott objektumok nevéről vagy az elérhető függvények névéről és paramétereiről is. Az objektum, a függvények és az egyéb ebben a fejezetben homályosan hagyott fogalmak definícióit a könyv későbbi részeiben részletesen tárgyaljuk. 4.1.5 Parancsállományok Láthattuk, hogy a konzolba egyszerre csak egy parancsot gépelhetünk be, úgy is gondolhatunk a konzolra, mint egy egysoros szövegszerkesztőre. Begépelünk egy sort és végrehajtjuk az ENTER-rel. A problémáink többsége viszont nem oldható meg egyetlen paranccsal, csak több tízzel vagy százzal, ezért ez az interaktív, konzolos használat nem alkalmas hosszabb elemzésre. Parancsainkat begépelhetjük egy .R kiterjesztésű, egyszerű, formázás nélküli szöveges állományba is. Az ilyen szöveges állományt parancsállománynak vagy szkriptállománynak nevezzük. Ilyen szöveges állományok létrehozására tetszőleges szövegszerkesztő alkalmas, de természetesen mi az RStudio segítségével fogjuk ezeket elkészíteni, ugyanis itt kapjuk a legnagyobb segítséget a parancsok gépeléséhez, majd végrehajtásához. A Forrás panel tartalmazza a parancsállomány lapokat, létrehozásuk a korábban látott File / New file / New R Script menüponttal történik. Parancsállományok mentésére és már létező megnyitására is van lehetőségünk a megfelelő menüpont kiválasztásával (File / Save és File / Open File). A parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, hiszen a konzol egysoros szövegszerkesztője helyett egy szinte végtelen sok parancssor begépelésére alkalmas szövegszerkesztő áll rendelkezésünkre. Mint minden szövegszerkesztőben, a különböző billentyűparancsok és a vágóasztal itt is megkönnyíti szerkesztés folyamatát. Az ENTER jelentése parancsállományos környezetben a szövegszerkesztőkben megszokott újsor beszúrása, ami lényegesen különbözik a konzolos használat parancs végrehajtási funkciójától. A parancsaink interaktív végrehajtásáért az RStudio-ban a Code/Run selected line(s) menüpont, vagy még gyakrabban a Ctrl+Enter billentyűkombináció felel. Ezekkel a módszerekkel tudjuk a parancsainkat a konzolba irányítani és végrehajtani. De nézzük meg ezt a gyakorlatban! 4.1.6 Munka az RStudio-ban Kezdjük a munkát! Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljünk be néhány sort. Figyeljük meg, hogy milyen sokat segít az RStudio a lenti sorok begépelésében. Az értékadás (&lt;-) operátort az Alt+- billentyűkombináció segítségével vigyük be. 1+23 getwd() # munkakönyvtár kiírása x &lt;- mean(1:100) plot(1:10) ?mean cat(&quot;- Vége -\\n&quot;) A szövegkurzorral álljunk az első sorra, és hajtsuk végre Ctrl+Enter billentyűparancsot. Láthatjuk, hogy (1) a sor átkerül a konzolba, (2) az RStudio végrehajtja a sort és az eredményt a konzolban megjeleníti, és (3) a szövegkurzor lejjebb lép a következő végrehajtható sorra. Egy újabb Ctrl+Enter így már ezt a sort hatja végre, és így tovább. Ha a sorok végrehajtása közben hibaüzenetet kapunk (Error), ne essünk kétségbe, a hibaüzenet a munka része. Nézzük át figyelmesen a begépelt sorainkat, javítsuk őket, és futtassuk újra az összes sort, fentről lefelé a Ctrl+Enter-ek segítségével. A parancsok végrehajtása során láthatjuk mennyire kényelmes, integrált környezetben találtuk magunkat. Az x &lt;- mean(1:100) hatására az Environment lapon megjelent az x objektum neve és értéke. A Plot lapon láthatunk egy ábrát, amit a plot(1:10) rajzolt meg, és a ?mean a Help lapon mutatja meg a mean() átlagszámoló függvény beépített súgóját. Mentsük el parancsállományunkat a File / Save vagy a Ctrl+S segítségével. Korábban létrehozott parancsállományokat a File / Open menüponttal nyithatunk meg. A soronkénti végrehajtás mellett nagyon gyakori a kijelölt szövegrészek végrehajtása, amit szintén a Ctrl+Enter-rel tudunk kezdeményezni. A kijelölt rész lehet több sor, a teljes parancsállomány, vagy valamelyik sor egy része. Ez utóbbi próbáljuk ki úgy, hogy a parancsállomány első sorában csak az 1+2 részt jelöljük ki, és ezt hajtsuk végre a Ctrl+Enter segítségével. Az eredmény a konzolban a 3 lesz. A teljes szkriptállomány végrehajtásához jelöljük ki Ctrl+A segítségével a parancsállomány összes sorát, és nyomjuk meg a Ctrl+Enter-t. A konzolban tudjuk ellenőrizni, hogy minden sort újra végrehajtottunk. Térjünk vissza a kiinduló adatelemzési problémánk megoldásához. Láttuk, hogy az R parancsok összegyűjtésére és végrehajtására a .R kiterjesztésű parancsállományok kiváló megoldást nyújtanak. Emlékezzünk vissza a fejezet eleji példára, amelyben a Csillagok háborúja c. film karaktereinek átlagos testmagasságát kerestük. Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljük be a megoldást jelentő sorokat. # A Csillagok háborúja c. film karaktereinek átlagos testmagassága # Abari Kálmán # 2022. 07. 06. # install.packages(&quot;dplyr&quot;) # a dplyr csomag telepítése # install.packages(&quot;psych&quot;) # a psych csomag telepítése data(starwars, package=&quot;dplyr&quot;) # adatbázis beolvasása csomagból # testmagasság átlagok fajonként psych::describeBy(starwars$height, starwars$species, fast=T, mat=T) Látható, hogy a feladat tényleges megoldását jelentő két R parancs mellett megjegyzéseket is becsempésztünk, hogy később is tudjuk, ki, mikor és miért készítette ezt a parancsállományt (a # utáni részeket a sor végéig az R figyelmen kívül hagyja; részletesebb információkat a megjegyzésekről a 5.1.3. fejezetben olvashatunk). Futtassuk a sorokat a Ctrl+Enter segítségével, fussuk át a kiszámolt átlagos testmagasságokat az output mean oszlopában, majd mentsük el a szkriptállományt Ctrl+S-sel starwars.R néven. Később, napok, hetek vagy hónapok múlva, újra megnyithatjuk starwars.R állományunkat (File / Open), és újra lefuttathatjuk mini-elemzésünket. Ezzel a fejezet eleji adatelemzési feladatunkat megoldottuk. Vajon lehet ezt ennél jobban csinálni? Igen! 4.1.7 RMarkdown állományok Az R parancsainkat olyan .Rmd kiterjesztésű, egyszerű, szöveges állományokban is összegyűjthetjük, amelyek többet nyújtanak, mint a parancsállományok, de szerkezetük kicsit kötöttebb. Az ilyen szöveges állományok az RMarkdown állományok. Miben nyújtanak többet: ahogyan a 11. fejezetben részletesen áttekintjük, az RMarkdown állományok az eredmények publikálásához, például HTML, PDF vagy Word formanyelvű állományok létrehozását teszik lehetővé. Hozzunk létre az RStudio-ban a File / New File / R Markdown menüponttal egy új RMarkdown állományt. A megjelenő dialógusdobozban töltsük ki a Title és Author mezőket, azaz adjunk címet és szerzőt a dokumentumhoz, majd kattintsunk az OK gombon. A Forrás panelen megjelenik egy új RMarkdown lap, amely egy alapértelmezett tartalommal jön létre, és nem üresen, mint a parancsállományok esetében. Említettük, hogy az RMarkdown állományok szerkezete kötöttebb, ez az alapértelmezett tartalom az eligazodásban segít minket. Érjük el, hogy az új RMarkdown ezeket a sorokat tartalmazza (a szerző neve a sajátunk legyen): --- title: &quot;A Csillagok háborúja c. film karaktereinek átlagos testmagassága&quot; author: &quot;Abari Kálmán&quot; date: &#39;2022. 07. 06.&#39; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` Adatok beolvasása és az átlagok kiírása ```{r} # install.packages(&quot;dplyr&quot;) # a dplyr csomag telepítése # install.packages(&quot;psych&quot;) # a psych csomag telepítése data(starwars, package=&quot;dplyr&quot;) # adatbázis beolvasása csomagból # testmagasság átlagok fajonként psych::describeBy(starwars$height, starwars$species, fast=T, mat=T) ``` Minden RMarkdown állomány egy fejléccel kezdődik, amelyet a --- karakterek határolnak. A természetes nyelvű szöveget szabadon a fejléc alatti részben bárhová írhatjuk, az R parancsokat azonban ún. R csonkokban kell elhelyeznünk, amelyeket speciális kezdő és záró sorok határolnak. A 11. fejezetben részletesebben olvashatunk ezekről. Most elégedjünk meg annyival, hogy egy RMarkdown állományban tetszőlegesen sok R csonkot elhelyezhetünk, és egy R csonk tetszőlegesen sok R parancsot tartalmazhat. Egy R csonkon belül a parancsok végrehajtása ugyanúgy Ctrl+Enter-rel történik, mint a parancsállományok esetében. Próbáljuk ki! A most begépelt RMarkdown állományunk második csonkjában lévő két R parancsot hajtsuk végre két Ctrl+Enter segítségével. A mini-elemzés eredménye ismét a konzolban látható. Hogyan foglalhatnánk össze a parancsállományok és az RMarkdown állományok közötti különbséget? A 4.1. táblázatban láthatjuk, hogy mindkét állományban összesen három különböző tartalmat szoktunk rögzíteni: fejléc információt arról, hogy mi az elemzés célja, ki és mikor készítette az állományt, magyarázó, természetes nyelvű szöveget (pl. magyar vagy angol nyelven), és az adatelemző R parancsokat. Az R parancsokat szabadon írhatjuk a parancsállományokba, viszont a fejléc információt és a magyarázó szövegeket megjegyzésbe kell tenni. Az RMarkdown állományokba a magyarázó, természetes nyelvű szövegek írhatók szabadon, míg az R parancsokat csonkokba, a fejléc információt pedig kötött módon, az állomány elejére kell írnunk. TÁBLÁZAT 4.1: A parancsállomány és az RMarkdown állomány összehasonlítása Tartalom Parancsállomány (.R) RMarkdown (.Rmd) Fejléc szöveg cím, szerző, dátum megjegyzésbe fejlécbe Magyarázó szöveg természetes nyelvű szöveg megjegyzésbe bárhová Adatelemzés R parancs bárhová R csonkba Valóban annyiban áll a különbség a két állománytípus között, hogy a máshová és máshogyan írjuk az R parancsokat és az egyéb magyarázó/fejléc szövegeinket? Nem. A 11. fejezetben részletesen bemutatjuk, hogy az RMardown állományok ereje abban van, hogy egy fordítási folyamat (knit-elés) során, olyan PDF, HTML vagy Word állományt tudunk előállítani, amely a magyarázó/fejléc szövegeken, és az R parancsokon kívül, az R parancsok outputját is tartalmazza, legyen az szöveges vagy ábra jellegű output. 4.1.8 Projektek használata Mostanra nagyon közel kerültünk az általunk ajánlott adatelemzési munkaformához, ugyanis már tudunk az RStudio-n belül parancsállományokat és RMarkdown állományokat használni. Még egy összetevő azonban kulcsfontosságú a kényelmes munkához: az RStudio-ban minden esetben projektet kell használnunk. Az RStudio lehetőséget ad arra, hogy minden egyes adatfeldolgozási feladatunkhoz egy projektet rendeljünk. Egy RStudio projekt minimálisan egy projekt könyvtárat és az ebben lévő lévő .Rproj kiterjesztésű projektállományt jelenti. Ezeket a következő módszerrel hozhatjuk létre. Először kattintsunk a File / New Project menüponton. Válasszuk ki a New Directory opciót (4.6. ábra), majd a New Project nyomógombon kattintsunk (4.7. ábra). ÁBRA 4.6: RStudio projekt létrehozása: 1. lépés A Directory name szöveges mezőbe a projektünk nevét határozhatjuk meg, ami egyben az új projektünk könyvtárneve is lesz. Adjuk meg itt az elso_projekt nevet. A Create project as subdirectory of mezőben azt a szülő könyvtárat határozhatjuk meg, ahová a projekt könyvtárunkat el szeretnénk helyezni. Ezt szabadon megválaszthatjuk, lehet az adott felhasználó dokumentumok könyvtára is. A projekt létrehozását a Create Project nyomógombbal fejezhetjük be. ÁBRA 4.7: RStudio projekt létrehozása: 2. lépés Két nagyon fontos dolog történt a fentiek hatására. Egyrészt a számítógépünkön létrejött az elso_projekt projektkönyvtár, és benne az elso_projekt.Rproj projektállomány, másrészt az RStudio ún. projekt üzemmódba került, azaz az elso_projekt lesz az aktív projekt. Az RStudio-ban egyszerre egy projekt lehet aktív, de elképzelhető, hogy egyetlen projekt sem aktív. Az RStudio felületén a jobb felső sarokban tájékozódhatunk, ahol most az elso_project feliratot látjuk, de amennyiben nincs aktív projektünk, akkor a Project: (none) feliratot olvashatjuk. Kerüljük a projekt nélküli állapotot. ÁBRA 4.8: RStudio projekt létrehozása: 3. lépés Minden adatfeldolgozási feladathoz – még a legkisebbhez is – hozzunk létre projektet. Minden állományt, amely a feladathoz tartozik a projektkönyvtáron belül helyezzünk el. Milyen állományok jöhetnek szóba: például parancsállományok, RMarkdown állományok, adatállományok, képállományok, dokumentációk és hivatkozásokat tartalmazó állományok. Érdemes ezeket rendezetten, ha szükséges, alkönyvtárakba szétosztva tárolni. Jó gyakorlat lehet, hogy a parancsállományokat és az RMarkdown állományokat közvetlenül a projektkönyvtárban (most ez az elso_projekt), az adatállományokat egy adat alkönyvtárban a projektkönyvtáron belül (most elso_projekt/adat) tároljuk, a képállományok és dokumentációk helye pedig lehet az elso_project/kep, illetve elso_projekt/doku alkönyvtár. Válthatunk egy másik projektre is (File / Open Project), de be is zárhatjuk az aktív projektet (File / Close project). Később újra megnyithatjuk ezt is a File / Open Project segítségével. A megnyitás során természetesen az .Rproj kiterjesztésű projektállományt kell kiválasztanunk. Ritkábban az is előfordulhat, hogy az adatfeldolgozási folyamatunkkal kapcsolatos állományok összegyűjtését korábban elkezdtük, és csak később szeretnénk ezt a könyvtárat egyben RStudio projektkönyvtárként is felhasználni. ÁBRA 4.9: RStudio projekt létrehozása: létező könyvtár megadása Korábban létrehozott könyvtárból szintén a File / New Project menüpont segítségével hozhatunk létre RSudio projektkönyvtárat. Itt azonban az Existing Directory opciót kell kiválasztani (4.6. ábra). Ezt követően ennek a létező könyvtárnak az elérési útját kell megadnunk az 4.9. ábrán látható beviteli mezőben. Végül foglaljuk össze, milyen előnyökkel jár a projekt használata: A logikailag egy adatfeldolgozási folyamathoz tartozó állományainkat fizikailag is együtt tudjuk tartani. Projekt üzemmódban az RStudio az aktuális könyvtárat a projektkönyvtárra állítja, így relatív hivatkozást használhatunk a kódunkban, amely a projekt hordozhatóságát biztosítja különböző számítógépek között. 4.1.9 Billenytűparancsok Az RStudio legfontosabb billentyűparancsa a Ctrl+Enter, amely a parancsot a konzolba küldi végrehajtásra. Van még néhány további billentyűparancs, amelyet érdemes felsorolni, hiszen ezek használatával gyorsítani, egyszerűsíteni tudjuk a munkánkat. Ctrl+Shift+N: új parancsállomány létrehozása, Ctrl+S: állomány mentése, Ctrl+W: lap bezárása a Forrás panelen, Ctrl+Tab / Ctrl+Shift+Tab: aktív lap léptetése előre és hátra a Forrás panelen, Ctrl+F: szöveg keresése és cseréje, Tab: kód kiegészítése, Ctrl+Shift+C: kijelölt sorok be- vagy kikommentelése, Ctrl+Alt+Fel / Le (és Shift+Jobbra / Balra): a kurzor magasságának állítása (és az oszlopszélesség beállítása) több sor szerkesztésére, Esc: a Konzol panelen kilépés a folytatás promptból, a Forrás panelen kilépés a többsoros szerkesztésből, Alt+Fel / Le: sor mozgatása fel vagy le, Alt+Shift+K: billentyűparancsok módosítása, Alt+-: értékadó operátor (&lt;-) beszúrása, Ctrl+Shift+M: pipe operátor (%&gt;%) beszúrása, Ctrl+Enter: az aktuális sor vagy a kijelölt rész futtatása, Ctrl+Alt+R: a teljes parancsállomány futtatása, Ctrl+Shift+P: a kurzor feletti csonkok parancsainak futtatása, Ctrl++ / Ctrl+-: betűméret nagyítása vagy kicsinyítése, Ctrl+Shift+F10: a munkamenet újraindítása. Ha valamelyik kombináció nem működik a számítógépünkön, akkor a Tools / Modify Keyboard Shortcuts menüpont alatt új billentyűparancsot adhatunk az ott felsorolt funkciókhoz. 4.1.10 Összefoglalás Az adatelemzési munka során az RStudio -t használjuk projekt üzemmódban, miközben RMarkdown állományba gyűjtjük az elemző R parancsokat és az egyéb magyarázó és fejléc szövegeket. Ebben a fejezetben ezt a tételmondatot töltöttük meg tartalommal. Megismertük az RStudio integrált környezetét. A Forrás panel lehetséges lapjai a parancsállomány, az RMarkdown állomány és az adatbázis. A Konzol panel legfontosabb lapja a konzol, amely központi szerepet játszik a munka során, hiszen a Ctrl+Enter-rel végrehajtott R parancsok eredménye és az esetleges hibaüzenetek is itt jelennek meg. A munka során a .R kiterjesztésű parancsállományok kiválóan alkalmasak a hosszabb elemzések R parancsainak tárolására, de ha a publikáláshoz is segítséget szeretnénk kapni, akkor inkább a a kötöttebb szerkezetű .Rmd kiterjesztésű RMarkdown állományba rögzítsük parancsainkat. Az RStudio rutinszerű használatához a billentyűparancsok ismerete is hozzátartozik. A projektszemlélet az adatelemzéssel kapcsolatos állományok egyben tartásáról, és a hordozhatóság biztosításáról szól. 4.1.11 Feladatok Bizonyosudjunk meg róla, hogy az alapvető szövegszerkesztési ismeretek birtokában vagyunk. Ismerjük az Insert billentyű funkcióját? Találjunk legalább 8 módszert, amely kizárólag a billentyű segítségével mozgatja a szövegkurzort! A szövegkijelölésnek milyen billentyűparancsait ismerjük? Milyen karaktertörlési lehetőségeket ismerünk? Ismerjük mindhárom vágóasztal-művelet billentyűparancsát? Az RStudio mellett milyen más intergrált fejlesztőeszközök léteznek az R-hez? Az Appearance menüpont Editor theme beállításával változtassunk az RStudio színösszeállításán. Keressük meg a legjobban hozzánk illőt! Vegyük figyelembe, hogy hosszútávon a minél sötétebb háttér a jó választás. A fenti feladatok megoldása 4.2 Segítség az R használatához Ebben a fejezetben: megismerjük az R hivatalos dokumentációit, az ún. cheet-sheet-ek forrását, és a parancssorból elérhető súgó parancsokat. Az R használatához számos segítséget találunk az Interneten, a telepített Alap R-ben és az RStudio-ban egyaránt. Az online segítségek közül elsősorban a http://cran.r-project.org címen olvasható R dokumentációkat emeljük ki, ahol több tucat, elsősorban angol nyelvű leírást találunk az R megismeréséhez. A bal oldali Documentation / Manuals menüpont alatt találjuk például az R hivatalos bevezető dokumentumát (An Introduction to R), melynek tanulmányozása rendkívül nagy lépést jelenthet az R alaptudás megszerzéséhez. Az említett menüpont alatt találjuk még a contributed documentation linket is, amely számos rövidebb, és hosszabb dokumentációt tartalmaz, angol és más nyelveken. Itt találjuk Solymosi Norbert nagyszerű magyar nyelvű R bevezetőjét is. Az R népszerűségének köszönhetően, nagyon sok további dokumentációt, tutoriált és példát találhatunk, ha az internetes keresőkhöz fordulunk. A fejezet végi egyik kitűzött feladatban összeállíthatjuk a saját listánkat. Rendkívül népszerűek ma az ún. cheat-sheet-ek, amelyek néhány PDF oldalon sok ábrával, és a lényeg kiemelésével mutatják be egy-egy témakör legfontosabb tudnivalóit. Az RStudio Help / Cheetsheets menüjéből, vagy közvetlenül a https://www.rstudio.com/resources/cheatsheets/ címről számos R téma cheet-sheet-jét érhetjük el. Most tekintsük át azokat a súgókat, amelyek az R parancssorából indíthatók. Az R megismerését kezdhetjük a help.start() paranccsal, ahol számos, az R nyelvet részletesen tárgyaló dokumentum közül választhatunk. Ha csak egyetlen függvénnyel kapcsolatban szeretnénk segítséget kérni, akkor használhatjuk a beépített súgórendszer parancsait. Adjuk ki a help(t.test) vagy a rövidebb ?t.test parancsot, ha a t.test() függvényről szeretnénk részletes leírását kapni. A ?függvénynév lehetőség, minden függvény esetében rendelkezésre áll a súgó kikérésére. Abban az esetben, ha nem ismerjük teljesen a függvény nevét, használhatjuk a help.search(&quot;test&quot;) parancsot, ekkor az összes olyan függvényt kilistázhatjuk, amelynek a nevében vagy a leírásában a test karaktersorozat előfordul. Hasznos lehet továbbá a find() parancs, amely elárulja, hogy az illető függvény melyik már betöltött csomagban foglal helyet. find(&quot;aov&quot;) #&gt; [1] &quot;package:stats&quot; A fenti példából kiolvasható, hogy az aov() függvény a stats csomagban található. Ugyancsak a betöltött csomagokban végez keresést az apropos() függvény, amellyel lehetőség van a parancssorból elérhető függvények vagy objektumok nevében keresni. apropos(&quot;aov&quot;) #&gt; [1] &quot;aov&quot; &quot;eff.aovlist&quot; &quot;summary.aov&quot; Tovább segítheti az egyes függvények használatának elsajátítását az example() parancs, amely az egyes függvények használatára mutat példát. example(t.test) Utolsó lehetőségként ejtsünk szót a demo() függvényről, amellyel olyan beépített szkripteket futtathatunk, amelyek az R tudását, erejét hivatottak demonstrálni. Próbáljuk ki a következő parancsokat. demo(graphics) demo(persp) demo(plotmath) demo(Hershey) 4.2.1 Összefoglalás Az RStudio a parancsok gépelését számos módon könnyíti meg, de ha egy függvényről részletesebb leírást szeretnénk olvasni, akkor a ?függvénynév parancsot használjuk. Egy-egy témakör gyors megismeréséhez a cheet-sheet-eket ajánljuk, amelyek az RStudio Help / Cheetsheets menüjéből is elérhetők. Az R hivatalos honlapján hosszabb leírásokat is találunk. 4.2.2 Feladatok Keressünk magyar nyelvű leírásokat az R-hez! A közösségi médiában melyek az R legfontosabb fórumai? Hogyan indíthatjuk el egy csomag beépített súgóját? Ismerjük meg így a fun csomagot! A fenti feladatok megoldása 4.3 Az Alap R használata Ebben a fejezetben: megtanuljuk az Alap R-ben a konzol, és a parancsállományok használatát, az R Commander kezelését, valamint a kötegelt feldolgozás módszereit. Amennyiben nagygépes környezetben dolgozunk, vagy valamilyen oknál fogva az RStudio-t nem tudjuk használni, akkor az Alap R lehet az egyetlen lehetőség R parancsok futtatására. Ebben az esetben sajnos le kell mondanunk a parancsok kényelmes bevitelét és végrehajtását támogató interaktív eszközökről, de természetesen az R teljes ereje, összes függvénye továbbra is rendelkezésünkre áll. Ebben a részben az Alap R lehetőségeit tekintjük át. Az Alap R elindítása az adott platformon a megfelelő bináris állomány futtatását jelenti. Windows operációs rendszerekben az R indítása többnyire az Asztalon lévő R ikon segítségével lehetséges. Ez az RGui.exe grafikus felhasználói felülettel rendelkező alkalmazást indítja, amelynek legfontosabb része a külön ablakban (R Console) megjelenő konzol (4.10. ábra). MacOs környezetben indítsuk el az R.app alkalmazást, amely egyetlen konzolt tartalmaz. Linux környezetben az R parancssori futtatásával szintén egy konzolt kapunk. 4.3.1 A konzol használata A konzol az Alap R környezet központi része mindegyik platformon. A konzol működése lényegében megegyezik a korábban megismert RStudio-s konzol működésével: egysoros parancsokat gépelünk be a prompt (&gt;) után, ENTER-t nyomunk, majd az R interpreter értelmezi és végrehajtja a begépelt parancsot, és megjelenik az eredmény. A 4.10. ábrán a Windows környezetben használható RGui alkalmazás látható, miután a konzolba két parancsot gépeltünk be és hajtottunk végre. ÁBRA 4.10: RGui alkalmazás a konzollal Windows környezetben Az RStudio konzoljának minden korábban említett alapfunkciója az Alap R konzoljában is elérhető, tudjuk használni a parancsok történetét, a kódkiegészítést a TAB billentyűvel, és a folytatás prompt (+) is megjelenik befejezetlen sorok esetén. Sőt a Windows alatt futó RGui ismeri a parancsállományokat is, bár a gépeléshez korántsem kapunk annyi támogatást mint az RStudio-ban. 4.3.2 Parancsállományok az RGui-ban Az RGui a Windows-os Alap R része, és ahogyan láthattuk, egy nagyon egyszerű grafikus környezet, amelynek központjában a konzol található (R Console ablak a 4.10. ábrán). Az RGui nagyszerű tulajdonsága, hogy támogatja a parancsállományok használatát. Az RGui-ban találunk menüpontokat (File/New script, File/Open script és File/Save), amelyekkel létrehozhatunk, megnyithatunk, és elmenthetünk parancsállományokat. Tudjuk, hogy a parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, de fontos műveletként jelenik meg az átirányítás, amely a szövegszerkesztőben összegyűjtött parancsokat vezeti át a konzolba. Az RGui-ban ez a Ctrl+R billentyűkombinációval lehetséges – ez gyakorlatilag az Rstudio-beli Ctrl+Enter –, de az Edit/Run line or selection vagy az Edit/Run all menüpontok is rendelkezésre állnak. A soronkénti végrehajtás mellett itt is lehetőség van kijelölt szövegrészek végrehajtására, de több sort, a teljes parancsállományt, vagy valamelyik sor egy részét is elküldhetjük a konzolba a Ctrl+R segítségével. 4.3.3 R Commander Eddig az R használatának két lényegesen eltérő módját mutattuk be: a konzolos használatot és a parancsállományos használatot (az RMarkdown állományok használatát is ez utóbbi csoportba sorolhatjuk). Láttuk, hogy a konzol az RStudio és az Alap R központi része, de az RStudio és az RGui a parancsállományos használatot is támogatja. Mindegyik fenti használati mód parancsok gépelésével jár együtt. Azonban létezik egy harmadik, az eddigiektől lényegesen eltérő módja az R használatának. Parancsok gépelése nélkül, csupán egérkattintássokkal is végezhetünk statisztikai elemzést. Az R erre alkalmas beépített eszközét R Commander-nek nevezik, de külső eszközök is képesek az R parancssoros lényét elfedni előlünk. Ilyen külső eszköz például a jamovi és a JASP. Mindhárom felsorolt eszközben közös, hogy grafikus felhasználói felületen mozgunk, és egérkattintással, menüben való navigálással, vezérlőelemek (rádiógombok, jelölőnégyzetek, listák, nyomógombok, beviteli mezők) használatával magyarázzuk el a kívánt tevékenységet. A továbbiakban az R Commander lehetőségeit tekintjük át röviden. Az R Commander az Rcmdr nevű csomagban foglal helyet, így használatához ezt a csomagot telepítenünk kell. Ezt követően a library() függvény segítségével tudjuk elindítani az R Commander-t: # install.packages(&quot;Rcmdr&quot;) # R Commander telepítése library(Rcmdr) # R Commander indítása Az indítás után egy külön R Commander ablak jelenik meg (4.11. ábra), melynek felépítése fentről lefelé a következő: (1) a gazdag menürendszer, (2) az eszköztár az aktuális adatbázis (Adattábla) mezővel és az Adattábla megtekintése gombokkal, (3) a parancsállomány vagy RMarkdown lapok, (4) az output számára fenntartott szöveges mező, és (5) az üzenetek helye. Megjegyezzük, hogy a 4.11. ábrán látható R Commander-t az Alap R-ből indítottuk. Amennyiben RStudio-ból adjuk ki a library(Rcmdr) parancsot, akkor a 4. és az 5. elem, azaz az output és az üzenetek rész nem lesz látható, mert az RStudio konzolja ezeket magába integrálja. ÁBRA 4.11: Az R Commander induló ablaka A kilépést az R Commander-ből a File / Kilépés menüpont segítségével kezdeményezhetjük. Kilépés után az R Commander újraindításához a következő parancsokat kell használnunk: # ha véletlenül bezártuk az R Commander-t detach(package:Rcmdr) library(Rcmdr) Az R Commander lényegét a legkönnyebben úgy tudjuk szemléltetni, ha egérkattintásokkal is megoldjuk a Csillagok háborúja c. filmmel kapcsolatos adatelemzési feladatunkat. Első lépésként telepítsük a dplyr csomagot. Természetesen, ha már korábban a telepítést bármilyen apropóból elvégeztük, akkor ezt nem kell megismételni, de a teljesség kedvéért kezdjük azzal, hogyan tudunk interaktívan csomagot telepíteni az R Commander segítségével. Válasszuk ki a Eszközök / Csomag telepítése menüpontot, ha szükséges válasszunk a tükörszerverek közül, majd válasszuk ki a megjelenő listából a dplyr csomagot. Ezt követően töltsük be a dplyr csomagot az Eszközök / Csomag(ok) betöltése menüponttal. Keressük meg a listában a dplyr csomagnevet és kattintsunk az OK gombon. Ezt követően olvassuk be a starwars adatbázist a dplyr csomagból, az Adatok / Csomagban lévő adatok / Adattábla beolvasása betöltött csomagból menüpont segítségével. Kattintsunk duplán a dplyr csomagneven, majd a jobb oldali listában szintén duplán a starwars adatbázison, majd az OK gombbal fejezzük be a műveletet. Figyeljük meg, hogy az R szkript és R Markdown lapok tartalmazni fogják az egérrel elmutogatott tevékenységeinknek megfelelő R parancsokat, illetve az output és üzenetek részben ezek végrehajtásáról is értesítést kapunk. Még egy rendkívül fontos dolog történt a dplyr csomag starwars adatbázisának beolvasása után. Az eszköztárban az Adattábla részben már nem a Nincs aktív adattábla szöveg szerepel, hanem a starwars adatbázis neve. Azt kell megjegyeznünk az R Commander használata során, hogy mindig van egy kitüntetett, aktív adattáblánk, és minden további tevékenység, amit a menüpontok segítségével el tudunk érni, az erre a kitüntetett, aktív adattáblára vonatkozik. Az aktív adattáblát le lehet cserélni. Amennyiben nyitnánk egy másik adatbázist, akkor a starwars feliratú gombon kattintva, egy listából kiválaszthatnánk, hogy melyik adatbázisunk legyen az R Commander-ben aktív. Folytassuk az adatelemzést az Elemzések / Összegzések / Numerikus változók összegzése menüpont kiválasztásával. A megjelenő dialógusdobozból válasszuk ki a height változót, az Összegzés csoportonként gombon kattintva pedig a species változót. Az OK gombok megnyomása után az output részben látjuk az elemzés eredményét. Az R Commander nagyon hatékony eszköz gyors elemzések, egyszerű adatbetekintések elvégzésére. Számos menüpontot kínál az adatok beolvasásához, előkészítéséhez és az elemzéséhez. Ráadásul az egyes menüpontokban elmutogatott tevékenységek R parancsait is szorgalmasan gyűjti, így azokat a File / Szkript mentése vagy File / R Markdown mentése kiválasztásával, el is tudjuk menteni magunk számára. Az R Commander vagy a jamovi és JASP ismerete nagyban hozzájárul a hatékony adatelemzéshez. Végül megemlítjük, hogy az R Commander tudása kibővíthető beépülő modulok (plugin-ek) segítségével. Ezek új menüpontokat, dialógusdobozokat és természetesen új függvényeket tartalmaznak. A beépülő modulok csomagok formájában érhetők el. Például az Easy R beépülő modul telepítéséhez az RcmdrPlugin.EZR csomagra van szükség. # egy beépülő modul telepítése install.packages(&quot;RcmdrPlugin.EZR&quot;) Telepítés után a beépülő modul betöltésére is szükség van, csak így tudjuk az új funkciókat elérni. Ezt az Eszközök / Rcmdr plugin(ok) betöltése menüpontban tehetjük meg. Az R Commander újraindulása után, már az új menüszerkezetet fogjuk látni. Az R Commander hivatalos oldalán részletesebb információkat olvashatunk. 4.3.4 Kötegelt futtatás Ha felidézzük az eddig tanultakat az R használati módjairól, akkor világos, hogy mindegyik az interaktív használathoz kötődik. Egy tipikus adatelemzési munka során pontosan erre van szükség: kezdeményezzük egy művelet végrehajtását és várjuk az eredményt. Újabb művelet, újabb output. Ezt a fajta interaktív használatot láttuk a konzolban, a parancsállományok és RMarkdown állományok esetén, és az R Commander-ben is. Azonban az interaktív használat mellett beszélünk ún. kötegelt feldolgozásról is. Ez azt jelenti, hogy egy parancsállomány összes sorát egyetlen lépésben hatjuk végre. Nem vagyunk kíváncsiak a soronkénti eredményekre, a teljes szkriptállomány futtatása ad olyan eredményt, amelyre nekünk éppen szükségünk van. Kötegelt futtatásra a source() függvényt használhatjuk, valamint az Alap R egy külső alkalmazását, az Rscript programot. Tegyük fel, hogy egy netflix.R parancsállományban összegyűjtöttük az összes olyan R sort, amely egyetlen ábra létrehozásához szükséges. Ez az ábra meglehetősen összetett, mert az egyes években megjelent filmek és sorozatok számát tartalmazza, és viszonylag sok adatelőkészítési műveletet előzte meg. Ezek nem mindig izgalmasak számunkra, annál inkább maga az ábra, amelynek létrehozása a netflix.R egyetlen célja. A következő sort az Alap R vagy az RStudio konzoljába/parancsállományába, vagy az RStudio RMarkdown állományába is elhelyezhetjük. A source() függvény a netflix.R minden sorát végrehajtja és reményeink szerint előállítja a kívánt ábrát. source(&quot;netflix.R&quot;, echo = T) A source() függvény kicsit másként közelít a parancsainkhoz, mint amit megszoktunk az interaktív konzolos és parancsállományos használat során. A source() először a teljes állományban ellenőrzi a parancsok szintaktikai helyességét, és csak akkor kezdi el az első majd az azt követő parancsok végrehajtásához, ha mindent rendben talált. Másik lehetőség parancsállomány kötegelt futtatására, az RScript program, amely ugyanúgy az Alap R része, mint a konzol vagy az interpreter. Az operációs rendszer parancssorából kell kiadnunk a következő parancsot: Rscript --vanilla netflix.R &gt; output.txt A fenti sor hatására ugyanúgy létrejön a kívánt ábra, de az output.txt-ben megkapjuk a futás közben keletkező egyéb outputokat is. Kötegelt feldolgozásra viszonylag ritkán van szükségünk, akkor is többnyire nagygépes környezetben. Az interaktív használat a legtöbb adatelemzési munka során elegendő rugalmasságot ad. 4.3.5 Összefoglalás Amennyiben az RStudio használatára nincs lehetőségünk, akkor az Alap R eszközeivel is kiválóan megoldhatjuk adatelemzési feladatainkat. A konzol és az RGui parancsállományai interaktív parancsvégrehajtást biztosítanak, a source() függvény és az RScript alkalmazás pedig a .R kiterjesztésű parancsállományok kötegelt feldolgozását segítik. Az R Commander parancsok gépelése nélkül teszi lehetővé elemzések végrehajtását, mindössze a megfelelő menüpontot kell kiválasztani, majd a dialógusdobozban elvégezni a szükséges beállításokat. Érdemes kipróbálni a jamovi és a JASP statisztikai programokat is. 4.3.6 Feladatok Foglaljuk össze az R használati módjait! Soroljuk fel mind a négy lehetőséget! Hasonlítsuk össze a parancsállományok használatát RGui-ban és RStudio-ban! Hasonlítsuk össze a parancsállományok és az RMarkdown használatát R Commander-ben és RStudio-ban! Töltsük le és telepítsük az ingyenesen elérhető jamovi és a JASP statisztikai programokat, majd nyissuk meg a beépített adatbázisait, és végezzünk néhány egyszerűbb elemzést! Ha elakadunk, keressünk videó tutoriált az eszközök használatáról. Melyik eszköz tetszik jobban? Miben hasonlítanak és miben térnek el? A fenti feladatok megoldása "],["az-r-nyelv.html", "5 Az R nyelv 5.1 Adatobjektumok 5.2 Függvények 5.3 Adatszerkezetek 5.4 További adatszerkezetek 5.5 Objektumok és típusok", " 5 Az R nyelv Az előző fejezetekben megismertük az R környezetet, az Alap R, az RStudio és a csomagok telepítését, megtanultuk a projektek, parancsállományok és RMarkdown állományok létrehozását. Tudjuk, a különböző környezetekben eltérő módszerekkel hajthatjuk végre az R parancsokat: a konzolban az Enter, a Windows-os RGui-ban a Ctrl+R, míg az RStudio-ban a Ctrl+Enter billentyűkombinációt kell használnunk. A parancsok végrehajtása közben érdemes észben tartani, ha a folytatás prompt (+) feltűnik, akkor kattintsunk bele a konzolba, és nyomjuk meg az Esc billentyűt, így tudunk kilépni a befejezetlen sor szerkesztéséből E fejezet példáinak kipróbáláshoz hozzunk létre egy gyakorlas nevű új projektet az RStudio-ban (File / New Project), majd készítsünk egy gyakorlas.Rmd RMarkdown állományt (File / New File / R Markdown) és egy gyakorlas.R parancsállományt (File / New File / R Script). A fejezet példáit egyaránt gépeljük az RMarkdown állomány R csonkjaiba, illetve a parancsállomány egymást követő soraiba. A fejezet további részében az R nyelvre koncentrálunk, arra, hogy mit írunk, és nem arra, hogy hová írjuk a parancsokat. 5.1 Adatobjektumok Ebben a fejezetben: áttekintjük az egyszerű számolási lehetőségeket R-ben, bevezetjük az aritmetikai operátor és a kifejezés fogalmát, megismerjük az objektum létrehozását és elnevezését, több parancs elhelyezését egy sorban, és a megjegyzések használatát. Az R nyelv megismerését számadatok írásával kezdjük. Az adatelemzés során a számszerű adatok kezelése a leggyakoribb, hiszen méréssel és számlálással is ilyen jellegű adatokhoz jutunk. Számszerű adat a testmagasságunk cm-ben kifejezve, az IQ-teszten elért pontszámunk, vagy a testvéreink és a Facebook ismerőseink száma is. 5.1.1 Számolás az R-ben Kezdjük a számszerű adatok megismerését egy egyszerű sor begépelésével. 2+2 #&gt; [1] 4 Végrehajtás után a konzolban láthatjuk az összeadás eredményét, a 4-et. Az eredmény előtt egy szögletes zárójelben lévő sorszámot is láthatunk ([1]), amely bonyolultabb outputokban segít eligazodni. Később az 5.3.3.2. fejezetben visszatérünk a [1] értelmezésére. Látjuk, ebben az esetben az R úgy viselkedik, mint egy számológép. Kiszámolja a parancssorba gépelt algebrai kifejezés értékét, majd a képernyőn megjeleníti. Természetesen az összeadáson túl más műveletet is használhatunk. 4+6*2 #&gt; [1] 16 A fenti példából látható, hogy az R követi a műveletek elvégzésének matematikában megszokott sorrendjét. Azaz a szorzás műveletre (*) hamarabb sor kerül, ennek eredménye 12. Ezt követi az összeadás (+), most már a 4 és a 12 között. Ennek az összeadás műveletnek az eredménye 16, ami egyben a kifejezés értéke is, tehát ez jelenik meg a konzolban. Természetesen a matematikában megszokott módon változtathatunk a műveletek végrehajtásának alapértelmezett sorrendjén, azaz használhatunk kerek zárójeleket. Ezeket az R a megszokott módon értelmezi: a zárójelben szereplő műveletek végrehajtását előreveszi. (4+6)*2 #&gt; [1] 20 A fenti példában az összeadás művelet lesz az első, amelynek az eredménye 10. Ezt követi a szorzás, így kapjuk a kifejezés értékeként a 20-at. Ezeket a matematikában megszokott algebrai kifejezéseket, az R-ben egyszerűen kifejezésnek vagy – utalva arra, hogy a kifejezés értéke szám – aritmetikai kifejezésnek nevezünk. Az eddigiek alapján az aritmetikai kifejezések tehát a következő nyelvi elemeket tartalmazhatják: számok, amelyeket numerikus konstansoknak nevezünk, műveleti jelek, amelyeket aritmetikai operátoroknak nevezünk, és kerek zárójelek. A fentiek alapján összetettebb aritmetikai kifejezéseket is megformálhatunk. Az R minden esetben kiszámolja a kifejezések értékét – azaz kiértékeli a kifejezést –, és a kapott értéket megjeleníti a konzolban. 4^2-3*2+1 #&gt; [1] 11 (104-20)/6-4*7*10/(5**2-5) #&gt; [1] 0 TÁBLÁZAT 5.1: Matematikai operátorok precedenciájuk csökkenő sorrendjében Operátor Művelet Példa ^ ** hatványozás 2^3;2**3 + - előjelek +3.3;-.5 %% %/% maradékos osztás és egész osztás 13%%4;15%/%4 * / szorzás és osztás 2*3;4/2 + - összeadás és kivonás 2+3;2-3 Az aritmetikai kifejezések használata során ne felejtkezzünk el a műveletek alapértelmezett végrehajtási sorrendjéről. A műveletek megjelenítését most az operátorok végzik, melyeknek fontos tulajdonsága, hogy mennyire szorosan kötik magukhoz az adatokat (vagy más néven az operandusokat). Az operátorok ezen fonos tulajdonságát precedenciának nevezzük. Az R-ben használható aritmetikai operátorokat a precedenciájuk csökkenő sorrendjében az 5.1. táblázat tartalmazza. Például a hatványozás és az előjel operátor precedenciája eltér egymástól, a hatványozás nagyobb precedenciájú, azaz szorosabban köti magához az adatokat, így végrehajtása megelőzi az előjel operátort. Ha nem vagyunk elég óvatosak, és plusz zárójelek segítségével nem biztosítjuk a kívánt végrehajtási sorrendet, akkor “váratlan” eredményhez juthatunk. A lenti példában láthatjuk, hogy zárójelek nélkül a nagyobb precedenciájú hatványozás az elsőként végrehajtott művelet. -2^2 # először hatványozás, majd előjel #&gt; [1] -4 (-2)^2 # először előjel, majd hatványozás #&gt; [1] 4 Eddig láthattuk, hogy kifejezéseinket operátorok, numerikus konstansok és zárójelek segítségével építettük fel. Ezek a kifejezések két alkotójukban is általánosíthatók: általánosítható a kifejezés adat része, amelyet eddig a numerikus konstansok képviseltek (ezekből lesznek az objektumok), általánosíthatő a kifejezés művelet része, amelyet eddig az operátorok jelenítettek meg (ezek lesznek a függvények). Az adatrész általánosítása tehát az adatobjektum (vagy röviden objektum), a műveleteké pedig a függvényobjektum (vagy röviden függvény). Ezeket tekintjük át a következőkben. 5.1.2 Objektumok Ha egy kifejezés értéket nem egyszerűen a képernyőn szeretnénk megjeleníteni, hanem azt később is fel szeretnénk használni, akkor objektumot4 kell létrehoznunk. Az objektumok révén a memóriába rögzíthetünk tetszőleges értékeket, később pedig elővehetjük és felhasználhatjuk ezeket az értékeket. Tudjuk, ha a lenti aritmetikai kifejezést a parancssorba írjuk, az R miután kiértékelte a kifejezést, a kifejezés értékét megjeleníti a konzolban. Ez az érték azonban a megjelenítés után rögtön el is vész, többször nem használhatjuk fel. 1157/13+2^3 #&gt; [1] 97 Ha létrehozunk egy x nevű objektumot, akkor ezt az értéket további kifejezésekben is szerepeltethetjük. Minden olyan helyen, ahol eddig számok jelentek meg a kifejezésekben, oda ez az x objektumnév is beírható. x &lt;- 1157/13+2^3 A fenti sor végrehajtása után írhatjuk a következőket, hiszen a kifejezések kiértékelése során az x objektum memóriában tárolt értékével fog számolni az R. x+2 # mintha 97+2 lenne #&gt; [1] 99 2*x^3+5 # 2*97^3+5 #&gt; [1] 1825351 Minden objektumnak van neve és tartozik hozzá a memóriában egy terület, ahol a kérdéses érték tárolásra kerül. Esetünkben az objektum neve x, a hozzá tartozó memóriaterületen pedig a 97 értéket tárolja az R. Az objektum leegyszerűsítve tehát egy név-érték pár, ahol a nevet és a memóriában eltárolandó értéket is mi magunk választjuk meg. Az objektumok kezeléséhez 3 művelet kapcsolódik: objektum létrehozása, objektum értékének lekérdezése, és az objektum értékének megváltoztatása. 5.1.2.1 Objektumok létrehozása Objektumot értékadással hozhatunk létre. Az értékadás tartalmaz egy értékadás operátort, melynek alakja &lt;- (balra nyíl), vagyis egy kisebb jel és egy mínusz előjel egymás után írva szóköz nélkül5. Az értékadás általános alakja: objektumnév &lt;- kifejezés # értékadó utasítás Ahol lehet a továbbiakban ezt a balra nyíl alakú értékadó operátort használjuk az értékadás során, és nem a szintén legális egyenlőségjelet (=). A balra nyíl írását az RStudio az Alt+- segítségével támogatja, így a bevitele nem okozhat nehézséget. Az egyenlőségjelet megtartjuk a függvényargumentumok elnevezésére. Az egyszerűség kedvéért a balra nyíl előtt lévő objektumnevet az értékadás bal oldalának, az utána lévő kifejezést az értékadás jobb oldalának nevezzük. Ha olyan objektumnevet szerepeltetünk az értékadásban, amely még nem létezik, akkor az R létrehoz egy ilyen nevű új objektumot, és a hozzá tartozó memóriaterületen pedig az értékadás jobb oldalán lévő kifejezés kiértékelése után kapott értéket tárolja el. a &lt;- 1+2 # objektum létrehozása A fenti sor végrehajtása után a konzolban nem jelenik meg eredmény, mégis egy nagyon fontos dolog történik, létrejön az a nevű objektum, amelynek értéke 3 lesz mindaddig, amig ezen nem változtatunk. A munkánk során létrehozott objektumok a memória egy speciális területére, a munkaterületre (workspace) kerülnek. Ha az értékadásban használt objektum már létezik, akkor a jobb oldali kifejezés kiértékelése után a kapott értékkel felülírja a bal oldali objektumhoz tartozó memóriaterületet. Ezzel a módszerrel tehát a korábban létrehozott objektum értékét módosíthatjuk. A már létező a objektum értékét könnyen megváltoztathatjuk. a &lt;- 10/3 # objektum értékének megváltoztatása 5.1.2.2 Objektumok értékének lekérdezése Az objektum memóriában tárolt értékét le is kérdezhetjük. A legegyszerűbb mód erre, ha az objektum nevét a parancssorba írjuk és végrehajtjuk a sort, máris megkapjuk az objektum memóriában tárolt értékét. a # vajon mi az &quot;a&quot; objektum értéke #&gt; [1] 3.333 Objektumok tetszőleges kifejezésben megjelenhetnek, akár egy értékadás jobb oldalán lévő kifejezésben is. A kifejezések kiértékelésében az objektum a memóriában tárolt értékével vesz részt. a*3 # a kifejezés értéke konzolba kerül #&gt; [1] 10 a &lt;- 4 + a * 3 # megváltozik az objektum értéke, nincs output a # megtudjuk az objektum értékét #&gt; [1] 14 A fenti sorokból kiolvasható, hogy immár az a objektum értéke 14. 5.1.2.3 Objektumok elnevezése Az objektumok elnevezésére eddig egyetlen betűt (karaktert) használtunk, de ez elég ritka eset a munka során. Helyes gyakorlat, ha az objektum neve utal az objektum tartalmára, céljára. Ha például testmagasságot tárolunk el egy objektumban, akkor írhatjuk a következőt: magassag &lt;- 179 A fenti sor létrehozza a munkaterületen a magassag nevű objektumot 179 értékkel. Az objektumok elnevezésére betűket, számjegyeket, és az aláhúzás (_) vagy pont (.) szimbólumokat használhatjuk. Az objektum neve csak betűvel vagy ponttal kezdődhet, számjeggyel vagy aláhúzással nem. Továbbá a név nem lehet az R-ben már lefoglalt kulcsszó, mint például if, function vagy TRUE (a kulcsszavak listáját a ?Reserved paranccsal ismerhetjük meg). Hagyományosan a pont karaktert használjuk az objektumnevekben a tagolásra (például magassag.peter Péter magasságának tárolására). Az R a magyar ékezetes karakterek használatát is megengedi az objektumnevekben, de csakúgy mint az állományok és könyvtárak elnevezésében, érdemes ezek használatát mellőzni. Az objektumoknak érdemes “beszédes” nevet választani, még ha ennek az ára némi extra gépelés is. Tudjuk, a Tab billentyű segíti a gépelést az RStudio-ban. Az R kis- és nagybetű érzékeny, vagyis az x és a X különböző objektumoknak számítanak. Például a következő pulzus.atlag &lt;- 72 parancs után a Pulzus.atlag #&gt; Error: object &#39;Pulzus.atlag&#39; not found sor hibát jelez (Error: object 'Pulzus.atlag' not found), azaz a Pulzus.atlag objektumot nem találja az R. Minden olyan esetben, ha nem létező objektumra hivatkozunk, a fenti hibaüzenet jelenik meg a konzolban. Amennyiben gondoskodunk nagy P-vel kezdődő objektumról is, akkor lehetőségünk van hibaüzenet nélkül mindkét objektum értékének kiíratására. Pulzus.atlag &lt;- 69 # új objektumot hozunk létre Pulzus.atlag; pulzus.atlag # két parancs egy sorban #&gt; [1] 69 #&gt; [1] 72 A gyakorlatban kerüljük el az olyan helyzeteket, amikor két objektumnév csak kis- nagybetűk használatában tér el. A fenti példában egy további apró újdonság is szerepelt. Ha egy parancssorban több utasítást szeretnénk elhelyezni, akkor ezeket pontosvesszővel (;) kell elválasztanunk. A pontosvesszővel elválasztott utasításokat az R értelmező egymás után, balról jobbra haladva hajtja végre, mintha külön sorba írtuk volna őket. A lenti sor 3 kifejezést (parancsot) tartalmaz pontosvesszővel elválasztva, mindegyik eredménye külön-külön jelenik meg a konzolban, mintha 3 különböző sorba írtuk volna őket. 1+2; 3+4; 5+6 # három kifejezés egy sorban #&gt; [1] 3 #&gt; [1] 7 #&gt; [1] 11 5.1.3 Megjegyzések Nagyon sok példában láttunk már magyar nyelvű, magyarázó, értelmező szövegrészeket az R parancsok körül. Ezek az R megjegyzések. Megjegyzést az R-ben a kettőskereszt (#) karakter használatával vezetünk be. Az R értelmező a kettőskereszttől a sor végéig tartó részt figyelmen kívül hagyja. Itt helyezhetjük el a paranccsal kapcsolatos magyarázatainkat magunk vagy a kódot később olvasók számára. Teljes sorokat, vagy a sorok végét tudjuk így kivonni a végrehajtás alól. # Érdekes tény, ha a 153 számjegyeit köbre emeljük, # majd összeadjuk őket, pontosan 153-at kapunk 1^3+5^3+3^3 # hatványozás a ^ operátorral #&gt; [1] 153 1**3+5**3+3**3 # hatványozás a ** operátorral #&gt; [1] 153 Nem kizárólag magyarázó szövegek kerülhetnek megjegyzésbe, sokszor R parancsok végrehajtását akadályozzuk meg ezzel a módszerrel. Úgy kerülhetjük el egy parancs végrehajtását, hogy nem kell kitörölnünk a parancsállományból vagy az RMarkdown állományból, egyszerűen csak megjegyzésbe kell tennünk őket. Emlékezzünk vissza, hogy az 3.1.3. fejezetben a csomagok telepítésért felelős parancsok esetében kifezetten javasoltuk a megjegyzések használatát: # xkcd: Randall Munroe webképregényei # install.packages(&quot;RXKCD&quot;) library(RXKCD) # csomag betöltése searchXKCD(&quot;Star Wars&quot;) # keresés címben vagy leírásban getXKCD(1769) # webképregény megjelenítése Végül megemlítjük, hogy az RStudio-ban egyszerre több kijelölt sort tudunk megjegyzésbe tenni, vagy onnan kivenni a Ctrl+Shift+C segítségével. 5.1.4 Összefoglalás Egyszerű kifejezéseket építhetünk numerikus konstansok (számok), operátorok és kerek zárójelek segítségével. A legfontosabb matematikai operátorok a négy alapművelet és a hatványozás. A kifejezés kiértékelése balról jobbra sorrendben történik, de ezt felülírhatja a kerek zárójelek használata és az operátorok precedenciája. Egy kifejezés értékét eltárolhatjuk a memória speciális területén, a munkamemóriában. Ehhez az értékadó operátorral (&lt;-) létre kell hoznunk egy új objektumot. Az objektum egy név-érték páros. Az objektum létrehozása után az objektum neve megjelenhet egy tetszőleges kifejezés adat részében. Több parancsot a pontosvesszővel (;) írhatunk egy sorba. Megjegyzéseket a kettőskereszt (#) segítségével helyezhetünk el. 5.1.5 Feladatok Gondoljuk át, mi lehet a következő algebrai kifejezés eredménye, majd ellenőrizzük R-ben is: \\(8/2(2+2)\\). Gondoljuk át, hogy a .342e1 név miért nem lehet érvényes objektumnév? Próbáljuk ki a make.names(\".342e1\") parancsot, majd tanulmányozzuk a ?make.names leírást! Magyarázzuk meg a make.names(c(\"\", \"\", \"\")) és a make.names(c(\"\", \"\", \"\"), unique = T) parancsok közötti különbséget! Gondoljuk át, hogy egy parancsállomány mely pontjain érdemes feltétlenül megjegyzéseket használni! Jelentősen segíthetjük a navigációt az RStudio parancsállományaiban, ha bizonyos megjegyzések végére ezt írjuk: ---- (szóköz és négy mínusz jel). Hogyan használhatjuk ezt a lehetőséget az RStudio-ban, és milyen előnyei vannak? Az RStudio-ban parancsállomány (.R) szerkesztése közben próbáljuk ki a Ctrl+Alt+R billentyűparancsot, és a hozzá kapcsolódó Shift+Alt+J billentyűparancsot is. Mi a jelentése az Alt+L, Shift+Alt+L, Alt+O és Shift+Alt+O billentyűparancsoknak? A most megismert funkciók hogyan válthatók ki RMarkdown (.Rmd) állomány szerkesztése közben? A fenti feladatok megoldása 5.2 Függvények Ebben a fejezetben: áttekintjük a függvényhívás lehetőségeit a nevesített argumentumokkal, az alapértelmezésekkel és az argumentumok sorrendjének megváltoztatásával, megismerjük a legfontosabb matematikai függvényeket, és pontosítjuk a kifejezés fogalmát. Az aritmetikai kifejezéseinkben használható operátorok nem teszik lehetővé minden matematikai művelet elvégzését. Mit tegyünk ha a 2 négyzetgyökét szeretnénk kiszámolni? A négyzetgyökvonás operátor nem létezik az R-ben, de ebben a speciális esetben a hatványozás operátor segítségével is elérhetjük a célunkat. 2^0.5 #&gt; [1] 1.414 Az R azonban más lehetőséget is biztosít a négyzetgyök kiszámítására és ez az sqrt() függvény. sqrt(2) #&gt; [1] 1.414 A függvények valamilyen utasítássorozatot hajtanak végre és a számítás eredményét szolgáltatják. Esetünkben az sqrt() függvény egy szám (pozitív) négyzetgyökét számolja ki, annak a számnak a négyzetgyökét, amely a kerek zárójelek között szerepel. Tehát az R a paraméterben megadott 2 értékre meghívja az sqrt() függvényt, ami visszatér a 2 négyzetgyökével. 5.2.1 A függvényhívás szabályai A függvényhívás általános alakja: függvénynév(argNév1=arg1, argNév2=arg2, ..., argNévN=argN) A függvény neve ugyanazoknak a szabályoknak engedelmeskedik, amelyeket az objektumok nevénél megtárgyaltunk (lévén a függvény is egy objektum). A függvény neve után kerek zárójelben következnek a függvény argumentumai, amelyek a függvény utasításainak a bemenő paraméterei. A függvény a bemenő paraméterek alapján az utasításainak megfelelően egy visszatérési értéket fog szolgáltatni. Egy függvény különböző hívásainál az előforduló argumentumok száma és azok sorrendje igen változatos képet mutathat. Elöljáróban elmondhatjuk, hogy a függvények argumentumai alapértelmezett értékkel is rendelkezhetnek, így ezek az argumentumok elhagyhatók. Továbbá, a függvények argumentumai névvel is rendelkeznek, amelyeket ha a függvény hívásánál felhasználjuk, az argumentumok sorrendje tetszőleges lehet. Először tekintsük át az R alapvető matematikai függvényeit (5.2. táblázat). Nézzük meg részletesebben a log() függvényt. Ha kikérjük a súgóját a ?log parancs begépelésével, akkor megtudhatjuk, hogy ez a legáltalánosabb logaritmus függvény, tetszőleges alap esetén hívható. Számunkra most a legfontosabb a súgónak az a sora, amely a logaritmus függvény használatát mutatja: log(x, base=exp(1)). TÁBLÁZAT 5.2: Az R alapvető matematikai függvényei Függvény Leírás Példa abs(x) abszolútérték függvény abs(-1) sign(x) előjel függvény sign(pi) sqrt(x) négyzetgyök függvény sqrt(9+16) exp(x) exponenciális függvény exp(1) log(x,base=exp(1)) logaritmus függvény log(exp(3));log(8,10) log10(x);log2(x) 10-es és 2-es alapú logaritmus log10(1000);log2(256) cos(x);sin(x);tan(x) trigonometrikus függvények cos(pi);sin(0);tan(0) round(x,digits=0) kerekítés adott tizedesre round(c(1.5,-1.5)) floor(x) x-nél kisebb, legnagyobb egész floor(c(1.5,-1.5)) ceiling(x) x-nél nagyobb, legkisebb egész ceiling(c(1.5,-1.5)) trunc(x) x-hez közelebbi egész x és 0 között trunc(c(1.5,-1.5)) Ebből kiolvasható, hogy a log() függvénynek 2 argumentuma (más néven paramétere) van. Az elsőt x-nek, a másodikat base-nek nevezik. A második paraméter alapértelmezett értékkel is rendelkezik, tehát ez a paraméter a hívásnál elhagyható, míg az x= argumentum megadása kötelező. A base= paraméter értéke könnyen kideríthető az exp(1) # Euler-féle szám, a természetes logaritmus alapja #&gt; [1] 2.718 parancsból. Ezt az irracionális számot a matematikában e-vel jelöljük, és Euler-féle számnak nevezzük, ez a természetes logaritmus alapja. Ha nem határozzuk meg a második paramétert, akkor a log() függvény ezzel a természetes alappal (base=exp(1)) számítja ki az x logaritmusát. Ezek alapján 2 természetes alapú logaritmusát a log(2) # 2 természetes alapú logaritmusa #&gt; [1] 0.6931 függvényhívás adja meg. Azt is megtehetjük, hogy felhasználjuk hívásnál az argumentum nevét (x), és egy egyenlőségjel (=) felhasználásával ezt a 2 elé szúrjuk be. log(x=2) # 2 természetes alapú logaritmusa #&gt; [1] 0.6931 A fenti sor természetesen ugyanúgy a 2 természetes alapú logaritmusát szolgáltatja, csak most explicit módon közöltük, hogy az aktuális paraméterben szereplő 2-es értéket az x= nevű formális paraméternek feleltetjük meg. Ez most felesleges gépelést jelentett és általában is elmondhatjuk, hogy matematikai függvények esetében az oly gyakori x= argumentumnevet szokás szerint nem írjuk ki a függvényhívás során. Hívjuk most két argumentummal a log() függvényt. A 100 10-es alapú logaritmusát a log(100, 10) # 100 10-es alapú logaritmusa #&gt; [1] 2 paranccsal tudhatjuk meg. A függvényhívásnál az x= formális argumentum a 100, a base= pedig a 10 értéket kapja. Természetesen ezt a hívásnál mi is rögzíthetjük a világosabb értelmezés kedvéért saját magunk számára a log(100, base=10) # 100 10-es alapú logaritmusa #&gt; [1] 2 vagy akár log(x=100, base=10) # 100 10-es alapú logaritmusa #&gt; [1] 2 formában is. Arra is lehetőség van, hogy megcseréljük az aktuális paraméterek sorrendjét. A legbiztonságosabb ekkor az összes paraméter nevesítése, log(base=10, x=100) # 100 10-es alapú logaritmusa #&gt; [1] 2 de két argumentum esetén így is egyértelmű a hozzárendelés: log(base=10, 100); log(10, x=100) # 100 10-es alapú logaritmusa 2x #&gt; [1] 2 #&gt; [1] 2 Ha az argumentumok nevesítése nélkül cseréljük fel az aktuális paramétereket, akkor természetesen nem a várt eredményt kapjuk, mert a 10 100-as alapú logaritmusa lesz az eredmény. log(10, 100) # 10 100-as alapú logaritmusa #&gt; [1] 0.5 Kényelmi lehetőség az aktuális paraméterek elnevezésénél, hogy rövidítéseket is használhatunk, addig csonkolhatjuk az argumentum nevét, amíg az argumentumok egyértelműen azonosíthatók maradnak. Így a példában akár a b=-vel is helyettesíthetjük a base= argumentumnevet: log(b=10, 100) # 100 10-es alapú logaritmusa #&gt; [1] 2 Mint korábban említettük, az x= argumentum nem rendelkezik alapértelmezett értékkel, így paraméter nélkül nem hívható a log() függvény. log() #&gt; Error: argument &quot;x&quot; is missing, with no default A fenti hibaüzenethez hasonlót láthatunk, ha egy függvényt nem megfelelő számú paraméterrel hívunk. Eddig a függvények aktuális paramétereiként csak numerikus konstansokat használtunk, pedig valójában tetszőleges kifejezéseket is megadhatunk. A függvény hívása előtt ezek kiértékelődnek és a hívás során ezek az értékek rendelődnek a formális paraméterekhez. alap &lt;- 10; log(exp(1)); log(exp(4),base=alap); log(2*exp(2),b=alap/2) #&gt; [1] 1 #&gt; [1] 1.737 #&gt; [1] 1.673 A fenti példa a következő numerikus konstansokkal történő hívásoknak felel meg: log(2.718282); log(54.59815, base=10); log(14.77811, base=5) #&gt; [1] 1 #&gt; [1] 1.737 #&gt; [1] 1.673 A függvények sokféle csoportja létezik az R-ben, a most látott matematikai függvények osztálya csak egy a sok közül. A következő fejezetekben függvények más csoportjait is megismerjük. 5.2.2 A kifejezés fogalma Elérkezett az idő, hogy a kifejezés fogalmát pontosíthassuk: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerek zárójelekkel helyesen összefűzött sorozata is kifejezés. Az R nyelv parancsai, vagy más néven utasításai lényegében kifejezések. Az R nyelvben egy parancs végrehajtása lényegében egy kifejezés kiértékelését jelenti, és a legtöbb esetben a kifejezés értékének megjelenítését a konzolban. A munka során az R értelmező az utasítások egymás utáni kiértékelését végzi. Az utasításokat újsor karakter vagy pontosvessző választhatja el. A szintaktikailag helyes utasítások kiértékelése mindig egy értéket eredményez, ez lesz az utasítás értéke. Még akkor is rendelkezik értékkel az utasításunk, ha az nem jelenik meg a parancssorban, például az értékadó utasítás értéke a jobb oldali kifejezés értéke. Ezért írhatjuk a következő parancsot: y &lt;- x &lt;- 10 x; y #&gt; [1] 10 #&gt; [1] 10 Amennyiben egy értékadás, mint kifejezés értékét szeretnénk megjeleníteni a konzolban, akkor tegyük kerekzárójelbe a teljes sort: (x &lt;- 20) #&gt; [1] 20 A kifejezés fogalmának gyakorlásához nézzünk egy példát. A másodfokú egyenlet megoldóképlete segítségével oldjuk meg az \\(x^{2}–5x+4=0\\) egyenletet. Gépeljük be a következő sorokat: egyutthato.a &lt;- 1 egyutthato.b &lt;- -5 egyutthato.c &lt;- 4 D &lt;- sqrt(egyutthato.b^2-4*egyutthato.a*egyutthato.c) (-egyutthato.b+D)/(2*egyutthato.a) # 1. gyök #&gt; [1] 4 (-egyutthato.b-D)/(2*egyutthato.a) # 2. gyök #&gt; [1] 1 A fenti hat sor mindegyike egy-egy kifejezés. Az első három sorban lévő kifejezéseknek nincs outputja a konzolban, céljuk új objektumok létrehozása, és maguk a kifejezések csupán értékadó operátort, objektumnevet és konstanst tartalmaznak. A negyedik sor kifejezése szintén output nélkül hajtódik végre, és itt is új objektum jön létre, a kifejezés több összetevőt tartalmaz: objektumneveket, függvényhívást, matematikai operátorokat és konstansokat. Az ötödik és hatodik sorban lévő kifejezések értékei a kiértékelés után megjelennek az outputban, és objektumnevekből, matematikai operátorokból, kerek zárójelekből és konstansokból épülnek fel. 5.2.3 Összefoglalás A függvényobjektumok (vagy röviden függvények) előre definiált utasítások sorozatát hajtják végre, és egy visszatérési értéket szolgáltatnak. A visszatérési érték meghatározását a függvény bemenő paraméterei, azaz az argumentumok is befolyásolják. Minden argumentumnak van neve, és rendelkezhetnek alapértelmezett értékkel is. Az R-rel való munka nem más, mint kifejezések létrehozása és végrehajtása, vagyis kiértékelése. A kifejezés fogalma: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerek zárójelekkel helyesen összefűzött sorozata is kifejezés. A kifejezések kiértékelése során az eredmény megjelenhet a konzolban, de látható output nélkül is végbemehet a kifejezés végrehajtása. 5.2.4 Feladatok Tekintsük át az 5.2. táblázat utolsó oszlopában szereplő R függvényeket. Próbáljuk megjósolni a függvények visszatérési értékét. Végezzünk ellenőrzést: gépeljük be, és hajtsuk végre a matematikai függvényeket! Egészítsük ki a begépelt matematikai függvényeket az argumentumok nevével, mindegyik argumentumnak adjunk nevet az 5.2. táblázat első oszlopa alapján! Az előző feladatban a matematikai függvények gépelése során milyen RStudio kényelmi funkciókat fedeztünk fel. Soroljunk fel legalább hármat! Az aranymetszés arányait tartalmazó épületek, képzőművészeti alkotások máig nagy esztétikai értékkel bírnak. Határozzuk meg ezt az arányt a \\(\\phi=\\frac{1+\\sqrt{5}}{2}\\) képlet segítségével! Egy A/4-es oldalra kb. 47 sort írhatunk 12-es betűmérettel, és kb. 35 sort 16-os betűmérettel. Egy üres lap hanyadik sorába írnánk címet 12-es és 16-os betűméret esetén? Próbáljuk ki mindezt egy szövegszerkesztőben is! A trigonometrikus függvények argumentumában radiánban kell megadni a szög értékét, és nem fokban. Ezt figyelembe véve határozzuk meg a 0, 30, 45, 60, 90 és 180 fok szinuszát, koszinuszát és tangensét! A fenti feladatok megoldása 5.3 Adatszerkezetek Ebben a fejezetben: áttekintjük a numerikus, karakteres és logikai konstansok írását, a vektor, mátrix, faktor, lista, és adattábla adatszerkezeteket, ezek kezelését, indexelését, tesztelését és konvertálását. Kezdünk egyre mélyebre ásni az R nyelvben. Megismertük már az adatobjektum, függvény és kifejezés fogalmát. Ezek birtokában már bátran belevághatunk könyvünk kulcsfontosságú fejezetébe, az adatszerkezetek tanulmányozásába. Legyünk alaposak az itt szereplő témakörök áttekintésében, és lehetőleg oldjunk meg minden kitűzött feladatot. Később ez sokszorosan megtérül. Minden statisztikai programcsomag adatokkal dolgozik. Az R-ben nevekkel ellátott objektumokban tároljuk ezeket az adatokat. Lényegében minden tevékenység ezen objektumok létrehozása, módosítása és lekérdezése köré csoportosítható. Ezeket a műveleteket az R-ben az operátorok és a függvények végzik. Láttuk, adatokból (objektumokból), operátorokból és függvényekből kifejezéseket építünk, és hajtunk végre – így foglalható össze minden egyes tevékenység az R-ben. Ebben a fejezetben a kifejezések adat részére összpontosítunk, hiszen minden adatelemzési munka kiinduló pontja maga az adat. Eddig csak számszerű (numerikus) adatokkal találkoztunk, és azok közül is csak az egész számok leírására fókuszáltunk. Adatfeldolgozási folyamatainkban a mért adatok azonban a numerikus mellett karakteres formában is előfordulnak, valamint az R-ben egy harmadik adattípus, a logikai is fontos szerepet kap. Összefoglalva, három R alaptípus lesz fontos számunkra az adatfeldolgozás során: numerikus típus, amely lehet double vagy integer, attól függően, hogy tizedestörteket vagy egész számokat szeretnénk tárolni, karakteres típus, amelyek nem egyetlen karaktert, hanem egy karaktersorozatot vagy más néven sztringet jelentenek, logikai típus, amely az adatszerkezetek manipulációja során jut nagyon fontos szerephez. A továbbiakban megismerjük, hogyan adhatjuk meg az R számára a fenti típusokba tartozó értékeket, illetve ezek felhasználásával, hogyan tudunk bonyolultabb adatszerkezeteket, összetett típusokat létrehozni. 5.3.1 Konstansok Mért adatokat közvetlenül az R-be konstansok segítségével írhatunk be. A konstansok olyan objektumoknak is tekinthetők, amelyeknek nincs nevük, csak értékük, és azt nem is tudjuk megváltoztatni. Ha Péter 18 éves, akkor azt a 18 leírásával közölhetjük az R-rel, és ez nem is jelenthet mást (nem lehet más az értéke), mint 18. A már említett három egyszerű típusnak megfelelően tekintsük át a numerikus, karakteres és logikai konstansokat. 5.3.1.1 Numerikus konstansok A numerikus konstansok többféle alakban is megjelenhetnek az R-ben. Az integer szóval az egész számok tárolását végző konstansra hivatkozunk, a double konstansok pedig törtrészt is tartalmazhatnak, de ez nem kötelező. Ha nem érdekes, hogy a szám integer vagy double, akkor egyszerűen a numerikus (R-ben numeric) elnevezést használjuk. TÁBLÁZAT 5.3: Numerikus konstansok írása Numerikus konstans formája Leírás 1, -1, 2, 100, 3.5, .4 pozitív és negatív double számok 1L, -1L, 2L, 100L pozitív és negatív integer számok az ’L’ utótaggal 1.2e3, 3e+4, .6e-2, 4e1L exponenciális alakú double és integer számok 0xef, 0XF01, -0xEf03, 0xd1L hexadecimális double és integer számok Az 5.3. táblázatban látható, hogy integer értékek írásához szükséges az L utótag használata, egyébként double-ként kezeli az R a számot, még akkor is ha nem adtunk meg törtrészt. Fontos szabály, hogy a tizedesvessző alakja az R-ben a pont. A nulla egész részű tizedes törtek esetében az értéktelen nullát elhagyhatjuk. 0.04; .04; -.04 # utóbbi egy negatív szám, a nulla egészrész megadása nélkül #&gt; [1] 0.04 #&gt; [1] 0.04 #&gt; [1] -0.04 Használhatunk az R-ben exponenciális alakú és hexadecimális (16-os számrendszerű) számokat is. 12e3; 12E+3; 12e-3; 0xa2e; 0Xa2e #&gt; [1] 12000 #&gt; [1] 12000 #&gt; [1] 0.012 #&gt; [1] 2606 #&gt; [1] 2606 Az exponenciális alakú számokat e vagy E karakter vágja ketté, egy bal oldali és egy jobb oldali részre. Az exponenciális alakú szám értéke: a bal oldali rész szorozva 10 annyiadik hatványával, mint amennyi a jobb oldali rész. Érdemes időt szentelni az exponenciális alakú számok értelmezésére, mert az R outputokban gyakran előfordulnak: a szám előjelét a bal oldali rész előjele dönti el, viszont a nagyságrendjét a jobb oldali szám nagyságrendje és előjele együtt határozza meg. Az exponenciális alakú számok nagy előnye, hogy a nagyon kis, illetve nagyon nagy számok nagyságát jobban meg tudjuk ítélni, és persze az ilyen alakú számok leírásánál helyet is megtakarítunk. 0.0000000000000000000000000016726 # proton tömege (kg) #&gt; [1] 1.673e-27 0.00000000000000000000000000000091093822 # elektron tömege (kg) #&gt; [1] 9.109e-31 100000000 # ennyi fele kell figyelni egy diáknak (százmillió) #&gt; [1] 1e+08 5970000000000000000000000 # A Föld tömege (kg) #&gt; [1] 5.97e+24 Az R automatikusan exponenciális alakra vált túl kicsi vagy túl nagy számok konzolbeli megjelenítésénél. Ezt a viselkedést az R egyik globális opciójának beállításával tudjuk szabályozni. A globális opciókat az options() függvénnyel tudjuk állítani az R-ben (?options), amelyben most a scipen= paramétert kell megadnunk. Minél nagyobb pozitív értéket adunk meg, annál jobban törekszik az R a számok fix alakú megjelenítésére, negatív érték megadásánál pedig ugyanez igaz az exponenciális alakra. options(scipen= 0) # az alapértelmezés 0.0000001 # túl kicsi: exponenciális lesz #&gt; [1] 1e-07 123 # marad fix alakú #&gt; [1] 123 100000000 # túl nagy: exponenciális lesz #&gt; [1] 1e+08 options(scipen=-8); 0.0000001; 123; 100000000 # exponenciális lesz mind #&gt; [1] 1e-07 #&gt; [1] 1.23e+02 #&gt; [1] 1e+08 options(scipen= 8); 0.0000001; 123; 100000000 # fix lesz mind #&gt; [1] 0.0000001 #&gt; [1] 123 #&gt; [1] 100000000 options(scipen= 0) # az alapértelmezés visszaállítása A 16-os számrendszerű számok írásához a 0-9 és a kis a-f vagy nagy A-F betűket használhatjuk fel. A hexadecimális számokat a 0x vagy 0X előtag vezeti be. Aritmetikai műveleteinkben rendszerint double típusú számokat, 10-es számrendszerben és fix (nem exponenciális) alakban használunk. De ettől bármikor eltérhetünk: 12L + -3.04 + 3.4e2 + -0x1af # számok 4 különböző formában #&gt; [1] -82.04 A számok megjelenését a konzolban még egy globális opció befolyásolja. A digits megszabja, hány értékes jegyre pontosan jelenjenek meg a számaink a konzolban. Lehetséges értékei az 1-22 tartományba esnek, alapértelmezés szerint 7 az értéke. A beállított érték csak egy ajánlás az R számára, és főképp tizedes törtek esetén okozhat meglepetést, ha túl kicsire állítjuk a digits értékét. options(digits = 1); 12.36 #&gt; [1] 12 options(digits = 2); 12.36 #&gt; [1] 12 options(digits = 3); 12.36 #&gt; [1] 12.4 options(digits = 4); 12.36 #&gt; [1] 12.36 options(digits = 7) # alapértelmezés visszaállítása Természetesen objektumokat is létrehozhatunk a numerikus értékek tárolására, ahogyan korábban már láttuk. Az objektum típusa a konstans típusával fog megegyezni: peter.magassaga &lt;- 181 # double objektum peter.sulya &lt;- 72L # integer objektum peter.bmi &lt;- peter.sulya /(peter.magassaga/100)^2 # double objektum 5.3.1.2 Karakteres konstansok Az R-ben a karakteres konstans (vagy más néven sztring vagy karaktersorozat) speciális karakterekkel határolt, tetszőleges karaktereket tartalmazó sorozat. A karakteres konstans tehát nem egyetlen karaktert jelent tipikusan, hanem többet. Három módszerrel adhatunk meg karakteres konstanst: &quot;Látni távol kis falucska tornyát.&quot; #&gt; [1] &quot;Látni távol kis falucska tornyát.&quot; &#39;Látni távol kis falucska tornyát.&#39; #&gt; [1] &quot;Látni távol kis falucska tornyát.&quot; r&quot;(Látni távol kis falucska tornyát.)&quot; #&gt; [1] &quot;Látni távol kis falucska tornyát.&quot; Karakteres konstansok készítésekor a tetszőleges karaktersorozatunkat dupla (\") vagy egyszeres (') idézőjellel kell körbevennünk, de az R 4.0.0-ás verziójától az r\"(tetszőleges_karaktersorozat)\" forma is elérhetővé vált. Láthatjuk, hogy az R a dupla idézőjelet részesíti előnyben az output megjelenítése során. Egy karakteres konstans tetszőleges karaktert (betűt, számjegyet, írásjeleket, szóközt stb.) tartalmazhat, de az első két megadási forma esetében azt a határolójelet el kell elkerülnünk, amelyet az illető karakteres konstans létrehozásánál használtuk. Látjuk, hogy az r\"(tetszőleges_karaktersorozat)\" forma adja a legnagyobb szabadságot, de a legtöbbször a dupla (\") idézőjeles formával találkozunk. A karakteres konstansok tartalmazhatnak ún. escape szekvenciákat, olyan backslash jellel (\\, fordított perjel) kezdődő karaktersorozatokat, amelyeket speciálisan értelmez az R. A legfontosabb escape szekvenciákat és jelentésüket az 5.4. táblázat tartalmazza. TÁBLÁZAT 5.4: Néhány escape szekvencia Escape szekvencia Jelentése \\t tabulátor \\r kocsi vissza karakter \\n új sor karakter \" dupla idézőjel ' szimpla idézőjel \\ backslash karakter Természetesen, karakteres objektumokat is létrehozhatunk. nev &lt;- &#39;Zsolt&#39;; foglalkozas &lt;- &quot;festő&quot;; lakohely &lt;- r&quot;(Érd)&quot; nev; foglalkozas; lakohely #&gt; [1] &quot;Zsolt&quot; #&gt; [1] &quot;festő&quot; #&gt; [1] &quot;Érd&quot; Karakteres operátor az R-ben nincs, de számos karakterkezelő függvény segíti a sztringek kezelését (5.5. táblázat). TÁBLÁZAT 5.5: Néhány karakterkezelő függvény Függvény Leírás Példa paste();paste0(sep=““) sztringek összefűzése paste(“a”,“b”,sep=“=”) nchar(x) karakterszrting hossza nchar(“alma”) substr(x,start,stop) sztring egy része substr(“alma”, 3, 5) tolower(x) kisbetűsre konvertál tolower(“Kiss Géza”) toupper(x) nagybetűsre konvertál toupper(“Kiss Géza”) chartr(old,new,x) karakterek cseréje chartr(“it”,“ál”,“titik”) cat(sep=” “) kiíratás cat(“alma”,“fa”,sep=““) grep();grepl();regexpr() részsztringek keresése grepl(pattern=“lm”,x=“alma”) sub();gsub() részsztringek cseréje gsub(“lm”,repl=“nyj”,x=“alma”) 5.3.1.3 Logikai konstansok Az eddigiekben megismert numerikus és karakteres konstansok nagyon sokfélék lehetnek, de ugyanígy a numerikus és karakteres objektumokhoz nagyon sok lehetséges numerikus és karakteres érték rendelhető. A logikai adattípus ezektől lényegesen egyszerűbb típus, mivel itt összesen két érték tárolására van módunk. Ez a logikai igaz és a logikai hamis érték, amelyek az R nyelvben a TRUE és a FALSE logikai értékeket jelentik. Az R a logikai értékek írását a T és F globális változók bevezetésével segíti, ezek induló értéke a TRUE és a FALSE logikai érték. Ezeket a logikai konstansokat értékadásban is szerepeltethetjük, így logikai objektumokat hozhatunk létre. fiu &lt;- TRUE; van.kocsija &lt;- FALSE; hazas &lt;- T fiu; van.kocsija; hazas #&gt; [1] TRUE #&gt; [1] FALSE #&gt; [1] TRUE Logikai értékeket vagy objektumokat relációs operátorok segítségével is létrehozhatunk (5.6. táblázat). TÁBLÁZAT 5.6: Relációs operátorok Operátor formája Művelet Példa Példa értéke &lt; kisebb 1&lt;2;“alma”&lt;“körte” TRUE TRUE &gt; nagyobb 3&gt;(1+2);“abc”&gt;“ab” FALSE TRUE &lt;= kisebb egyenlő 1&lt;=-.3;“él”&lt;=“elő” FALSE TRUE &gt;= nagyobb egyenlő 3/4&gt;=7/9;“aki”&gt;=“Ági” FALSE TRUE == egyenlő 20==2e1;“Len”==“len” TRUE FALSE != nem egyenlő exp(1)!=pi;“Len”!=“len” TRUE TRUE %in% tartalmazás c(8, 12) %in% 1:10 TRUE FALSE Numerikus és karakteres adatok is lehetnek a relációs operátorok bemenő adatai. Numerikus adatok esetén a számok nagysága, karakteres adatok esetén az ábécében elfoglalt hely és a sztringek hossza (lexikografikus sorrend) alapján végzi az R az összehasonlítást. A sztringek lexikografikus összehasonlítása, magyar területi beállítások esetén, a magyar ékezetes karaktereket is helyesen kezeli. A logikai értékkel visszatérő kifejezéseket (egyszerű) logikai kifejezéseknek nevezzük. Ezekből az egyszerű logikai kifejezésekből a logikai operátorok segítségével összetett logikai kifejezéseket hozhatunk létre (5.7. táblázat). TÁBLÁZAT 5.7: Logikai operátorok Operátor Művelet Példa Példa értéke ! logikai NEM !(1&lt;2); !T; !F FALSE FALSE TRUE &amp; logikai ÉS T &amp; T; T &amp; F; F &amp; T; F &amp; F TRUE FALSE FALSE FALSE | logikai VAGY T | T; T | F; F | T; F | F TRUE TRUE TRUE FALSE 5.3.1.4 Összefoglalás Az adatfeldolgozás során többnyire számokkal és szövegekkel dolgozunk. Az R a numerikus és a karakteres adatok írásának szabályait pontosan rögzíti. Numerikus konstansok írása a matematikában megszokott módon történik (például 12, -24, 12e+3, 0xabc3), azonban fontos megjegyeznünk, hogy a tizedestörtek esetében pontot kell használnunk az egész és a törtrész elválasztására (például 12.34, -0.04, 3.12e+12). Karakteres konstansok esetében a következő formákat használhatjuk: “tetszőleges karakterek”, ‘tetszőleges karakterek’, és r”(tetszőleges karakterek)“. A logikai konstansok az adatmanipuláció során nyújtanak segítséget, két leheséges értékük a logikai igaz és hamis: a TRUE, FALSE vagy rövidebben a T, F. 5.3.1.5 Feladatok Mi a hasonlóság a következő három numerikus konstans között: 0xabc, 2748, .2748e4. Az R öt előre definiált konstassal rendelkezik (?Constants). Írassuk ki ezek értékeit, állapítsuk meg típusukat! Az aranymetszés arányszámát (\\(\\phi=\\frac{1+\\sqrt{5}}{2}\\)) írassuk a konzolba legalább 8 tizedes pontossággal! Az r\"(tetszőleges karakterek)\" formájú karakteres konstans megadásnak több válozata is létezik, soroljunk fel még legalább öt lehetőséget (?Quotes)! Milyen előnyökkel rendelkezik ez a megadási forma az idézőjelek és a fordított perjel tekintetében? Helyezzünk el idézőjeleket karakteres konstansokban, mindhárom megadási forma mellett! Próbáljuk ki az 5.5. táblázat karakterkezelő függvényeit! Gépeljük be az utolsó oszlopban lévő példákat, és vizsgáljuk meg a függvények visszatérési értékét. Próbáljuk ki az 5.6. táblázat relációs operátorait! Gépeljük be a példákat és ellenőrizzük az eredményeket. A logikai operátorok működéséről teljes képet kaphatunk az 5.7. táblázatból. Próbáljuk ki ezeket a parancsokat is! A fenti feladatok megoldása 5.3.2 Áttekintés Az előző fejezetben láttuk, hogy az R-ben leírható értékek alapvetően 4 típusba sorolhatók. Ezek a double, az integer, a karakteres és a logikai alaptípusok. Ezen értékek felhasználásával nagyon egyszerűen tudunk objektumokat létrehozni. Ezek az objektumok, mindjárt látjuk, az R legalapvetőbb adatszerkezetének, a vektornak az egyelemű változatai. obj.double &lt;- 12.03 obj.integer &lt;- 12L obj.karakteres &lt;- &quot;Péter&quot; obj.logikai &lt;- TRUE A fenti objektumok típusa rendre double, integer, karakteres és logikai. Ezt könnyen ellenőrizhetjük a typeof() vagy class() függvényekkel. A typeof() az objektum alaptípusát adja meg, a class() pedig inkább az R objektum-orientált lehetőségeihez kapcsolódó függvény, de a fenti objektumok esetében nagyon hasonló eredményt szolgáltat, és a későbbiek során is sokat fogjuk használni. Egyedül a double objektumokok esetén tér el a visszatérési értéke, class() ugyanis ekkor a numeric outputot adja. typeof(obj.double); class(obj.double) #&gt; [1] &quot;double&quot; #&gt; [1] &quot;numeric&quot; typeof(obj.integer); class(obj.integer) #&gt; [1] &quot;integer&quot; #&gt; [1] &quot;integer&quot; typeof(obj.karakteres); class(obj.karakteres) #&gt; [1] &quot;character&quot; #&gt; [1] &quot;character&quot; typeof(obj.logikai); class(obj.logikai) #&gt; [1] &quot;logical&quot; #&gt; [1] &quot;logical&quot; Az adatelemzési problémáink megoldásához egyszerre több adatérték feldolgozására van szükséges. Mivel az R nyelvet statisztikai adatfeldolgozásra tervezték, így nem csodálkozhatunk azon, ha több értéket is el tudunk tárolni egymás utáni memóriahelyeken a fenti 4 alaptípusból (double, integer, karakteres és logikai). Ezt többféleképp megtehetjük, például egy vagy több dimenzió mentén, illetve keverhetjük a típusokat vagy ragaszkodhatunk az azonos típusba tartozó értékek egymásutánjához. Ennek megfelelően több különböző R adatszerkezettel kell számolnunk. Ebben a fejezetben az R leggyakrabban használt adatszerkezetit tekintjük át. Most felsoroljuk és jellemezzük őket: vektor - Azonos alaptípusú értékeket egymás után sorolunk fel, egy dimenzó mentén. mátrix - Azonos alaptípusú értékekből egy kétdimenziós szerkezetet hozunk létre, amelynek vannak sorai és oszlopai. faktor - Integer értékeket egymás után teszünk, egy dimenzió mentén, de megadjuk, hogy melyik szám milyen címkét jelöl. lista - Tetszőleges típusú objektumokat egymás után sorolunk fel, egy dimenzió mentén. adattábla - Tetszőleges típusú, de azonos elemszámú objektumokat egymás után sorolunk fel. Tipikusan azonos hosszúságú vektorokat vagy faktorokat teszünk egymás mellé, és így egy kétdimenziós szerkezetet kapunk, amelynek vannak sorai és oszlopai. Az 5.1 ábra összefoglalja az adatszerkezetek fenti tulajdonságait. Beszélünk numerikus (double vagy integer), karakteres és logikai vektorokról, melyek egydimenziósak és homogének, azaz azonos típusú adatokat tartalmaznak. Ugyanez igaz a mátrixokra, csak két dimenzióban, sorokkal és oszlopokkal. A faktor egy integer vektor (azaz egydimenziós és homogén), azonban külön nyilvántartást vezet arról, hogy az egyes integer értékeknek milyen címke felel meg. Az adattábla lesz a legfontosabb adatszerkezet számunkra: kétdimenziós, de oszlopai homogének, hiszen ezek vektorok (numerikus, karakteres vagy logikai) vagy faktorok lehetnek. A lista a legszabadabb adatszerkezet, egydimenziós, de elemei bármilyen adatszerkezethez tartozhatnak. Például az 5.1. ábrán egy 8 elemű lista jelenik meg, amelynek első eleme egy numerikus vektor, utolsó eleme pedig egy adattábla. ÁBRA 5.1: Az R legfontosabb adatszerkezetei Az 5.8. táblázatban más szempontból mutatjuk be az adatszerkezeteket: példát mutatunk adott típusú (adatszerkezetű) objektumok létrehozására, és közöljük, hogy a typeof() és a class() milyen outputot szolgáltat az így létrehozott objektumok esetében. TÁBLÁZAT 5.8: Adatszerkezetek Adatszerkezet Létrehozó parancs typeof(x) class(x) double vektor c(12, 14) double numeric integer vektor c(12L, 14L) integer integer karakteres vektor c(‘a’,‘az’,‘egy’) character character logikai vektor c(T, TRUE,FALSE,F) logical logical double mátrix matrix(1.3,nrow=2,ncol=3) double matrix array integer mátrix matrix(1L,nrow=2,ncol=3) integer matrix array karakteres mátrix matrix(‘az’,nrow=2,ncol=3) character matrix array logikai mátrix matrix(F,nrow=2,ncol=3) logical matrix array faktor factor(c(‘D’,‘D’,‘ND’)) integer factor lista list(A=‘Pék’,B=1:2) list list adattábla data.frame(id=c(‘a’,‘b’), pont=c(4,9)) list data.frame A következő alfejezetekben részletesen áttekintjük a vektor, a mátrix, a faktor, a lista és az adattábla adatszerkezeteket, ugyanis ezek töltik be a legfontosabb szerepet az adatelemzések során. Mindegyik esetben megvizsgáljuk: hogyan hozhatjuk létre az adott adatszerkezetű objektumot, hogyan tesztelhetjük, hogy az adott típusú objektumról van-e szó, hogyan konvertálhatunk más adatszerkezetekből ilyen típusú objektumot, milyen műveletekben vehet részt, hogyan érhetjük el az objektum részeit, azaz hogyan indexelhetjük az objektumokat. 5.3.2.1 Összefoglalás A különböző típusú konstansokat objektumok létrehozására használhatjuk fel. A statisztikában egy objektumok értéke több konstans egymásutánja. A legegyszerűbb adatszerkezet az R-ben a vektor, amelyben tetszőlegesen sok, azonos típusú értéket helyezhetünk el egy dimenzió mentén. A faktor és a lista is egydimenziós, míg a mátrix és az adattábla kétdimenziós. A faktor integer vektor, amelyben a számoknak címkéket feleltetünk meg. A lista elemi tetszőleges típusúak lehetnek. A mátrix ugyanúgy homogén, minta a vektor és a faktor. Az adattábla felfogható azonos elemszámú vektorok/faktorok listájának. 5.3.2.2 Feladatok Próbáljuk ki az 5.8. táblázatban szereplő példákat. Hozzuk létre a különböző típusú objektumokat és vizsgáljuk meg a typeof() és class() függvényekkel az objektumok típusát. A fenti feladatok megoldása 5.3.3 Vektor Az R legalapvetőbb adatszerkezete a vektor. A vektort egymás melletti (vagy alatti) cellákban tárolt értékek sorozataként képzelhetjük el (5.1. ábra), mely értékek mindegyike azonos típusú. Így azt mondhatjuk, hogy a vektor azonos típusú (egynemű, homogén) adatok egydimenziós együttese. A vektor fontos jellemzője, hogy homogén, tehát a vektort alkotó értékek vagy kizárólag integer, vagy kizárólag double, vagy kizárólag karakteres, vagy kizárólag logikai típusúak lehetnek. 5.3.3.1 Vektor létrehozása Vektort legegyszerűbben a c() függvénnyel hozhatunk létre, az argumentumlistában egymás felsoroljuk a vektort alkotó értékeket. Double vektort hozhatunk létre például, ha a paraméterben numerikus konstansokat sorolunk fel: v.d &lt;- c(2, 4, 6, 8); v.d # numerikus (double) vektor létrehozása #&gt; [1] 2 4 6 8 A v.d objektum egy 4 elemű double vektor. Az első eleme a 2, a második eleme a 4, a harmadik a 6 és a negyedik egyben utolsó eleme a 8. A vektor elemei szóközökkel elválasztva jelennek meg a konzolban. Karakteres vektort hasonlóan hozhatunk létre, a v.k vektor 3 elemű lesz. v.k &lt;- c(&quot;erős&quot;, &#39;közepes&#39;, &quot;gyenge&quot;); v.k # karakteres vektor létrehozása #&gt; [1] &quot;erős&quot; &quot;közepes&quot; &quot;gyenge&quot; Egy logikai vektor csak logikai konstansokat tartalmazhat (TRUE vagy FALSE, illetve a T és F rövidebb változatot is használhatjuk): v.l &lt;- c(TRUE, FALSE, T); v.l # logikai vektor létrehozása #&gt; [1] TRUE FALSE TRUE A v.d, v.k és v.l objektum egy-egy példa az R különböző típusú vektoraira. Az objektumok fontos jellemzője az objektum hossza, ami vektorok esetén a vektort alkotó elemek számát jelenti. Ezt a length() függvénnyel kérdezhetjük le. length(v.d); length(v.k); length(v.l) # vektor hossza #&gt; [1] 4 #&gt; [1] 3 #&gt; [1] 3 A vektor hosszát létrehozása után is módosíthatjuk, szintén a length() függvényt használjuk, de az értékadás bal oldalán. length(v.l) &lt;- 5 # vektor hosszának módosítása A v.l logikai vektor most már 5 elemű lesz: v.l #&gt; [1] TRUE FALSE TRUE NA NA Mivel nem adtuk meg a 4. és 5. elemét, így az NA lesz, ami a hiányzó érték jele az R-ben. Az NA minden vektornak eleme lehet, a vektor típusától függetlenül. v.i &lt;- c(12L, NA, 15L) # 3 elemű integer vektor; a 2. eleme nem ismert Térjünk vissza a vektorok létrehozásához. A c() függvény paraméterébe természetesen konstansok helyett tetszőleges kifejezéseket is írhatunk: szamok &lt;- c(1, (2+3)*4, 1/4, .5^3); szamok #&gt; [1] 1.000 20.000 0.250 0.125 nevek &lt;- c(&quot;Péter&quot;, paste0(&#39;Zso&#39;, &quot;lt&quot;)); nevek #&gt; [1] &quot;Péter&quot; &quot;Zsolt&quot; iteletek &lt;- c(T, 1&lt;2, 2==3); iteletek #&gt; [1] TRUE TRUE FALSE A vektorok esetében a homogenitás központi szerepet játszik. Az R abban az esetben sem fog különböző típusú elemekből vektort létrehozni, ha ezeket egyetlen c() függvényhívásban szerepeltetjük. Ekkor automatikus típuskonverzió történik. Nézzük ezeknek az eseteit: eset.1 &lt;- c(2,4,&quot;6&quot;,8); eset.1 #&gt; [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot; eset.2 &lt;- c(T, FALSE,&quot;6&quot;); eset.2 #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;6&quot; eset.3 &lt;- c(T, FALSE, 3); eset.3 #&gt; [1] 1 0 3 Amennyiben karakteres konstans szerepel az elemek között, a vektor karakteres típusú lesz. Ha numerikus és logikai értéket sorolunk fel, akkor a vektor numerikus lesz, azzal a kiegészítéssel, hogy a TRUE logikai érték 1-re, a FALSE pedig 0-ra konvertálódik. További lehetőség a c() függvény használata során, hogy a paraméterben vektort is szerepeltethetünk. Ekkor ezek az elemek is szerepelni fognak az eredményvektorban: regi.v.1 &lt;- c(1, 2, 3) regi.v.2 &lt;- c(7, 8, 9) uj.v &lt;- c(0, regi.v.1, 4, 5, 6, regi.v.2, 10, c(11, 12)); uj.v #&gt; [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 A fenti példában létrehozott uj.v 13 elemű numerikus vektor összerakásához felhasználtunk két 3 elemű vektort és egy kételemű vektort is. Vektorok létrehozása során még egy érdekes lehetőségről érdemes szót ejteni. A c() függvényben a vektor egyes elemeit elnevezhetjük, és ezek a nevek az outputban is meg fognak jelenni. Az elemek elnevezéséhez írjunk egy nevet és egy egyenlőségjelet az argumentumként használt elem elé. Ha a név nem egyetlen szó (vagyis tartalmaz szóközt), akkor a karakterkonstansok megadásánál látott három módszer valamelyikét használhatjuk (tehát a dupla és szimpla idézőjeleket és az r\"()\" konstrukciót), vagy a backtick (`) szimbólumot. Ezzel a módszerrel például a naponta tanulással töltött időnket úgy rögzíthetjük, hogy az output “beszédesebb” lesz, több információt tartalmaz. tan.ido &lt;- c(Hétfő=35, Kedd=95); tan.ido #&gt; Hétfő Kedd #&gt; 35 95 tan.ido &lt;- c(Hétfő=35, &quot;Kedd délelőtt&quot;=50, `Kedd délután`=45); tan.ido #&gt; Hétfő Kedd délelőtt Kedd délután #&gt; 35 50 45 A vektorelemek nevei lekérdezhetők a names() függvénnyel. Amennyiben az értékadás bal oldalán szerepeltetjük, a vektor elemneveit tudjuk módosítani. names(tan.ido) # elemnevek lekérdezése #&gt; [1] &quot;Hétfő&quot; &quot;Kedd délelőtt&quot; &quot;Kedd délután&quot; names(tan.ido) &lt;- c(&quot;H&quot;, &quot;K.1&quot;, &quot;K.2&quot;) # elemnevek módosítása tan.ido #&gt; H K.1 K.2 #&gt; 35 50 45 5.3.3.2 Szabályos vektorok létrehozása Ha egy vektor elemei szabályos rendben követik egymást, akkor szabályos vektorokról beszélünk. Ilyen lehet például a következő három numerikus vektor és két karakteres vektor. c(1, 2, 3, 4, 5); c(1, 3, 5, 7); c(1, 1, 1, 2, 2, 2) c(&quot;férfi&quot;, &quot;nő&quot;, &quot;férfi&quot;, &quot;nő&quot;); c(&quot;f.1&quot;, &quot;f.2&quot;, &quot;f.3&quot;) Szabályos numerikus vektorokat hozhatunk létre a kettőspont (:) operátorral vagy a seq() függvénnyel. Az így létrehozott vektorok ugyanis valamilyen számtani sorozat egymást követő elemei, vagyis az egymás mellett lévő elemek különbsége (a lépésköz) állandó. 5.3.3.2.1 A kettőspont operátor. A legegyszerűbb vektorlétrehozási mód a kettőspont (:) operátor, ahol az egymást követő elemek távolsága 1 vagy -1. Általános alakja: start:stop. 1:10 # a lépésköz +1, növekvő sorozat #&gt; [1] 1 2 3 4 5 6 7 8 9 10 10:1 # a lépésköz -1, csökkenő sorozat #&gt; [1] 10 9 8 7 6 5 4 3 2 1 -1.5:5 # a lépésköz +1, növekvő sorozat #&gt; [1] -1.5 -0.5 0.5 1.5 2.5 3.5 4.5 10.5:3 # a lépésköz -1, csökkenő sorozat #&gt; [1] 10.5 9.5 8.5 7.5 6.5 5.5 4.5 3.5 Látható, hogy az így létrehozott vektorok lehetnek csökkenő vagy növekvő rendezettségűek, valamint tört értékeket is használhatunk operandusként. A sorozat nem feltétlenül a kettőspont utáni értékig tart, mindössze annyi igaz, hogy a sorozat vége a stop értéknél mindig kisebb egyenlő (vagy nagyobb egyenlő, csökkenő sorozat esetén). Hosszabb numerikus vektorokat is könnyűszerrel létrehozhatunk. A 101:140 parancs hatására 40 elemet hozunk létre. Hosszabb vektorok outputjában könnyebben el tudunk igazodni a sorok elején lévő [x] konstrukció segítségével: minden sorban a sor első eleme a vektor x. eleme. A lenti outputban szereplő [17] például azt mutatja, hogy a sor elején lévő 117 a 40 elemű vektor 17. eleme. 101:140 # a lépésköz +1, növekvő sorozat #&gt; [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #&gt; [17] 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 #&gt; [33] 133 134 135 136 137 138 139 140 5.3.3.2.2 A seq() függvény A seq() függvény nagyobb szabadságot ad a numerikus sorozatok generálására. Legegyszerűbb használata esetén a kettőspont (:) operátort kapjuk vissza: seq(1, 10) # a lépésköz +1, növekvő sorozat #&gt; [1] 1 2 3 4 5 6 7 8 9 10 A seq() függvény használatához négy argumentum nevét és jelentését kell megtanulnunk: a from= a sorozat első elemét határozza meg, a to= az utolsó elemet, a by= a lépésközt és a length.out= a létrehozandó vektor elemeinek a számát. A négy paraméterből három megadása már egyértelműen azonosítja a kívánt vektort: seq(from=1, to=10, by=2) # a lépésköz +2, növekvő sorozat #&gt; [1] 1 3 5 7 9 seq(from=1, to=10, length.out=5) # a lépésköz +2.25, növekvő sorozat #&gt; [1] 1.00 3.25 5.50 7.75 10.00 seq(to=10, by=-1.3, length.out=5) # a lépésköz -1.3, csökkenő sorozat #&gt; [1] 15.2 13.9 12.6 11.3 10.0 seq(from=1, by=1.3, length.out=5) # a lépésköz +1.3, növekvő sorozat #&gt; [1] 1.0 2.3 3.6 4.9 6.2 A seq_along() függvénnyel szintén tudunk 1-től induló, +1-es lépésközű sorozatot alkotni, amelynek utolsó értéke, a paraméterben megadott vektor elemszáma. x &lt;- c(&quot;Hétfő&quot;, &quot;Kedd&quot;, &quot;Szerda&quot;); y &lt;- 11:20 seq_along(x) # numerikus vektor 1-től, +1-es lépésközzel, 3 elemű #&gt; [1] 1 2 3 seq_along(y) # numerikus vektor 1-től, +1-es lépésközzel, 10 elemű #&gt; [1] 1 2 3 4 5 6 7 8 9 10 5.3.3.2.3 A rep() függvény Tetszőleges típusú vektor létrehozására használhatjuk a rep() függvényt, amely egy létező vektor értékeit ismétli meg. A rep() első paramétere az ismétlendő vektor, a times= pedig az ismétlések számát adja meg. rep(2, times=3) # számot ismétlünk 3-szor #&gt; [1] 2 2 2 rep(c(2, 0, -2), times=3) # numerikus vektort ismétlünk 3-szor #&gt; [1] 2 0 -2 2 0 -2 2 0 -2 rep(&quot;nap&quot;, times=3) # sztringet ismétlünk 3-szor #&gt; [1] &quot;nap&quot; &quot;nap&quot; &quot;nap&quot; rep(c(F, T, T), times=3) # logikai vektort ismétlünk 3-szor #&gt; [1] FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE TRUE A fenti példában mindenhol háromszor ismételtük meg az első paramétert, méghozzá úgy, hogy az R egymás után sorolta fel őket. Egy vektor ismétlésének van egy másik esete is, amikor az elemeit sorban egyenként véve végezzük el az ismétlést (helyben ismétlés). Ekkor nem a times= paramétert, hanem az each= argumentumot kell használnunk a függvény hívásánál. rep(2, each=3) # számot ismétlünk 3-szor #&gt; [1] 2 2 2 rep(c(2, 0, -2), each=3) # numerikus vektort elemeit ismételjük 3-szor #&gt; [1] 2 2 2 0 0 0 -2 -2 -2 rep(&quot;nap&quot;, each=3) # sztringet ismétlünk 3-szor #&gt; [1] &quot;nap&quot; &quot;nap&quot; &quot;nap&quot; rep(c(F,T,T), each=3) # logikai vektor elemeit ismételjük 3-szor #&gt; [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE Látjuk, hogy egyelemű vektorok ismétlése esetén nincs különbség a times= és az each= paraméterek használata között. Utolsó esetként elemenként szeretnénk ismételni, de eltérő ismétlésszámmal. Ekkor a times= paraméterben a bemenő vektor elemszámával azonos hosszú vektort kell megadni. Ez a vektor tartalmazza az elemek ismétlés számát. rep(c(2, 3, 4), times=c(1, 2, 3)) # numerikus vektort elemeit ismételjük #&gt; [1] 2 3 3 4 4 4 rep(c(&quot;nap&quot;, &quot;part&quot;), times=c(2, 3)) # karakteres vektort elemeit ismételjük #&gt; [1] &quot;nap&quot; &quot;nap&quot; &quot;part&quot; &quot;part&quot; &quot;part&quot; rep(c(T, F, T), times=c(2, 3, 4)) # logikai vektort elemeit ismételjük #&gt; [1] TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE TRUE Végezetül bemutatjuk, hogy az each= és az egyelemű értékkel rendelkező times= egyszerre is alkalmazható. Ekkor először a helyben ismétlés (each=), majd az így kapott vektor teljes ismétlése következik (times=). rep(1:5, each=2, times=3) # kombinált ismétlés #&gt; [1] 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5 5.3.3.2.4 A paste() függvény Szabályos karakteres vektor létrehozására használhatjuk a paste() függvényt. Egy előtaghoz (például f) hozzáfűzhetünk 10 különböző számot, amely így egy 10 elemű karakteres vektort eredményez. paste(&quot;f&quot;, 1:10) # 10 elemű sztring vektor #&gt; [1] &quot;f 1&quot; &quot;f 2&quot; &quot;f 3&quot; &quot;f 4&quot; &quot;f 5&quot; &quot;f 6&quot; &quot;f 7&quot; &quot;f 8&quot; &quot;f 9&quot; &quot;f 10&quot; Láthatjuk, hogy az f karakter és a számok közé egy szóköz került, de ezt a sep= argumentummal megváltoztathatjuk: paste(&quot;f&quot;, 1:10, sep=&quot;-&quot;) # gondolatjel az elválasztó #&gt; [1] &quot;f-1&quot; &quot;f-2&quot; &quot;f-3&quot; &quot;f-4&quot; &quot;f-5&quot; &quot;f-6&quot; &quot;f-7&quot; &quot;f-8&quot; &quot;f-9&quot; &quot;f-10&quot; paste(&quot;f&quot;, 1:10, sep=&quot;&quot;) # nincs elválasztó #&gt; [1] &quot;f1&quot; &quot;f2&quot; &quot;f3&quot; &quot;f4&quot; &quot;f5&quot; &quot;f6&quot; &quot;f7&quot; &quot;f8&quot; &quot;f9&quot; &quot;f10&quot; A collapse= argumentum használatával, akár egyetlen karakteres értékbe is összeolvaszthatjuk a fenti elemeket. Az argumentumban az összevonásnál használt elválasztó karaktert adjuk meg. paste(&quot;f&quot;, 1:10, sep=&quot;-&quot;, collapse=&quot;_&quot;) # gondolatjel az elválasztó, egy sztring #&gt; [1] &quot;f-1_f-2_f-3_f-4_f-5_f-6_f-7_f-8_f-9_f-10&quot; Az eddigiek összefoglalásaként nézzünk példát különböző típusú és elemhosszú vektorok létrehozására. y &lt;- 12L # 1 elemű integer vektor y &lt;- 12 # 1 elemű double vektor y &lt;- &quot;Bízz magadban!&quot; # 1 elemű karakteres vektor y &lt;- TRUE # 1 elemű logikai vektor y &lt;- c(23.8, -5) # 2 elemű double vektor y &lt;- c(&quot;H&quot;, &quot;K&quot;) # 2 elemű karakteres vektor y &lt;- c(T, FALSE) # 2 elemű logikai vektor y &lt;- c(1, 2, 3, 4, 5) # 5 elemű double vektor y &lt;- 1:5 # 5 elemű integer vektor y &lt;- seq(from=9, to=100, by=2) # 46 elemű double vektor y &lt;- rep(c(&quot;H&quot;, &quot;K&quot;), times=10) # 20 elemű karakteres vektor z &lt;- seq_along(y) # 20 elemű integer vektor y &lt;- paste(&quot;év&quot;, 2001:2020) # 20 elemű karakteres vektor 5.3.3.3 A vektoraritmetika szabályai Amint az előzőekben láttuk, az R rendszer legalapvetőbb adattárolási szerkezete a vektor. Az R egyik legnagyszerűbb tulajdonsága pedig az, ahogyan a vektorokkal műveleteket végezhetünk. Korábban már láttuk, hogyan tudunk összeadni két számot az R-ben. Próbáljunk meg összeadni két 2 elemű vektort: c(1, 2) + c(3, 4) # két vektor összeadása #&gt; [1] 4 6 A két fenti vektort a parancssorban hoztuk létre a c() függvénnyel. Az összeadás eredménye egy 2 elemű vektor. Az eredményvektor az 1+3 és a 2+4 műveletek alapján jött létre, vagyis az összeadás operandusaiban szereplő vektor azonos sorszámú elemeire hajtotta végre a kijelölt műveletet az R. Két vektor összeadásánál természetesen használhatunk objektumneveket is: x &lt;- c(1, 2, 3); y &lt;- c(2, 3, 4) x + y # két vektor összeadása #&gt; [1] 3 5 7 Itt az eredményvektor 3 elemű, és a komponensenkénti művelet végrehajtás szabályainak megfelelően az 1+2, 2+3 és a 3+4 összeadások eredménye lesz a 3 új elem. Az összeadás műveletet tetszőleges operátorral felcserélhetjük, használhatjuk az összes aritmetikai, relációs és logikai operátort. c(1,2) - c(2,3) # két vektor összeadása #&gt; [1] -1 -1 x &lt;- c(1, 2, 3); y &lt;- c(2, 3, 4) x - y # két vektor különbsége #&gt; [1] -1 -1 -1 x * y # két vektor szorzata #&gt; [1] 2 6 12 x / y # két vektor hányadosa #&gt; [1] 0.5000000 0.6666667 0.7500000 x ^ y # x az y-adikon #&gt; [1] 1 8 81 x == y # x egyenlő y-nal? #&gt; [1] FALSE FALSE FALSE x &lt; y # x kisebb, mint y? #&gt; [1] TRUE TRUE TRUE A fenti műveletek közül a hatványozás végrehajtása tűnhet kicsit szokatlannak, itt ugyanis egy 3 elemű vektort, mint alapot egy 3 elemű másik vektorra, mint kitevőre emeljük. Ha azonban a komponensenkénti végrehajtás szabályát észben tartjuk, akkor világos, hogy az eredményvektor az 1^2, 2^3 és a 3^4 eredménye. A komponensenkénti végrehajtás szabálya a logikai operátorokra is érvényes. !c(T, T, F, F) # logikai NEM egy vektorra #&gt; [1] FALSE FALSE TRUE TRUE c(T, T, F, F) &amp; c(T, F, T, F) # logikai ÉS két vektorral #&gt; [1] TRUE FALSE FALSE FALSE c(T, T, F, F) | c(T, F, T, F) # logikai VAGY két vektorral #&gt; [1] TRUE TRUE TRUE FALSE A vektorok közötti műveletek legegyszerűbb esetét tekintettük át eddig, azaz azonos elemszámú vektorokat adtunk össze vagy vontunk ki egymásból. Ha az operátor két oldalán lévő vektorok elemszáma eltér, akkor az általános szabály az, hogy a rövidebbik vektort az R megismétli mindaddig, míg a hosszabbik vektor elemszámát el nem éri. Ha a rövidebbik vektort nem egész számszor megismételve kapjuk a hosszabb vektor hosszát, akkor figyelmeztetést kapunk az R-től, melyben erre a tényre felhívja a figyelmünket, de a kijelölt műveletet az R ennek ellenére végrehajtja. c(1, 2) + 5 # két eltérő elemszámú vektor összeadása #&gt; [1] 6 7 A fenti példában egy 2 elemű és egy 1 elemű vektort adunk össze. A rövidebb vektort még egyszer megismételve már az c(5, 5) vektort kapjuk, így a kijelölt összeadás minden fennakadás nélkül végrehajtható. Az eredményvektor az 1+5 és a 2+5 összeadások eredménye lesz. Most egy 2 elemű és egy 3 elemű vektort adunk össze. c(1, 2) + c(3, 4, 5) # két eltérő elemszámú vektor összeadása #&gt; Warning in c(1, 2) + c(3, 4, 5) : #&gt; longer object length is not a multiple of shorter object length #&gt; [1] 4 6 6 A rövidebbik vektort még egyszer megismételve a c(1, 2, 1, 2) vektort kapjuk, de mivel nincs szükség minden elemre, ezért figyelmeztető üzenetet kapunk. Az eredményvektor az 1+3, 2+4 és az 1+5 összeadások eredménye lesz. A következő példában már nincs figyelmeztetés, hiszen a rövidebb vektort egész számszor, pontosan kétszer kellett megismételni a koordinátánkénti művelet végrehajtáshoz. c(1, 2) + c(3, 4, 5, 6) # két eltérő elemszámú vektor összeadása #&gt; [1] 4 6 6 8 Foglaljuk össze a vektoraritmetika szabályait: azonos elemszámú vektorok között az azonos pozícióban lévő vektorelemek között hajtódik végre a kijelölt művelet (vagyis koordinátánkénti végrehajtás történik), különböző elemszámú vektorok esetében pedig először a rövidebbik vektor ismétléssel kiegészül a hosszabbik vektor hosszára, és ezt követi a koordinátánkénti végrehajtás. Az operátorokon túl az 5.2. táblázatban szereplő matematikai függvények is támogatják a vektor paramétert. Ekkor nem egyetlen értékkel térnek vissza, hanem a bemenő vektor minden elemére kiszámolt függvényértékek vektorával. sqrt(c(4, 9, 16)) # 3 szám négyzetgyöke #&gt; [1] 2 3 4 log(x=c(1, 10, 100), base=10) # 3 szám 10-es alapú logaritmusa #&gt; [1] 0 1 2 x &lt;- 1.3:10; round(x) # 9 szám egészre kerekítve #&gt; [1] 1 2 3 4 5 6 7 8 9 5.3.3.4 Függvények vektorokkal Az előző fejezetben láttuk, hogy a matematikai függvények vektor argumentumot is elfogadnak, és a vektor minden elemére kiszámolják a függvényértéket. Míg a log(x=16, base=2) függvényhívás a matematikában megszokott módon egyetlen bemenő értékhez (16) egyetlen kimenő éréket szolgáltat (4), addig az R lehetőségeit jobban kihasználó log(x = c(1, 2, 4, 8, 16), base=2) függvényhívás négy bemenő értékből (c(1, 2, 4, 8, 16)) négy kimenő érték c(0, 1, 2, 3, 4) állít elő. A függvények és a vektorok kapcsolatának azonban van egy másik aspektusa, amely szorosan kötődik a statisztikai műveletek végrehajtásához. Az R függvények egy nagy csoportja eleve olyan vektort vár az argumentumába, amely több tíz vagy több száz elemet tartalmaz, és tipikusan egyetlen értékkel tér vissza. Ezeket a függvényeket vektor alapú függvényeknek nevezzük, és ebbe a csoportba tartoznak az R statisztikai mutatókat számoló függvényei is. A vektor alapú függvényekre az jellemző, hogy a bemenő vektor elemeivel egy előre definiált műveletsorozatot hajtanak végre, például összeadják a vektor elemeit, kiszámolják az elemek átlagát vagy szórását, és visszatérési értékként ezt az összeget, átlagot vagy szórást szolgáltatják. A legfontosabb vektor alapú függvényeket az 5.9. táblázat tartalmazza. TÁBLÁZAT 5.9: Függvények vektorokkal Függvény Leírás Példa Példa értéke max(x) az x vektor legnagyobb eleme max(1:10) 10 min(x) az x vektor legkisebb eleme min(11:20) 11 sum(x) x elemeinek összege sum(1:5) 15 prod(x) x elemeinek szorzata prod(1:5) 120 mean(x) x számtani közepe (mintaátlag) mean(1:10) 5.5 median(x) x mediánja median(1:10) 5.5 range(x) x legkisebb és legnagyobb eleme range(1:10) 1 10 sd(x) az x minta szórása sd(1:10) 3.03 var(x) az x minta varianciája var(1:10) 9.17 cor(x,y) korreláció x és y között cor(1:10,11:20) 1 5.3.3.5 Típusok kezelése Minden R vektor típusa a négy alaptípus egyike lehet: double, integer, karakteres vagy logikai. Korábban láttuk, hogy a class() és a typeof() függvények pontos tájékoztatást adnak a vektorok típusáról. Létezik azonban egy függvénycsalád, amellyel megvizsgálhatjuk, hogy egy tetszőleges objektum az adott típushoz tartozik-e. Ez az is.*() függvénycsalád, amelynek eleme az is.double(), is.integer(), is.logical() ésis.character() függvény. Nézzünk egy példát használatukra. x.d &lt;- c(3.5, 4.1, 9.2) # új objektum - double vektor is.double(x.d) # x.d vajon double #&gt; [1] TRUE is.integer(x.d) # x.d vajon integer #&gt; [1] FALSE is.character(x.d) # x.d vajon karakteres #&gt; [1] FALSE is.logical(x.d) # x.d vajon logikai #&gt; [1] FALSE Láttuk korábban, hogy a logikai értékek esetében, ha szükséges, automatikus típuskonverzió történik numerikus típusra (TRUE - 1, FALSE - 0). Sok esetben azonban explicit típuskonverzióra van szükség, amit az as.*() függvénycsaláddal hajthatunk végre. Vektorok esetében használhatjuk az as.double(), as.integer(), as.logical() vagy as.character() függvényeket. Nézzünk ezekre is néhány példát. as.double(c(T, F)) # logikai vektorból double #&gt; [1] 1 0 as.integer(c(&quot;2.9&quot;, &quot;a&quot;, &quot;3&quot;)) # karakteres vektorból integer #&gt; [1] 2 NA 3 as.character(1:5) # integer vektorból karakteres #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; as.logical(0:3) # integer vektorból logikai #&gt; [1] FALSE TRUE TRUE TRUE Karakteres értékből könnyen kaphatunk számot, például a \"2.9\" vagy \"3\" esetén, viszont az \"a\" karakter esetében NA érték kerül az integer vektorba, ahogyan ezt a fenti példában is láthatjuk. 5.3.3.6 Az NA hiányzó érték Korábbi példáinkban már felbukkant a hiányzó érték, amelyet az R-ben az NA jelöl. Az adatelemzési munkánkat végigkísérik a hiányzó adatok. Első lépésként azt jegyezzük meg, hogy az NA hiányzó érték tetszőleges típusú vektorban lehet elem. x &lt;- c(2, NA, 4); x # NA numerikus vektorban #&gt; [1] 2 NA 4 x &lt;- c(NA, &quot;erős&quot;, &quot;gyenge&quot;); x # NA karakteres vektorban #&gt; [1] NA &quot;erős&quot; &quot;gyenge&quot; x &lt;- c(T, NA, NA); x # NA logikai vektorban #&gt; [1] TRUE NA NA Egy NA érték jelenlétét a vektorban az is.na() függvénnyel tudjuk kimutatni. Az is.na() argumentuma tetszőleges vektor lehet, visszatérési értéke pedig a bemenő vektor elemszámával megegyező logikai vektor. A visszatérő logikai vektor csak abban a pozícióban tartalmaz TRUE értéket, ahol bemenő vektorban hiányzó adatot találunk. x &lt;- c(1, NA, 3, 4, NA) # két NA a numerikus vektorban is.na(x) # két TRUE a logikai vektorban #&gt; [1] FALSE TRUE FALSE FALSE TRUE Hiányzó értékeket is tartalmazó vektor esetén néhány vektor alapú függvény meglepő eredményt adhat. A statisztikai mutatókat számoló függvények rendre NA-val térnek vissza, ha a bemenő vektorban van hiányzó érték. mean(c(2, NA, 3, 4, 2, 5)) # NA-t tartalmazó vektor átlaga NA #&gt; [1] NA Ha kíváncsiak vagyunk az NA értéken kívüli elemek átlagára, akkor egy második paramétert is szerepeltetnünk kell a mean() függvényben, és minden más statisztikai mutatót számoló függvényben. Az na.rm= argumentum TRUE értéke biztosítja, hogy az átlag számítása során a hiányzó értékeket figyelmen kívül hagyjuk. mean(c(2, NA, 3, 4, 2, 5), na.rm=T) # NA-t tartalmazó vektor átlaga már nem NA #&gt; [1] 3.2 5.3.3.7 Az Inf és a NaN Az R-ben a numerikus műveletek eredménye – a matematikai értelmezéstől sokszor eltérően – vezethet pozitív vagy negatív végtelen eredményre. Ezeket az Inf és a -Inf szimbólumok jelölik, amelyeket különböző kifejezésekben akár mi is felhasználhatunk. 1/0 # ez a matematikában nem értelmes, de R-ben Inf #&gt; [1] Inf log(0) #&gt; [1] -Inf exp(Inf) #&gt; [1] Inf mean(c(1, 2, Inf)) #&gt; [1] Inf Néhány esetben a numerikus kifejezések eredménye nem értelmezhető számként, ezt az R-ben a NaN (Not a Number) jelöli. Ilyen kifejezések például: 0/0 #&gt; [1] NaN Inf-Inf #&gt; [1] NaN Inf/Inf #&gt; [1] NaN Egy kifejezés véges vagy végtelen voltát az is.finite() vagy is.infinite() függvényekkel tesztelhetjük. A NaN értékre az is.nan() függvénnyel kérdezhetünk rá. Figyeljük meg, a NaN értékre, mind az is.nan(), mind az is.na() függvény TRUE értéket ad. x &lt;- c(1, NA, NaN, Inf, -Inf) is.na(x) # melyik elem hiányzó #&gt; [1] FALSE TRUE TRUE FALSE FALSE is.nan(x) # melyik elem nem szám #&gt; [1] FALSE FALSE TRUE FALSE FALSE is.infinite(x) # melyik elem végtelen #&gt; [1] FALSE FALSE FALSE TRUE TRUE is.finite(x) # melyik elem véges #&gt; [1] TRUE FALSE FALSE FALSE FALSE 5.3.3.8 Vektor indexelése Fontos részhez érkeztünk, érdemes kicsit lassítanunk. Már nagyon sok mindent megtanultunk a vektorokról: egy vektorban egy dimenzió mentén azonos típusú értékeket sorolhatunk fel, amellyel a vektoraritmetika szabályai szerint műveleteket tudunk végezni. Például hozzunk létre egy 10 elemű vektort, növeljük meg minden egyes vektorelem értékét 1-gyel. x &lt;- 11:20 # x integer vektor létrehozása x + 1 # kiíratjuk az 1-gyel megnövelt értékeket (x nem változik) #&gt; [1] 12 13 14 15 16 17 18 19 20 21 x # x értékének kiírása #&gt; [1] 11 12 13 14 15 16 17 18 19 20 A fenti sorok hatására a konzolban egy 10 elemű vektor elemei jelennek meg, minden elem 1-gyel nagyobb, mint az x adott eleme. Egyetlen összeadás (+) operátor segítségével valójában 10 összeadás végrehajtását írtuk elő. Vegyük észre, hogy maga az x vektor nem módosult, továbbra is az eredeti 11:20 elemeket tartalmazza. Egy objektum ugyanis addig őrzi az értékét, amíg értékadó operátor segítségével felül nem írjük. Tekintsük most a következő sorokat. y &lt;- 11:20 # y integer vektor létrehozása y &lt;- y + 1 # megnöveljük 1-gyel y értékeit (y megváltozik) y # y értékének kiírása #&gt; [1] 12 13 14 15 16 17 18 19 20 21 Az y vektor 10 elemű, a 11:20 értékekkel hoztuk létre. A második sorban azonban megváltoztatjuk az y értékét, mert újra az értékadás bal oldalán szerepel az y objektum. Az y új értéke az értékadás jobb oldalán szereplő kifejezés értéke lesz, azaz a y+1 összeadás eredménye, ami nem más, mint a 12:21. Az y értékének megjelenítésével ellenőrizhetjük, hogy valóban a 12:21 elemek kerülnek a konzolba. A fenti példában y minden értékét megváltoztattuk. Az eredeti 11:20 helyett az új érték 12:21. Az y vektor minden egyes eleme megváltozott, például ahol 11 volt, ott most 12 van, ahol 12 volt ott most 13. Ha szükség van az eredeti és az új y értékekre akkor kicsit módosítanunk kell az eddigi sorokon. z &lt;- 11:20 # z integer vektor létrehozása z.uj &lt;- z + 1 # z.uj double vektor létrehozása (z nem változik) z # z értékének kiírása #&gt; [1] 11 12 13 14 15 16 17 18 19 20 z.uj # z.uj értékének kiírása #&gt; [1] 12 13 14 15 16 17 18 19 20 21 A z vektor is 10 elemű, a 11:20 a kezdőértéke, és jól látható, hogy a fenti sorok hatására ez nem is változik meg, hiszen a z újra már nem jelenik meg értékadás bal oldalán. Értékadás jobb oldalán viszont felbukkan, a második sorban a z.uj objektum létrehozásához használtuk fel z értékét. Az z és z.uj objektumok értékének kiírásával ellenőrizhetjük, hogy a z továbbra is biztonságosan tárolja a 11.20 értékeket, de a z.uj-ban a kívánt 12:21 módosított értékek is megtalálhatók. A további munkafázisokban így az eredeti és a módosított értékek is elérhetők lesznek, ami újdonság, mert az előző példákban ez a lehetőség nem volt elérhető. Az x objektumot használó példában csak az eredeti, az y vektoros példában csak a módosított értékeket tudnánk a későbbiekben használni. Összefoglalva az eddigieket, két tanulságot vonhatunk le. Egyfelől, a vektorműveleteknek csak akkor lesz “maradandó” hatása, ha objektumban őrizzük a számítás eredményét, azaz értékadást használunk. Ez az objektum lehet a kiindulásként használt eredeti objektum (y &lt;- y + 1), de biztonságosabb ha új objektumot hozunk létre az új értékek számára (z.uj &lt;- z + 1), mert így az eredeti értékeket a jövőben is tudjuk használni. Másfelől, ezek a példák ráirányítják a figyelmet a vektoraritmetika egy nagyszerű jellemzőjére: a vektorműveletek megadása független a vektor hosszától, nem lesz bonyolultabb egy vektorművelet, például az x+1 összeadás ha x nem 10 elemű, hanem mondjuk 100 hosszú. Az összeadás művelet parancsa 100 elemű vektor esetén is csupán x+1, azonban a háttérben nem 10, hanem 100 összeadás történik. Akár 10, akár 100 elemű az x, az összes elemre az x segítségével hivatkozhatunk, és az x+1 összeadás az x összes eleméhez hozzáad 1-et. De mit tegyünk, ha nincs szükségünk x összes elemére, vagy nem szeretném x összes elemét megnövelni 1-gyel, csak néhányat. Ekkor indexelést kell használnunk. Az adatfeldolgozás során gyakori, hogy a vektor egyes elemeit külön-külön szeretnénk elérni, lekérdezni vagy módosítani. A vektor egy tetszőleges részét, egy vagy több elemét az indexelés művelettel érhetjük el, melynek eredménye szintén vektor lesz. Az index operátor jele a szögletes zárójel ([]) az R-ben, amit a vektor neve után kell írnunk. Vektorok indexelésének általános alakja: vektor[indexvektor] # az eredmény egy vektor Az indexvektor lehet numerikus, karakteres és logikai vektor is. Nézzük ezeket sorban. 5.3.3.8.1 Indexelés numerikus vektorokkal Kezdjük egy 10 elemű x vektor létrehozásával. x &lt;- 11:20; x #&gt; [1] 11 12 13 14 15 16 17 18 19 20 Megfigyelhetjük, hogy az x vektor 1. eleme 11, a 2. a 12, az utolsó, a 10. pedig éppen 20. Ebben a felsorolásban az elemek sorszámai (1., 2., 10.) pontosan a vektor indexeit jelentik. A vektor indexelése tehát 1-gyel kezdődik, ez az 1. elem indexe, a 2. elem indexe 2, az utolsó elemé pedig 10. Ha az index operátorba egy ilyen egyszerű sorszámot írunk, akkor a vektor adott indexű elemét érhetjük el. x[1] # x vektor 1. eleme #&gt; [1] 11 x[2] # x vektor 2. eleme #&gt; [1] 12 x[10] # x vektor 10. eleme #&gt; [1] 20 Nem csak lekérdezhetjük, hanem az értékadó operátor segítségével módosíthatjuk is valamelyik elemet. x[2] &lt;- 100 # x 2. elemének módosítása x[3] &lt;- 2*x[2] # x 3. elemének módosítása x #&gt; [1] 11 100 200 14 15 16 17 18 19 20 Itt először a második elemet 100-ra cseréljük, majd a harmadikat a második kétszeresére. A változást ellenőrizhetjük a konzolban. Ha az x vektort az elemszámánál nagyobb indexszel próbáljuk elérni, akkor NA értéket kapunk: x[11] # x csak 10 elemű, a 11. nem létező elem #&gt; [1] NA Vektorokat azonban nem csak egy elemű indexvektorokkal indexelhetünk, hanem két vagy több elemű numerikus vektorokat is használhatunk. Ebben az esetben az indexvektorban felsorolt sorszámoknak megfelelő indexű elemeket érhetjük el. x &lt;- 11:20 x[c(1, 3, 5)] # x vektor 1., 3. és 5. eleme #&gt; [1] 11 13 15 x[c(3, 5, 3, 1)] # x vektor 3., 5., 3. és 1. eleme #&gt; [1] 13 15 13 11 x[3:6] # x vektor 3., 4., 5. és 6. eleme #&gt; [1] 13 14 15 16 y &lt;- c(3,7) x[y] # x vektor 3. és 7. eleme #&gt; [1] 13 17 x[seq(from=2, to=10, by=2)] # x vektor páros indexű elemei #&gt; [1] 12 14 16 18 20 A fenti példákban látható, hogy az indexelés során létrejött vektorok elemszáma az indexvektor elemszámával egyenlő. Egy indexet akár többször is felsorolhatunk, és tetszőleges sorrend megengedett. A szögletes zárójelben lévő indexvektort helyben is elkészíthetjük a c() és seq() függvénnyel (vagy bármilyen más vektorlétrehozó függvénnyel), vagy a kettőspont (:) operátorral, de korábban létrehozott objektumot is használhatunk indexelésre (x[y]). Az indexelés során több vektorelemet egy lépésben is tudunk módosítani. Az indexelt elemek kaphatnak azonos vagy különböző értéket. Itt is a vektoraritmetika szabályai működnek. x &lt;- 11:20 x[c(1, 2, 3)] &lt;- c(110, 120, 130) # x 1., 2. és 3. elemét módosítjuk x[c(4, 5, 6)] &lt;- 0 # x 4., 5. és 6. elemét módosítjuk x[c(7, 8, 9)] &lt;- c(170, 180) # x 7., 8. és 9. elemét módosítjuk x #&gt; [1] 110 120 130 0 0 0 170 180 170 20 A fenti példában az x vektor három-három elemét módosítjuk az egyes értékadások során. Az értékadó operátor (&lt;-) engedelmeskedik a vektoraritmetika szabályainak, azaz az értékadás bal és jobb oldalán szereplő vektorokat tekinthetjük két olyan vektornak, amelyek között műveletet szeretnénk végrehajtani. Az első értékadásban azonos elemszámú a két vektor, a koordinátánkénti értékadás azonnal megtörténik (x[c(1, 2, 3)] &lt;- c(110, 120, 130)). A másik két értékadásban különbözik a két vektor elemszáma, így először ismétléssel kiegészül a jobb oldali, rövidebbik vektor, majd ezután következhet a koordinátánkénti végrehajtás. Egy vektor indexe mindig egész szám, de az R megengedi, hogy tört értékeket tartalmazó indexvektort szerepeltessünk az index operátorban, ekkor az egész részét veszi az indexeknek, egyszerűen csonkolja őket. x &lt;- 11:20 x[2.3] # x 2. eleme #&gt; [1] 12 x[2.8] # x 2. eleme #&gt; [1] 12 Negatív értékeket tartalmazó numerikus vektorral is indexelhetünk, ekkor a negatív előjellel megadott sorszámokon kívül az összes többi elemet tudjuk elérni vagy módosítani. x &lt;- 11:15 x[-3] # minden x elem, kivéve a 3. #&gt; [1] 11 12 14 15 x[-c(1, 5)] # minden x elem, kivéve az 1. és az 5. #&gt; [1] 12 13 14 x[-(1:3)] # minden x elem, kivéve az első 3 #&gt; [1] 14 15 x[-2] &lt;- 0 # minden x elem módosul, kivéve a 2. x #&gt; [1] 0 12 0 0 0 5.3.3.8.2 Indexelés karaketeres vektorokkal Amennyiben egy vektor elemei rendelkeznek névvel, akkor karakteres indexvektorokat is használhatunk az indexeléshez. Ez meglehetősen nagy könnyebbséget jelent, ugyanis nem kell ismernünk a kívánt elem pozícióját, azaz indexét, elegendő fejben tartanunk az elem nevét. Vegyük példaként a tanulók matematika versenyen elért pontszámait tartalmazó vektort. x &lt;- c(&#39;Peti&#39;=35, &#39;Bori&#39;=37, &#39;Éva&#39;=33) x[&quot;Bori&quot;] # x &quot;Bori&quot; nevű eleme #&gt; Bori #&gt; 37 x[c(&quot;Peti&quot;, &quot;Éva&quot;)] # x &quot;Peti&quot; és &quot;Éva&quot; nevű eleme #&gt; Peti Éva #&gt; 35 33 x[c(&quot;Peti&quot;, &quot;Éva&quot;)] &lt;- c(36, 34) # x fenti 2 elemének módosítása x #&gt; Peti Bori Éva #&gt; 36 37 34 Látható, hogy a kívánt elem eléréséhez, például Bori matematika teljesítményéhez nem kell ismernünk Bori pontszámának pozícióját, elegendő a névre emlékeznünk. 5.3.3.8.3 Indexelés logikai vektorokkal Vektorok indexeléséhez logikai vektorokat is használhatunk. Első pillanatban kényelmetlennek, sőt feleslegesnek tűnik ez a lehetőség, de a következő fejezetben, a vektorok szűrésénél, magunk is meggyőződhetünk e módszer káprázatos erejéről A logikai indexvektor működése nagyon egyszerű. Hossza az indexelendő vektor hosszával egyenlő, és a TRUE logikai értékkel jelezzük, hogy az adott pozíción lévő elemet el akarjuk érni, a FALSE értékkel pedig azt, hogy nincs szükség arra az elemre. x &lt;- 11:15 x[c(T, F, T, T, F)] # x vektor 1., 3., és 4. eleme #&gt; [1] 11 13 14 A fenti példában TRUE szerepel az 1., 3. és 4. pozícióban, így az x vektor 1., 3. és 4. elemeit érhetjük el. Az indexelésre használt logikai vektor elemszáma kisebb is lehet, mint az indexelt vektor hossza, ekkor az R az indexvektor ismétlésével kapja meg a kívánt hosszt. x &lt;- 11:15 x[c(T, F)] # x vektor 1., 3. és 5. eleme #&gt; [1] 11 13 15 x[T] # x vektor összes eleme #&gt; [1] 11 12 13 14 15 x[F] # x vektor egyik eleme sem #&gt; integer(0) A c(T, F) vektor két elemű, az indexelendő x viszont 5 hosszú, így az R ismétléssel előállítja a c(T, F, T, F, T) öt elemű vektort, és ezt használja az x indexeléséhez. Ha a csupa TRUE értékű vektorral indexelünk, akkor az x vektor összes elemét megkapjuk, ha pedig a csupa FALSE értékkel, akkor az üres vektort kapjuk. Az integer(0) az üres integer vektort jelöli. A logikai vektorral indexelt vektorelemeket ugyanúgy módosíthatjuk, mint korábban a numerikus és karakteres indexvektorok esetén. x &lt;- 11:15 x[c(T, F)] &lt;- 0 # x vektor 1., 3. és 5. elemét módosítjuk x[c(F, T, F, T, F)] &lt;- c(120, 140) # x vektor 2. és 4. elemét módosítjuk x #&gt; [1] 0 120 0 140 0 5.3.3.8.4 Indexelés speciális értékekkel Az indexelésnek van néhány speciális esete, amelyet érdemes ismernünk. Vektorok indexelése során az indexoperátor üresen is maradhat, ekkor a vektor összes elemét elérhetjük, vagyis az x és x[] kifejezések ugyanazt az outputot adják. x &lt;- 11:15 x[] # x minden eleme #&gt; [1] 11 12 13 14 15 x[NaN] # egyetlen NA #&gt; [1] NA x[NA] # x elemszámának megfelelő NA #&gt; [1] NA NA NA NA NA A fenti példákból kiolvasható, hogy a NaN és NA indexként való használata egyetlen NA-t, vagy az x hosszának megfelelő számú hiányzó értéket szolgáltat. Legyünk óvatosak, ha az indexvektor tartalmaz NA értéket, akkor az eredménybe azon a pozíción szintén NA fog bekerülni. x &lt;- 11:15 x[c(1, NA, 2)] # x 1. eleme, NA és x 2. eleme #&gt; [1] 11 NA 12 x[c(1, NA, 2)] &lt;- 100 # x 1. és 2. elemének módosítása x #&gt; [1] 100 100 13 14 15 Kerüljük az értékadást NA-t tartalmazó indexvektor használata esetén. A fenti példában az értékadás ugyan nem jelez hibát, és ellenőrizhetjük, hogy valóban megtörtént az első két vektorelem módosítása. Azonban az értékadás jobb oldalán a több elemű vektor már nem engedélyezett, például az x[c(1, NA, 2)] &lt;- c(100, 200) értékadás hibaüzenethez vezet. Összefoglalva, minden esetben ellenőrizzük, hogy az indexvektorunk tartalmaz-e NA hiányzó értéket. 5.3.3.9 Vektor szűrése Eddig a vektorok elemeit pozíciójuk alapján értük el. Akár sorszámot, elemnevet vagy megfelelő pozícióban lévő logikai igaz/hamis értéket használtunk indexelésre, végső soron az számított, hogy az adott elem hol található a vektorelemek egydimenziós sorában. Ebben a fejezetben egy teljes más kiinduló pontot használunk a vektorelemek elérésére és ez a vektor tartalma lesz, vagyis a vektorelem konkrét értéke (és nem a pozíciója). Bővítsük ki a matematika pontszámokat tartalmazó vektorunkat, rögzítsük hat tanuló eredményét. x &lt;- c(&#39;Peti&#39;=35, &#39;Bori&#39;=37, &#39;Éva&#39;=33, &#39;Pál&#39;=21, &#39;Gergő&#39;=34, &#39;Ili&#39;=40) x #&gt; Peti Bori Éva Pál Gergő Ili #&gt; 35 37 33 21 34 40 Ha arra vagyunk kíváncsiak, hogy kik értek el 36 pontnál többet a versenyen és milyen pontszámokkal, akkor rövid áttekintés után megadhatjuk a választ, sőt a pozíció alapján könnyen elvégezhetjük az alábbi indexeléseket is. x[c(2, 6)] # indexelés numerikus vektorral #&gt; Bori Ili #&gt; 37 40 x[c(&quot;Bori&quot;, &quot;Ili&quot;)] # indexelés karakteres vektorral #&gt; Bori Ili #&gt; 37 40 x[c(F, T, F, F, F, T)] # indexelés logikai vektorral #&gt; Bori Ili #&gt; 37 40 A fenti sorok az eddigiekhez képest semmilyen újdonságot nem tartalmaznak, lényegében összefoglalják a pozíció alapú indexelésről tanultakat. Felmerülhet bennünk a kérdés, ha x nem hat elemű, hanem 60 vagy esetleg 600, akkor mennyi esélyünk lenne az indexelt kifejezések előállítására. Nem sok. Adódik azonban egy másik lehetőség, amely közvetlenül abból indul ki, hogy a 36 pontnál nagyobb vektorelemeket keressük. Logikai művelettel ezt a következőképp fogalmazhatjuk meg. x &gt; 36 # relációs művelet, logikai vektort eredményez #&gt; Peti Bori Éva Pál Gergő Ili #&gt; FALSE TRUE FALSE FALSE FALSE TRUE Korábban láttuk, hogy ez a művelet a vektoraritmetikai szabályainak engedelmeskedve két lépésben értelmezhető: (1) mivel különböző elemhosszú a két vektor, x hat elemű, a 36 egy elemű, először a jobb oldal is hat elemű lesz (c(36, 36, 36, 36, 36, 36)), majd (2) koordinátánként a relációs művelet végrehajtásra kerül, azaz x minden eleméről döntés születik, hogy nagyobb-e, mint 36. A relációs művelet eredménye egy hat elemű logikai vektor, amely pontosan ott TRUE, ahol az illető x elem nagyobb 36-nál, minden más helyen pedig FALSE. Esetünkben a Bori és Ili elemeknél jelenik meg a TRUE, vagyis a 2. és 6. pozícióban. Vegyük észre, hogy ez pontosan az a logikai vektor, mint amit korábban hoztunk létre a pozíció alapú indexelés egyik példájaként (x[c(F, T, F, F, F, T)]). A relációs művelet eredményét, mint logikai vektort, kiválóan fel tudjuk használni az indexelésben a 36 pontnál nagyobb vektorelemek eléréséhez. x[x &gt; 36] # x vektor szűrése (36-nál nagyobb elemek leválogatása) #&gt; Bori Ili #&gt; 37 40 A fenti sor az első példa szűrésre. A szűrés lényegében logikai vektorral való indexelés, ahol a logikai indexvektort egy olyan logikai kifejezés állítja elő, amely hivatkozik a vektor tartalmára. A definíciót értelmezve a példára: a logikai vektor, amely alapján az indexelés történik a c(F, T, F, F, F, T), a logikai kifejezés, amely ezt előállítja az x&gt;36, a vektor tartalmára pedig természetesen az x objektumnévvel utalunk a logikai kifejezésen belül. A szűrés nagyszerűen kezeli a vektorhosszal kapcsolatban korábban felvetett problémánkat. Ha az x nem hat, hanem 60 vagy 600 elemű, akkor is az x[x&gt;36] végzi a 36-nál nagyobb elemek leválogatását. Próbáljuk ki a szűrést nagyobb elemszám esetén is. Generáljunk 60 véletlen értékeket a 0-40 értéktartományból, úgy mintha 60 tanuló matematika pontszáma állna rendelkezésre. A sample() függvény az x= argumentumában megadott értékekből, a size=-ban megadott darabszámnyit állít elő. A replace=T argumentummal gondoskodunk arról, hogy egy érték többször is szerepelhessen az eredményvektorban. pontszamok &lt;- sample(x = 0:40, size = 60, replace = T) # véletlen értékek pontszamok[1:10] # vektor első 10 eleme #&gt; [1] 37 9 26 35 22 20 31 39 27 29 pontszamok[pontszamok &gt; 36] # vektor szűrése #&gt; [1] 37 39 38 37 37 38 37 A pontszamok vektor 60 elemű, az első 10 értékét a képernyőn láthatjuk. A 36-nál nagyobb elemek megjelenítését szűréssel végeztük. Látható, hogy a szűrés nem lett bonyolultabb a vektor hosszának növekedésével. Más relációs operátorokat (5.6. táblázat) is használhatunk a szűrésben, sőt logikai operátorok (5.7. táblázat) segítségével tetszőleges természetes nyelven megfogalmazott feltételt át tudunk fordítani R logikai kifejezésbe. A logikai operátorokat tartalmazó logikai kifejezéseket összetett logikai kifejezéseknek nevezzük. Írassuk ki a pontszámokat 36 és 39 között, majd 3 és 6 között, és végül mindezeket együtt. pontszamok[pontszamok&gt;=36 &amp; pontszamok&lt;=39] #&gt; [1] 37 39 38 36 37 36 37 36 38 36 37 pontszamok[pontszamok&gt;=3 &amp; pontszamok&lt;=6] #&gt; [1] 4 5 5 3 4 4 pontszamok[(pontszamok&gt;=36 &amp; pontszamok&lt;=39) | (pontszamok&gt;=3 &amp; pontszamok&lt;=6)] #&gt; [1] 37 39 4 38 36 5 37 36 5 3 4 4 37 36 38 36 37 Időnként szükségünk lehet arra az információra, hogy a vektorban melyik pozícióban vannak a feltételnek eleget tevő vektorelemek. Erre a feladatra a which() függvényt használhatjuk. A which() függvény bemenő paraméterként egy logikai vektort vár, visszatérési értéke pedig a TRUE logikai értékek indexe lesz. Térjünk vissza a matematika pontszámokhoz. x &lt;- c(&#39;Peti&#39;=35, &#39;Bori&#39;=37, &#39;Éva&#39;=33, &#39;Pál&#39;=21, &#39;Gergő&#39;=34, &#39;Ili&#39;=40) which(x &gt; 36) # hol vannak 36-nál nagyobb elemek #&gt; Bori Ili #&gt; 2 6 which(36 &lt;= x &amp; x &lt;= 39) # hol vannak 36-39 közötti elemek #&gt; Bori #&gt; 2 which(x == 21) # hol van a 21-es elem #&gt; Pál #&gt; 4 which(x != 21) # hol van nem 21-es elem #&gt; Peti Bori Éva Gergő Ili #&gt; 1 2 3 5 6 Az outputokban nem látjuk a tanulók pontszámát, tehát nem a szűrés a which() célja, azoknak a vektorelemeknek az indexét látjuk, amelyek az egyszerű vagy összetett logikai kifejezéseknek eleget tesznek. Végezetül tekintsük át a szűrés és az értékadás kapcsolatát. Az adatelemzés során előfordulhat, hogy bizonyos feltételnek eleget tevő elemeket módosítani szeretnénk. Például, ha egy vektorban előzetesen a hiányzó értékeket 99-cel jelöljük, akkor a későbbi hibamentes elemzéshez NA-ra kell módosítanunk ezeket az értékeket. x &lt;- c(11, 3, 99, 4, 99) # nyers vektor, a 99 jelentése hiányzó érték x[x == 99] &lt;- NA # 99 átírása NA-ra x #&gt; [1] 11 3 NA 4 NA Az x így már helyes módon tartalmazza a hiányzó értékeket. Ha esetleg később kiderül ezeknek az elemeknek a tényleges értéke, akkor az NA-t kell helyettesítenünk új értékekkel. Vigyázzunk, az x == NA kifejezés helytelen a hiányzó értékek tesztelésére, erre az is.na() függvényt kell használnunk. x[is.na(x)] &lt;- c(5, 7) # hiányzó értékek módosítása x #&gt; [1] 11 3 5 4 7 Az x vektorban két hiányzó érték volt, így a fenti értékadás jobb oldalán két elemű vektort használunk. Ha mindkét hiányzó értéket azonos számmal szeretnénk felülírni, akkor elegendő lenne a x[is.na(x)] &lt;- 7 kifejezés is. Korábban már említettük a (5.3.3.8.4. alfejezetben, hogy kerüljük az értékadást NA-t tartalmazó indexvektor használata esetén. Azonban nem minden esetben tudunk kitérni az ilyen esetek elől. Növeljük meg a hiányzó értékeket tartalmazó x vektor azon elemeit 1-gyel, amelyek 36-nál kisebbek! A nyilvánvalónak látszó x[x &lt; 36] &lt;- x[x &lt; 36] + 1 parancs helytelen, hibaüzenetet ad. Az értékadás mindkét oldalán a logikai kifejezésekhez fűzzük hozzá a &amp; !is.na(x) kifejezést, így tudjuk az NA értékeket eltávolítani az értékadás mindkét oldaláról. x &lt;- c(33, NA, 32, 38, NA, 37) x[x &lt; 36 &amp; !is.na(x)] &lt;- x[x &lt; 36 &amp; !is.na(x)] + 1 5.3.3.10 Vektor rendezése Egy vektor elemeit növekvő vagy csökkenő sorrendbe rendezhetjük. Az R-ben a vektor elemeit a sort() vagy az order() függvénnyel rendezhetjük. x &lt;- c(1:5, 5:3); x #&gt; [1] 1 2 3 4 5 5 4 3 sort(x) # x elemei növekvő sorrendben #&gt; [1] 1 2 3 3 4 4 5 5 sort(x, decreasing=T) # x elemei csökkenő sorrendben, vagy: rev(sort(x)) #&gt; [1] 5 5 4 4 3 3 2 1 A sort() függvény alapértelmezés szerint növekvő sorrendbe rendezi a bemeneti vektort, ha azonban a decreasing= paramétert TRUE-ra állítjuk, csökkenő rendezést kapunk. A rev() függvénnyel, amely a bementi vektor elemeit fordított sorrendben sorolja fel, szintén elérhetjük a csökkenő rendezettséget. Ha a sort() függvénnyel átrendezett vektort a továbbiakban fel szeretnénk használni, akkor azt érdemes új objektumban tárolni (x.2 &lt;- sort(x)). A vektor rendezésének másik módja az order() függvényhez kapcsolódik. A visszatérési érték ekkor egy numerikus indexvektor, amellyel a bemenő vektort indexelve rendezett vektort kapunk. x &lt;- c(1:5, 5:3); x #&gt; [1] 1 2 3 4 5 5 4 3 order(x) # indexekkel tér vissza #&gt; [1] 1 2 3 8 4 7 5 6 x[order(x)] # azonos a sort(x)-szel #&gt; [1] 1 2 3 3 4 4 5 5 x[order(x, decreasing=T)] # azonos a sort(x, decreasing=T)-val #&gt; [1] 5 5 4 4 3 3 2 1 Az order() függvény esetében is használhatjuk a decreasing= paramétert, amellyel csökkenő sorrendbe rendezhetjük a vektorunkat. A numerikus vektorokon túl a karakteres és logikai vektorokat is sorba rendezhetjük a sort() és order() függvényekkel. 5.3.3.11 Összefoglalás Gratulálunk! Maratoni alfejezetünk végigolvasásával jelentős lépést tett meg az Olvasó a magabiztos R ismeretek megszerzéséhez. A vektor minden adatelemzési munka alapja, biztos kezelése kulcsfontosságú. Tetszőleges vektor létrehozásához a c() függvényt használhatjuk, és az elemeket akár nevesíthetjük is. Szabályos vektort a seq(), seq_along(), rep() és a paste() függvénnyel, vagy a kettőspont (:) operátorral készíthetünk. Megbeszéltük a vektorok közötti műveletek végrehajtásának fő szabályát: ismétléssel hozzuk azonos hosszra a vektorokat ha szükséges, majd koordinátánként végezzük el a kívánt műveletet. A vektorokat támogatják a matematikai függvények is, minden vektorelemre meghívódik a függvény. A statisztikai függvények szintén vektort várnak, de többnyire egy értéket szolgáltatnak. A vektorok típusának tesztelése az is.(), a konvertálása pedig az as.() függvényekkel történik. A vektorok indexelésével (vektor[indexvektor]) a vektor elemeit pozíció alapján, a vektorok szűrésével (vektor[logikai-indexvektor]) a vektor elemeit érték alapján érhetjük el vagy módosíthatjuk. A vektorok rendezését a sort() és az order() függvénnyel is elvégezhetjük. 5.3.3.12 Feladatok Hozzuk létre a következő numerikus vektort: 12, 14, 17. Hozzuk létre a következő karakteres vektort: “Vác”, “Eger”, “Pécs”. Hozzuk létre a következő logikai vektort: TRUE, FALSE, FALSE. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és a különbség 1. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 102, az utolsó 8 és a különbség -1. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és a különbség 2. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, a különbség 3 és a vektor 25 elemű. Hozzuk létre azt a numerikus vektort, amely 12 elemű, és minden elemének -2 az értéke! Hozzuk létre azt a karakteres vektort, amely 7 elemű, és minden elemének “Péntek” az értéke! Hozzuk létre azt a logikai vektort, amely 7 elemű, és minden elemének TRUE az értéke! Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket háromszor egymás után megismétli! Hány elemű az így létrejött vektor? Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket háromszor helyben megismétli! Hány elemű az így létrejött vektor? Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket helyben megismétli úgy, hogy a 2-őt 4-szer, a 3-at 5-ször és az 5-öt 7-szer ismétli meg! Hány elemű az így létrejött vektor? Szabályos vektorok létrehozásának van egy korábban még nem említett módja: a sequence() függvény. Ismerjük meg a súgóból ezt a függvényt, és értelmezzük a sequence(4) és sequence(c(4,5)) függvényhívásokat! Vektorok létrehozásának számos módját megismertük ebben a fejezetben, de elemek megadása nélkül, vagy akár nulla hosszúsággal is létrehozhatunk vektort. A double(), integer(), character() és logical() függvények közvetlenül az adott típusnak megfelelő vektort hozzák létre. A súgó tanulmányozásával állítsunk elő 0 és 10 elemű vektor objektumokat mind a négy típus esetén. Próbáljuk ki az 5.9. táblázatban szereplő példákat. Hozzuk létre a 'Peti'=5, 'Bori'=NA, 'Éva'=3, 'Pál'=NA, 'Gergő'=5, 'Ili'=4 adatokat tartalmazó vektort, majd rendezzük, indexeljük az első és az utolsó elemét, válogassuk le az 5-ös értékeket, csökkentsük mindegyik értéket 1-gyel, csak az 5-öket csökkentsük 1-gyel. A fenti feladatok megoldása 5.3.4 Mátrix A mátrix adatszerkezet egyetlen lényeges dologban különbözik a vektortól: a mátrix kétdimenziós, sorokba és oszlopokba szervezi az elemeket, míg a vektor egydimenziós (érdemes visszalapozni a 5.1. ábrához). A mátrix ugyanúgy homogén, mint a vektor, ennek megfelelően beszélünk double, integer, karakteres és logikai mátrixokról. 5.3.4.1 Mátrix létrehozása Mátrix létrehozásához a matrix() függvényt használjuk, amely egy kiinduló vektor elemeit használja fel a mátrix feltöltéséhez. A data= argumentumban kell megadnunk a kiinduló vektort, majd az nrow= és/vagy ncol= argumentumokban közöljük a sorok és oszlopok számát. x &lt;- matrix(data=1:20, nrow=4) # 4x5-ös integer mátrix x #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 5 9 13 17 #&gt; [2,] 2 6 10 14 18 #&gt; [3,] 3 7 11 15 19 #&gt; [4,] 4 8 12 16 20 A fenti példában a 20 elemű vektort 4 sorban rendezi el a matrix() függvény, ennek megfelelően 5 oszlopos lesz az x mátrix. A matrix() függvényben az ncol= paraméter is használható. x &lt;- matrix(data=1:20, nrow=4, ncol=5) # 4x5-ös integer mátrix x #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 5 9 13 17 #&gt; [2,] 2 6 10 14 18 #&gt; [3,] 3 7 11 15 19 #&gt; [4,] 4 8 12 16 20 x &lt;- matrix(data=1:20, nrow=4, ncol=10) # 4x10-es integer mátrix x #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 1 5 9 13 17 1 5 9 13 17 #&gt; [2,] 2 6 10 14 18 2 6 10 14 18 #&gt; [3,] 3 7 11 15 19 3 7 11 15 19 #&gt; [4,] 4 8 12 16 20 4 8 12 16 20 Az ncol=5 szerepeltetése nem jelent változást az előző példához képest, az x mátrix 4 sort és 5 oszlopot fog tartalmazni, rövidebben 4 \\(\\times\\) 5-ös. A következő sorban az ncol=10 argumentum már egy 40 elemű mátrix létrehozását kezdeményezi (4 \\(\\times\\) 10-es), így az 1:20 vektor ismétlésével állnak elő a szükséges elemek. (Figyelmeztetést kapunk, ha a szükséges mátrixelemszám eléréséhez nem egész számszor kell ismételni a kiinduló vektort, de a mátrix ebben az esetben is létre fog jönni.) A fenti példában azt is megfigyelhetjük, hogy a 20 elemű vektorból oszlop-folytonosan jön létre a mátrix, vagyis először az első oszlop töltődik fel a vektorelemekkel, majd a második, és így tovább. Ha sor-folytonosan szeretnénk a bemenő vektor elemeiből mátrixot képezni, akkor a byrow= paramétert igazra kell állítanunk. x &lt;- matrix(1:12, nrow=3, byrow=T) # 3x4-es integer mátrix, sor-folytonosan x #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 Mátrixot karakteres vagy logikai értékekből is építhetünk. matrix(c(&quot;az&quot;,&quot;egy&quot;), nrow=2, ncol=3, byrow=T) # 2x3-as karakteres mátrix #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;az&quot; &quot;egy&quot; &quot;az&quot; #&gt; [2,] &quot;egy&quot; &quot;az&quot; &quot;egy&quot; matrix(c(T,F,T), nrow=2, ncol=6, byrow=T) # 2x6-os logikai mátrix #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] TRUE FALSE TRUE TRUE FALSE TRUE #&gt; [2,] TRUE FALSE TRUE TRUE FALSE TRUE Az előző fejezetben láttuk, hogy a vektorok elemeinek nevet is adhatunk, így olvashatóbbá tehetjük rögzített adatainkat. A matrix() függvény dimnames= argumentumában az egyes sorok és oszlopok elnevezéséről, valamint a két dimenzió nevéről is gondoskodhatunk. x &lt;- matrix(0, nrow = 2, ncol = 3, dimnames = list(&#39;1. dim. neve&#39;=c(&quot;sor.1&quot;, &quot;sor.2&quot;), &#39;2. dim. neve&#39;=c(&quot;oszl.1&quot;, &quot;oszl.2&quot;, &quot;oszl.3&quot;))) x #&gt; 2. dim. neve #&gt; 1. dim. neve oszl.1 oszl.2 oszl.3 #&gt; sor.1 0 0 0 #&gt; sor.2 0 0 0 A dimnames= argumentum a dimenzió-, sor- és oszlopneveket listába rendezve várja. A listákról a 5.3.6. fejezetben olvashatunk. A sor- és oszlopnevek megadásánál tartsuk be az objektumok elnevezésével kapcsolatos szabályokat, azaz betűvel kezdjünk, kerüljük a szóközt és egyéb írásjeleket, tagolásra a pontot használjuk. Létező mátrix esetén a rownames() és a colnames() függvényekkel tudjuk a sor- és oszlopneveket lekérdezni, illetve módosítani. Az egyes dimenziónevek módosítására a names(dimnames(x)) konstrukciót használhatjuk. rownames(x) # sornevek lekérdezése #&gt; [1] &quot;sor.1&quot; &quot;sor.2&quot; colnames(x) # oszlopnevek lekérdezése #&gt; [1] &quot;oszl.1&quot; &quot;oszl.2&quot; &quot;oszl.3&quot; rownames(x) &lt;- c(&quot;eset.1&quot;, &quot;eset.2&quot;) # sornevek módosítása colnames(x) &lt;- c(&quot;o.1&quot;, &quot;o.2&quot;, &quot;o.3&quot;) # oszlopnevek módosítása x #&gt; 2. dim. neve #&gt; 1. dim. neve o.1 o.2 o.3 #&gt; eset.1 0 0 0 #&gt; eset.2 0 0 0 names(dimnames(x)) &lt;- c(&quot;esetek&quot;, &quot;oszlopok&quot;) # dimenziónevek módosítása x #&gt; oszlopok #&gt; esetek o.1 o.2 o.3 #&gt; eset.1 0 0 0 #&gt; eset.2 0 0 0 5.3.4.2 Mátrix indexelése A mátrixok indexelése nagyon hasonló a vektorok indexeléséhez. Itt is az index operátort ([]) kell használnunk, de a két dimenzió miatt vesszővel választjuk el a sorra és az oszlopra vonatkozó indexeket. Mátrix indexelésének általános alakja: # mátrix indexelése, az eredmény egy mátrix vagy egy vektor mátrix[sor-indexvektor, oszlop-indexvektor] A sor-indexvektorra és az oszlop-indexvektorra ugyanazok a szabályok érvényesek, mint vektor esetén az indexvektorra. Használhatunk numerikus, karakteres és logikai egy vagy több elemű vektort, numerikus indexeknél negatív értéket, és természetesen el is hagyhatjuk az egyes dimenziók indexvektorait. Nézzünk ezekre néhány példát. x &lt;- matrix(1:10, nrow=2, ncol=5, byrow=T) x #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 x[2, 3] # 1 elem elérése, vektor output #&gt; [1] 8 x[2, c(1,4)] # 2 elem elérése, vektor output #&gt; [1] 6 9 x[, c(1,4)] # 4 elem elérése, 2x2-es mátrix output #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 6 9 x[, -c(1,4)] # 6 elem elérése, 2x3-as mátrix output #&gt; [,1] [,2] [,3] #&gt; [1,] 2 3 5 #&gt; [2,] 7 8 10 x[1, ] # 5 elem elérése, vektor output #&gt; [1] 1 2 3 4 5 x[c(2, 1), c(T, F, T)] # 6 elem elérése, 2x3-as mátrix output #&gt; [,1] [,2] [,3] #&gt; [1,] 6 8 9 #&gt; [2,] 1 3 4 A mátrix indexelése során a kapott új adatszerkezetek elveszthetik a kétdimenziós jellegüket és így mátrix helyett vektor is lehet az indexelés eredménye. Ha ezt el akarjuk kerülni, használjuk a drop=FALSE paramétert az indexben, ekkor minden esetben mátrix lesz az eredmény. x[2, 3, drop=F] # 1 elem elérése, 1x1-es mátrix output #&gt; [,1] #&gt; [1,] 8 x[2, c(1,4), drop=F] # 2 elem elérése, 1x2-es mátrix output #&gt; [,1] [,2] #&gt; [1,] 6 9 x[2, , drop=F] # 5 elem elérése, 1x5-ös mátrix output #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 6 7 8 9 10 x[, 3, drop=F] # 2 elem elérése, 2x1-es mátrix output #&gt; [,1] #&gt; [1,] 3 #&gt; [2,] 8 Amennyiben a mátrixunk sor- és oszlopnevekkel is rendelkezik, akkor ezeket is felhasználhatjuk az indexelés során. x &lt;- matrix(1:10, nrow=2, ncol=5, byrow=T) rownames(x) &lt;- c(&quot;eset1&quot;, &quot;eset2&quot;) colnames(x) &lt;- paste(&quot;v&quot;, 1:5, sep=&quot;.&quot;) x #&gt; v.1 v.2 v.3 v.4 v.5 #&gt; eset1 1 2 3 4 5 #&gt; eset2 6 7 8 9 10 x[&quot;eset1&quot;, c(&quot;v.2&quot;, &quot;v.1&quot;)] # 2 elem elérése, vektor output #&gt; v.2 v.1 #&gt; 2 1 x[1:2, c(&quot;v.2&quot;, &quot;v.1&quot;)] # 4 elem elérése, 2x2-es mátrix #&gt; v.2 v.1 #&gt; eset1 2 1 #&gt; eset2 7 6 x[&quot;eset2&quot;, paste(&quot;v&quot;, 1:3, sep=&quot;.&quot;)] # 3 elem elérése, vektor #&gt; v.1 v.2 v.3 #&gt; 6 7 8 x[&quot;eset1&quot;, c(T,F), drop=F] # 3 elem elérése, 1x3-as mátrix #&gt; v.1 v.3 v.5 #&gt; eset1 1 3 5 5.3.4.3 Számítások a mátrix soraiban és oszlopaiban Az előző részben említettük, ha üresen hagyjuk a mátrix sor vagy oszlop pozícióját az indexelés során, akkor a mátrix teljes oszlopára vagy sorára tudunk hivatkozni, vagyis alapesetben vektort kapunk. Az így kapott vektorokkal tetszőleges műveleteket hajthatunk végre. Hozzunk létre egy 3 \\(\\times\\) 4-es mátrixot, amely 3 tanuló átlagát tartalmazza 4 tantárgyból. x &lt;- matrix(c(3.7, 5.3, 5.1, 4.2, 4.4, 3.8, 2.9, 4.2, 5.1, 4, 3, 5), nrow=3, ncol=4, byrow=T, dimnames = list(c(&quot;Pál&quot;, &quot;Ili&quot;, &quot;Éva&quot;), c(&quot;matek&quot;, &quot;magyar&quot;, &quot;angol&quot;, &quot;ének&quot;))) x #&gt; matek magyar angol ének #&gt; Pál 3.7 5.3 5.1 4.2 #&gt; Ili 4.4 3.8 2.9 4.2 #&gt; Éva 5.1 4.0 3.0 5.0 mean(x[1,]) # Pál féléves átlaga #&gt; [1] 4.575 sd(x[,4]) # énekből a csoport átlaga #&gt; [1] 0.4618802 Négy speciális függvénnyel az oszlopok és sorok összegét és átlagát számíthatjuk ki. rowSums(x) # sorösszegek, a tanulók jegyeinek összege #&gt; Pál Ili Éva #&gt; 18.3 15.3 17.1 rowMeans(x) # sorátlagok, a tanulók félév végi átlaga #&gt; Pál Ili Éva #&gt; 4.575 3.825 4.275 colSums(x) # oszlopösszegek, a tantárgyak jegyeinek összege #&gt; matek magyar angol ének #&gt; 13.2 13.1 11.0 13.4 colMeans(x) # oszlopátlagok, a tantárgyak átlaga #&gt; matek magyar angol ének #&gt; 4.400000 4.366667 3.666667 4.466667 Általánosabb megoldás, ha az apply() függvényt használjuk, amelyben a mátrix soraira vagy oszlopaira vonatkozó függvényt mi határozzuk meg, így az összegzésen és az átlagszámításon kívül más függvényeket is elérhetünk. Az apply() első paramétere maga a mátrix, a második helyen pedig 1 vagy 2 áll, attól függően, hogy a mátrix soraira (1) vagy oszlopaira (2) akarjuk a harmadik paraméterben szereplő függvényt alkalmazni. apply(x, 1, mean) # sorátlagok, a tanulók félév végi átlaga #&gt; Pál Ili Éva #&gt; 4.575 3.825 4.275 apply(x, 1, sd) # soronkénti szórások #&gt; Pál Ili Éva #&gt; 0.7544314 0.6652067 0.9844626 apply(x, 1, min) # soronkénti minimumok #&gt; Pál Ili Éva #&gt; 3.7 2.9 3.0 apply(x, 2, mean) # oszlopátlagok, a tantárgyak átlaga #&gt; matek magyar angol ének #&gt; 4.400000 4.366667 3.666667 4.466667 apply(x, 2, sd) # oszloponkénti szórások #&gt; matek magyar angol ének #&gt; 0.7000000 0.8144528 1.2423097 0.4618802 apply(x, 2, min) # oszloponkénti minimumok #&gt; matek magyar angol ének #&gt; 3.7 3.8 2.9 4.2 Hiányzó értékek esetén a fenti függvények NA értéket adnak eredményül, így itt is szükséges az na.rm=T argumentum szerepeltetése. x[&quot;Pál&quot;, &quot;matek&quot;] &lt;- NA # módosítjuk Pál matek jegyét hiányzóra rowMeans(x) # Pálnál NA lesz #&gt; Pál Ili Éva #&gt; NA 3.825 4.275 apply(x, 1, mean) # Pálnál NA lesz #&gt; Pál Ili Éva #&gt; NA 3.825 4.275 rowMeans(x, na.rm=T) # így jó Pálnál is #&gt; Pál Ili Éva #&gt; 4.866667 3.825000 4.275000 apply(x, 1, mean, na.rm=T) # így jó Pálnál is #&gt; Pál Ili Éva #&gt; 4.866667 3.825000 4.275000 5.3.4.4 Sorok és oszlopok kezelése Mátrixokat az rbind() és a cbind() függvényekkel is építhetünk. cbind(1, 1:2, 1:4) # mátrix létrehozása oszlopvektorokból #&gt; [,1] [,2] [,3] #&gt; [1,] 1 1 1 #&gt; [2,] 1 2 2 #&gt; [3,] 1 1 3 #&gt; [4,] 1 2 4 rbind(1, 1:2, 1:4) # mátrix létrehozása sorvektorokból #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 1 1 1 #&gt; [2,] 1 2 1 2 #&gt; [3,] 1 2 3 4 Vektor paraméterek esetén, a felsorolt vektorok fogják alkotni az új mátrix oszlopait (cbind() esetén), illetve sorait (rbind() esetén), a rövidebb vektor, ha van ilyen, ismétlődni fog. Új oszloppal vagy új sorral is kiegészíthetjük a már létező mátrixunkat. x &lt;- matrix(1:12, nrow=4, ncol=3); x #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 cbind(-3:0, x, 13:16) # oszlopvektorok hozzáfűzése x elé és mögé #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] -3 1 5 9 13 #&gt; [2,] -2 2 6 10 14 #&gt; [3,] -1 3 7 11 15 #&gt; [4,] 0 4 8 12 16 rbind(-1, x, 1) # sorvektorok hozzáfűzése x fölé és alá #&gt; [,1] [,2] [,3] #&gt; [1,] -1 -1 -1 #&gt; [2,] 1 5 9 #&gt; [3,] 2 6 10 #&gt; [4,] 3 7 11 #&gt; [5,] 4 8 12 #&gt; [6,] 1 1 1 Tetszőleges pozícióba beszúrhatunk egy oszlopot vagy egy sort. Ehhez első lépésben a létező x mátrixhoz hozzáillesztjük az új oszlopot vagy sort, majd indexeléssel átrendezzük az oszlopokat vagy sorokat. cbind(x, 13:16)[, c(1,2,4,3)] # oszlopvektor hozzáfűzése, majd oszlopok indexelése #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 5 13 9 #&gt; [2,] 2 6 14 10 #&gt; [3,] 3 7 15 11 #&gt; [4,] 4 8 16 12 rbind(x, -1)[c(1, 2, 3, 5, 4),] # sorvektor hozzáfűzése, majd sorok indexelése #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] -1 -1 -1 #&gt; [5,] 4 8 12 Hasznos lehetőség összesítő sorok vagy oszlopok mátrixhoz fűzése és elnevezése: x &lt;- matrix(1:12, nrow=4, ncol=3); x #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 x &lt;- rbind(x,apply(x,2,mean)) # átlag sor hozzáfűzése rownames(x) &lt;- c(1:4,&quot;átlag&quot;) # az új sor nevének átírása x #&gt; [,1] [,2] [,3] #&gt; 1 1.0 5.0 9.0 #&gt; 2 2.0 6.0 10.0 #&gt; 3 3.0 7.0 11.0 #&gt; 4 4.0 8.0 12.0 #&gt; átlag 2.5 6.5 10.5 A sorok vagy oszlopok sorrendjét is megcserélhetjük a mátrixban, valamint ezek törlésére is van lehetőségünk: x &lt;- matrix(1:12, nrow=4, ncol=3); x #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 y &lt;- x[, c(2, 3, 1)] # oszlopcsere y &lt;- x[c(3, 2, 4, 1), ] # sorcsere y &lt;- x[, c(1, 3)] # a 2. oszlop törlése y &lt;- x[c(1, 3), ] # az 2. és a 4. sor törlése 5.3.4.5 Összefoglalás A mátrix homogén kétdimenziós adatszerkezet, és többnyire a matrix() függvénnyel hozzuk létre, de használhatjuk a cbind() és rbind() függvényeket is. Mátrix indexelése a [,] operátorral történik, ahol sor- és oszlopindex megadásra van lehetőségünk. A mátrix sorain vagy oszlopain külön-külön is tudunk műveleteket végezni az apply() függvénnyel, a sor- és oszlopneveket a rownames() és a colnames() függvénnyel kezelhetjük. 5.3.4.6 Feladatok Hozzunk létre egy csupa 1-ből álló mátrixot, amelynek 3 sora és 2 oszlopa van! Hozzunk létre egy 3 \\(\\times\\) 4-es karakteres mátrixot, amely 12 különbüző keresztnevet tartalmaz! Hozzunk létre egy 3 \\(\\times\\) 4-es logikai mátrixot, amelynek 1. és 3. sora TURE a 2. sora pedig FALSE értékeket tartalmaz! Mátrixok indexelésére olyan speciális indexmátrix is használható, amelynek két oszlopa van, és az elérendő elemek sor- és oszlopkoordinátáit tartalmazza. Mutassunk példát erre a mátrix[indexmátrix] alakú mátrixindexelésre! A fenti feladatok megoldása 5.3.5 Faktor A faktor adattípus nagyon hasonló a vektorhoz, ugyanis minden faktor egy speciális integer vektor, a faktor tehát homogén és egydimenziós adatszerkezet. Faktorokat elsősorban kategorikus változók értékeinek tárolására használjuk, ilyen például a személyek neme vagy iskolai végzettsége. A faktor egy lényeges ponton több mint egy egyszerű integer vektor. A faktor karbantart egy összerendelést az 1-gyel kezdődő numerikus egészek és a faktor lehetséges karakteres értékei, a címkék között (az 5.1. ábrán ezt egy piros kis téglalappal jelöltük). Egy faktorelem értéke csak ezekből a címkékből kerülhet ki, ami nagy fokú védelmet jelent számunkra az adatkezelés során. Ha például létrehozunk egy faktort az (1-\"férfi\", 2-\"nő\") összerendeléssel, akkor egy faktorelem csak a \"férfi\" vagy \"nő\" címkéket veheti fel, más értéket nem (az NA hiányzó érték természetesen lehet faktorelem értéke is). A munka során mindig a címkékkel találkozunk, a háttérben lévő numerikus egészek csak ritkán kapnak szerepet. 5.3.5.1 Faktor létrehozása A faktorokat jellemzően karakteres vagy numerikus vektorokból hozzuk létre a factor() függvénnyel. A faktor létrehozásánál mindig gondoskodjunk a faktor lehetséges értékeinek, vagyis a faktor címkéiknek megadásáról. A címkéket néha (faktor)szinteknek (levels) is nevezzük. Mivel a kategorikus változóink lehetséges értékei többnyire ismertek az adatkezelés elején, a faktorszintek felsorolása nem okozhat nehézséget. Most hozzunk létre egy faktort, amely öt személy nemét tartalmazza. x &lt;- c(&quot;férfi&quot;, &quot;férfi&quot;, &quot;nő&quot;, &quot;férfi&quot;, &quot;nő&quot;) # karakteres vektor létrehozása x.f &lt;- factor(x, levels=c(&quot;férfi&quot;, &quot;nő&quot;)) # faktor létrehozása x.f # faktor kiíratása #&gt; [1] férfi férfi nő férfi nő #&gt; Levels: férfi nő unclass(x.f) # integer kódok a háttérben #&gt; [1] 1 1 2 1 2 #&gt; attr(,&quot;levels&quot;) #&gt; [1] &quot;férfi&quot; &quot;nő&quot; Az x.f faktort az x karakteres vektorból hoztuk létre, így x.f ugyanúgy 5 hosszú, mint az x. Az x.f outputjában olvasható Levels: férfi nő rész azt közli velünk, hogy a háttérben az 1 numerikus értéknek a \"férfi\" címke, míg a 2-nek a \"nő\" címke felel meg. A belső integer kódok is feltárulnak az unclass(x.f) outputjában. A szám-címke összerendelést magunk szabályozhatjuk, ha a factor() függvény levels= argumentumában módosítunk a sorrenden. x.f &lt;- factor(x, levels=c(&quot;nő&quot;, &quot;férfi&quot;)) # faktor létrehozása x.f #&gt; [1] férfi férfi nő férfi nő #&gt; Levels: nő férfi A fenti x.f faktor ugyanannak az 5 személynek a nemét tartalmazza, de az összerendelést a levels=c(\"nő\", \"férfi\") paraméterrel (1-\"nő\", 2-\"férfi\")-re változtattuk. Láthatjuk, a címkék sorrendje a faktor értékeitől független, mégis fontos szerepet kap majd a táblázatok és ábrák megjelenítésénél, tehát érdemes rá odafigyelni. A levels= argumentum szerepeltetése a factor() függvényben sok kellemetlenségtől kímélhet meg minket. Ha elhagyjuk, akkor a factor() függvény a karakteres vektorban aktuálisan rendelkezésre álló értékekből konstruálja meg a faktort. Nézzünk erre három esetet. (x.f.1 &lt;- factor(c(&quot;férfi&quot;, &quot;férfi&quot;, &quot;nő&quot;, &quot;férfi&quot;, &quot;nő&quot;))) #&gt; [1] férfi férfi nő férfi nő #&gt; Levels: férfi nő (x.f.2 &lt;- factor(c(&quot;férfi&quot;, &quot;Férfi&quot;, &quot;nő&quot;, &quot;férfi&quot;, &quot;nő&quot;))) #&gt; [1] férfi Férfi nő férfi nő #&gt; Levels: férfi Férfi nő (x.f.3 &lt;- factor(c(&quot;nő&quot;, &quot;nő&quot;, &quot;nő&quot;, &quot;nő&quot;, &quot;nő&quot;))) #&gt; [1] nő nő nő nő nő #&gt; Levels: nő Az első esetben a faktor létrehozásához használt karakteres vektor megegyezik a korábban látottakhoz, azaz helyesen tartalmazza mind a \"férfi\", mind a \"nő\" címkéket, így az x.f.1 faktor a címkék lexikografikus rendezése alapján az (1-\"férfi\", 2-\"nő\") összerendeléssel jön létre. A második esetben karakteres vektorunk elgépelés miatt egy \"Férfi\" címkét is tartalmaz, ami az x.f.2 faktor szintjei között is meg fog jelenni. A harmadik esetben az okozza a problémát, hogy 5 azonos nemű személy került a mintába, így a \"férfi\" címke egyáltalán nem jelenik meg az x.f.3 faktor szintjei között. Az x.f.2 és az x.f.3 faktorok tehát más-más okok miatt, de hibásan tartalmazzák a faktorszinteket, és ez a későbbi működést alapvetően befolyásolja. Az x.f.2 három különböző nemet ismer, az x.f.3 pedig mindössze egyet. A fenti hibák a levels= szerepeltetésével könnyen kiküszöbölhetők. (x.f.2 &lt;- factor(c(&quot;férfi&quot;, &quot;Férfi&quot;, &quot;nő&quot;, &quot;férfi&quot;, &quot;nő&quot;), levels=c(&quot;férfi&quot;, &quot;nő&quot;))) #&gt; [1] férfi &lt;NA&gt; nő férfi nő #&gt; Levels: férfi nő (x.f.3 &lt;- factor(c(&quot;nő&quot;, &quot;nő&quot;, &quot;nő&quot;, &quot;nő&quot;, &quot;nő&quot;), levels=c(&quot;férfi&quot;, &quot;nő&quot;))) #&gt; [1] nő nő nő nő nő #&gt; Levels: férfi nő A fenti példákban látható, hogy a \"Férfi\" címke helyére hiányzó érték került, az x.f.3 faktor pedig már \"férfi\" értéket is fel tud venni a jövőben. Numerikus vektorokból is készíthetünk faktorokat. Például a könnyebb rögzíthetőség miatt öt személy nemét most numerikus vektorban hoztuk létre azzal a szabállyal, hogy a 0 jelentése nő, az 1 jelentése férfi. A faktor létrehozása során ekkor a levels= szerepe a lehetséges numerikus értékek felsorolása lesz, és a plusz paraméterként szereplő labels= segít a faktorszintek beszédes elnevezésében. Az elnevezés a levels=-ben lévő numerikus értékek sorrendjében történik, ezért nagyon fontos, hogy a labels= címkéi kövessék ezt a sorrendet. x &lt;- c(1, 1, 0, 1, 0) # numerikus vektor létrehozása, 0-nő, 1-férfi (x.f.1 &lt;- factor(x, levels=c(0, 1), labels=c(&quot;nő&quot;, &quot;férfi&quot;))) #&gt; [1] férfi férfi nő férfi nő #&gt; Levels: nő férfi (x.f.2 &lt;- factor(x, levels=c(1, 0), labels=c(&quot;férfi&quot;, &quot;nő&quot;))) #&gt; [1] férfi férfi nő férfi nő #&gt; Levels: férfi nő A fenti példában látható, hogy a levels= értékeinek sorrendje vezérli az elnevezést, a 0 mindkét esetben \"nő\", az 1 \"férfi\" címkéhez fog vezetni. Az x.f.1 és x.f.2 faktorok mindössze a háttérben lévő összerendelésben különböznek, első esetben az (1-\"nő\", 2-\"férfi\"), míg második esetben az (1-\"férfi\", 2-\"nő\") lesz a faktorszintek sorrendje. Vegyük észre, hogy az eredeti 0 (nő) és 1 (férfi) értékek a faktorban már eltűnnek, szerepüket a címkék veszik át (nő, férfi) és az azok alapját jelentő 1-től sorszámozott integer vektorok. 5.3.5.2 Rendezett faktor A kategorikus változók két csoportját különböztetjük meg, a nominális változókat – ilyen volt az eddig látott nem változó –, és az ordinális változókat. Ez utóbbira példa az iskolai végzettség, mert ennek lehetséges értékei (alap, közép és felső értékekkel) sorba rendezhetők. Ha a változó szintjei közötti rendezettséget szeretnénk az R-ben is kifejezni, akkor rendezett faktort érdemes használni. Az eddigi factor() függvény is alkalmas az ordered = T argumentum használatával, de az ordered() függvényt is használhatjuk rendezett faktor létrehozására. # rendezett faktor létrehozása x &lt;- c(&quot;felső&quot;, &quot;közép&quot;, &quot;alap&quot;, &quot;közép&quot;, &quot;felső&quot;) x.f &lt;- ordered(x = x, levels=c(&quot;alap&quot;, &quot;közép&quot;, &quot;felső&quot;)) x.f #&gt; [1] felső közép alap közép felső #&gt; Levels: alap &lt; közép &lt; felső Az ordered() függvénnyel létrehozott rendezett faktor outputjában a szintek között a rendezettséget a kisebb (&lt;) jelek teszik hangsúlyossá, de a függvény használata nem tér el a korábban látott factor() függvénytől. 5.3.5.3 Szabályos faktor létrehozása Ismétlést tartalmazó faktorokat a gl() függvénnyel is létrehozhatunk. Tipikusan a szintek (n=) számát, az ismétlések számát (k=) és a címkéket (labels=) szoktuk megadni. Rendezett faktort az ordered = T argumentummal készíthetünk. (x.f &lt;- gl(n = 3, k = 2)) #&gt; [1] 1 1 2 2 3 3 #&gt; Levels: 1 2 3 (x.f &lt;- gl(n = 3, k = 2, labels=c(&quot;alap&quot;, &quot;közép&quot;, &quot;felső&quot;))) #&gt; [1] alap alap közép közép felső felső #&gt; Levels: alap közép felső (x.f &lt;- gl(n = 3, k = 2, labels=c(&quot;alap&quot;, &quot;közép&quot;, &quot;felső&quot;), ordered=T)) #&gt; [1] alap alap közép közép felső felső #&gt; Levels: alap &lt; közép &lt; felső 5.3.5.4 Faktor indexelése és szűrése Faktor indexelése a [] operátorral történik. Indexvektorként numerikus, karakteres és logikai vektorokat is használhatunk. Faktor indexelésének általános alakja: faktor[indexvektor] # az eredmény egy faktor Hozzunk létre egy faktort, amely hat személy dohányzási szokását tartalmazza (D-dohányzik, ND-nem dohányzik). (x.f &lt;- factor(c(&quot;D&quot;, &quot;D&quot;, &quot;ND&quot;, &quot;D&quot;, &quot;ND&quot;, &quot;ND&quot;), levels = c(&quot;ND&quot;, &quot;D&quot;))) #&gt; [1] D D ND D ND ND #&gt; Levels: ND D x.f[1] # az x faktor 1. eleme (faktorszintek változatlanok) #&gt; [1] D #&gt; Levels: ND D x.f[1, drop=T] # az x faktor 1. eleme (faktorszintek változtak) #&gt; [1] D #&gt; Levels: D x.f[1:3] # az x faktor 1., 2. és 3. eleme #&gt; [1] D D ND #&gt; Levels: ND D x.f[c(T, F)] # az x faktor 1, 3. és 5. eleme #&gt; [1] D ND ND #&gt; Levels: ND D x.f[x.f == &quot;D&quot;] # x szűrése (a dohányzók) #&gt; [1] D D D #&gt; Levels: ND D x.f[x.f != &quot;D&quot;] # x szűrése (a nem dohányzók) #&gt; [1] ND ND ND #&gt; Levels: ND D Az indexelés eredménye minden esetben egy faktor lesz, amelynek szintjei alapesetben megegyeznek az eredeti faktor szintjeivel. A drop=T argumentum a nem használt címkéket eltávolítja a faktorszintek közül. Logika kifejezéseket is használhatunk az indexelés során, azaz szűrést is végezhetünk. Indexelt faktor természetesen érékadás bal oldalán is szerepelhet. A faktor adatszerkezet megvéd minket az értékadások során, hiszen egy faktorelem csak a faktorszintekben szereplő értékek egyikét veheti fel. x.f # az x.f faktor kiírása #&gt; [1] D D ND D ND ND #&gt; Levels: ND D x.f[1] &lt;- &quot;ND&quot; # az x.f faktor 1. eleme legális értéket kap x.f[2] &lt;- &quot;nem dohányzik&quot; # az x.f faktor 2. eleme NA lesz x.f #&gt; [1] ND &lt;NA&gt; ND D ND ND #&gt; Levels: ND D Mivel a \"nem dohányzik\" címke nem szerepel a faktorszintek között, az x.f faktor 2. eleme NA lesz, egy figyelmeztető üzenet kíséretében. 5.3.5.5 Faktorok kezelése A faktorok kényelmes használatát két további függvény segíti. Az nlevels() függvénnyel a faktorszintek számát ismerhetjük meg, a levels() függvénnyel pedig lekérdezhetők és módosíthatók a faktorszintek. Nézzünk egy példát az iskolai végzettséggel kapcsolatban. Összesen 7 személyről tudjuk, hogy alap-, közép- vagy felsőfokú végzettségű, de az egyszerűbb rögzítés miatt indulásként ezt az információt számokkal kódoltuk (1-alap, 2-közép, 3-felső). # numerikus vektor létrehozása isk.vegz &lt;- c(1, 1, 2, 1, 3, 3, 2) # faktor létrehozása isk.vegz.f &lt;- factor(isk.vegz, levels=c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) isk.vegz.f # a faktor értéke #&gt; [1] 1 1 2 1 3 3 2 #&gt; Levels: 1 2 3 nlevels(isk.vegz.f) # a faktor szintjeinek száma #&gt; [1] 3 levels(isk.vegz.f) # a faktor szintjei #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; # a faktor szintjeinek módosítása levels(isk.vegz.f) &lt;- c(&quot;alap&quot;, &quot;közép&quot;, &quot;felső&quot;) isk.vegz.f # a faktor értéke #&gt; [1] alap alap közép alap felső felső közép #&gt; Levels: alap közép felső Az isk.vegz.f faktort az \"1\", \"2\" és \"3\" címkékkel hoztuk létre, de később a levels() függvénnyel beszédesebb faktorszinteket hoztunk létre. 5.3.5.6 Összefoglalás A faktor olyan integer vektor, amely az 1-től sorszámozott értékeihez egy-egy karakteres címkét rendel. Ezek a címkék alkotják a faktorelemek lehetséges értékeit, amelyeket más néven faktorszinteknek is neveznek. A faktor létrehozásához a factor() függvényt használjuk és karakteres vektor konstansaiból vagy numerikus vektor címkeként kezelt számértékeiből jönnek létre a faktor lehetséges értékei. Rendezett faktorok szintjei között létezik egy természetes rendezettség, létrehozásukhoz az ordered() függvényt használjuk. Az nlevels() függvény a faktorszintek számát adja meg, míg a levels() a szintek nevének lekérdezését és módosítását szolgálja. 5.3.5.7 Feladatok Hozzuk létre azt a karakteres vektort, amely a férfi, nő karakteres konstansokat, úgy helyezi el egymás mellett, hogy a 7 darab férfi érték után 13 db nő címke következik! Hány elemű az így létrejött vektor? Egy vizsgálatban az első 10 személy neme férfi, a többi 8 neme nő volt. Hozzuk létre azt a faktort, amely leírja a neme változót! Egy vizsgálatban városi (“V”) és falusi (“F”) fiatalok vettek részt! A megkérdezettek településtípusa rendre a következő volt: F, F, V, F, V, V, V, F. Hozzuk létre azt a faktort, amely leírja a településtípus változót! Egy vizsgálatban a dohányzási szokást egy kétértékű skálán mérték: 0-nem dohányzik; 1-dohányzik. A megkérdezettek dohányzási szokása a következő volt: 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0. Hozzuk létre azt a faktort, amely leírja a dohányzási szokás változót! A fenti feladatok megoldása 5.3.6 Lista Az eddig megismert vektor, mátrix és faktor adatszerkezet mindegyike homogén volt, csak azonos típusú értékek tárolására használhatjuk őket. A lista típusú adatokban különböző adatszerkezetű elemeket is felsorolhatunk, de sem a típusra, sem a méretre nincs korlátozás. Egy listaelem lehet vektor, mátrix, faktor, adattábla vagy akár egy másik lista is (5.1. ábra). Látható, hogy a lista az R legszabadabb adatszerkezete, egydimenziós, és fő célja a logikailag összetartozó, de szerkezetileg különböző adatok tárolása. 5.3.6.1 Lista létrehozása A list() függvénnyel hozhatunk létre legegyszerűbben listákat, itt vesszővel elválasztva kell megadnunk a lista elemeit. x &lt;- list(1:10, c(&quot;A&quot;,&quot;B&quot;), c=T) # 3 elemű lista x #&gt; [[1]] #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; [[2]] #&gt; [1] &quot;A&quot; &quot;B&quot; #&gt; #&gt; $c #&gt; [1] TRUE A fenti példában x egy 3 elemű lista, az első eleme egy 10 elemű numerikus vektor, a második eleme egy 2 elemű karakteres vektor, a harmadik eleme pedig egy 1 elemű logikai vektor. A harmadik elemnek a c nevet adtuk, de bármelyik elemet elnevezhettük volna ezzel a módszerrel. Ha a lista értékét megjelenítjük a képernyőn, akkor a listaelemek egymás alatt jelennek meg. Az első két esetben a kettős szögletes zárójelben ([[]]) lévő sorszám azonosítja a lista elemeit, a harmadik esetben pedig a listaelem általunk megadott neve a dollárjel ($) után. A listaelemek nevét a names() függvénnyel kérdezhetjük le és állíthatjuk be. names(x) # az x lista elemeinek neve #&gt; [1] &quot;&quot; &quot;&quot; &quot;c&quot; names(x)[c(1,2)] &lt;- c(&quot;a&quot;,&quot;b&quot;) # az x 1. és 2. elemének elnevezése names(x) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; x #&gt; $a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $b #&gt; [1] &quot;A&quot; &quot;B&quot; #&gt; #&gt; $c #&gt; [1] TRUE 5.3.6.2 Lista indexelése Egy lista indexelése a már megszokott [] indexoperátorral történik, amelyben továbbra is lehetőségünk van numerikus, karakteres és logikai indexvektor megadására is. x[1] # az x lista 1. elemét tartalmazó 1 elemű lista #&gt; $a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x[c(2, 3)] # az x lista 2. és 3. elemét tartalmazó 2 elemű lista #&gt; $b #&gt; [1] &quot;A&quot; &quot;B&quot; #&gt; #&gt; $c #&gt; [1] TRUE x[&quot;a&quot;] # az x lista 1. elemét tartalmazó 1 elemű lista #&gt; $a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x[c(T, F, T)] # az x lista 1. és 3. elemét tartalmazó 1 elemű lista #&gt; $a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $c #&gt; [1] TRUE A [] operátorral kapott eredmény minden esetben lista, még akkor is, ha a lista egyetlen elemét érjük el. Nagyon fontos ettől megkülönböztetni a [[]] operátor eredményét, amely a lista valamelyik (egyetlen) elemével, annak az értékével tér vissza. Itt nincs mód több listaelem elérésére, és szokás szerint numerikus vagy karakteres értékkel indexelünk. x[[1]] # az x lista 1. eleme #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x[[&quot;b&quot;]] # az x lista 2. eleme #&gt; [1] &quot;A&quot; &quot;B&quot; x[[3]] # az x lista 3. eleme #&gt; [1] TRUE A [[]] operátor alkalmazása helyett a rövidebb dollár ($) operátort is használhatjuk azoknak a listaelemeknek az elérésére, amelyeket korábban elneveztünk. A lista nevét és az elem nevét fűzzük össze a $ operátorral. x$a # az x lista 1. eleme #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x$b # az x lista 2. eleme #&gt; [1] &quot;A&quot; &quot;B&quot; x$c # az x lista 3. eleme #&gt; [1] TRUE Ha a lista elemét valamelyik módszer segítségével elértük, akkor további indexelés segítségével az elem összetevőit is lekérdezhetjük vagy módosíthatjuk. x[[&quot;a&quot;]][3:4] # az x lista 1. elemének 3. és 4. eleme #&gt; [1] 3 4 x$a[4:5] &lt;- 0 # az x lista 1. elemének 4. és 5. eleme 0 lesz x$c &lt;- 1:2 # az x lista 3. elemének módosítása x #&gt; $a #&gt; [1] 1 2 3 0 0 6 7 8 9 10 #&gt; #&gt; $b #&gt; [1] &quot;A&quot; &quot;B&quot; #&gt; #&gt; $c #&gt; [1] 1 2 A lista indexelésére tehát a következő lehetőségek állnak rendelkezésre: lista[indexvektor] # az eredmény egy lista lista[[index]] # az eredmény a lista egy eleme lista$elemnév # az eredmény a lista egy eleme 5.3.6.3 Művelet a listaelemekkel Egy lista minden elemével az lapply() vagy az sapply() függvény segítségével hajthatunk végre műveletet. lapply(X=x, FUN=length) # az x lista minden elemének a hossza egy listába #&gt; $a #&gt; [1] 10 #&gt; #&gt; $b #&gt; [1] 2 #&gt; #&gt; $c #&gt; [1] 2 sapply(X=x, FUN=length) # az x lista minden elemének a hossza egy vektorba #&gt; a b c #&gt; 10 2 2 Az lapply() a bemenő lista elemszámával egyező méretű listával tér vissza, melynek értékei az második paraméterben szereplő függvény visszatérési értékei. Az sapply() hasonlóan jár el, de a visszatérési értéke egy vektor. 5.3.6.4 Összefoglalás A lista az R legszabadabb adatszerkezete, egydimenziós és inhomogén. Listát a list() függvénnyel hozhatunk létre, melynek argumentumában tetszőleges adatszerkezetű objektumokat felsorolhatunk, ezek alkotják a lista egyes elemeit. Lista indexelése a [], [[]] és $ operátorokkal is lehetséges. 5.3.6.5 Feladatok Hozzunk létre egy háromelemű listát a TRUE, 12, és “Verseny” konstansokból! Hozzunk létre egy háromelemű listát a TRUE, 12, és “Verseny” konstansokból, de gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve”, “indulok” és “leiras”! Hozzunk létre egy háromelemű listát a TRUE, 12 és “Verseny” konstansokból, valamint az induló versenyzők végső pontszámaiból, amelyek rendre: 89, 78, 23, 67, 99, 69, 85, 77, 58, 72, 48, 81. Gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve”, “indulok”, “leiras” és “pontszam”! A fenti feladatok megoldása 5.3.7 Adattábla Az adattábla (data frame) az R legfontosabb adatszerkezete, központi szerepet játszik az adatfeldolgozásban, lényegében minden statisztikai munka kiindulópontja. Inhomogén, kétdimenziós szerkezet, sorok és oszlopok alkotják, alapvetően azonos hosszúságú vektorokból és faktorokból épül fel (5.1. ábra). Az adattábla egyesíti a mátrix és a lista adatszerkezet előnyeit. Az adattábla kétdimenziós, mint a mátrix, és inhomogén, mint a lista. Ha mátrixként tekintünk az adattáblára, akkor sorokból és oszlopokból áll, ha listaként, akkor azonos hosszúságú (oszlop)vektorok/faktorok egydimenziós sorozata. 5.3.7.1 Adattábla létrehozása Adattáblát legegyszerűbben a data.frame() függvénnyel hozhatunk létre, amely azonos hosszú vektorokat vagy faktorokat vár az argumentumában. A data.frame() tehát listaszerűen konstruálja az adattáblát. df &lt;- data.frame( nev = c(&quot;Péter&quot;, &quot;Éva&quot;, &quot;Lajos&quot;), pont = c(34, 32, 29) ) df # adattábla kiírása #&gt; nev pont #&gt; 1 Péter 34 #&gt; 2 Éva 32 #&gt; 3 Lajos 29 A fenti df adattáblát egy 3 elemű karakteres vektorból, és egy 3 elemű numerikus vektorból hoztuk létre. A data.frame() függvénynek ezt a két vektort adtuk meg, ennek megfelelően két oszlopa lesz az adattáblának. Mindkét vektor 3 elemű, így 3 sor lesz a df-ben. Adattáblánk így 3 \\(\\times\\) 2-es. Mindkét argumentumot elneveztük (nev, pont), ezekből oszlopnevek lesznek. Az oszlopok elnevezéséhez az objektumneveknél használt szabályokat vegyük figyelembe (5.1.2.3. fejezet), és ne használjunk ékezetes karaktereket és szóközt. A fenti outputból kiolvasható, hogy az adattábla sornevekkel is rendelkezik, ezek automatikusan jönnek létre 1-től kezdődő sorszámmal. Ha a data.frame() függvényben a paraméterek hossza nem azonos, akkor a rövidebb vektorok és faktorok ismétléssel kiegészülnek a leghosszabb oszlop hosszára. Az ismétlés azonban csak egész számszor lehetséges, egyébként hibaüzenetet kapunk. tipus &lt;- factor(c(&#39;A&#39;,&#39;B&#39;)); x &lt;- 6:8; y &lt;- 1:6 df2 &lt;- data.frame( tipus, pont.1=x, pont.2=y ) df2 #&gt; tipus pont.1 pont.2 #&gt; 1 A 6 1 #&gt; 2 B 7 2 #&gt; 3 A 8 3 #&gt; 4 B 6 4 #&gt; 5 A 7 5 #&gt; 6 B 8 6 A példában egy 6 sorból és 3 oszlopból álló adattáblát készítettünk (df2 6 \\(\\times\\) 3-as). A data.frame() függvényben nem azonos a tipus faktor és a két numerikus vektor (x, y) hossza, így ismétléssel kapjuk meg a fenti eredményt. Továbbá, ha elhagyjuk az argumentum nevét, akkor az oszlopnév a megfelelő objektum neve alapján jön létre. Így kapta az első oszlop a tipus nevet. 5.3.7.2 Adattábla felépítése Adattábláink ritkán olyan kicsik, mint a fenti df vagy df2. Sokszor több tucat sorból és oszlopból állnak, így az adattábla áttekintésére nem az adattáblát tároló objektum értékének képernyőre írása a legszerencsésebb. Kényelmesebb, ha az RStudio adatbázis ablakában jelenítjük meg az adattábla tartalmát, amit a Környezet panel megfelelő adatbázisnevén való kattintással és vagy a View() paranccsal kezdeményezhetünk. Próbáljuk ki a View(df) és View(df2) függvényhívásokat. Hasznos információ szolgáltat az str() függvény is, amely az adattábla szerkezetéről ad felvilágosítást. str(df) # a df adattábla szerkezete #&gt; &#39;data.frame&#39;: 3 obs. of 2 variables: #&gt; $ nev : chr &quot;Péter&quot; &quot;Éva&quot; &quot;Lajos&quot; #&gt; $ pont: num 34 32 29 Láthatjuk, hogy a df adattáblánk 3 sort (megfigyelést) és 2 oszlopot (változót) tartalmaz, valamint leolvashatjuk az egyes oszlopok típusát is. Megfigyelhetjük, hogy a nev oszlop karakteres, a pont pedig numerikus vektor. Láttuk korábban, hogy az adattábla sorai és oszlopai névvel is rendelkeznek. names(df); colnames(df) # oszlopnevek #&gt; [1] &quot;nev&quot; &quot;pont&quot; #&gt; [1] &quot;nev&quot; &quot;pont&quot; rownames(df) # sornevek #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; A rownames() a sorok nevét, a colnames() és a names() az oszlopok nevét írja ki, de segítségükkel ezeket módosíthatjuk is. A sorok és oszlopok nevének meghatározásánál ügyeljünk arra, hogy azok minden esetben legyenek egyediek. Két azonos sornév létrehozása hibaüzenethez vezet, de az azonos oszlopnevek használatát is kerüljük. rownames(df) &lt;- paste0(1:3, &quot;.szemely&quot;) # sornevek módosítása names(df) &lt;- c(&quot;X&quot;,&quot;Y&quot;) # oszlopnevek módosítása df #&gt; X Y #&gt; 1.szemely Péter 34 #&gt; 2.szemely Éva 32 #&gt; 3.szemely Lajos 29 A length() függvény az oszlopok számával tér vissza. Az nrow() és az ncol() a sor és oszlopok számával tér vissza. length(df); ncol(df) # oszlopok száma #&gt; [1] 2 #&gt; [1] 2 nrow(df) # sorok száma #&gt; [1] 3 5.3.7.3 Adattábla indexelése Az adattáblák indexelése a mátrixok és a listáknál megtanult indexelési formákat jelentik. Az általános indexelése formák a következők: adattábla[sorindexvektor, oszlopindexvektor] # adattábla, vektor vagy faktor adattábla[oszlopindexvektor] # adattábla adattábla$oszlopnév # vektor vagy faktor A mátrixokhoz hasonlóan indexelhetjük a sorokat és az oszlopokat, hiszen az adattábla kétdimenziós. A [] operátorban szerepel egy vessző, amely a sor- és oszlopkoordinátákat választja el egymástól. Használhatjuk a következő hivatkozásokat: df2 # a df2 adattábla kiírása #&gt; tipus pont.1 pont.2 #&gt; 1 A 6 1 #&gt; 2 B 7 2 #&gt; 3 A 8 3 #&gt; 4 B 6 4 #&gt; 5 A 7 5 #&gt; 6 B 8 6 df2[2, 3] # a df2 2. sorában a 3. oszlop adata, vektor eredmény #&gt; [1] 2 df2[c(2, 3), 3] # a df2 2. és 3. sorában a 3. oszlop adata, vektor #&gt; [1] 2 3 df2[c(2, 3), 1:2] # a df2 2. és 3. sorában a 1. és 2. oszlop adata, adattábla #&gt; tipus pont.1 #&gt; 2 B 7 #&gt; 3 A 8 df2[c(2, 3), ] # a df2 2. és 3. sora, adattábla #&gt; tipus pont.1 pont.2 #&gt; 2 B 7 2 #&gt; 3 A 8 3 df2[2, ] # a df2 2. sora, adattábla #&gt; tipus pont.1 pont.2 #&gt; 2 B 7 2 df2[, 3] # a df2 3. oszlopa, vektor #&gt; [1] 1 2 3 4 5 6 df2[, 3, drop=F] # a df2 3. oszlopa, adattábla #&gt; pont.2 #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 df2[, 1:2] # a df2 1. és 2. oszlopa, adattábla #&gt; tipus pont.1 #&gt; 1 A 6 #&gt; 2 B 7 #&gt; 3 A 8 #&gt; 4 B 6 #&gt; 5 A 7 #&gt; 6 B 8 Numerikus indexvektorok mellett használhatunk karakteres és logikai vektorokat is indexelésre. df2[, c(&quot;tipus&quot;, &quot;pont.1&quot;)] # minden sor, 1. és 2. oszlop #&gt; tipus pont.1 #&gt; 1 A 6 #&gt; 2 B 7 #&gt; 3 A 8 #&gt; 4 B 6 #&gt; 5 A 7 #&gt; 6 B 8 df2[c(T, F), c(&quot;tipus&quot;, &quot;pont.1&quot;)] # páratlan sorok 1. és 2. oszlop #&gt; tipus pont.1 #&gt; 1 A 6 #&gt; 3 A 8 #&gt; 5 A 7 Karakteres vektorok tipikusan oszlopindexekben fordulnak elő, logikai vektorok pedig, később látjuk, az adattábla szűrésénél kapnak fontos szerepet. Ha az adattáblára listaként tekintünk, akkor [] operátorban egyetlen indexvektort is szerepeltethetünk, amely az adattábla oszlopait indexeli, és minden esetben adattáblát szolgáltat, még akkor is, ha az adattábla egyetlen oszlopát érjük el. df2[2] # a df2 2. oszlopa, adattábla #&gt; pont.1 #&gt; 1 6 #&gt; 2 7 #&gt; 3 8 #&gt; 4 6 #&gt; 5 7 #&gt; 6 8 df2[1:2] # a df2 1. és 2. oszlopa, adattábla #&gt; tipus pont.1 #&gt; 1 A 6 #&gt; 2 B 7 #&gt; 3 A 8 #&gt; 4 B 6 #&gt; 5 A 7 #&gt; 6 B 8 df2[&quot;tipus&quot;] # a df2 1. oszlopa, adattábla #&gt; tipus #&gt; 1 A #&gt; 2 B #&gt; 3 A #&gt; 4 B #&gt; 5 A #&gt; 6 B df2[c(&quot;tipus&quot;, &quot;pont.2&quot;)] # a df2 1. és 3. oszlopa, adattábla #&gt; tipus pont.2 #&gt; 1 A 1 #&gt; 2 B 2 #&gt; 3 A 3 #&gt; 4 B 4 #&gt; 5 A 5 #&gt; 6 B 6 Az adattábla egyes oszlopai a $ operátorral is elérhetők, amely az adattábla nevét és az oszlop nevét választja el egymástól. Az eredmény minden esetben vektor vagy faktor lesz. df2$tipus # a df2 1. oszlopa, faktor #&gt; [1] A B A B A B #&gt; Levels: A B df2$pont.1 # a df2 2. oszlopa, vektor #&gt; [1] 6 7 8 6 7 8 Az adattábla indexelése után kapott adatszerkezetek tovább indexelhetők. Attól függően, hogy a kiinduló adattábla indexelésével kapott adatszerkezet egy- vagy kétdimenziós használhatjuk a [] és $ operátorokat is. df2[4:1, 1:2][2] # df2-ből adattábla, majd adattábla #&gt; pont.1 #&gt; 4 6 #&gt; 3 8 #&gt; 2 7 #&gt; 1 6 df2[4:1, 1:2]$tipus # df2-ből adattábla, majd faktor #&gt; [1] B A B A #&gt; Levels: A B df2$pont.2[1:3] # df2-ből vektor, majd vektor #&gt; [1] 1 2 3 Ne felejtsük el, hogy adattábla indexelése során a lekért elemek módosítására is lehetőségünk van, és a vektoraritmetika szabályai továbbra is teljesülnek. df2[2, 3] &lt;- 200 # egyetlen érték módosítása df2$pont.2 &lt;- df2$pont.2 + 1 # teljes oszlop módosítása df2 # df2 kiírása #&gt; tipus pont.1 pont.2 #&gt; 1 A 6 2 #&gt; 2 B 7 201 #&gt; 3 A 8 4 #&gt; 4 B 6 5 #&gt; 5 A 7 6 #&gt; 6 B 8 7 5.3.7.4 Adattáblák szűrése Az adattábla indexelésénél logikai vektorokat is használhatunk sorindexvektorban, melyek az adattábla tartalmára vonatkozó relációs kifejezések is lehetnek. Ezzel a módszerrel érhetjük el, hogy az adattábla sorait valamilyen szempont szerint leválogassuk, megszűrjük. df2[df2$tipus == &quot;A&quot;, ] # az A típusú sorok leválogatása #&gt; tipus pont.1 pont.2 #&gt; 1 A 6 2 #&gt; 3 A 8 4 #&gt; 5 A 7 6 df3 &lt;- df2[df2$pont.1&lt;8 &amp; df2$pont.2&gt;2, 2:3] # összetett logikai kifejezés Az első szűrésünk az adattábla \"A\" címkékkel rendelkező sorait válogatta le, de csak képernyőn olvashatók ezek a sorok. A második szűrés eredményét azonban megőrizzük egy új df3 objektumban, és látható, hogy a pont.1 és a pont.2 numerikus vektorokra vonatkozó összetett logikai kifejezéssel végezzük. 5.3.7.5 Adattáblák sorainak rendezése Az adattábla sorainak rendezése a vektoroknál megismert order() függvény és a [] operátor kombinált alkalmazásával lehetséges. Rendezzük a pont.1 változó alapján a df2 sorait. df2[order(df2$pont.1), ] # df2 sorainak rendezése pont.1 növekvő sorrendjében #&gt; tipus pont.1 pont.2 #&gt; 1 A 6 2 #&gt; 4 B 6 5 #&gt; 2 B 7 201 #&gt; 5 A 7 6 #&gt; 3 A 8 4 #&gt; 6 B 8 7 Az order() függvény decreasing=TRUE argumentumával csökkenő sorrendet is elérhetünk. Az order() függvény több oszlopot is képes fogadni, így több oszlop alapján is tudunk sorokat rendezni. # df2 sorainak rendezése pont.1 és pont.2 csökkenő sorrendjében df2[order(df2$pont.1, df2$pont.2, decreasing=T), ] #&gt; tipus pont.1 pont.2 #&gt; 6 B 8 7 #&gt; 3 A 8 4 #&gt; 2 B 7 201 #&gt; 5 A 7 6 #&gt; 4 B 6 5 #&gt; 1 A 6 2 5.3.7.6 Részösszefoglalás Az adattábla minden statisztikai munka kiindulópontja. Kétdimenziós, inhomogén szerkezet, de mivel azonos hosszú vektorok vagy faktorok listájának is tekinthető, oszlopaiban homogén adatszerkezet. Létrehozása a data.frame() függvénnyel lehetséges, ahol az argumentumban az oszlopokat alkotó vektorokat és faktorokat kell felsorolni. Az adattábla indexelése a mátrixoknál és a listáknál tanultak alapján lehetséges. 5.3.7.7 Feladatok Hozzunk létre egy 30 \\(\\times\\) 3-as adattáblát, csoport, matematika és magyar oszlopnevekkel. A csoport változó legyen egy 5.a, 5.b és 5.c címkéket tetszőleges sorrendben tartalmazó faktor, a matematika és a magyar pedig 1-5 osztályzatokat tartalmazó numerikus vektor. Írassuk ki a MASS csomag survey adattáblájának 3. sorában az 5. oszlopban lévő értéket! Írassuk ki a MASS csomag survey adattáblájának 3. és 6. sorában sorában az 5. oszlopban lévő értékeket! Az adattábla típus maradjon meg! Írassuk ki a MASS csomag survey adattáblájának 3. és 6. sorából az összes adatértéket! Írassuk ki a MASS csomag survey adattábla Pulse oszlopát háromféle módszerrel! Írassuk ki a MASS csomag survey adattábla Pulse változójának első 3 elemét háromféle módszerrel! A HSAUR3 csomag Forbes2000 adattáblája 2000 vállalat adatát tartalmazza! Határozzuk meg a magyar cégek nevét és helyezését (country oszlop alapján)! Írassuk ki a képernyőre a 10 legnagyobb piaci értékkel (marketvalue oszlop) rendelkező cég nevét és piaci értékét! Határozzuk meg a legkisebb profittal (profits oszlop) rendelkező 5 cég minden adatát! Határozzuk meg a legnagyobb profittal (profits oszlop) rendelkező 10 amerikai vagy japán cég nevét, országát és profitját! A fenti feladatok megoldása 5.4 További adatszerkezetek Ebben a fejezetben: megismerjük a tömb, táblázat, dátum, idő, időtartam és tibble adatszerkezeteket, valamint a a munkaterület és munkakönyvtár kezelésének függvényeit. Az R legfontosabb adatszerkezetit megismertük az előző fejezetben. Az adatelemzés kiindulópontja az adattábla, amely a mátrix és a lista adatszerkezet előnyeit egyesíti, lényegében vektorok és faktorok egymásutánja. A munka során azonban találkozhatunk három vagy több dimenzióba szervezett adatokkal (tömb és táblázat), valamint szükség lehet dátum, idő és időtartam kezelésére is. A Tidyverse R megújította az adattáblát, és bevezette a saját tibble típusát az adatok szokásos tárolására. Definiáljuk pontosabban a fenti, új adatszerkezeteket: tömb - Azonos alaptípusú értékekből 3 vagy több dimenzió mentén készítünk adatszerkezetet. táblázat - A gyakorisági táblázatok R megfelelője, amelyben tipikusan integer adatokat rögzítünk, egy, két vagy több dimenzió mentén. dátum - Egyetlen double érték, amelynek jelentése az 1970-01-01 óta eltelt napok száma. dátum-idő - Egyetlen double érték, amelynek jelentése az 1970-01-01 óta eltelt másodpercek száma. időtartam - Egyetlen double érték, amelynek különböző mértékegységekben mutatja két időpont közötti különbséget. tibble - Speciális adattábla, amely a Tidyverse R része, és megkönnyíti az adatok kezelését. Az 5.8. táblázatban már korábban bemutattuk az R legfontosabb adatszerkezeteit, aZ 5.10. táblázat azokat az új adatszerkezeteket sorolja fel, amelyeket ebben a fejezetben mutatunk be. Most is közöljük, hogy a typeof() és a class() milyen outputot szolgáltat az egyes adatszerkezetek esetén. TÁBLÁZAT 5.10: Adatszerkezetek (folytatás) Adatszerkezet Létrehozó parancs typeof(x) class(x) integer tömb array(2L,dim=c(2,3,5)) integer array double tömb array(2,dim=c(2,3,5)) double array karakteres tömb array(‘a’,dim=c(2,3,5)) character array logikai tömb array(T,dim=c(2,3,5)) logical array táblázat table(sample(1:10, 100, T)) integer table dátum as.Date(‘1971-05-09’) double Date dátum-idő as.POSIXct(‘2018-08-01 22:00’,‘UTC’) double POSIXct POSIXt időtartam as.difftime(7,units=‘days’) double difftime tibble tibble(x=1:3,y=letters[1:3]) list tbl_df tbl data.frame 5.4.1 Tömbök és táblázatok A tömb a mátrix általánosításával nyerhető adatszerkezet. Az azonos típusú adatokat a mátrix két dimenzió mentén rendezi össze. Azonban három vagy több dimenzió mentén is elvégezhető ez az összerendezés. Így nyerjük a három vagy több dimenziós tömböket. A mátrix két dimenziós tömbnek is tekinthető (vagy a vektor egy egy dimenziós tömbnek). A táblázat a tömbökhöz nagyon hasonló adatszerkezet, de tipikusan számlálással nyert integer értékeket rögzítünk bennük. A tömbökhöz hasonlóan lehetnek egy, két, vagy több dimenziósak. 5.4.1.1 Tömb létrehozása és indexelése Az array() függvénnyel egyszerűen hozhatunk létre tömböt. A függvény a data= argumentumban megadott vektor elemeit a dim= argumentumban megadott dimenzió-méretek mentén rendezi össze. x &lt;- array(data=1:12, dim=c(2, 3, 2)) # az 1:12 vektorból 3 dimenziós tömb x #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 A háromdimenziós integer tömb 2 \\(\\times\\) 3 \\(\\times\\) 2-es, azaz 2 sorból, 3 oszlopból és 2 lapból áll. Természetesen double, karakteres és logikai tömbök is hasonló módszerrel hozhatók létre, csak a data= értéket kell megfelelően megválasztani. A tömb kiíratása során az indexoperátorokban ([]) szereplő sorszámok segítségével igazodhatunk el az elemek között. A háromdimenziós x tömb dimenziói a sorok, oszlopok és a lapok. A 12 elemet két lapon a , , 1 és a , , 2 nevű lapokon, két-két sorba [1, ], [2, ] és három-három oszlopba [ ,1], [ ,2], [ ,3] rendezve sorolja fel az R. A második lapon a 2. sor 1. eleméhez meg kell találnunk a , , 2 lapot, a [2, ] sort és az [ ,1] oszlopot, ami esetünkben a 8. A tömbök indexelése a mátrixokhoz hasonló, csak a dimenziószámnak megfelelő számú indexvektort kell használhatunk. Ha x 3 dimenziós, akkor az x[1,3,2] egy lehetséges példa indexelésére, ahol az első sor harmadik oszlopában lévő elemre gondolunk, a második lapról. Emlékezhetünk, hogy kétdimenziós mátrixok esetén csak a sor és oszlop azonosító indexekre volt szükségünk (például x[2,3]), míg 4 vagy afeletti dimenziószámok esetén természetesen 4 vagy több, vesszővel elválasztott indexet kell megadnunk. 5.4.1.2 Táblázat létrehozása Táblázatokat a table() függvénnyel hozhatunk létre, tipikusan kategorikus adatokból, vagyis faktor típusú objektumokból. A MASS csomag survey adattáblája több faktor oszlopot is tartalmaz, ezt használjuk a továbbiakban. data(&quot;survey&quot;, package = &quot;MASS&quot;) # a survey betöltése str(survey) #&gt; &#39;data.frame&#39;: 237 obs. of 12 variables: #&gt; $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 2 2 2 2 1 2 1 2 2 ... #&gt; $ Wr.Hnd: num 18.5 19.5 18 18.8 20 18 17.7 17 20 18.5 ... #&gt; $ NW.Hnd: num 18 20.5 13.3 18.9 20 17.7 17.7 17.3 19.5 18.5 ... #&gt; $ W.Hnd : Factor w/ 2 levels &quot;Left&quot;,&quot;Right&quot;: 2 1 2 2 2 2 2 2 2 2 ... #&gt; $ Fold : Factor w/ 3 levels &quot;L on R&quot;,&quot;Neither&quot;,..: 3 3 1 3 2 1 1 3 3 3 ... #&gt; $ Pulse : int 92 104 87 NA 35 64 83 74 72 90 ... #&gt; $ Clap : Factor w/ 3 levels &quot;Left&quot;,&quot;Neither&quot;,..: 1 1 2 2 3 3 3 3 3 3 ... #&gt; $ Exer : Factor w/ 3 levels &quot;Freq&quot;,&quot;None&quot;,..: 3 2 2 2 3 3 1 1 3 3 ... #&gt; $ Smoke : Factor w/ 4 levels &quot;Heavy&quot;,&quot;Never&quot;,..: 2 4 3 2 2 2 2 2 2 2 ... #&gt; $ Height: num 173 178 NA 160 165 ... #&gt; $ M.I : Factor w/ 2 levels &quot;Imperial&quot;,&quot;Metric&quot;: 2 1 NA 2 2 1 1 2 2 2 ... #&gt; $ Age : num 18.2 17.6 16.9 20.3 23.7 ... Egydimenziós gyakorisági táblázat létrehozásához egyetlen faktort használunk a table() argumentumában. Érdemes a useNA=\"ifany\" argumentumot is használni, amely a faktorban lévő hiányzó értékek számát adja meg, amennyiben van hiányzó érték a változóban. table(survey$Sex, useNA = &quot;ifany&quot;) # egydimenziós gyakorisági táblázat #&gt; #&gt; Female Male &lt;NA&gt; #&gt; 118 118 1 Az output első sorában az egydimenziós táblázat (integer vektor) elemeinek a nevét olvashatjuk, melyek a Sex faktor lehetséges értékeit és a hiányzó értékek címkéjét jelentik. A táblázat második sorában lévő számok az egyes címkék előfordulási gyakoriságát jelentik a faktorban. Ebben a kutatásban (?survey) 118 nőt és 118 férfit kérdeztek meg, egyetlen személynek nem ismerjük a nemét. Kétdimenziós gyakorisági táblázat készítéséhez két faktorra van szükség. A nem (Sex) mellett a kezességet (W.Hnd) is bevontuk a vizsgálatba: # kétdimenziós gyakorisági táblázat table(survey$Sex, survey$W.Hnd, useNA = &quot;ifany&quot;) #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 7 110 1 #&gt; Male 10 108 0 #&gt; &lt;NA&gt; 1 0 0 A kétdimenziós gyakorisági táblázat (integer mátrix) sornevei és oszlopnevei segítenek értelmezni a gyakorisági értékeket. A 7 például a balkezes nők számát jelenti a mintában. Három vagy magasabb dimenziószámú táblázatokat is hasonlóan készíthetünk: egyre több faktort vonunk be a table() függvénybe. Háromdimenziós gyakorisági táblázatra mutatunk példát az Exer faktor bevonásával. # háromdimenziós gyakorisági táblázat table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = &quot;ifany&quot;) #&gt; , , = Freq #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 3 45 1 #&gt; Male 3 62 0 #&gt; &lt;NA&gt; 1 0 0 #&gt; #&gt; , , = None #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 1 10 0 #&gt; Male 2 11 0 #&gt; &lt;NA&gt; 0 0 0 #&gt; #&gt; , , = Some #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 3 55 0 #&gt; Male 5 35 0 #&gt; &lt;NA&gt; 0 0 0 A háromdimenziós vagy afeletti táblázatok esetében az ftable() kétdimenziós ábrázolással segíti a gyakorisági adatok értelmezését. tab3 &lt;- table(survey$Sex, survey$W.Hnd, survey$Exer) ftable(tab3) # háromdimenziós táblázat két dimenzióban #&gt; Freq None Some #&gt; #&gt; Female Left 3 1 3 #&gt; Right 45 10 55 #&gt; Male Left 3 2 5 #&gt; Right 62 11 35 tab4 &lt;- table(survey$Sex, survey$W.Hnd, survey$Exer, survey$Smoke) ftable(tab4) # négydimenziós táblázat két dimenzióban #&gt; Heavy Never Occas Regul #&gt; #&gt; Female Left Freq 0 2 1 0 #&gt; None 0 1 0 0 #&gt; Some 0 3 0 0 #&gt; Right Freq 3 36 4 2 #&gt; None 0 9 1 0 #&gt; Some 2 47 3 3 #&gt; Male Left Freq 0 2 1 0 #&gt; None 0 1 0 1 #&gt; Some 1 3 1 0 #&gt; Right Freq 4 45 6 7 #&gt; None 1 7 2 0 #&gt; Some 0 31 0 4 A table() függvény helyett használhatjuk az xtabs() függvényt is, amely támogatja a kicsit kényelmesebb formula argumentumot. Az R formula olyan kifejezés, amely tartalmaz egy tilde (~) karaktert, és annak két oldalán rendszerint egy adattábla oszlopnevei jelennek meg. A table() és az xtabs() általános használata a következő: table(df$változó_1, df$változó_2, ..., df$változó_n) xtabs(~változó_1 + változó_2 + ... + változó_n, data=df) Az xtabs() használatára mutatunk 3 példát. Figyeljük meg, hogy a hiányzó értékek megjelenítéséhez itt az addNA=T argumentumot kell használnunk. Az xtabs() függvény speciális formulájának bal oldala üres, jobb oldalán pedig a faktor változók + karakterrel vannak összekapcsolva. xtabs(~Sex, data=survey, addNA = T) # 1D gyakorisági táblázat #&gt; Sex #&gt; Female Male &lt;NA&gt; #&gt; 118 118 1 xtabs(~Sex+W.Hnd, data=survey, addNA = T) # 2D gyakorisági táblázat #&gt; W.Hnd #&gt; Sex Left Right &lt;NA&gt; #&gt; Female 7 110 1 #&gt; Male 10 108 0 #&gt; &lt;NA&gt; 1 0 0 xtabs(~Sex+W.Hnd+Exer, data=survey, addNA = T) # 3D gyakorisági táblázat #&gt; , , Exer = Freq #&gt; #&gt; W.Hnd #&gt; Sex Left Right &lt;NA&gt; #&gt; Female 3 45 1 #&gt; Male 3 62 0 #&gt; &lt;NA&gt; 1 0 0 #&gt; #&gt; , , Exer = None #&gt; #&gt; W.Hnd #&gt; Sex Left Right &lt;NA&gt; #&gt; Female 1 10 0 #&gt; Male 2 11 0 #&gt; &lt;NA&gt; 0 0 0 #&gt; #&gt; , , Exer = Some #&gt; #&gt; W.Hnd #&gt; Sex Left Right &lt;NA&gt; #&gt; Female 3 55 0 #&gt; Male 5 35 0 #&gt; &lt;NA&gt; 0 0 0 5.4.1.3 Táblázatok átalakítása Korábban megismertük az as.*() kezdetű függvényeket, amelyek egyszerű típuskonverziót végeznek. A gyakorisági táblázatokat gyakran szeretnénk vektor, mátrix, tömb, vagy még gyakrabban adattábla típusban rögzíteni. Ezek az átalakítások az as.vector(), as.matrix(), as.array(), valamint az as.data.frame() függvénnyel könnyen elvégezhetők. tab1 &lt;- table(survey$Sex, useNA = &quot;ifany&quot;) # 1D gyakorisági táblázat tab2 &lt;- table(survey$Sex, survey$W.Hnd, useNA = &quot;ifany&quot;) # 2D tab3 &lt;- table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = &quot;ifany&quot;) # 3D (vekt &lt;- as.vector(tab1)) # 1D táblázatból vektor #&gt; [1] 118 118 1 (mat &lt;- as.matrix(tab2)) # 2D táblázatból mátrix #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 7 110 1 #&gt; Male 10 108 0 #&gt; &lt;NA&gt; 1 0 0 (tomb &lt;- as.array(tab3)) # 3D táblázatból 3D tömb #&gt; , , = Freq #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 3 45 1 #&gt; Male 3 62 0 #&gt; &lt;NA&gt; 1 0 0 #&gt; #&gt; , , = None #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 1 10 0 #&gt; Male 2 11 0 #&gt; &lt;NA&gt; 0 0 0 #&gt; #&gt; , , = Some #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 3 55 0 #&gt; Male 5 35 0 #&gt; &lt;NA&gt; 0 0 0 (df1 &lt;- as.data.frame(tab1)) # 1D táblázatból adattábla #&gt; Var1 Freq #&gt; 1 Female 118 #&gt; 2 Male 118 #&gt; 3 &lt;NA&gt; 1 (df2 &lt;- as.data.frame(tab2)) # 2D táblázatból adattábla #&gt; Var1 Var2 Freq #&gt; 1 Female Left 7 #&gt; 2 Male Left 10 #&gt; 3 &lt;NA&gt; Left 1 #&gt; 4 Female Right 110 #&gt; 5 Male Right 108 #&gt; 6 &lt;NA&gt; Right 0 #&gt; 7 Female &lt;NA&gt; 1 #&gt; 8 Male &lt;NA&gt; 0 #&gt; 9 &lt;NA&gt; &lt;NA&gt; 0 (df3 &lt;- as.data.frame(tab3)) # 3D táblázatból adattábla #&gt; Var1 Var2 Var3 Freq #&gt; 1 Female Left Freq 3 #&gt; 2 Male Left Freq 3 #&gt; 3 &lt;NA&gt; Left Freq 1 #&gt; 4 Female Right Freq 45 #&gt; 5 Male Right Freq 62 #&gt; 6 &lt;NA&gt; Right Freq 0 #&gt; 7 Female &lt;NA&gt; Freq 1 #&gt; 8 Male &lt;NA&gt; Freq 0 #&gt; 9 &lt;NA&gt; &lt;NA&gt; Freq 0 #&gt; 10 Female Left None 1 #&gt; 11 Male Left None 2 #&gt; 12 &lt;NA&gt; Left None 0 #&gt; 13 Female Right None 10 #&gt; 14 Male Right None 11 #&gt; 15 &lt;NA&gt; Right None 0 #&gt; 16 Female &lt;NA&gt; None 0 #&gt; 17 Male &lt;NA&gt; None 0 #&gt; 18 &lt;NA&gt; &lt;NA&gt; None 0 #&gt; 19 Female Left Some 3 #&gt; 20 Male Left Some 5 #&gt; 21 &lt;NA&gt; Left Some 0 #&gt; 22 Female Right Some 55 #&gt; 23 Male Right Some 35 #&gt; 24 &lt;NA&gt; Right Some 0 #&gt; 25 Female &lt;NA&gt; Some 0 #&gt; 26 Male &lt;NA&gt; Some 0 #&gt; 27 &lt;NA&gt; &lt;NA&gt; Some 0 Az ellenkező irányú átalakítás is érdekes lehet, vagyis amikor egy-, két- vagy háromdimenziós tömbökből gyakorisági táblázatot képezünk (as.table() függvény), de főképp amikor az adattáblában létező gyakorisági adatokat táblázattá alakítjuk. Itt érdemes az xtabs(Freq~Változó_1+Változó_2+...+Változó_n, data=df) függvényhívást használni, ahol a tilde (~) előtti oszlop az adattábla gyakorisági adatait tartalmazza, a jobbra lévő változók pedig lényegében a faktor változókat nevezik meg. as.table(vekt) # vektorból 1D táblázat #&gt; A B C #&gt; 118 118 1 as.table(mat) # mátrixból 2D táblázat #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 7 110 1 #&gt; Male 10 108 0 #&gt; &lt;NA&gt; 1 0 0 as.table(tomb) # tömbből 3D táblázat #&gt; , , = Freq #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 3 45 1 #&gt; Male 3 62 0 #&gt; &lt;NA&gt; 1 0 0 #&gt; #&gt; , , = None #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 1 10 0 #&gt; Male 2 11 0 #&gt; &lt;NA&gt; 0 0 0 #&gt; #&gt; , , = Some #&gt; #&gt; #&gt; Left Right &lt;NA&gt; #&gt; Female 3 55 0 #&gt; Male 5 35 0 #&gt; &lt;NA&gt; 0 0 0 xtabs(Freq~Var1, data=df1) # adattáblából 1D táblázat #&gt; Var1 #&gt; Female Male #&gt; 118 118 xtabs(Freq~Var1+Var2, data=df2) # adattáblából 2D táblázat #&gt; Var2 #&gt; Var1 Left Right #&gt; Female 7 110 #&gt; Male 10 108 xtabs(Freq~Var1+Var2+Var3, data=df3) # adattáblából 3D táblázat #&gt; , , Var3 = Freq #&gt; #&gt; Var2 #&gt; Var1 Left Right #&gt; Female 3 45 #&gt; Male 3 62 #&gt; #&gt; , , Var3 = None #&gt; #&gt; Var2 #&gt; Var1 Left Right #&gt; Female 1 10 #&gt; Male 2 11 #&gt; #&gt; , , Var3 = Some #&gt; #&gt; Var2 #&gt; Var1 Left Right #&gt; Female 3 55 #&gt; Male 5 35 Érdekes lehet egy harmadik eset is, amikor a gyakorisági adatok állnak rendelkezésre (táblázatos vagy adattábla formátumban) és el szeretnénk készíteni ennek a nyers adatokat tartalmazó adattábla megfelelőjét. Vegyük a legbonyolultabb eddig tárgyalt esetet, és legyen a tab3 a kiinduló pontunk, amely egy táblázat. A táblázatot a korábban tanult módszerrel gyakoriságokat tartalmazó adattáblává alakítjuk, majd eseteket (nyers adatokat) tartalmazó adattáblává. tab3 &lt;- table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = &quot;ifany&quot;) ftable(tab3) # 3D gyakorisági táblázat kiterítve #&gt; Freq None Some #&gt; #&gt; Female Left 3 1 3 #&gt; Right 45 10 55 #&gt; NA 1 0 0 #&gt; Male Left 3 2 5 #&gt; Right 62 11 35 #&gt; NA 0 0 0 #&gt; NA Left 1 0 0 #&gt; Right 0 0 0 #&gt; NA 0 0 0 df3 &lt;- as.data.frame(df3) # adattáblából 3D táblázat df3 #&gt; Var1 Var2 Var3 Freq #&gt; 1 Female Left Freq 3 #&gt; 2 Male Left Freq 3 #&gt; 3 &lt;NA&gt; Left Freq 1 #&gt; 4 Female Right Freq 45 #&gt; 5 Male Right Freq 62 #&gt; 6 &lt;NA&gt; Right Freq 0 #&gt; 7 Female &lt;NA&gt; Freq 1 #&gt; 8 Male &lt;NA&gt; Freq 0 #&gt; 9 &lt;NA&gt; &lt;NA&gt; Freq 0 #&gt; 10 Female Left None 1 #&gt; 11 Male Left None 2 #&gt; 12 &lt;NA&gt; Left None 0 #&gt; 13 Female Right None 10 #&gt; 14 Male Right None 11 #&gt; 15 &lt;NA&gt; Right None 0 #&gt; 16 Female &lt;NA&gt; None 0 #&gt; 17 Male &lt;NA&gt; None 0 #&gt; 18 &lt;NA&gt; &lt;NA&gt; None 0 #&gt; 19 Female Left Some 3 #&gt; 20 Male Left Some 5 #&gt; 21 &lt;NA&gt; Left Some 0 #&gt; 22 Female Right Some 55 #&gt; 23 Male Right Some 35 #&gt; 24 &lt;NA&gt; Right Some 0 #&gt; 25 Female &lt;NA&gt; Some 0 #&gt; 26 Male &lt;NA&gt; Some 0 #&gt; 27 &lt;NA&gt; &lt;NA&gt; Some 0 # az átalakítás 2 sora: df.long &lt;- df3[rep(row.names(df3), df3$Freq), c(&quot;Var1&quot;, &quot;Var2&quot;, &quot;Var3&quot;)] rownames(df.long) &lt;- seq_along(rownames(df.long)) head(df.long) # az első 6 sor kiírása #&gt; Var1 Var2 Var3 #&gt; 1 Female Left Freq #&gt; 2 Female Left Freq #&gt; 3 Female Left Freq #&gt; 4 Male Left Freq #&gt; 5 Male Left Freq #&gt; 6 Male Left Freq 5.4.2 Dátum és idő Az adatelemzés során a dátumok kezelésének két fő oka lehet, egyrészt szűrésekben használhatjuk őket, például adott dátum vagy időpont előtti, utáni vagy közötti sorok leválogatásában, másrészt statisztikai elemzések is irányulhatnak két dátum vagy időpont között eltelt időtartamra. 5.4.2.1 Dátum kezelése Amennyiben le akarjuk kérdezni az aktuális dátumot, akkor a Sys.Date() függvényt kell használnunk. datum &lt;- Sys.Date() # aktuális dátum, dátum típusú objektum datum # datum kiírása #&gt; [1] &quot;2022-07-13&quot; typeof(datum) # datum típusa #&gt; [1] &quot;double&quot; class(datum) # datum típusa #&gt; [1] &quot;Date&quot; unclass(datum) # datum alapja #&gt; [1] 19186 Láthatjuk, hogy a datum objektum dátum (Date) típusú annak ellenére, hogy az objektum értéke a képernyőn kettős idézőjelek között jelenik meg. A dátum típus alapja egy double szám van, amely az 1970. 01. 01. óta eltelt napok számát tartalmazza, ahogyan az unclass(datum) ezt számunkra meg is mutatja. Világos, hogy az a double érték lehet nulla vagy negatív is. unclass(as.Date(&quot;1980-01-01&quot;)) # a double szám pozitív #&gt; [1] 3652 unclass(as.Date(&quot;1970-01-01&quot;)) # a double szám nulla #&gt; [1] 0 unclass(as.Date(&quot;1960-01-01&quot;)) # a double szám negatív #&gt; [1] -3653 5.4.2.1.1 Dátum létrehozása karakteres adatból Dátumot legtöbb esetben karakteres konstansból hozunk létre az as.Date() függvény segítségével. A dátumok változatos formában jelenhetnek meg, a szabványos \"2019-02-12\" (ISO 8601) alak mellett sok olyan forma létezik, amelyben elválasztó karakterként a perjel vagy a pont szerepel, valamint az év-hó-nap hármas sorrendje is változhat. A konkrét dátum értelmezéséhez az as.Date() függvény format= argumentumát kell helyesen beállítani. A használható kódokat a 5.11. táblázat tartalmazza. TÁBLÁZAT 5.11: Formátumkódok a dátumokban Formátum kód Jelentés %Y év 4 számjeggyel %y év 2 számjeggyel %m hónap %b hónap rövidített neve %B hónap teljes neve %d nap as.Date(&quot;2020-04-12&quot;) # szabványos, nem kell format= argumentum #&gt; [1] &quot;2020-04-12&quot; as.Date(&quot;2020/04/12&quot;) # szabványos, nem kell format= argumentum #&gt; [1] &quot;2020-04-12&quot; as.Date(&quot;04/12/2020&quot;, format=&quot;%m/%d/%Y&quot;) # amerikai stílus #&gt; [1] &quot;2020-04-12&quot; as.Date(&quot;12.04.2020&quot;, format=&quot;%d.%m.%Y&quot;) # brit stílus #&gt; [1] &quot;2020-04-12&quot; as.Date(&quot;2020. 04. 12.&quot;, format=&quot;%Y. %m. %d.&quot;) # magyar stílus #&gt; [1] &quot;2020-04-12&quot; Látható, hogy a szabványos esetekben nem szükséges a format= argumentum használata, de a formátumkódokkal tetszőleges sztringet dátum típusúvá alakíthatunk. A hónapnevek megjelenése azonban nyelvfüggő, ezért itt a R verziónk helyi beállításaira is figyelni kell. Sys.getlocale(&quot;LC_TIME&quot;) # a helyi beállítás magyar? #&gt; [1] &quot;Hungarian_Hungary.utf8&quot; as.Date(&quot;2020. ápr. 12.&quot;, format=&quot;%Y. %b %d.&quot;) # rövid magyar hónapnévvel #&gt; [1] &quot;2020-04-12&quot; as.Date(&quot;2020. április 12.&quot;, format=&quot;%Y. %B %d.&quot;) # magyar hónapnévvel #&gt; [1] &quot;2020-04-12&quot; Magyar számítógépes környezetben a helyi beállítás (?locales) alapértelmezés szerint magyar, ennek megfelelően a magyar hónapnevekkel dolgozik az as.Date() függvény, így a fenti konverziók a kívánt eredményt adják. A Sys.getlocale(\"LC_TIME\") paranccsal vizsgálhatjuk meg, hogy milyen környezetben dolgozunk. A Sys.setlocale(\"LC_TIME\", \"C\") utasítás észak-amerikai beállításokra vált az R, az angol hónapnevek felismerésére így nyílik lehetőség: lct &lt;- Sys.getlocale(&quot;LC_TIME&quot;) # helyi beállítás mentése Sys.setlocale(&quot;LC_TIME&quot;, &quot;C&quot;) # észak-amerikai beállítás #&gt; [1] &quot;C&quot; as.Date(&quot;Apr 12, 2020&quot;, format=&quot;%b %d, %Y&quot;) # rövid angol hónapnévvel #&gt; [1] &quot;2020-04-12&quot; as.Date(&quot;12 April 2020&quot;, format=&quot;%d %B %Y&quot;) # angol hónapnévvel #&gt; [1] &quot;2020-04-12&quot; Sys.setlocale(&quot;LC_TIME&quot;, lct) # magyar helyi beállítás visszatöltése #&gt; [1] &quot;Hungarian_Hungary.utf8&quot; 5.4.2.1.2 Dátum létrehozása numerikus adatokból Dátumot a szeparáltan létező numerikus év, hónap, nap információkból is létrehozhatunk. Ehhez először az ISOdate() függvénnyel időpontot állítunk elő, majd az as.Date()-tel dátumot. Ezzel a módszerrel egyszerre több dátumot is előállíthatunk. as.Date(ISOdate(year = 2020, month = 4, day = 12)) # dátum előállítása #&gt; [1] &quot;2020-04-12&quot; as.Date(ISOdate(year = 2020, month = 1:4, day = 12)) # dátumok előállítása #&gt; [1] &quot;2020-01-12&quot; &quot;2020-02-12&quot; &quot;2020-03-12&quot; &quot;2020-04-12&quot; 5.4.2.1.3 Dátum konvertálása Ha már van egy dátum típusú objektumunk, akkor azt változatos módon jeleníthetjük meg a format() függvény segítségével, amely egyszerű karakteres adattal tér vissza. (datum &lt;- as.Date(&quot;04/12/2020&quot;, format = &quot;%m/%d/%Y&quot;)) #&gt; [1] &quot;2020-04-12&quot; format(datum, format=&quot;%Y. %m. %d.&quot;) # magyar dátum #&gt; [1] &quot;2020. 04. 12.&quot; format(datum, format=&quot;%Y. %B %d.&quot;) # magyar dátum #&gt; [1] &quot;2020. április 12.&quot; format(datum, format=&quot;%Y. %b %d.&quot;) # magyar dátum #&gt; [1] &quot;2020. ápr. 12.&quot; format(datum, format=&quot;%Y-%m&quot;) # csak az év és a hónap #&gt; [1] &quot;2020-04&quot; format(datum, format=&quot;%Y&quot;) # csak az év #&gt; [1] &quot;2020&quot; 5.4.2.2 Dátum-idő kezelése A dátum-idő (POSIXct típus) olyan double érték, amelynek jelentése az 1970-01-01 óta eltelt másodpercek száma. Az aktuális dátum és idő lekérdezése Sys.time() függvénnyel lehetséges, és ez az általunk dátum-idő típusnak tekintett POSIXct objektummal tér vissza: ido &lt;- Sys.time() # pontos dátum-idő, POSIXct típusú objektum ido # ido kírása #&gt; [1] &quot;2022-07-13 09:12:37 CEST&quot; typeof(ido) # ido típusa #&gt; [1] &quot;double&quot; class(ido) # ido típusa #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; unclass(ido) # ido alapja #&gt; [1] 1657696357 A fentiek alapján úgy tűnhet, hogy a POSIXct objektum egész másodperceket tárol csupán, de ez nem így van. Az alapértelmezett megjelenítéseken módosítva láthatóvá válnak a tört másodpercek is: op &lt;- options(digits.secs = 6, digits = 16) ido # POSIXct kiírása változott digits.sec=6 miatt #&gt; [1] &quot;2022-07-13 09:12:37.349261 CEST&quot; unclass(ido) # double kiírása változott digits=6 miatt #&gt; [1] 1657696357.349262 options(op) # alapértelmezések visszaállítása A POSIXct objektumok másik érdekessége az időzóna tárolása, amely alapértelmezés szerint a magyar környezetben futó R helyi beállításainak megfelelően közép-európai (CEST) időt jelent. A saját rendszerünk időzónája a Sys.timezone() függvénnyel kérdezhető le, a lehetséges időzónákat az OlsonNames() függvény listázza. A legtöbb esetben ezzel nem kell foglalkoznunk, nemzetközi kutatások esetében azonban fontos lehet ismerni az időzóna váltás lehetőségét. Egyik lehetőség, hogy eleve a kívánt időzónának megfelelő időpontokkal dolgozunk. Ekkor a Sys.setenv() függvénnyel beállíthatjuk a kívánt időzónát, amely a legtöbb esetben a a koordinált világidő (UTC) vagy másképp a greenwichi középidő (GMT). Tudjuk, hogy a magyarországi időzóna téli időszámításkor közép-európai idő (CET, UTC+1), nyáron közép-európai nyári idő (CEST, UTC+2). tz &lt;- Sys.timezone() # helyi időzóna mentése Sys.setenv(TZ=&quot;UTC&quot;) # UTC (GMT) időzóna beállítása Sys.time() # pontos dátum-idő lekérése UTC szerint #&gt; [1] &quot;2022-07-13 07:12:37 UTC&quot; Sys.setenv(TZ=tz) # alapértelmezett időzóna visszaállítása A másik lehetőség, hogy már egy létező POSIXct objektumon végzünk időzóna konverziót, amely így az objektum óra (vagy egyéb) részét is érintheti. ido &lt;- Sys.time() # pontos dátum-idő, helyi beállításnak megfelelően ido.utc &lt;- as.POSIXct(format(ido, tz=&quot;UTC&quot;), tz=&quot;UTC&quot;) # konverzió UTC-re ido # helyi időzónával #&gt; [1] &quot;2022-07-13 09:12:37 CEST&quot; ido.utc # UTC-vel #&gt; [1] &quot;2022-07-13 07:12:37 UTC&quot; 5.4.2.2.1 Dátum-idő létrehozása karakteres adatból Amennyiben karakteres formában rendelkezésre áll egy időpont, akkor mindössze az egyes komponensek jelentését kell elmagyaráznunk az as.POSIXct() függvény format= argumentumában. Szabványos idő megadása esetén ((ISO 8601)) ezt el is hagyhatjuk. as.POSIXct(&quot;2022-06-02 22:12:23&quot;, tz = &quot;Europe/Budapest&quot;) # szabványos idő #&gt; [1] &quot;2022-06-02 22:12:23 CEST&quot; as.POSIXct(&quot;2019.09.06. 16 34 17&quot;, format=&quot;%Y.%m.%d. %H %M %S&quot;, tz=&quot;UTC&quot;) #&gt; [1] &quot;2019-09-06 16:34:17 UTC&quot; A dátum értelmezéséhez használt kódok köre (5.11. táblázat) kibővül a ??. táblázatban szereplő időre vonatkozó kódokkal, így ezeket is használhatjuk a POSIXct objektum létrehozása során. Teljes listát az ?strptime súgójában olvashatunk. Formátum kód Jelentés %H óra (00-23) %I óra (01-12) %M perc (00-59) neve %p AM/PM jelzése %S másodperc (00-59) %Z időzóna (csak output) 5.4.2.2.2 Dátum-idő létrehozása numerikus adatokból Dátum-időt szeparáltan létező információkból is létrehozhatunk. Ehhez az ISOdatetime() függvényt kell használni, ahol minden egyes komponens egyesével felsorolható: # POSIXct objektum a dátum-idő tárolására ISOdatetime(year=2022, month=7, day=3, hour=11, min=12, sec=3, tz = &quot;Europe/Budapest&quot;) #&gt; [1] &quot;2022-07-03 11:12:03 CEST&quot; 5.4.2.2.3 Dátum-idő konvertálása A POSIXct objektum dátum típusúvá konvertálható az as.Date() függvénnyel, illetve a format() függvény segítségével tetszőleges formájú karakteres dátumot/időt nyerhetünk ki az objektumból. ido &lt;- Sys.time() # pontos dátum-idő, helyi beállításnak megfelelően ido # dátum-idő objektum #&gt; [1] &quot;2022-07-13 09:12:37 CEST&quot; as.Date(ido) # dátum objektum #&gt; [1] &quot;2022-07-13&quot; format(ido, format=&quot;%Y. %m. %d.&quot;) # magyar dátum #&gt; [1] &quot;2022. 07. 13.&quot; format(ido, format=&quot;%Y. %B %d. %H.%M.%S&quot;) # magyar dátum-idő #&gt; [1] &quot;2022. július 13. 09.12.37&quot; format(ido, format=&quot;%Y. %b %d. %H:%M:%S&quot;) # magyar dátum-idő #&gt; [1] &quot;2022. júl. 13. 09:12:37&quot; format(ido, format=&quot;%Y. %m. %d. %H:%M:%S %Z&quot;) # magyar dátum-idő #&gt; [1] &quot;2022. 07. 13. 09:12:37 CEST&quot; 5.4.2.3 Műveletek és az időtartam kezelése A többnyire szöveges formában megjelenő dátumok és dátum-idők R objektummá alakításának a legnagyobb haszna, hogy a Date és POSIXct objektumokkal számos műveletet hajthatunk végre. Lehetőségünk van például különböző dátumok összehasonlítására, kivonására, léptetésére, vagy ábrákon a tengelyeket címkézhetjük dátum objektumokkal. Két dátum (vagy dátum-idő) különbsége az időtartam, amelyet a kivonás (-) operátorral, vagy a difftime() függvénnyel is előállíthatunk. Utóbbi nagyobb szabadságot ad, mert rendelkezik egy unit= argumentummal az időtartam mértékegységének megadására, így értéke lehet a \"secs\", \"mins\", \"hours\", \"days\" vagy \"weeks\" is. Sys.Date() - as.Date(&quot;2001-03-17&quot;) # születésnap óta eltelt idő napokban #&gt; Time difference of 7788 days difftime(Sys.Date(), as.Date(&quot;2001-03-17&quot;)) # ua. #&gt; Time difference of 7788 days difftime(Sys.Date(), as.Date(&quot;2001-03-17&quot;), unit=&quot;hours&quot;) # órákban #&gt; Time difference of 186912 hours as.numeric(difftime(Sys.Date(), as.Date(&quot;2001-03-17&quot;), unit=&quot;hours&quot;)) # számként #&gt; [1] 186912 Ne feledjük, hogy az időtartam is egy típus az R-ben (difftime osztály), ahogyan a következő sorokban ez megfigyelhetjük: difft &lt;- difftime(Sys.Date(), as.Date(&quot;2001-03-17&quot;), unit=&quot;hours&quot;) typeof(difft) # difft típusa #&gt; [1] &quot;double&quot; class(difft) # difft típusa #&gt; [1] &quot;difftime&quot; unclass(difft) # difft alapja #&gt; [1] 186912 #&gt; attr(,&quot;units&quot;) #&gt; [1] &quot;hours&quot; A difftime() működik dátum-idővel is, és természetesen két dátum vagy időpont között a szokásos műveletek is elvégezhetők. A Google Űrlap időbélyeg oszlopából rögzítettünk két adatot és elvégeztünk néhány műveletet köztük: idobelyeg.1 &lt;- as.POSIXct(&quot;2022.04.06. 11:11:33&quot;, format=&quot;%Y.%m.%d. %H:%M:%S&quot;, tz=&quot;UTC&quot;) idobelyeg.2 &lt;- as.POSIXct(&quot;2022.04.06. 12:06:35&quot;, format=&quot;%Y.%m.%d. %H:%M:%S&quot;, tz=&quot;UTC&quot;) idobelyeg.1 == idobelyeg.2 # nem egyenlőek #&gt; [1] FALSE idobelyeg.1 &lt; idobelyeg.2 # az első időbélyeg a korábbi #&gt; [1] TRUE # hány másodperc telt el a két válasz között as.numeric(difftime(idobelyeg.2, idobelyeg.1, unit=&quot;sec&quot;)) #&gt; [1] 3302 5.4.3 Összefoglalás A dátumokat Date a dátum-időket POSIXct objektumban tároljuk az R-ben, melyekkel a szokásos dátumkezelő műveletek már könnyen elvégezhetők. Időtartamot, vagyis két dátum vagy időpont közötti különbséget a difftime() függvénnyel határozhatunk meg. 5.4.4 Feladatok Konvertáljuk dátummá a következő két sztringet: \"6November2020\", \"2013-02-29\"! Utóbbi esetben mi lehet a hiba oka? A seq() függvény from= és to= argumentuma a dátum típusú objektumokkal is működik. A by= argumentum értéke ilyenkor lehet numerikus (ekkor napokat jelent), de lehet x weeks, x months vagy x years, ahol x nullánál nagyobb egész lehet. Hozzunk létre egy dátum-vektort 2020 összes hétfőjének dátumával! A Halley-üstökös utoljára 1986-ban járt a Naprendszerünkben, így az előrejelzések szerint legközelebb 2061. július 26-ban tér vissza. Rögzítsük ezt dátumként, és számoljuk ki, hány napotot kell még várni az üstökös érkezésére. A fenti feladatok megoldása 5.4.5 Tibble A Tidyverse R használata során az adatainkat tibble típusú objektumban tároljuk. Használatához töltsük be a tidyverse csomagot. library(tidyverse) x &lt;- rep(c(&#39;A&#39;,&#39;B&#39;), times=4); y &lt;- rep(6:9, times=2); z &lt;- 1:8 df &lt;- tibble(nev=x, pont.1=y, pont.2=z) df #&gt; # A tibble: 8 × 3 #&gt; nev pont.1 pont.2 #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 A 6 1 #&gt; 2 B 7 2 #&gt; 3 A 8 3 #&gt; 4 B 9 4 #&gt; 5 A 6 5 #&gt; 6 B 7 6 #&gt; 7 A 8 7 #&gt; 8 B 9 8 A tibble objektumok alaptípusa lista, de az osztálytípusok között megjelennek a tibble-re specifikus osztályok is. A A tbl_df osztály jelenléte hozza magával azokat az új tulajdonságokat és lehetőségeket, amit a Tidyverse R központi adatszerkezetévé teszi ezt az objektumtípust. attributes(df) #&gt; $class #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 #&gt; #&gt; $names #&gt; [1] &quot;nev&quot; &quot;pont.1&quot; &quot;pont.2&quot; typeof(df); class(df) #&gt; [1] &quot;list&quot; #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; A tibble és a data frame típusú objektumok között az átjárhatóságot az as_tibble() és az as.data.frame() függvény biztosítja. as_tibble(df) #&gt; # A tibble: 8 × 3 #&gt; nev pont.1 pont.2 #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 A 6 1 #&gt; 2 B 7 2 #&gt; 3 A 8 3 #&gt; 4 B 9 4 #&gt; 5 A 6 5 #&gt; 6 B 7 6 #&gt; 7 A 8 7 #&gt; 8 B 9 8 as.data.frame(df) #&gt; nev pont.1 pont.2 #&gt; 1 A 6 1 #&gt; 2 B 7 2 #&gt; 3 A 8 3 #&gt; 4 B 9 4 #&gt; 5 A 6 5 #&gt; 6 B 7 6 #&gt; 7 A 8 7 #&gt; 8 B 9 8 A tibble típus tesztelése az is_tibble() segítségével történik, de a tibble típusú objektumokra az is.data.frame() is igaz értékkel tér vissza: is_tibble(df); is.data.frame(df) #&gt; [1] TRUE #&gt; [1] TRUE Melyek a data frame és a tibble közötti különbségek? Már három eltérést akár észre is vehettünk. Az első a tibble létrehozásához kötődik. Egy tibble típusú objektum, csak azonos hosszúságú oszlopvektorokból hozható létre, így biztonságosabban konstruálható, mint az ismétlést is támogató data frame típusú objektumok. Tibble esetében csak az egy hosszú vektorok ismétlése megengedett. Tehát ez a konstrukció működik: tibble(a=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), p=1) #&gt; # A tibble: 3 × 2 #&gt; a p #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 a 1 #&gt; 2 b 1 #&gt; 3 c 1 A második különbség, hogy a tibble a létrehozás során nem végez automatikus típuskonverziót. Tehát a karakteres vektorokat nem alakítja át faktorokká. str(df) #&gt; tibble [8 × 3] (S3: tbl_df/tbl/data.frame) #&gt; $ nev : chr [1:8] &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; ... #&gt; $ pont.1: int [1:8] 6 7 8 9 6 7 8 9 #&gt; $ pont.2: int [1:8] 1 2 3 4 5 6 7 8 A harmadik különbség az adatok megjelenítésében van. Tibble esetében csak az első 10 sor jelenik meg, és annyi oszlop, amennyi az aktuális képernyőre kifér. A több oszlop neve alul jelenik meg. Az oszlopnevek alatt az oszlop típusa is megjelenik. A negyedik eltérés a tibble indexeléséhez kötődik. Az [ operátor használata során minden esetben tibble típusú objektumot kapunk, nem kaphatunk vektort, azaz nem történhet dimenzióvesztés. df[, 2] #&gt; # A tibble: 8 × 1 #&gt; pont.1 #&gt; &lt;int&gt; #&gt; 1 6 #&gt; 2 7 #&gt; 3 8 #&gt; 4 9 #&gt; 5 6 #&gt; 6 7 #&gt; 7 8 #&gt; 8 9 df[1, ] #&gt; # A tibble: 1 × 3 #&gt; nev pont.1 pont.2 #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 A 6 1 df[1, 2] #&gt; # A tibble: 1 × 1 #&gt; pont.1 #&gt; &lt;int&gt; #&gt; 1 6 df[1, 2, drop=T] #&gt; [1] 6 5.4.6 A munkaterület függvényei Megbeszéltük, hogy a munka során az objektumaink a memória speciális területére, a munkaterületre (workspace) kerülnek. Ha még korábban nem is hoztunk létre objektumot, akkor a következő három parancs, három objektumot hoz létre a munkaterületen: fib.0 &lt;- 0 fib.1 &lt;- 1 fib.2 &lt;- fib.0 + fib.1 A munkaterületen létrehozott objektumok neveit az ls() függvény listázza ki: # ls() A munkaterületről objektumot az rm() paranccsal távolíthatunk el, például a rm(fib.0) # fib.0 törlése ls() #&gt; [1] &quot;a&quot; &quot;alap&quot; &quot;D&quot; &quot;datum&quot; #&gt; [5] &quot;df&quot; &quot;df.long&quot; &quot;df1&quot; &quot;df2&quot; #&gt; [9] &quot;df3&quot; &quot;difft&quot; &quot;egyutthato.a&quot; &quot;egyutthato.b&quot; #&gt; [13] &quot;egyutthato.c&quot; &quot;eset.1&quot; &quot;eset.2&quot; &quot;eset.3&quot; #&gt; [17] &quot;fib.1&quot; &quot;fib.2&quot; &quot;fiu&quot; &quot;foglalkozas&quot; #&gt; [21] &quot;hazas&quot; &quot;ido&quot; &quot;ido.utc&quot; &quot;idobelyeg.1&quot; #&gt; [25] &quot;idobelyeg.2&quot; &quot;import_example&quot; &quot;isk.vegz&quot; &quot;isk.vegz.f&quot; #&gt; [29] &quot;iteletek&quot; &quot;lakohely&quot; &quot;lct&quot; &quot;magassag&quot; #&gt; [33] &quot;mat&quot; &quot;nev&quot; &quot;nevek&quot; &quot;obj.double&quot; #&gt; [37] &quot;obj.integer&quot; &quot;obj.karakteres&quot; &quot;obj.logikai&quot; &quot;op&quot; #&gt; [41] &quot;peter.bmi&quot; &quot;peter.magassaga&quot; &quot;peter.sulya&quot; &quot;pontszamok&quot; #&gt; [45] &quot;pulzus.atlag&quot; &quot;Pulzus.atlag&quot; &quot;regi.v.1&quot; &quot;regi.v.2&quot; #&gt; [49] &quot;survey&quot; &quot;szamok&quot; &quot;tab1&quot; &quot;tab2&quot; #&gt; [53] &quot;tab3&quot; &quot;tab4&quot; &quot;table.kiir&quot; &quot;tan.ido&quot; #&gt; [57] &quot;tipus&quot; &quot;tomb&quot; &quot;tz&quot; &quot;uj.v&quot; #&gt; [61] &quot;v.d&quot; &quot;v.i&quot; &quot;v.k&quot; &quot;v.l&quot; #&gt; [65] &quot;van.kocsija&quot; &quot;vekt&quot; &quot;x&quot; &quot;x.d&quot; #&gt; [69] &quot;x.f&quot; &quot;x.f.1&quot; &quot;x.f.2&quot; &quot;x.f.3&quot; #&gt; [73] &quot;y&quot; &quot;z&quot; &quot;z.uj&quot; a fib.0 objektumot távolította el, így az ls() eredményében ez nem is szerepel. Az összes munkaterület-objektum eltávolítása a # rm(list = ls()) # összes objektum törlése # ls() segítségével történik. 5.4.7 A munkakönyvtár függvényei Az R használata során mindig van egy kitüntetett, aktuális könyvtárunk, amelyet munkakönyvtárnak nevezünk. A munkakönyvtár célja, hogy az állományok nyitása és mentése során, ha nem használunk külön könyvtárhivatkozást, akkor ez lesz az alapértelmezett könyvtár. A munkakönyvtár az R-ben lekérdezhető ill. beállítható a getwd() és a setwd() parancsok kiadásával. Például getwd() setwd(&quot;C:/Data/peldak&quot;) parancsokkal először megismerjük az aktuális könyvtárat, majd megváltoztatjuk a C:/Data/peldak könyvtárra. Figyeljük meg, hogy az elérési útban perjelet (/) használtunk. Megjegyezzük, hogy az RStudio projekt üzemmódú használata során nincs szükség a munkakönyvtár beállítására a setwd() paranccsal, sőt, kerüljük a használatát. A munkakönyvtárunk a munka során végig maradjon meg az alapértelmezetten beállított könyvtár, maga a projektkönyvtár. A munkakönyvtár jelentőségét tovább növeli, hogy az R indításakor ebben a könyvtárban 2 állomány létezését figyeli: * .Rhistory (a visszahívható parancsokat tartalmazó szöveges állomány) * .RData (a tárolt objektumokat tartalmazó bináris állomány). A fenti állományok ugyanis betöltésre kerülnek az R indításakor, ha azokat az R megtalálja a munkakönyvtárban. Így ezek után, az .Rhistory állományból jövő parancsok között válogathatunk a parancssor használata során, illetve az .RData állományban tárolt objektumok azonnal elérhetőek, vagyis lesz egy induló munkaterületünk. 5.4.8 Csomagkezelő függvények Korábban megbeszéltük, hogy a csomagok adatobjektumokat és függvényeket tartalmaznak. Az ún. egyéb csomagok (számuk kb. 17000) elsődleges célja az Alap R tudásának kiegészítése. Az R indítása után néhány csomag automatikusan betöltésre kerül a standard csomagok közül. Ezeket a csomagokat és egyéb ún. környezeteket listázhatunk ki a search() függvénnyel. search() detach(&quot;tools:rstudio&quot;) ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; A fenti eredményben a package karaktersorozattal kezdődő elemek mutatják, hogy melyek az éppen betöltött csomagok. A listában nem szereplő, de korábban telepített csomagok betöltéséhez használjuk a library() vagy require() függvényeket. library(MASS) require(foreign) search() ## [1] &quot;.GlobalEnv&quot; &quot;package:foreign&quot; &quot;package:MASS&quot; ## [4] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [7] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [10] &quot;Autoloads&quot; &quot;package:base&quot; A fenti példában a MASS és a foreign csomag betöltését és annak hatását követhetjük nyomon a search() függvény outputjára. Egy csomag betöltése azt jelenti, hogy a csomagban lévő függvények és objektumok a memóriába kerültek, azokat a parancsainkban ezután szabadon felhasználhatjuk. Egy adott csomagban (esetünkben a foreign csomagban) lévő függvények és objektumok a library(help=foreign) vagy a help(package=foreign) paranccsal kérdezhetők le. Betöltött csomagok esetében használhatjuk az ls(name=&quot;package:foreign&quot;, all.names = T) ls(name=&quot;package:base&quot;, all.names = T) parancsot is, amely a csomag adatobjektumainak és függvényeinek a nevét listázza. Betöltött csomagot a detach() függvénnyel távolíthatunk el a memóriából: detach(package:foreign) detach(package:MASS) Ha a használni kívánt csomag még nincs telepítve a számítógépünkre, akkor az @ref(Csomagok_telepítése). fejezetben ismertetett módok egyikét válasszuk, attól függően, hogy a csomag melyik tárhelyről érhető el. A CRAN-ról elérhető csomagok közül telepítsük fel a DescTools és psych csomagokat: install.packages(&quot;DescTools&quot;) install.packages(&quot;psych&quot;) A számítógépünkön telepített csomagokról az installed.packages() függvény ad tájékoztatást. Amennyiben a csomagok &lt;- installed.packages() View(csomagok) # RStudio-ban vagy RGui-ban parancsot kiadjuk az RStudio-ban, akkor csomagjainkat kényelmesen áttekinthetjük. Csomagok frissítésére használjuk a már korábban említett update.packages() parancsot. 5.4.9 Feladatok Írassuk ki a munkaterület objektumait! Hozzunk létre egy pulzus nevű objektumot és újra írassuk ki a munkaterület objektumneveit! Távolítsuk el a pulzus objektumot a munkaterületről! Határozzuk meg az aktuális munkakönyvtárat! Növeljük meg a betű méretét az RGui, az R Commander és az R Studio alkalmazásokban is! Vizsgáljuk meg, hogy a számítógépünkön van-e telepítve a DescTools csomag, ha nincs telepítsük! Derítsük ki, hogy a DescTools csomagnak mi a célja? Soroljunk fel három függvényt és adattáblát ebből a csomagból! Távolítsuk el a memóriából a DescTools csomagot! Telepítsük a számítógépünkre a következő csomagokat: HSAUR2, psych, prettyR, descr és pastecs! 5.5 Objektumok és típusok Az R-ben használható objektumok név-érték párok, vagyis minden objektumnak van neve és értéke. Objektumok alatt ebben a könyvben az adatobjektumokat értjük, bár már említettünk, hogy valójában a függvények is objektumoknak tekinthetők az R-ben, hiszen a függvénynek is van neve, és értéke, az utóbbi pedig utasítások sorozata. Az R-ben minden objektum, például az eddig vizsgált vektorok, attribútumokkal is rendelkezhetnek. Az attribútumok név-értek párok, amelyek speciális tulajdonságokkal ruházzák fel az objektumunkat. Például a names nevű attribútummal a vektor egyes elemeit nevezhetjük el. Későbbiekben látjuk a dim, dimnames, level és class attribútumok jelentőségét is. Egy objektum összes attribútuma az attributes() függvénnyel kérdezhetők le. Ha a names attribútumra vagyunk kíváncsiak a names() függvényt is használhatjuk. Ha létrehozunk egy x numerikus vektort, akkor x &lt;- 1:5 # integer vektor attributes(x) # x attribútumainak kiírása #&gt; NULL names(x) # x name attribútumának kiírása #&gt; NULL x &lt;- numeric(0) mode(x) &lt;- &quot;list&quot; class(x) #&gt; [1] &quot;list&quot; length(x) #&gt; [1] 0 attr(x, &quot;length&quot;) &lt;- &quot;integer&quot; Az x numerikus vektornak nincsenek attribútumai. A NULL az általános, elem nélküli vektort jelenti. A fenti outputban szereplő két NULL esetünkben azt jelzi, hogy nem állítottunk be semmilyen attribútumot, így names attribútumot sem. x &lt;- c(&quot;a&quot;=1, &quot;b&quot;=2, &quot;c&quot;=3, &quot;d&quot;=4, &quot;e&quot;=5) # integer vektor attributes(x) # x attribútumainak kiírása #&gt; $names #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; names(x) # x name attribútumának kiírása #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; A names attribútum beállítható a names() függvénnyel is. names(x) &lt;- c(&quot;elégtelen&quot;, &quot;elégséges&quot;, &quot;közepes&quot;, &quot;jó&quot;, &quot;jeles&quot;) attributes(x) # x attribútumainak kiírása #&gt; $names #&gt; [1] &quot;elégtelen&quot; &quot;elégséges&quot; &quot;közepes&quot; &quot;jó&quot; &quot;jeles&quot; names(x) # x name attribútumának kiírása #&gt; [1] &quot;elégtelen&quot; &quot;elégséges&quot; &quot;közepes&quot; &quot;jó&quot; &quot;jeles&quot; A names attribútum értéke karakteres vektor lehet, amely az outputokban is megjelenik és a indexelésben is felhasználhatjuk. x #&gt; elégtelen elégséges közepes jó jeles #&gt; 1 2 3 4 5 x[c(&quot;közepes&quot;, &quot;jó&quot;)] #&gt; közepes jó #&gt; 3 4 Rögzítsük a (0, 1, 2) értékek előfordulási gyakoriságait a (18, 12, 20) elemeket tartalmazó vektorban. Az elemek nevei most is karakteres konstansok lesznek, az automatikus konverzióról az R gondoskodik. y &lt;- c(18, 12, 20) names(y) &lt;- 0:2 y #&gt; 0 1 2 #&gt; 18 12 20 names(y) #&gt; [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; Az y vektor indexelésénél fontos, hogy megkülönböztessük a numerikus és a karakteres indexeket, az utóbbiaknál mindig idézőjelet kell használnunk. x[1] #&gt; elégtelen #&gt; 1 x[&quot;1&quot;] #&gt; &lt;NA&gt; #&gt; NA x[c(1,3)]; x[c(&quot;0&quot;, &quot;2&quot;)] #&gt; elégtelen közepes #&gt; 1 3 #&gt; &lt;NA&gt; &lt;NA&gt; #&gt; NA NA Egyetlen attribútum lekérdezésére és beállítására az attr() függvényt is használhatjuk. Az attr() függvényben meg kell adnunk az elérendő attribútum nevét is. attr(x, &quot;names&quot;) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) attr(x, &quot;names&quot;) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; attributes(x) #&gt; $names #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; Attribútumok törlésére a NULL értéket használjuk. names(x) &lt;- NULL # names attribútum törlése attr(x, &quot;names&quot;) &lt;- NULL # names attribútum törlése attributes(x) &lt;- NULL # az összes attribútum törlése A dim argumentum x &lt;- 1:12 # integer vektor x #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 attr(x, &quot;dim&quot;) &lt;- c(2,6) # integer mátrix (2x6-os) attributes(x) #&gt; $dim #&gt; [1] 2 6 x #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 1 3 5 7 9 11 #&gt; [2,] 2 4 6 8 10 12 attr(x, &quot;dim&quot;) &lt;- c(2, 3, 2) # integer tömb (2x3x2-es) attributes(x) #&gt; $dim #&gt; [1] 2 3 2 x #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 Amennyiben x &lt;- 1:12 # integer vektor attr(x, &quot;dim&quot;) &lt;- c(2,6) # integer mátrix (2x6-os) dimnames(x) &lt;- list(nem=c(&quot;férfi&quot;, &quot;nő&quot;), osztaly=LETTERS[1:6]) x #&gt; osztaly #&gt; nem A B C D E F #&gt; férfi 1 3 5 7 9 11 #&gt; nő 2 4 6 8 10 12 attributes(x) #&gt; $dim #&gt; [1] 2 6 #&gt; #&gt; $dimnames #&gt; $dimnames$nem #&gt; [1] &quot;férfi&quot; &quot;nő&quot; #&gt; #&gt; $dimnames$osztaly #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; Osztályok A faktor ennek megfelelően tartalmaz egy levels attribútumot, amely a faktor különböző értékeit (szintjeit) sorolja fel. A faktorok class attribútumának értéke pedig factor. f &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;)) attributes(f) #&gt; $levels #&gt; [1] &quot;a&quot; &quot;b&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; levels(f) #&gt; [1] &quot;a&quot; &quot;b&quot; class(f) #&gt; [1] &quot;factor&quot; class(f) &lt;- NULL #attributes(f)&lt;- NULL #f unclass(f) #&gt; [1] 1 2 1 #&gt; attr(,&quot;levels&quot;) #&gt; [1] &quot;a&quot; &quot;b&quot; A class() függvény az objektum class argumentumával tér vissza. Azok az objektumok, amelyek nem rendelkeznek class argumentummal, a class() visszatérési értéke \"numeric\", ha az objektum integer vagy double vektor \"array\" és/vagy \"matrix\", ha az objektum rendelkezik dim attributummal más esetben a typeof() visszatérési értékével. Az unclass() visszatérési értéke az az objektum, amelynek a class attribűtumát eltávolították. A korábban tárgyat típusok mindegyike osztály: Date, difftime, POSIXct, POSIXlt, table. x &lt;- as.Date(&quot;2020-03-12&quot;) attributes(x) #&gt; $class #&gt; [1] &quot;Date&quot; class(x) #&gt; [1] &quot;Date&quot; x &lt;- Sys.Date()-as.Date(&quot;2020-03-12&quot;) x #&gt; Time difference of 853 days attributes(x) #&gt; $class #&gt; [1] &quot;difftime&quot; #&gt; #&gt; $units #&gt; [1] &quot;days&quot; class(x) #&gt; [1] &quot;difftime&quot; x &lt;- ISOdate(year = 2020, month = 12, day = 2) x #&gt; [1] &quot;2020-12-02 12:00:00 GMT&quot; attributes(x) #&gt; $class #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; #&gt; #&gt; $tzone #&gt; [1] &quot;GMT&quot; class(x) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; x &lt;- as.POSIXlt(x) x #&gt; [1] &quot;2020-12-02 12:00:00 GMT&quot; attributes(x) #&gt; $names #&gt; [1] &quot;sec&quot; &quot;min&quot; &quot;hour&quot; &quot;mday&quot; &quot;mon&quot; &quot;year&quot; &quot;wday&quot; &quot;yday&quot; &quot;isdst&quot; #&gt; #&gt; $class #&gt; [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; #&gt; #&gt; $tzone #&gt; [1] &quot;GMT&quot; class(x) #&gt; [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; x &lt;- table(sample(LETTERS[1:3], 100, replace = T)) x #&gt; #&gt; A B C #&gt; 33 34 33 attributes(x) #&gt; $dim #&gt; [1] 3 #&gt; #&gt; $dimnames #&gt; $dimnames[[1]] #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; #&gt; #&gt; #&gt; $class #&gt; [1] &quot;table&quot; class(x) #&gt; [1] &quot;table&quot; A listaelemek nevét a x lis names attribútuma tartalmazza, segítségével a többi elemnek is adhatunk értéket: names(x) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; names(x)[c(1,2)] &lt;- c(&quot;a&quot;,&quot;b&quot;) names(x) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;C&quot; x #&gt; a b C #&gt; 33 34 33 5.5.0.1 Értékek kizárása A faktor létrehozásánál gondoskodhatunk bizonyos értékek kizárásáról, olyan értékekről, amelyeket nem szeretnénk a faktorban felsorolni: factor(c(1:5, NA, 3:6)) #&gt; [1] 1 2 3 4 5 &lt;NA&gt; 3 4 5 6 #&gt; Levels: 1 2 3 4 5 6 Alapértelmezés szerint az NA értéket zárjuk ki a faktor szintjeiből, de ezt megváltoztathatjuk az exclude= paraméter használatával: factor(c(1:5, NA, 3:6), exclude=NULL) #&gt; [1] 1 2 3 4 5 &lt;NA&gt; 3 4 5 6 #&gt; Levels: 1 2 3 4 5 6 &lt;NA&gt; factor(c(1:5, NA, 3:6), exclude=c(4, NA)) #&gt; [1] 1 2 3 &lt;NA&gt; 5 &lt;NA&gt; 3 &lt;NA&gt; 5 6 #&gt; Levels: 1 2 3 5 6 Ahogy látjuk a fenti példában, akár az NA értéket is bevonhatjuk a faktor szintjeibe, akár más értékeket is kizárhatunk az NA-n kívül. Nézzük, hogyan tekint az R az adattáblára. #typeof(df); class(df); length(df) #is.list(df); is.matrix(df); is.data.frame(df) Az adattáblák alaptípusa list, osztálytípusa pedig data.frame a hossza pedig az alkotó (oszlop)vektorok/faktorok száma. Az adattáblára tehát tekinthetünk úgy, mint egy listára, melynek elemei az adattábla oszlopai lesznek. Feladat 234 (23)4 2(34) Más programozási nyelvekben az “objektum” helyett a “változó” elnevezést használják, de a változó fogalma már foglalt a statisztikában, így szerencsésebb a memóriában tárolt adatokra objektumként hivatkozni.↩︎ További értékadás operátorok a -&gt;, &lt;&lt;-, -&gt;&gt; és a =. Ezeket nem használjuk ebben a könyvben.↩︎ "],["beolvasas.html", "6 Beolvasás 6.1 Alapvető formátumok 6.2 A Tidyverse R és az inline beolvasás 6.3 Kiírás és más lehetőségek", " 6 Beolvasás 6.1 Alapvető formátumok Ebben a fejezetben áttekintjük: a táblázatkezelők állományainak beolvasását, a tagolt szöveges állományok fogalmát és azok beolvasását az Alap R-ben. Az R-ben adatokkal dolgozunk, amelyek beolvasására és kiírására az R számos eljárást kínál. Adatokat beolvashatunk a billentyűzetről, a vágóasztalról és külső adatforrásból, állományból vagy adatbázisból is. Az R-ben feldolgozott adatokat a vágóasztalra, adatbázisba vagy állományba írhatjuk ki. Ebben a fejezetben csak a két legtermészetesebb beolvasási módszert ismertetjük, az adatok beolvasást táblázatkezelők (pl. Microsoft Excel, LibreOffice Calc) állományaiból és tagolt szöveges állományokból. 6.1.1 Táblázatkezelők A táblázatkezelők saját állományai (pl. .xlsx és .ods) kezelhetők a legkényelmesebben az adatelemzés során. Az adatbevitel és a rögzített adatok karbantartása, későbbi módosítása ebben a formátumban a legegyszerűbb, ráadásul a számítógépes tesztek sokszor ilyen típusú állományokba írják a válaszokat. Ezek az állományok (munkafüzetek) munkalapokból állnak, így akár több adatbázist is tárolhatunk egyetlen munkafüzetben. Egy Excel vagy LibreOffice Calc adatbázis esetén tudnunk kell, hogy az melyik munkalapon helyezkedik el, ritkábban pedig azt is, melyik tartományban foglal helyet a beolvasandó adatbázis. Az Excel és LibreOffice Calc adatbázisok beolvasást a rio csomag import() függvényével végezzük, melynek egyetlen kötelező argumentuma a fájl elérési útja (file=). Előkészítettünk egy 4 munkalapos Excel és LibreOffice Calc adatbázist (agatha_christie_m.xlsx, agatha_christie_m.ods), amelynek mindegyik munkalapján ugyanazt az adatbázist találjuk meg, de egyre zajosabb környezetben. Az 1. munkalapon nincsenek zavaró cellák, csupán a adatbázisunk értékes adatcellái az A1 cellától kezdődően.. Ebben az esetben nincs szükség más argumentumra, csak az állomány elérési útjára. library(rio) ac.1 &lt;- import(file = &quot;adat/agatha_christie_m.xlsx&quot;) # MS Excel head(ac.1[1:3], n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger ac.1 &lt;- import(file = &quot;adat/agatha_christie_m.ods&quot;) # LibreOffice Calc head(ac.1[1:3], n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger A 2. munkalapon már nem az A1 cellában kezdődik az adatbázis, de továbbra sincs zavaró egyéb cella. Az import() megtalálja az adatbázist a munkalapon az Excel adatbázis esetében, de a LibreOffice Calc adatbázis beolvasásához pontosítani kell az adatbázis helyét. A tartomány közvetlen megadásával (range=\"F7:I52\") utasítjuk az import() függvényt, hogy honnan olvassa be az adatbázisunkat. Természetesen a megadott cellatartomány az oszlopneveket is tartalmazza annak első sorában. Az XLSX és az ODS beolvasása közötti eltérés rávilágít az import() függvényünk működésére. Nem maga az import() végzi a közvetlen beolvasást, hanem okosan kiválasztja a beolvasandó állomány kiterjesztése alapján, hogy melyik csomag, melyik konkrét függvényét hívja. Az Excel állományokat a Tidyverse R readxl csomag read_excel() függvénye fogja beolvasni, a LibreOffice Calc állományokat a readODS csomag read_ods() függvénye, amelyek hívását már az import() végzi. Mivel két különböző függvény dolgozik a háttérben, így az XLSX és az ODS állományokat beolvasó parancs paraméterezése is eltérhet, és esetünkben el is tér. A file= argumentum közös, és természetesen a munkalap sorszámát meg kell adnunk, amely mindkét esetben a sheet=2-vel történik. ac.2 &lt;- import(file = &quot;adat/agatha_christie_m.xlsx&quot;, sheet=2) head(ac.2, n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger #&gt; szereplo #&gt; 1 Miss Marple #&gt; 2 Miss Marple #&gt; 3 Miss Marple ac.2 &lt;- import(file = &quot;adat/agatha_christie_m.ods&quot;, sheet=2, range=&quot;F7:I52&quot;) head(ac.2, n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger #&gt; szereplo #&gt; 1 Miss Marple #&gt; 2 Miss Marple #&gt; 3 Miss Marple A 3. munkalapon már az első 6 sor zavaró, nem az adatbázishoz tartozó adatokat tartalmaz, így azokat elegendő kihagyni (skip=6) a beolvasásból az Excel esetében, míg az ODS-hez a tartomány pontos megadása szükséges a sikeres beolvasásához. ac.3 &lt;- import(file = &quot;adat/agatha_christie_m.xlsx&quot;, sheet=3, skip=6) head(ac.3, n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger #&gt; szereplo #&gt; 1 Miss Marple #&gt; 2 Miss Marple #&gt; 3 Miss Marple ac.3 &lt;- import(file = &quot;adat/agatha_christie_m.ods&quot;, sheet=3, range=&quot;F7:I52&quot;) head(ac.3, n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger #&gt; szereplo #&gt; 1 Miss Marple #&gt; 2 Miss Marple #&gt; 3 Miss Marple A 4. munkalapon már rendkívül terhelt az adatbázisunk a környező zavaró celláktól, így közvetlenül a tartomány megadásával (range=\"F7:I52\") utasítjuk az import() függvényt Excel esetében is, hogy honnan olvassa be az adatbázisunkat. ac.4 &lt;- import(file = &quot;adat/agatha_christie_m.xlsx&quot;, sheet=4, range=&quot;F7:I52&quot;) head(ac.4, n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger #&gt; szereplo #&gt; 1 Miss Marple #&gt; 2 Miss Marple #&gt; 3 Miss Marple ac.4 &lt;- import(file = &quot;adat/agatha_christie_m.ods&quot;, sheet=4, range=&quot;F7:I52&quot;) head(ac.4, n=3) #&gt; megjelenes.eve cim.magyar cim.angol #&gt; 1 1930 Gyilkosság a paplakban The Murder at the Vicarage #&gt; 2 1942 Holttest a könyvtárszobában The Body in the Library #&gt; 3 1942 A láthatatlan kéz The Moving Finger #&gt; szereplo #&gt; 1 Miss Marple #&gt; 2 Miss Marple #&gt; 3 Miss Marple Jegyezzük meg, ha csak tehetjük, adatainkat táblázatkezelő programmal hozzuk létre és annak saját formátumában (XLSX vagy ODS) tároljuk. 6.1.2 Tagolt szöveges állományok A tagolt szöveges állományok kitüntetett szerepet játszanak a statisztikai adatfeldolgozásban, ugyanis minden statisztikai programcsomag és táblázatkezelő be tud olvasni ilyen formátumú állományokat, és ki tud exportálni ilyen formátumba. A tagolt szöveges állományok létrehozásához pedig egy jegyzettömbszerű szövegszerkesztő is elegendő, tehát ez a formátum elég nagy szabadságot ad az adataink kezeléshez. 6.1.2.1 Tagolt szöveges állomány létrehozása A tagolt szöveges állomány egy egyszerű, formázást nem tartalmazó szöveges állomány, amelyet azonos szerkezetű sorok alkotnak. A sorokat az operációs rendszernek megfelelő sorvége karakterek zárják. Jegyzettömbszerű szövegszerkesztő használata során, az ENTER leütésével ezek a sorvége karakterek kerülnek fizikailag a szöveges állományba. Linux és macOS operációs rendszer alatt az LF karakter, Windows platformon a CR és LF karakterek. Ezeket sorvége karaktereknek hívjuk, az LF a soremelés (\\n), a CR a kocsi vissza (\\r) karakter. Annak ellenére, hogy különböző platformokon más-más jelzi a sorvégét, a beolvasó függvények felismerik ezeket, és helyesen értelmezik. Ezzel nekünk nem kell külön foglalkoznunk. Minden tagolt szöveges állományban van egy kitüntetett karakter, a tagoló karakter. Ez tipikusan a pontosvessző (;), a szóköz (), a tabulátor (\\t) vagy a vessző (,) karakter. A tagolt szöveges állomány minden sorában ezek egyikét használjuk az adatértékek elválasztására, ráadásul minden sorban azonos számú adatértéknek kell szerepelni, ennek megfelelően minden sorban azonos számú tagoló karakter van. Nézzünk példát pontosvesszővel tagolt szöveges állományra: nem;kor;pulzus fiú;12;71 fiú;11;69 lány;14;70 Összesen 4 sora van, soronként 3 adatértékkel, és 2 pontosvesszővel. Látható, hogy az első sor kitüntetett, azaz igazából nem méréssel kapott adatokat tartalmaz, hanem megnevezi azokat. Gyakori, hogy a tagolt szöveges állományok első sora ilyen speciális fejlécsor, amely tehát oszlopneveket tartalmaz. Ez nem kötelező, elképzelhető, hogy az első sorban már közvetlenül adatértékek vannak. Nézzünk egy szóközzel tagolt szöveges állományt: nem kor pulzus atlag fiú 12 71 3,92 fiú 11 69 4,12 lány 14 70 5,00 Ez a tagolt szöveges állomány 4 sort, soronként 4 adatértéket és 3 elválasztó szóközt tartalmaz. Az első sora fejlécsor. Látható, hogy tizedes törtek is szerepelnek az állományban, a tizedesvesszőt valóban vesszővel jelöltük. Ez nem minden esetben van így, tizedes pont is elválaszthatná az egész és tört részt. Tekintsünk egy elsőre kicsit rendezetlen szöveges állományt: Általános iskolai felmérés 2019.03.02. #2.b nem,kor,pulzus,atlag fiú,12,71,3.92 #fiú,11,69,4.12 lány,14,70,5.00 # ellenőrizni Az állomány második felében valóban felfedezhetjük a rendezettséget, a fejlécet 4 oszlopnévvel, és alatta a sorokat 4-4 adatértékkel. Ez a rész olyan, mint egy vesszővel elválasztott szöveges állomány, ahol a tizedes törtekben pontot használunk az egész és tört rész elválasztására. Az állomány eleje azonban egyáltalán nem hasonlít a tagolt szöveges állományokra, és ráadásul kettős kereszttel (#), vagyis megjegyzésnek szánt szövegekkel tarkított soraink is vannak. Az ilyen szabadabb stílusú állományok is beolvashatók az R-be, csupán meg kell adnunk, hogy az elejéről hány sort hagyjon figyelmen kívül (3 sort), és mit tekintsen megjegyzésnek (a kettős keresztet) a beolvasását végző eljárás. Ebben az esetben a fejlécen kívül még 2 adatsor lesz a beolvasott adattáblában. Melyek a tagolt szöveges állományok fontos jellemzői: a tagoló karakter, a decimális elválasztó, van-e fejlécsor, hány sort lépjünk át az elejéről, mi a megjegyzés karakter, milyen kódolású az állomány. Ahogyan említettük tagolt szöveges állományt egy jegyzettömbszerű szövegszerkesztővel mi is létrehozhatunk, de ha módunk van rá, akkor a minél kényelmesebb adatbevitel miatt, használjunk táblázatkezelőt, és az abban elkészült táblázatos formában lévő adatokat exportáljuk ki tagolt szöveges állományba. Például magyar Excel esetén választhatjuk a CSV (pontosvesszővel tagolt), vagy a Szöveges (tabulátorral tagolt) formátumot. Érdemes minden esetben megőrizni a táblázatkezelő saját formátumában az adatokat, mert a kényelmes szerkesztés miatt továbbra is abban érdemes az adatokat módosítani, de a változtatások után, utolsó lépésként, végezzük el az exportot a tagolt szöveges állományba. 6.1.2.2 A read.table() család Tagolt szöveges állományok beolvasásának hagyományos módja a read.table() függvénycsalád használata. Azért nevezzük függvénycsaládnak, mert valójában több függvényt használhatunk, amelyek csak a paraméterek alapértelmezett értékében térnek el egymástól: read.table(sep=\"\", dec=\".\"), read.csv(sep=\",\", dec=\".\"), read.csv2(sep=\";\", dec=\",\"), read.delim(sep=\"\\t\", dec=\".\"), read.delim2(sep=\"\\t\", dec=\",\"). Érdemes a fenti függvénynevek megtanulása helyett egyetlen függvényt, a read.table()-t használni, és inkább a lehetséges paraméterek jelentését tanuljuk meg: file= A beolvasandó állomány elérési útja. sep= Az elválasztó karakter a beolvasandó állományban. Tipikus értékei: sep=\";\", sep=\" \", sep=\",\", és tabulátor elválasztó esetén sep=\"\\t\". dec= A decimális elválasztó, vagyis a tizedesvessző alakja az állományban. Tipikusan a dec=\",\" beállítást kell használnunk, de előfordulhat, hogy a pont a tizedes elválasztó, így a dec=\".\"-ra van szükségünk. header= Ha van fejléc a szöveges állományban, akkor header=TRUE, egyébként a header=FALSE beállítást használjuk. na.strings= A hiányzó érték jelölése a szöveges állományban. Az alapértelmezett beállítás a legtöbb esetben megfelelő, hiszen a \"\" (semmi) és az \"NA\" jelölésből alapértelmezés szerint hiányzó érték lesz. comment.char= A tipikus megjegyzés karakter a #, de meg tudjuk változtatni, ha szükséges. skip= A szöveges állomány első néhány sorát figyelmen kívül hagyhatjuk. stringsAsFactors= A stringsAsFactors=TRUE beállítással elérhetjük a karakteres oszlopok automatikus faktorrá konvertálását. fileEncoding= A szöveges állományt alkotó karakterek kódolási szabványát adhatjuk meg. Tipikusan az UTF-8 kódolású szöveges állományok beolvasása során kell használnunk (fileEncoding=\"UTF-8\"), de a magyar környezetben készült szöveges állományok esetében is rögzíthetjük a kódolási szabványt (fileEncoding=\"latin2\"). strip.white= A felesleges szóközök és tabulátorok eltávolítása az adatok elejéről és végéről. quote= A szöveges állományban lévő adatvédő idézőjelek alakja. Végezzük el az egyetem.csv tagolt szöveges állomány beolvasását, amelynek első néhány sora a következő: hallgato;Height;neme;lefekves;felkeles;Drink 1;67;female;-2,5;5,5;víz 2;64;female;1,5;8;üdítő 3;61;female;-1,5;7,5;tej A beolvasandó állományunk egy első sorában oszlopneveket tartalmazó szöveges állomány, amelynek a tartalmát a következő parancsok egy d.df adattáblában helyezik el. Az állományban az adatokat (és az oszlopneveket is) a pontosvessző (;) választja el, a numerikus értékekben pedig tizedesvessző szerepel. data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv&quot; d.df &lt;- read.table(file = data.file, header=T, sep=&quot;;&quot;, dec=&quot;,&quot;, strip.white = T, stringsAsFactors = F, fileEncoding = &quot;latin2&quot;) str(d.df) #&gt; &#39;data.frame&#39;: 657 obs. of 6 variables: #&gt; $ hallgato: int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ Height : num 67 64 61 61 70 63 61 64 66 65 ... #&gt; $ neme : chr &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot; ... #&gt; $ lefekves: num -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ... #&gt; $ felkeles: num 5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ... #&gt; $ Drink : chr &quot;víz&quot; &quot;üdítő&quot; &quot;tej&quot; &quot;víz&quot; ... 6.1.3 Összefoglalás A statisztikai munka első lépése az adatbázisok, adatmátrixok beolvasása. Adatainkat legkényelmesebb Excel vagy LibreOffice Calc táblázatkezelők saját formátumú adatállományiban tárolni (XLSX, ODS), de néha nem kerülhetjük el a tagolt szöveges állományok használatát. A táblázatkezelők adatállományait a rio csomag import() függvényével olvashatjuk be, a tagolt szöveges állományokat a read.table() függvénnyel. 6.1.4 Feladatok Olvassuk be a https://onlinestatbook.com/2/case_studies/data/leniency.xls Excel állományt, állapítsuk meg hány sora és oszlopa van. Olvassuk be a https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv tagolt szöveges állományt, állapítsuk meg hány sora és oszlopa van. A fenti feladatok megoldása 6.2 A Tidyverse R és az inline beolvasás Ebben a fejezetben áttekintjük az inline beolvasás eseteit és a tagolt szöveges állományok Tidyverse R beolvasását. 6.2.1 A read_delim() függvénycsalád A Tidyverse R is képes a tagolt szöveges állományok beolvasására, és rendszerint gyorsabb, jobban paraméterezhető lehetőséget nyújt. Lényeges különbség az előző részben látott read.table() családhoz képest, hogy minden esetben tibble típusú adattábla a beolvasás eredménye. A read_delim() család tagjai: read_delim(), read_csv, read_csv2, read_tsv. Minden esetben használjuk a read_delim() függvényt, amely nagyon hasonló paraméterekkel rendelkezik, mint a read.table(): file= Ugyanaz, mint a read.table() függvénynél. delim= Ugyanaz, mint a read.table() függvénynél a sep= argumentum. locale= A decimális elválasztó és a kódolási szabvány beállításához a locale() függvényt használjuk. Ha a szokásos vessző a tizedes vessző alakja, akkor a locale = locale(decimal_mark = \",\"), egyébként a locale = locale(decimal_mark = \".\") beállítást használjuk. Ha a kódolási szabványt is be szeretnénk állítani a vessző decimális elválasztó mellett, akkor a locale = locale(decimal_mark = \".\", encoding = \"UTF-8\") beállításra van szükségünk az UTF-8 beállításához. col_names= Ugyanaz, mint a read.table() függvénynél a header= argumentum. na= Ugyanaz, mint a read.table() függvénynél a na.strings= argumentum. comment= Ugyanaz, mint a read.table() függvénynél a comment.char= argumentum. skip= Ugyanaz, mint a read.table() függvénynél. trim_ws Ugyanaz, mint a read.table() függvénynél a strip.white= argumentum. quote Ugyanaz, mint a read.table() függvénynél. Végezzük el a már korábban megismert egyetem.csv tagolt szöveges állomány beolvasását a Tidyverse R segítségével: data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv&quot; library(tidyverse) d.tbl &lt;- read_delim(file = data.file, col_names=T, delim=&quot;;&quot;, locale=locale(decimal_mark=&quot;,&quot;, encoding = &quot;latin2&quot;), trim_ws= T) str(d.tbl) #&gt; spec_tbl_df [657 × 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #&gt; $ hallgato: num [1:657] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ Height : num [1:657] 67 64 61 61 70 63 61 64 66 65 ... #&gt; $ neme : chr [1:657] &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot; ... #&gt; $ lefekves: num [1:657] -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ... #&gt; $ felkeles: num [1:657] 5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ... #&gt; $ Drink : chr [1:657] &quot;víz&quot; &quot;üdítő&quot; &quot;tej&quot; &quot;víz&quot; ... #&gt; - attr(*, &quot;spec&quot;)= #&gt; .. cols( #&gt; .. hallgato = col_double(), #&gt; .. Height = col_double(), #&gt; .. neme = col_character(), #&gt; .. lefekves = col_double(), #&gt; .. felkeles = col_double(), #&gt; .. Drink = col_character() #&gt; .. ) #&gt; - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; 6.2.2 Inline beolvasás Ebben a könyvben a külső adatállományokból való beolvasás mellet az inline adatbeolvasást is részletesen bemutatjuk. Kisebb adatbázisok, egyszerűbb adatfeldolgozás esetén az adatokat közvetlenül a parancsállományokban is elhelyezhetjük, ezt nevezzük sorok közötti, vagy más néven inline adatbeolvasásának. A szokásos eset azonban a külső adatállományból való adatbeolvasás. Az adatok inline beolvasása azt jelenti, hogy nem külső állományból, hanem az R parancsállományba gépelt adatokból indulunk ki. Felhasználjuk a c(), factor() és a data.frame() függvényeket az Alap R-ből, valamint a tibble() vagy tribble() függvényeket a Tidyverse R-ből. Esetleg használhatjuk az állományok beolvasását végző, most megismert read.table() (Alap R) és read_delim() (Tidyverse R) függvénycsaládokat is. A legegyszerűbb adatfeldolgozási feladatok egyetlen változót érintenek, ezek pedig numerikus vektorban vagy faktorban tárolhatók az R-ben. Ez az inline beolvasás legegyszerűbb esete. # 4 óvodás testmagassága cm-ben magassag &lt;- c(132, 143, 129, 145) mean(magassag) # testmagasság átlaga #&gt; [1] 137.2 # a 4 óvodás neme nem &lt;- factor(c(&quot;fiú&quot;, &quot;lány&quot;, &quot;lány&quot;, &quot;fiú&quot;), levels=c(&quot;fiú&quot;, &quot;lány&quot;)) table(nem, useNA = &quot;ifany&quot;) # gyakorisági táblázat a nemre #&gt; nem #&gt; fiú lány #&gt; 2 2 Több változó tárolása esetén adattábla (data frame) vagy tibble típusú objektumot hozunk létre a korábban már megismert data.frame() és tibble() függvények segítségével. Előkészítő lépésként természetesen az oszlopokat alkotó vektorokra is szükség van. library(tidyverse) magassag &lt;- c(132, 143, 129, 145) nem &lt;- factor(c(&quot;fiú&quot;, &quot;lány&quot;, &quot;lány&quot;, &quot;fiú&quot;), levels=c(&quot;fiú&quot;, &quot;lány&quot;)) d.df &lt;- data.frame(magassag, nem) # data frame létrehozása d.tbl &lt;- tibble(magassag, nem) # tibble létrehozása A létrehozott adattáblák is nagyon hasonlítanak egymásra, és felhasználásuk is azonos módon történik: d.df # data frame #&gt; magassag nem #&gt; 1 132 fiú #&gt; 2 143 lány #&gt; 3 129 lány #&gt; 4 145 fiú d.tbl # tibble #&gt; # A tibble: 4 × 2 #&gt; magassag nem #&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 132 fiú #&gt; 2 143 lány #&gt; 3 129 lány #&gt; 4 145 fiú mean(d.df$magassag) # testmagasság átlaga #&gt; [1] 137.2 mean(d.tbl$magassag) # testmagasság átlaga #&gt; [1] 137.2 table(d.df$nem, useNA = &quot;ifany&quot;) # gyakorisági táblázat a nemre #&gt; #&gt; fiú lány #&gt; 2 2 table(d.tbl$nem, useNA = &quot;ifany&quot;) # gyakorisági táblázat a nemre #&gt; #&gt; fiú lány #&gt; 2 2 Nem kell feltétlenül az adattáblát alkotó oszlopokat külön numerikus vagy faktor oszlopokban előzőleg elkészíteni, ezeket a data.frame() vagy tibble() argumentumába közvetlenül is beírhatjuk: d.df &lt;- data.frame( magassag = c(132, 143, 129, 145), nem = factor(c(&quot;fiú&quot;, &quot;lány&quot;, &quot;lány&quot;, &quot;fiú&quot;), levels=c(&quot;fiú&quot;, &quot;lány&quot;)) ) d.tbl &lt;- tibble( magassag = c(132, 143, 129, 145), nem = factor(c(&quot;fiú&quot;, &quot;lány&quot;, &quot;lány&quot;, &quot;fiú&quot;), levels=c(&quot;fiú&quot;, &quot;lány&quot;)) ) Tibble létrehozásának másik módja a tribble() függvény, amelynek argumentumába táblázatos formában adhatjuk meg az adatokat. A változóneveket a ~ karakter vezeti be, minden adatértéket és oszlopnevet vessző választ el egymástól a tribble() argumentumában. d.tbl &lt;- tribble( ~magassag, ~nem, 132, &quot;fiú&quot;, 143, &quot;lány&quot;, 129, &quot;lány&quot;, 145, &quot;fiú&quot; ) d.tbl #&gt; # A tibble: 4 × 2 #&gt; magassag nem #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 132 fiú #&gt; 2 143 lány #&gt; 3 129 lány #&gt; 4 145 fiú Vegyük észre, hogy a nem oszlop a fenti példában karakteres vektor, a faktorrá alakításáról a factor() függvénnyel gondoskodnunk kell. d.tbl$nem &lt;- factor(d.tbl$nem, levels=c(&quot;fiú&quot;, &quot;lány&quot;)) d.tbl #&gt; # A tibble: 4 × 2 #&gt; magassag nem #&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 132 fiú #&gt; 2 143 lány #&gt; 3 129 lány #&gt; 4 145 fiú A read.table() és read_delim() függvénycsaládokat is használhatjuk inline beolvasásra. Mindkét esetben egy inline, szóközzel tagolt szöveges állományt illesztettünk a kódba, ennek megfelelően állítottuk be az elválasztó karaktereket. A read.table() esetében körbevettük a textConnection() függvénnyel is a beillesztett adatokat, erre a Tidyverse R read_delim()-jénél már nincs szükség. A nem faktorrá konvertálásáról se felejtkezzünk el. d.df &lt;- read.table(file = textConnection(&quot; magassag nem 132 fiú 143 lány 129 lány 145 fiú &quot;), header=T, sep=&quot; &quot;) d.df$nem &lt;- factor(d.df$nem, levels=c(&quot;fiú&quot;, &quot;lány&quot;)) d.df #&gt; magassag nem #&gt; 1 132 fiú #&gt; 2 143 lány #&gt; 3 129 lány #&gt; 4 145 fiú d.tbl &lt;- read_delim(&quot; magassag nem 132 fiú 143 lány 129 lány 145 fiú &quot;, col_names=T, delim=&quot; &quot;) d.tbl$nem &lt;- factor(d.tbl$nem, levels=c(&quot;fiú&quot;, &quot;lány&quot;)) d.tbl #&gt; # A tibble: 4 × 2 #&gt; magassag nem #&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 132 fiú #&gt; 2 143 lány #&gt; 3 129 lány #&gt; 4 145 fiú 6.2.3 Összefoglalás swwwww 6.2.4 Feladatok sadadasda A fenti feladatok megoldása 6.3 Kiírás és más lehetőségek Ebben a fejezetben áttekintjük a tagolt szöveges állományok kiírását objektumok olvasását és írását bináris állományokba, más statisztikai programcsomagok adatállományainak olvasását és írását, és a fix széles mezővel rendelkező állományok olvasását. 6.3.1 Tagolt szöveges állomány kiírása Adattáblák és mátrixok kiírására a write.table() függvényt használhatjuk az Alap R-ből és a write_delim() függvényt a Tidyverse R-ből. Mindkét függvény egy-egy függvénycsalád reprezentánsa, de az Alap R-ből elegendő ismerni az említett tagot, a Tidyverse R-ből pedig az említetten kívül a write_csv2() függvényt. Néhány új argumentummal kell megismerkednünk, a korábban tanult argumentumok jelentését még egyszer nem soroljuk fel. A write.table() mátrixok és adattáblák kiírására is alkalmas, míg a write_delim() és a write_csv2() csak az adattáblákat rögzíti. Az első paraméter (x=) a kiírandó objektum neve mindhárom függvény esetében. Az első példában a write.table() függvénnyel egy mátrixot és a korábban létrehozott d.df adattáblát írjuk ki. A row.names= és a col.names= logikai paraméterek szabályozzák, hogy a sor és oszlopnevek szerepeljenek-e a kimeneti állományban. Ezek alapértelmezett értéke TRUE. x.mat &lt;- matrix(1:12, nrow=3) # mátrix létrehozása write.table(x.mat, &quot;output/adat/x_mat.txt&quot;, col.names=F, row.names=F) # kiírása # adattábla kiírása write.table(x = d.df, file = &quot;output/adat/df_out.txt&quot;, sep = &quot;\\t&quot;, quote = F, dec = &quot;,&quot;, row.names = F, col.names = T, fileEncoding = &quot;UTF-8&quot;) A Tidyverse kiíró függvényei UTF-8 kódolású állományt hoznak létre minden esetben, és a decimális elválasztó alakja write_delim() esetében pont, write_csv2() esetében pedig vessző. A sornevek soha nem íródnak ki, az oszlopnevek kiírását a col_names= argumentummal szabályozhatjuk. library(tidyverse) # tabulátorral tagolt szöveges állomány létrehozása write_delim(x = d.tbl, file = &quot;output/adat/tbl_out.txt&quot;, delim = &quot;\\t&quot;, col_names = T) # pontosvesszővel tagolt szöveges állomány létrehozása write_csv2(x = d.tbl, file = &quot;output/adat/tbl_out.csv&quot;, col_names = T) 6.3.2 R objektumok írása és olvasása Az R-rel való munka során sok objektummal dolgozunk, többségük külső állományok beolvasásával jön létre, melyeket aztán a munka során változatos módon manipulálunk. Az adattábla és a tibble típusú objektumok képezik a statisztikai munka kiinduló pontját. Egyéb objektumok mentéséről eddig nem beszéltünk, pedig a munka során ezek mentése és beolvasása is érdekes lehet. Egy objektum értékét eltárolhatjuk szöveges állományban a dput() függvénnyel, és visszaolvashatjuk a dget()-tel: library(MASS) dput(x = survey, file = &quot;output/adat/dput_out.txt&quot;) # survey kiírása txt-be d.df &lt;- dget(file = &quot;output/adat/dput_out.txt&quot;) # survey beolvasása txt-ből Igazán gyors kiírást és visszaolvasást nem várhatunk a szöveges állományoktól, így nagyobb adatbázisok esetében (is) érdemes az objektumok bináris mentését és visszaállítását választani. A saveRDS() és a readRDS() Alap R függvényekkel tudjuk megoldani, hogy az R saját RDS formátumú bináris állományába tudjunk lementeni és visszatölteni egy objektumot. # survey kiírása bináris állományba saveRDS(object = survey, file = &quot;output/adat/survey.rds&quot;) # survey beolvasása bináris állományból d.df &lt;- readRDS(file = &quot;output/adat/survey.rds&quot;) A Tidyverse R write_rds() és read_rds() függvényei ugyanezt a tevékenységet végzik, de alapértelmezés szerint nem tömörítenek, így némileg gyorsabb működést biztosítanak: library(tidyverse) # survey kiírása bináris állományba write_rds(x = survey, file = &quot;output/adat/survey_2.rds&quot;) # survey beolvasása bináris állományból d.df &lt;- read_rds(file = &quot;output/adat/survey_2.rds&quot;) Egyszerre több objektumok tárolását is elvégezhetjük az R másik saját bináris formátuma, az RData segítségével. A save() függvényben felsoroljuk a tárolni kívánt objektumok nevét, és megadunk egy .RData kiterjesztésű állományt. A visszaolvasás a load() segítségével történik. Figyeljük meg, hogy a load() használata során nincs szükség az értékadás (&lt;-) operátorra, mert az RData állomány tartalmazza az objektumneveket is, így ezekkel a nevekkel jönnek létre a munkaterületen a bináris állományban eltárolt objektumok. Az azonos nevű, már létező objektumokat figyelmeztetés nélkül felülírja a load(), így legyünk óvatosak a függvény használatával. # survey és Animals kiírása bináris állományba save(survey, Animals, file = &quot;output/adat/MASS_2.RData&quot;) # survey és Animals beolvasása bináris állományból load(file = &quot;output/adat/MASS_2.RData&quot;) Az összes objektum, amely pillanatnyilag a munkaterületen tartózkodik, elmenthető a save.image() segítségével. Visszatöltés szintén a load()-dal lehetséges. # minden objektum mentése bináris állományba a munkaterületről save.image(file = &quot;output/adat/osszes_obj.RData&quot;) # az objektumok beolvasása a munkaterületre load(file = &quot;output/adat/osszes_obj.RData&quot;) 6.3.3 Más típusú adatállományok Az R számos más formátumú adatállomány beolvasását támogatja az eddig tanultakon kívül. Például az Alap R foreign csomagja DBF, Stata, Minitab, SPSS, SAS és Epi adatállományokat is be tud olvasni. A Tidyverse R haven csomagja SPSS, Stata, és SAS fájlokat, a readxl csomagja pedig Excel .xls és .xlsx állományokat is. Json állományokat olvashatunk be a jsonlite, XML állományokat az xml2 csomaggal. A rio csomag különleges pozícióban van, ugyanis minden eddig felsorolt adatállomány beolvasását támogatja egyetlen parancs, az import() segítségével. A beolvasandó állomány kiterjesztéséből tudni fogja, hogy pontosan milyen módon (melyik csomag megfelelő függvénye segítségével) olvassa be az adatállományt. Az import() támogatja az adattábla és a tibble létrehozását is a setclass= argumentuma segítségével. Példaképp pontosvesszővel tagolt szöveges, SPSS és XLSX állományokat olvasunk be: library(rio) data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv&quot; d.df &lt;- import(file = data.file, sep=&quot;;&quot;, header=T, dec=&quot;,&quot;) str(d.df) #&gt; &#39;data.frame&#39;: 657 obs. of 6 variables: #&gt; $ hallgato: int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ Height : num 67 64 61 61 70 63 61 64 66 65 ... #&gt; $ neme : chr &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot; ... #&gt; $ lefekves: num -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ... #&gt; $ felkeles: num 5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ... #&gt; $ Drink : chr &quot;v\\xedz&quot; &quot;\\xfcd\\xedt\\xf5&quot; &quot;tej&quot; &quot;v\\xedz&quot; ... data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/nepesseg.sav&quot; d.df &lt;- import(file = data.file) str(d.df) #&gt; &#39;data.frame&#39;: 12 obs. of 4 variables: #&gt; $ HONAP : num 1 2 3 4 5 6 7 8 9 10 ... #&gt; ..- attr(*, &quot;label&quot;)= chr &quot;Hónap 1994-ben&quot; #&gt; ..- attr(*, &quot;format.spss&quot;)= chr &quot;F5.0&quot; #&gt; ..- attr(*, &quot;display_width&quot;)= int 12 #&gt; ..- attr(*, &quot;labels&quot;)= Named num [1:12] 1 2 3 4 5 6 7 8 9 10 ... #&gt; .. ..- attr(*, &quot;names&quot;)= chr [1:12] &quot;január&quot; &quot;február&quot; &quot;március&quot; &quot;április&quot; ... #&gt; $ NEPESSEG: num 10273 10270 10267 10265 10262 ... #&gt; ..- attr(*, &quot;label&quot;)= chr &quot;Népesség száma hó végén&quot; #&gt; ..- attr(*, &quot;format.spss&quot;)= chr &quot;F5.0&quot; #&gt; $ ELVESZUL: num 10238 9285 10105 9617 9548 ... #&gt; ..- attr(*, &quot;label&quot;)= chr &quot;Élveszületések száma&quot; #&gt; ..- attr(*, &quot;format.spss&quot;)= chr &quot;F5.0&quot; #&gt; $ HALAL : num 13888 12825 12516 11753 12328 ... #&gt; ..- attr(*, &quot;label&quot;)= chr &quot;Halálozások száma&quot; #&gt; ..- attr(*, &quot;format.spss&quot;)= chr &quot;F5.0&quot; data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/pothoff2.xlsx&quot; d.tbl &lt;- import(file = data.file, setclass = &quot;tibble&quot;) str(d.tbl) #&gt; tibble [108 × 5] (S3: tbl_df/tbl/data.frame) #&gt; $ person: num [1:108] 1 1 1 1 2 2 2 2 3 3 ... #&gt; $ sex : chr [1:108] &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; ... #&gt; $ age : num [1:108] 8 10 12 14 8 10 12 14 8 10 ... #&gt; $ y : num [1:108] 21 20 21.5 23 21 21.5 24 25.5 20.5 24 ... #&gt; $ agefac: num [1:108] 8 10 12 14 8 10 12 14 8 10 ... A rio csomag univerzális állománykiíró függvénye az export(). Szintén a kiírandó állomány kiterjesztése dönti el, hogy pontosan melyik konkrét függvényt fogja működtetni az export(), ennek megfelelően a háttérben lévő függvény argumentumaival esetlegesen mi is bővíthetjük az export() argumentumlistáját. A következő példákban pontosvesszővel tagolt, SPSS, SAS, XLSX és RDS adatállományokat hozunk létre: export(x = d.df, file = &quot;output/adat/rio_out.csv&quot;, dec=&quot;,&quot;, sep=&quot;;&quot;) # CSV export(x = d.df, file = &quot;output/adat/rio_out.sav&quot;) # SPSS export(x = d.df, file = &quot;output/adat/rio_out.sas7bdat&quot;) # SAS export(x = d.df, file = &quot;output/adat/rio_out.xlsx&quot;) # Excel export(x = d.df, file = &quot;output/adat/rio_out.ods&quot;) # LibreOffice Calc export(x = d.df, file = &quot;output/adat/rio_out.RDS&quot;) # RDS 6.3.4 Adatok csomagokban Az adatelemzési munkánk R-ben az adattáblák létrehozásával kezdődik. Az adatokat külső adatállományból többféle módszerrel beolvashatjuk, illetve inline módon is létrehozhatjuk (lásd @ref(#beolvas-alapveto) fejezet). Azonban számos csomag tartalmaz saját adattáblát, amelyeket használhatunk az R megismerése során is. A csomagokban elérhető adattáblák nevét és rövid leírását a data() függvény segítségével ismerhetjük meg. data(package=&quot;MASS&quot;) # a MASS csomagban lévő adattáblák data() # betöltött csomagokban lévő adattáblák data(package = .packages(all.available = TRUE)) # a telepített csomagokban lévő adattáblák Amennyiben egy adattáblára szükségünk van egy csomagból, akkor a csomag betöltése nélkül is elérhetjük az adattáblát: data(survey, package=&quot;MASS&quot;) head(survey) #&gt; Sex Wr.Hnd NW.Hnd W.Hnd Fold Pulse Clap Exer Smoke Height M.I #&gt; 1 Female 18.5 18.0 Right R on L 92 Left Some Never 173.0 Metric #&gt; 2 Male 19.5 20.5 Left R on L 104 Left None Regul 177.8 Imperial #&gt; 3 Male 18.0 13.3 Right L on R 87 Neither None Occas NA &lt;NA&gt; #&gt; 4 Male 18.8 18.9 Right R on L NA Neither None Never 160.0 Metric #&gt; 5 Male 20.0 20.0 Right Neither 35 Right Some Never 165.0 Metric #&gt; 6 Female 18.0 17.7 Right L on R 64 Right Some Never 172.7 Imperial #&gt; Age #&gt; 1 18.25 #&gt; 2 17.58 #&gt; 3 16.92 #&gt; 4 20.33 #&gt; 5 23.67 #&gt; 6 21.00 A szokásos eljárás azonban a csomag betöltése, amely után az adattábla nevét szabadon használhatjuk: library(tidyr) smiths #&gt; # A tibble: 2 × 5 #&gt; subject time age weight height #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 John Smith 1 33 90 1.87 #&gt; 2 Mary Smith 1 NA NA 1.54 Ha az adattábla részletesebb leírására vagyunk kíváncsiak egy betöltött csomagból, akkor a ? operátort vagy a help() függvényt is használhatjuk: ?survey # a survey leírása (MASS be van töltve) help(topic = &quot;smiths&quot;) # a smiths leírása (tidyr be van töltve) help(smiths, package=&quot;tidyr&quot;) # a smiths leírása (tidyr nincs betöltve) 6.3.5 Fix széles mezők Ritkábban szükség lehet fix széles mezőket tartalmazó szöveges állományok beolvasására is. A read.fwf() (Alap R) és read_fwf() (Tidyverse R) függvények gondoskodnak arról, hogy az egyes mezőkben lévő adatokat úgy tudjuk azonosítani, hogy az állományban minden sorban azonos, rögzített szélességükkel hivatkozunk rájuk. Tekintsük a következő fix mezőszélességekkel rendelkező állományt: nev;telefon;kor Ági+3630459785921,2 Zoltán+3630459785942,4 Bea+3630459785938,6 Az állomány tartalmaz egy fejlécsort, ami az oszlopok elnevezését segíti, és most pontosvesszővel tagolt. Ez a sor még nem tartozik a fix széles adatmezőkhöz. A következő három sorban azonban 7 pozíción a nevet, 12 pozíción a telefonszámot, 3 pozíción az egy tizedesre pontos életkort soroljuk fel. Ideiglenesen hozzuk létre ezt az állományt magunk is a cat() függvénnyel. A tempfile() függvényt használjuk egy a rendszerünkben érvényes ideiglenes állomány nevének meghatározására. A cat() függvénnyel egy 4 soros szöveges állományt hozunk létre. Az első sor pontosvesszővel elválasztott oszlopneveket tartalmaz, a következő három sor pedig 3 fix széles adatmezőt. file &lt;- tempfile() # ideiglenes állománynév cat(file = file, &quot;nev;telefon;kor&quot;, &quot; Ági+3630459785921,2&quot;, &quot; Zoltán+3630459785942,4&quot;, &quot; Bea+3630459785938,6&quot;, sep=&quot;\\n&quot;) A beolvasást az Alap R read.fwf() függvényével végezzük el először. A width= paraméterében kell megadnunk az egyes mezők hosszát. A függvény a megadott mezőhossz értékek alapján egy ideiglenes, tabulátorral elválasztott szöveges állományt hoz létre, amely a read.table() függvénnyel kerül ténylegesen feldolgozásra. A header=TRUE paraméterrel jelezzük, hogy az első sor oszlopneveket tartalmaz, a sep= paraméter pedig az első sorban használt elválasztó karaktert jelöli. A sep= paraméterre csak akkor van szükség, ha oszlopneveket tartalmazó sort is be akarunk olvasni. Láthatjuk, hogy a függvény által visszaadott adattábla 3 sort és 3 oszlopot tartalmaz. d.df &lt;- read.fwf(file = file, widths=c(7,12,4), header=T, sep=&quot;;&quot;, dec=&quot;,&quot;, colClasses=c(&quot;character&quot;, &quot;character&quot;, &quot;double&quot;), fileEncoding = &quot;UTF-8&quot;) d.df #&gt; nev telefon kor #&gt; 1 Ági +36304597859 21.2 #&gt; 2 Zoltán +36304597859 42.4 #&gt; 3 Bea +36304597859 38.6 A Tidyverse R read_fwf() függvénye nagyon hasonlóan működik. Nem támogatja az oszlopnevek kiolvasását az állományból, így az első sort átlépjük (skip=1) és az oszlopneveket a col_names= argumentumban soroljuk fel, a szélességek megadására használt fwf_width() függvényben. Az oszlopok típusát itt is megadjuk a col_types= argumentumban. library(tidyverse) d.tbl &lt;- read_fwf(file = file, skip=1, col_positions = fwf_widths(widths = c(7, 12, 4), col_names = c(&quot;nev&quot;, &quot;telefon&quot;, &quot;kor&quot;)), locale=locale(decimal_mark=&quot;,&quot;, encoding = &quot;UTF-8&quot;), col_types = &quot;ccd&quot;) d.tbl #&gt; # A tibble: 3 × 3 #&gt; nev telefon kor #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Ág i+3630459785 921 #&gt; 2 Zoltá n+3630459785 942 #&gt; 3 Bea +36304597859 38.6 6.3.6 Összefoglalás asdasd 6.3.7 Feladatok 1 A cat() függvénnyel a dput()-hoz hasonlóan szöveges állományba írhatjuk egy karakteres, numerikus vagy logikai vektor értékét. Mindkét függvénnyel végezzük el a kiírást, és vessük össze a kapott szöveges állományok tartalmát! 1. A Kaggle egyik adatbázisában 4000 videójáték értékelése található. Töltsük le a CSV adatállományt, és nyissuk meg. Keressük meg az R-bloggers oldalon az adatállományhoz kapcsolódó cikket, és próbáljunk ki néhány elemző parancsot. A blogger melyik csomag, melyik függvényével végezte a beolvasást? 1. Keressük fel és tanulmányozzuk a Great R packages for data import, wrangling and visualization oldalt! A bevezetésben lefektetett alapelvek közül melyiket erősíti meg ez az oldal? 1. Töltsünk le 10 érdekesnek tűnő adatállományt a 19 Places to Find Free Data Sets for Data Science Projects oldalról, és nyissuk meg őket! A fenti feladatok megoldása "],["adatmanipulacio.html", "7 Adatmanipuláció 7.1 Adatkezelés az Alap R-ben 7.2 Adatkezelés Tidyverse R-ben 7.3 Haladó adatkezelés", " 7 Adatmanipuláció 7.1 Adatkezelés az Alap R-ben Ebben a fejezetben: Ebben a fejezetben az adattáblák manipulációját tekintjük át, melyek az adatkezelés szempontjából a legfontosabb R objektumok. Mint korábban láttuk, a mátrixhoz hasonlóan sorokat és oszlopokat tartalmaz, illetve a listához hasonlóan elemekből, méghozzá azonos hosszúságú oszlopvektorokból épül fel (5.1. ábra). Az adattábla kettős eredete jelentősen megkönnyíti az ilyen adatok kezelését. Az adattábla sorai egyedekre (személyek, tárgyak, dolgok stb.) vonatkozó megfigyelések, az oszlopok pedig a megfigyelt tulajdonságok. A statisztikához közelebbi fogalmakkal, az adattáblában az adatmátrixunkat/többdimenziós mintánkat rögzíthetjük, a sorok a mintaelemek, az oszlopok a megfigyelt változók. Az adattábla inhomogén adatszerkezet, oszlopai különböző típusú adatokat is tartalmazhatnak. Jellemzően kvalitatív (nominális és ordinális skálán mért) adatok tárolására a faktort használjuk, kvantitatív (intervallum és arányskálán mért) adatok tárolására a numerikus vektort. Természetesen adattáblában karakteres és logikai vektorok is szerepelhetnek, sőt dátumokat és időpontokat is kezelhetünk az adattáblában. 7.1.1 Információ megtekintése Az adatbázis beolvasása (@ref(#beolvasas)) után következik az információk begyűjtése a beolvasott adatokról. A legfontosabb információkérő függvényeket a 7.1 táblázat tartalmazza. Az információ megszerzésének célja az egyszerű tájékozódáson kívül a beolvasás helyességének ellenőrzése: rendelkezésre áll-e a kívánt sor- és oszlopszám, az oszlopnevek rendben vannak-e, a numerikusnak szánt változók valóban számokat tartalmaznak-e és a karakteres oszlopokban az esetleges magyar ékezetek rendben megjelennek-e. TÁBLÁZAT 7.1: Információt kérő függvények Függvény Leírás Példa str(object) szerkezet kiírása str(df) dim(x) x dimenziói dim(df) nrow(x) x sorainak száma nrow(df) ncol(x) x oszlopainak száma ncol(df) names(x) x elemeinek neve names(df) colnames(x) x oszlopnevei colnames(df) rownames(x) x sornevei rownames(df) head(x,n=6) x első sorai head(df) tail(x,n=6) x utolsó sorai tail(df) View(x) x teljes tartalma View(df) class(x) x típusa class(df);class(df$oszlop) length(x) x hossza length(df);length(df$oszlop) unique(x) x különböző értékei unique(df$oszlop) table(…,useNA) gyakorisági tábla table(df$oszlop,useNA=‘ifany’) summary(object) leíró adatok summary(df);summary(df$oszlop) Az adatelemzési munkánk során a beolvasás előtt már sok ismeretünk összegyűlt az adatbázisról, de most tegyünk úgy, mintha egy ismeretlen flow.xlsx adatbázist kellene felfedeznünk. flow &lt;- rio::import(file = &quot;adat/flow.xlsx&quot;) # beolvasás str(flow) # a teljes szerkezet #&gt; &#39;data.frame&#39;: 100 obs. of 25 variables: #&gt; $ alkatoi.tev : chr &quot;Igen&quot; &quot;Igen&quot; &quot;Nem&quot; &quot;Nem&quot; ... #&gt; $ kor : num 26 20 22 21 21 25 53 21 22 21 ... #&gt; $ nem : chr &quot;Férfi&quot; &quot;Nő&quot; &quot;Nő&quot; &quot;Férfi&quot; ... #&gt; $ csaladi.allapot: chr &quot;Egyedülálló&quot; &quot;Egyedülálló&quot; &quot;Élettársi kapcsolatban él&quot; &quot;Egyedülálló&quot; ... #&gt; $ isk.vegz : chr &quot;Egyetem&quot; &quot;Gimnázium&quot; &quot;Gimnázium&quot; &quot;Gimnázium&quot; ... #&gt; $ flow.1 : num 2 4 4 3 5 5 5 4 5 5 ... #&gt; $ flow.2 : num 4 4 4 4 5 5 5 4 4 5 ... #&gt; $ flow.3 : num 5 5 3 3 5 5 3 4 4 5 ... #&gt; $ flow.4 : num 5 5 4 4 2 5 3 4 5 5 ... #&gt; $ flow.5 : num 5 5 5 3 3 5 5 5 5 5 ... #&gt; $ flow.6 : num 1 4 2 3 4 1 3 2 2 4 ... #&gt; $ flow.7 : num 2 4 1 4 4 3 5 3 5 5 ... #&gt; $ flow.8 : num 4 5 4 4 4 5 4 4 5 5 ... #&gt; $ flow.9 : num 5 5 3 4 5 5 3 4 5 5 ... #&gt; $ flow.10 : num 4 5 4 3 5 5 5 4 4 5 ... #&gt; $ flow.11 : num 4 5 2 3 5 5 3 3 5 5 ... #&gt; $ flow.12 : num 4 4 1 3 4 5 5 4 5 5 ... #&gt; $ flow.13 : num 5 4 2 4 5 3 5 4 5 5 ... #&gt; $ flow.14 : num 3 4 2 4 5 5 3 3 5 5 ... #&gt; $ flow.15 : num 3 5 3 4 4 5 5 4 5 5 ... #&gt; $ flow.16 : num 3 3 3 3 4 2 4 2 3 5 ... #&gt; $ flow.17 : num 4 5 3 4 3 2 4 4 5 5 ... #&gt; $ flow.18 : num 5 5 4 4 2 5 5 5 5 5 ... #&gt; $ flow.19 : num 4 5 4 2 5 5 5 2 5 5 ... #&gt; $ flow.20 : num 3 4 1 2 4 5 1 2 3 5 ... class(flow) # típus #&gt; [1] &quot;data.frame&quot; dim(flow) # sor- és oszlopszám #&gt; [1] 100 25 A fenti sorok után világossá válik, hogy egy 100 sort és 25 oszlopot tartalmazó adattábla (data frame) áll rendelkezésre. Az oszlopnevek a names() és a colnames() függvényekkel is megismerhetők names(flow)[1:4] # az első 4 oszlop neve #&gt; [1] &quot;alkatoi.tev&quot; &quot;kor&quot; &quot;nem&quot; &quot;csaladi.allapot&quot; colnames(flow)[5:8] # a következő 4 oszlop neve #&gt; [1] &quot;isk.vegz&quot; &quot;flow.1&quot; &quot;flow.2&quot; &quot;flow.3&quot; Az oszlopnevek viszonylag beszédesek, de jobban is megismerhetjük ezeket a változókat. class(flow$alkatoi.tev) # az alkotoi.tev változó típusa #&gt; [1] &quot;character&quot; unique(flow$alkatoi.tev) # egyedi értékei #&gt; [1] &quot;Igen&quot; &quot;Nem&quot; table(flow$alkatoi.tev, useNA = &quot;ifany&quot;) # gyakorisági táblázata #&gt; #&gt; Igen Nem #&gt; 39 61 class(flow$kor) # a kor változó típusa #&gt; [1] &quot;numeric&quot; table(flow$kor, useNA = &quot;ifany&quot;) # gyakorisági táblázata #&gt; #&gt; 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 36 39 40 42 43 45 50 51 52 53 #&gt; 1 2 2 4 22 18 4 4 3 5 4 1 2 1 1 1 1 1 2 1 1 3 3 4 5 3 #&gt; 69 #&gt; 1 Az adatbázis tetszőleges részét megjeleníthetjük a konzolban a szokásos indexelés segítségével: d.df[sorindex, oszlopindex] Például 4 sorból az első 5 oszlopot így tekinthetjük meg: flow[c(1:2, 50:51), 1:5] #&gt; alkatoi.tev kor nem csaladi.allapot isk.vegz #&gt; 1 Igen 26 Férfi Egyedülálló Egyetem #&gt; 2 Igen 20 Nő Egyedülálló Gimnázium #&gt; 50 Nem 22 Nő Egyedülálló Gimnázium #&gt; 51 Igen 39 Nő Házas Egyetem Ne feledjük, hogy az RStudio-ban az Environment fülön is megjelenik a flow adatbázis a sikeres beolvasás után. Kattintva a neven a teljes adatbázist áttekinthetjük a bal felső részben (ezt a View(flow) paranccsal is kezdeményezhetjük), de a flow előtti ikonon kattintva megjeleníthetjük az adatbázis str()-ból ismert szerkezete is. További kényelmi lehetőség, ha a tibble típus kényelmes megjelenítését is kihasználjuk. Ehhez konvertáljuk át az adattáblánkat tibble típusúvá, és egyszerűen jelenítsük meg az objektumot: library(tidyverse) flow.tbl &lt;- as_tibble(flow) # tibble típusú adatbázis létrehozása flow.tbl # kényelmes megjelenítés #&gt; # A tibble: 100 × 25 #&gt; alkatoi.tev kor nem csaladi.allapot isk.vegz flow.1 flow.2 flow.3 flow.4 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Igen 26 Férfi Egyedülálló Egyetem 2 4 5 5 #&gt; 2 Igen 20 Nő Egyedülálló Gimnázi… 4 4 5 5 #&gt; 3 Nem 22 Nő Élettársi kapcs… Gimnázi… 4 4 3 4 #&gt; 4 Nem 21 Férfi Egyedülálló Gimnázi… 3 4 3 4 #&gt; 5 Igen 21 Nő Egyedülálló Gimnázi… 5 5 5 2 #&gt; 6 Igen 25 Nő Elvált Egyetem 5 5 5 5 #&gt; 7 Nem 53 Nő Özvegy Gimnázi… 5 5 3 3 #&gt; 8 Nem 21 Nő Egyedülálló Gimnázi… 4 4 4 4 #&gt; 9 Nem 22 Nő Élettársi kapcs… Gimnázi… 5 4 4 5 #&gt; 10 Nem 21 Nő Egyedülálló Gimnázi… 5 5 5 5 #&gt; # … with 90 more rows, and 16 more variables: flow.5 &lt;dbl&gt;, flow.6 &lt;dbl&gt;, #&gt; # flow.7 &lt;dbl&gt;, flow.8 &lt;dbl&gt;, flow.9 &lt;dbl&gt;, flow.10 &lt;dbl&gt;, flow.11 &lt;dbl&gt;, #&gt; # flow.12 &lt;dbl&gt;, flow.13 &lt;dbl&gt;, flow.14 &lt;dbl&gt;, flow.15 &lt;dbl&gt;, flow.16 &lt;dbl&gt;, #&gt; # flow.17 &lt;dbl&gt;, flow.18 &lt;dbl&gt;, flow.19 &lt;dbl&gt;, flow.20 &lt;dbl&gt; 7.1.2 Oszlopok kezelése 7.1.2.1 Oszlopnevek módosítása A sikeres beolvasás és a szükséges tájékozódás után az oszlopnevek áttekintése és esetleges módosítása a következő lépés. Ez kulcsfontosságú a további munka szempontjából, ugyanis a jól megválasztott változónevek jelentősen meggyorsíthatják a további munkát, és fordítva, a kevésbe beszédes, következetlen, a túl rövid vagy túl hosszú változónevek akadályozhatják a sikeres adatelemzést. A változónevek mindig legyenek beszédesek, csak az angol ábécé kisbetűit és számjegyeket használjunk, több részből álló neveket aláhúzással (_) esetleg ponttal (.) tagoljuk (R kódolási stílus). Egy adattábla oszlopait a names() vagy colnames(), a sorait a rownames() függvény használatával kérdezhetjük le és nevezhetjük át. A sornevek egymástól különböző, karakteres vagy numerikus egész értékek lehetnek, míg az oszlopnevek csak karakteres adatok. Az oszlopnevek módosításának több oka lehet. Példánkban magyar változónevekre váltunk, de sokszor rövidítjük vagy beszédesebbé tesszük az oszlopaink nevét. bandak &lt;- rio::import(file = &quot;adat/metal_bandak.xlsx&quot;) bandak #&gt; banda fan formed split origin #&gt; 1 Kiuas 106 2000 2013 Finnország #&gt; 2 Accept 681 1968 &lt;NA&gt; Németország #&gt; 3 Metallica 4122 1981 &lt;NA&gt; USA #&gt; 4 Zonata 23 1998 2003 Svédország #&gt; 5 Therion 1266 1987 &lt;NA&gt; Svédország names(bandak) # az összes oszlop neve #&gt; [1] &quot;banda&quot; &quot;fan&quot; &quot;formed&quot; &quot;split&quot; &quot;origin&quot; names(bandak)[2] &lt;- &quot;rajongo&quot; # 2. oszlop nevének átírása names(bandak)[3:5] &lt;- c(&quot;alakulas&quot;,&quot;felbomlas&quot;,&quot;orszag&quot;) # 3-5. oszlopok átnevezése names(bandak)[names(bandak)==&quot;banda&quot;] &lt;- &quot;nev&quot; # a &quot;banda&quot; nevű oszlop átnevezése bandak #&gt; nev rajongo alakulas felbomlas orszag #&gt; 1 Kiuas 106 2000 2013 Finnország #&gt; 2 Accept 681 1968 &lt;NA&gt; Németország #&gt; 3 Metallica 4122 1981 &lt;NA&gt; USA #&gt; 4 Zonata 23 1998 2003 Svédország #&gt; 5 Therion 1266 1987 &lt;NA&gt; Svédország 7.1.2.2 Oszlop indexelése Az Alap R-ben az oszlopok indexelése a [ vagy [[ operátor segítségével történhet. Mivel az adattáblák örökölték a kétdimenziós mátrix és az egydimenziós lista adatszerkezet indexelési lehetőségeit, így az oszlopokra négyféle módon hivatkozhatunk: adattábla[,oszlopindex] # hivatkozás egy vagy több oszlopra adattábla[oszlopindex] # hivatkozás egy vagy több oszlopra adattábla[[oszlopnév]] # hivatkozás egyetlen oszlopra adattábla$oszlopnév # hivatkozás egyetlen oszlopra Az fenti példa első sorában mátrixszerűen, második sorában listaszerűen indexelünk. A továbbiakban a mátrixszerű, azaz vesszőt tartalmazó hivatkozást használjuk. Az oszlopindex lehet numerikus vektor pozitív vagy negatív értékekkel, karakteres vektor, vagy akár logikai vektor is. Ha csak egyetlen oszlopra vagyunk kíváncsiak, akkor a [[ vagy még gyakrabban a $ operátort használjuk az oszlop nevének megadásával. Az oszlopok elérése mindennapos a statisztikai munka során, így ezeket az indexelési formákat ismernünk kell. mean(flow$kor, na.rm=T) # kor átlaga #&gt; [1] 29.26 summary(flow[c(&quot;kor&quot;, &quot;flow.1&quot;)]) # kor és flow.1 leíró statisztikai adatai #&gt; kor flow.1 #&gt; Min. :17.0 Min. :1.00 #&gt; 1st Qu.:21.0 1st Qu.:3.00 #&gt; Median :23.0 Median :4.00 #&gt; Mean :29.3 Mean :4.01 #&gt; 3rd Qu.:33.0 3rd Qu.:5.00 #&gt; Max. :69.0 Max. :5.00 # &quot;flow&quot; szót tartalmazó oszlopok száma ncol(flow[grepl(pattern = &quot;flow&quot;, names(flow))]) #&gt; [1] 20 Ne feledjük, hogy mátrixszerű indexelés során is kaphatunk egydimenziós eredményt, hiszen ha egyetlen oszlopra hivatkozunk, akkor a [ operátor automatikusan az egydimenziós vektorra vált a kétdimenziós adattábla helyett. Ezt a drop=F használatával akadályozhatjuk meg. flow[1:3, c(&quot;kor&quot;, &quot;nem&quot;)] # két oszlop, nincs dimenzióvesztés #&gt; kor nem #&gt; 1 26 Férfi #&gt; 2 20 Nő #&gt; 3 22 Nő flow[1:3, &quot;kor&quot;] # egy oszlop, dimenzióvesztés #&gt; [1] 26 20 22 flow[1:3, &quot;kor&quot;, drop=F] # egy oszlop, nincs dimenzióvesztés #&gt; kor #&gt; 1 26 #&gt; 2 20 #&gt; 3 22 7.1.2.3 Oszlopok sorrendje Ha már jól ismerjük az oszlopok indexelését, akkor számos további műveletre nyílik lehetőség. Ezek közül a legegyszerűbb az oszlopok sorrendjének megváltoztatása. Ha az oszlopindex hivatkozásai az eredeti oszlopsorrendtől eltérnek, akkor máris új oszlopsorrendet határoztunk meg. # a korábbi 1. oszlop (alkotoi.tev) átkerül a 3. oszlopba flow &lt;- flow[, c(2, 3, 1, 4:25)] flow[1:2, 1:3] #&gt; kor nem alkatoi.tev #&gt; 1 26 Férfi Igen #&gt; 2 20 Nő Igen Természetesen oszlopsorszámok helyett változóneveket is használhatunk. bandak #&gt; nev rajongo alakulas felbomlas orszag #&gt; 1 Kiuas 106 2000 2013 Finnország #&gt; 2 Accept 681 1968 &lt;NA&gt; Németország #&gt; 3 Metallica 4122 1981 &lt;NA&gt; USA #&gt; 4 Zonata 23 1998 2003 Svédország #&gt; 5 Therion 1266 1987 &lt;NA&gt; Svédország # a rajongo oszlop a végére kerül bandak &lt;- bandak[,c(&quot;nev&quot;, &quot;alakulas&quot;, &quot;felbomlas&quot;, &quot;orszag&quot;, &quot;rajongo&quot;)] bandak #&gt; nev alakulas felbomlas orszag rajongo #&gt; 1 Kiuas 2000 2013 Finnország 106 #&gt; 2 Accept 1968 &lt;NA&gt; Németország 681 #&gt; 3 Metallica 1981 &lt;NA&gt; USA 4122 #&gt; 4 Zonata 1998 2003 Svédország 23 #&gt; 5 Therion 1987 &lt;NA&gt; Svédország 1266 7.1.2.4 Oszlopok létrehozása és törlése Láttuk korábban, hogy a cbind() segítségével oszlopokat adhatunk a meglévő adatbázisunkhoz. Például a meglévő bandak adatbázishoz adjunk hozzá egy kétoszlopos új adatbázist, amely a bandák Wikipédia oldalának címét, és egy szubjektív rangsort tartalmaz. bandak.kieg &lt;- data.frame(wikipedia=c(&quot;https://en.wikipedia.org/wiki/Kiuas&quot;, &quot;https://hu.wikipedia.org/wiki/Accept&quot;, &quot;https://hu.wikipedia.org/wiki/Metallica&quot;, &quot;https://en.wikipedia.org/wiki/Zonata&quot;, &quot;https://en.wikipedia.org/wiki/Therion_(band)&quot;), rangsor=c(2,4,1,3,5)) bandak.2 &lt;- cbind(bandak, bandak.kieg) str(bandak.2) Egyetlen oszlop beszúrására is van lehetőségünk, és hasonlóan törölhetünk egyetlen oszlopot is: adattábla$új.oszlopnév # új oszlop beszúrása a dataframe végére adattábla$oszlopnév &lt;- NULL # oszlop törlése Szúrjuk be a rangsor változót az eredeti bandak adatbázisba, majd távolítsuk el. bandak$rangsor &lt;- c(2,4,1,3,5) # új oszlop beszúrása bandak$rangsor &lt;- NULL # oszlop törlése 7.1.2.5 Típuskonverzió Az oszlopok nevének és sorrendjének optimális beállítása után meg kell vizsgálnunk, hogy az oszlopaink típusa megfelel-e az általa reprezentált statisztikai változók mérési skálájának. Nem léphetünk tovább az elemzés felé, amíg ez az összefüggés nem teljesül. Változó mérési skálája R típus nominális faktor ordinális faktor (rendezett) intervallum numerikus vektor arány numerikus vektor Cél mérési skála Típuskonverzió R függvény nominális numerikusból faktor karakteresből faktor factor(x) ordinális numerikusból faktor (rendezett) karakteresből faktor (rendezett) ordered(x) intervallum arány karakteresből numerikus faktorból numerikus as.numeric(x) as.numeric(as.character(x)) A típuskonverzió két leggyakoribb esetével foglalkozunk itt. Az egyik faktorrá konvertálás teszi a típuskonverziók legnagyobb részét. Ezt a factor() függvénnyel végezzük el. A kiinduló változónk lehet numerikus vagy karakteres. factor(c(1, 1, 2, 1, 1, 1, 2)) #&gt; [1] 1 1 2 1 1 1 2 #&gt; Levels: 1 2 factor(c(&quot;Dohányzik&quot;, &quot;Dohányzik&quot;, &quot;Nem dohányzik&quot;)) #&gt; [1] Dohányzik Dohányzik Nem dohányzik #&gt; Levels: Dohányzik Nem dohányzik Mindkét esetben előfordulhat, hogy a kiinduló változóban lévő egyedi numerikus értékek A numerikus típuskonverzió kevésbé gyakori, de előfordulhat. Például kor &lt;- c(44, 39, &quot;55 év&quot;, 38) kor[3] &lt;- &quot;55&quot; as.numeric(kor) #&gt; [1] 44 39 55 38 7.1.2.6 Transzformáció Számos esetben szükség lehet az adattábla oszlopaiban lévő értéke átalakítására (transzformálására). Az értékeket vagy helyben (ugyanabban az oszlopban) változtatjuk meg, vagy új oszlopként szúrjuk be az adattáblába. Adatok transzformálásához tekintsük a women adattáblát, amely a weight változójában font-ban mért értékeket tartalmaz. Ezt alakítsuk át kg-ban mért adatokká egy új oszlopban: data(women); women #&gt; height weight #&gt; 1 58 115 #&gt; 2 59 117 #&gt; 3 60 120 #&gt; 4 61 123 #&gt; 5 62 126 #&gt; 6 63 129 #&gt; 7 64 132 #&gt; 8 65 135 #&gt; 9 66 139 #&gt; 10 67 142 #&gt; 11 68 146 #&gt; 12 69 150 #&gt; 13 70 154 #&gt; 14 71 159 #&gt; 15 72 164 women$suly&lt;-round(women$weight*0.45) women #&gt; height weight suly #&gt; 1 58 115 52 #&gt; 2 59 117 53 #&gt; 3 60 120 54 #&gt; 4 61 123 55 #&gt; 5 62 126 57 #&gt; 6 63 129 58 #&gt; 7 64 132 59 #&gt; 8 65 135 61 #&gt; 9 66 139 63 #&gt; 10 67 142 64 #&gt; 11 68 146 66 #&gt; 12 69 150 68 #&gt; 13 70 154 69 #&gt; 14 71 159 72 #&gt; 15 72 164 74 Ugyanezt az eredményt a transform() függvény segítségével is elérhetjük, ahol a subset()-hez hasonlóan némileg egyszerűbben hivatkozhatunk az adattábla változóira. Most alakítsuk át height változót inch-ről cm-re. transform(women, magassag=round(height*2.45)) #&gt; height weight suly magassag #&gt; 1 58 115 52 142 #&gt; 2 59 117 53 145 #&gt; 3 60 120 54 147 #&gt; 4 61 123 55 149 #&gt; 5 62 126 57 152 #&gt; 6 63 129 58 154 #&gt; 7 64 132 59 157 #&gt; 8 65 135 61 159 #&gt; 9 66 139 63 162 #&gt; 10 67 142 64 164 #&gt; 11 68 146 66 167 #&gt; 12 69 150 68 169 #&gt; 13 70 154 69 172 #&gt; 14 71 159 72 174 #&gt; 15 72 164 74 176 Amennyiben a fenti példákban nem új változónevek az átalakítás célpontjai, hanem már létező oszlopok, akkor helyben végezzük a transzformációt: transform(women, height=height-10) #&gt; height weight suly #&gt; 1 48 115 52 #&gt; 2 49 117 53 #&gt; 3 50 120 54 #&gt; 4 51 123 55 #&gt; 5 52 126 57 #&gt; 6 53 129 58 #&gt; 7 54 132 59 #&gt; 8 55 135 61 #&gt; 9 56 139 63 #&gt; 10 57 142 64 #&gt; 11 58 146 66 #&gt; 12 59 150 68 #&gt; 13 60 154 69 #&gt; 14 61 159 72 #&gt; 15 62 164 74 A változók átalakításának másik gyakori esete, amikor az eredetileg folytonos változót kategórikus változóvá alakítjuk. A cut() függvény segítségével numerikus vektorból faktort állíthatunk elő. cut(1:10,3) #&gt; [1] (0.991,4] (0.991,4] (0.991,4] (0.991,4] (4,7] (4,7] (4,7] #&gt; [8] (7,10] (7,10] (7,10] #&gt; Levels: (0.991,4] (4,7] (7,10] A fenti példában a 10 elemű bemenő vektortból 3 szintű faktort hoztunk létre. Ha az intervallumok határát magunk szeretnénk megadni, akkor a második (breaks) argumentumban egy vektort kell megadnunk: cut(1:10,breaks=c(0,2,10)) #&gt; [1] (0,2] (0,2] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] #&gt; Levels: (0,2] (2,10] A létrejövő faktor szintjei az intervallumok leírásaiból állnak, természetesen ezeket megvaáltoztathatjuk, csak a labels= paramétert kell használnunk: cut(1:10,breaks=c(0,2,7,10),label=c(&quot;gyenge&quot;,&quot;közepes&quot;,&quot;erős&quot;)) #&gt; [1] gyenge gyenge közepes közepes közepes közepes közepes erős erős #&gt; [10] erős #&gt; Levels: gyenge közepes erős Adattáblák esetében a cut() függvény használatára láthatunk egy példát: transform(women,height=cut(height,breaks=c(0,60,70,100),labels=c(&quot;alacsony&quot;,&quot;közepes&quot;,&quot;magas&quot;))) #&gt; height weight suly #&gt; 1 alacsony 115 52 #&gt; 2 alacsony 117 53 #&gt; 3 alacsony 120 54 #&gt; 4 közepes 123 55 #&gt; 5 közepes 126 57 #&gt; 6 közepes 129 58 #&gt; 7 közepes 132 59 #&gt; 8 közepes 135 61 #&gt; 9 közepes 139 63 #&gt; 10 közepes 142 64 #&gt; 11 közepes 146 66 #&gt; 12 közepes 150 68 #&gt; 13 közepes 154 69 #&gt; 14 magas 159 72 #&gt; 15 magas 164 74 car csomag recode() függvénye 7.1.2.7 Faktor változó összefoglalás 7.1.2.8 Numerikus változó összefoglalás 7.1.3 Sorok kezelése Sokszor előfordul, hogy egy adattábla valamely változójának értékeivel szeretnénk a sorokat elnevezni, illetve fordítva, az adattábla sorneveit oszlopvektorban szeretnénk látni. A fivethirtyeight csomag unisex_names adattáblája adattábla állományból történő beolvasása során a read.table() függvényben a ”row.names=n” argumentum megadásával a szöveges állomány n. oszlopából nyerjük a sorok neveit. Az mtcars adattábla sorneveit a következő parancs segítségével vihetjük be változóba: data(unisex_names, package = &quot;fivethirtyeight&quot;) head(unisex_names) #&gt; # A tibble: 6 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 #&gt; 4 Jackie 132929. 0.421 0.579 0.158 #&gt; 5 Avery 121797. 0.335 0.665 0.330 #&gt; 6 Jaime 109870. 0.562 0.438 0.124 rownames(unisex_names) &lt;- unisex_names$name head(unisex_names) #&gt; # A tibble: 6 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 #&gt; 4 Jackie 132929. 0.421 0.579 0.158 #&gt; 5 Avery 121797. 0.335 0.665 0.330 #&gt; 6 Jaime 109870. 0.562 0.438 0.124 mtcars2&lt;-data.frame(name=rownames(mtcars),mtcars,row.names=1:32) mtcars2[1:10,] #&gt; name mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; 2 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; 5 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; 6 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; 7 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; 8 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; 9 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; 10 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 A fordított irányhoz a következő parancsot kell használnunk: mtcars3&lt;-mtcars2 # új adattábla rownames(mtcars3)&lt;-mtcars3$name # sornevek meghatározása mtcars3&lt;-mtcars3[2:11] # a felesleges első oszlop törlése mtcars3[1:10,] #&gt; mpg cyl disp hp drat wt qsec vs am gear #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 7.1.3.1 Rendezés A vektorok rendezésénél már megismertük az order() függvényt (3.1.8. fejezet), amelyet adattáblák rendezésére is használhatunk. Az mtcars adattábla sorait a fogyasztási adatok (mpg változó) alapján növekvő sorrendbe rendezhetjük, ha a sorok indexelésére az order() függvény visszatérési értékét használjuk: order(mtcars$mpg) #&gt; [1] 15 16 24 7 17 31 14 23 22 29 12 13 11 6 5 10 25 30 1 2 4 32 21 3 9 #&gt; [26] 8 27 26 19 28 18 20 A fenti indexeket a sorkoordináta helyére írva, megkapjuk a rendezett adattáblát (helytakarékosságból az első 10 sorát írjuk ki): mtcars[order(mtcars$mpg)[1:10],] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Rendezési szempontnak a sorneveket is használhatjuk: mtcars[order(rownames(mtcars))[1:10],] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Rendezésnél egynél több változót is figyelembe vehetünk, ekkor az order() függvényben több változónevet kell felsorolnunk vesszővel elválasztva: mtcars[order(mtcars$mpg,mtcars$disp)[1:10],c(&quot;mpg&quot;,&quot;disp&quot;)] #&gt; mpg disp #&gt; Lincoln Continental 10.4 460.0 #&gt; Cadillac Fleetwood 10.4 472.0 #&gt; Camaro Z28 13.3 350.0 #&gt; Duster 360 14.3 360.0 #&gt; Chrysler Imperial 14.7 440.0 #&gt; Maserati Bora 15.0 301.0 #&gt; Merc 450SLC 15.2 275.8 #&gt; AMC Javelin 15.2 304.0 #&gt; Dodge Challenger 15.5 318.0 #&gt; Ford Pantera L 15.8 351.0 Csökkenő sorrendű rendezéshez használhatjuk az order() függvény ”decreasing=TRUE” argumentumát, vagy a rev() függvényt. Több rendezési szempont esetén ha keverni szeretnénk a rendezési irányokatt, akkor numerikus oszlopvektorok előtt a mínusz (-) jellel fordíthatjuk meg a rendezés irányát csökkenőre. mtcars[order(mtcars$mpg,-mtcars$disp)[1:10],c(&quot;mpg&quot;,&quot;disp&quot;)] #&gt; mpg disp #&gt; Cadillac Fleetwood 10.4 472.0 #&gt; Lincoln Continental 10.4 460.0 #&gt; Camaro Z28 13.3 350.0 #&gt; Duster 360 14.3 360.0 #&gt; Chrysler Imperial 14.7 440.0 #&gt; Maserati Bora 15.0 301.0 #&gt; AMC Javelin 15.2 304.0 #&gt; Merc 450SLC 15.2 275.8 #&gt; Dodge Challenger 15.5 318.0 #&gt; Ford Pantera L 15.8 351.0 7.1.4 Adattábla szűrése Sokszor előfordul, hogy az adattábla sorait egy vagy több változó (oszlop) értéke szerint szeretnénk leválogatni. Az adattábla indexelése során a sorkoordináta helyén logikai kifejezést szerepeltetünk. Ha például le szeretnénk kérdezni, azokat a sorokat, amelyekben a fogyásztás értéke kisebb mint 15 mérföld/gallon, akkor a következő logikai kifejezést használhatjuk: mtcars$mpg&lt;15 #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE #&gt; [13] FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE #&gt; [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE A fenti logikai vekorban pontosan azokban a pozíciókban szerepel TRUE érték, amelyik sorban fogyásztás értéke kisebb mint 15 mérföld/gallon. Ha ezt szerpeltetjük a sorkoordináta helyén, a kívánt sorokhoz jutunk: mtcars[mtcars$mpg&lt;15,] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 #&gt; Camaro Z28 13.3 8 350 245 3.73 3.840 15.41 0 0 3 4 Több váltózón alapuló feltétel megadásához összetett logikai kifejezést kell írnunk: mtcars[mtcars$mpg&lt;15 &amp; mtcars$disp&gt;400,] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 Adattáblák szűrését egyszerűsíti a subset() függvény, amely az első paraméterében egy adattáblát, második paraméterében pedig a szűrést jelentő logikai kifejezést várja. A fenti szűrés subset() függvény használatával: subset(mtcars, mpg&lt;15 &amp; disp&gt;400) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 A subset() függvény egy select argumentumot is tartalmazhat, melynek sgítségével a szűrés eredményében megjelenő oszlopokat határozhatjuk meg: subset(mtcars, mpg&lt;15 &amp; disp&gt;400, select=c(&quot;mpg&quot;,&quot;disp&quot;)) #&gt; mpg disp #&gt; Cadillac Fleetwood 10.4 472 #&gt; Lincoln Continental 10.4 460 #&gt; Chrysler Imperial 14.7 440 7.1.5 Hiányzó értékeket tatalmazó sorok eltávolítása Az NA értéket is tartalmazó adattáblánkból az na.omit() függvény használatával távolíthatjuk el azokat a sorokat, amelyekben a hiányzó érték előfordul. data(mtcars) mtcars[c(2,5,7),1]&lt;-NA mtcars[1:10,] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag NA 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout NA 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 NA 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 na.omit(mtcars)[1:10,] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 7.1.6 Adattáblák indexelése Az adattáblák indexelésére a mátrixok és listák indexelési eljárásait is használhatjuk. A 3.5. fejezetben már áttekintettük az Alap R lehetőségeit. data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/metacritic_games.csv&quot; library(tidyverse) d.tbl &lt;- read_delim(file = data.file, delim = &quot;,&quot;) d.tbl #&gt; # A tibble: 5,699 × 15 #&gt; game platform developer genre number_players rating release_date #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Portal 2 PC Valve So… Acti… &lt;NA&gt; E10+ Apr 18, 2011 #&gt; 2 The Elder Scroll… PC Bethesda… Role… No Online Mul… M Nov 10, 2011 #&gt; 3 The Legend of Ze… 3DS GREZZO Misc… No Online Mul… E10+ Jun 19, 2011 #&gt; 4 Batman: Arkham C… PC Rockstea… Acti… &lt;NA&gt; T Nov 21, 2011 #&gt; 5 Super Mario 3D L… 3DS Nintendo Acti… No Online Mul… E Nov 13, 2011 #&gt; 6 Deus Ex: Human R… PC Nixxes S… Acti… No Online Mul… M Aug 23, 2011 #&gt; 7 Pushmo 3DS Intellig… Misc… 1 Player E Dec 8, 2011 #&gt; 8 Total War: Shogu… PC Creative… Stra… Online Multip… T Mar 15, 2011 #&gt; 9 FIFA Soccer 12 PC Electron… Spor… &lt;NA&gt; E Sep 27, 2011 #&gt; 10 Battlefield 3 PC EA DICE Acti… &lt;NA&gt; M Oct 25, 2011 #&gt; # … with 5,689 more rows, and 8 more variables: positive_critics &lt;dbl&gt;, #&gt; # neutral_critics &lt;dbl&gt;, negative_critics &lt;dbl&gt;, positive_users &lt;dbl&gt;, #&gt; # neutral_users &lt;dbl&gt;, negative_users &lt;dbl&gt;, metascore &lt;dbl&gt;, #&gt; # user_score &lt;dbl&gt; d.df &lt;- as.data.frame(d.tbl) head(d.df) #&gt; game platform developer #&gt; 1 Portal 2 PC Valve Software #&gt; 2 The Elder Scrolls V: Skyrim PC Bethesda Game Studios #&gt; 3 The Legend of Zelda: Ocarina of Time 3D 3DS GREZZO #&gt; 4 Batman: Arkham City PC Rocksteady Studios #&gt; 5 Super Mario 3D Land 3DS Nintendo #&gt; 6 Deus Ex: Human Revolution PC Nixxes Software #&gt; genre number_players rating release_date positive_critics #&gt; 1 Action &lt;NA&gt; E10+ Apr 18, 2011 51 #&gt; 2 Role-Playing No Online Multiplayer M Nov 10, 2011 32 #&gt; 3 Miscellaneous No Online Multiplayer E10+ Jun 19, 2011 84 #&gt; 4 Action Adventure &lt;NA&gt; T Nov 21, 2011 27 #&gt; 5 Action No Online Multiplayer E Nov 13, 2011 81 #&gt; 6 Action No Online Multiplayer M Aug 23, 2011 52 #&gt; neutral_critics negative_critics positive_users neutral_users negative_users #&gt; 1 1 0 1700 107 19 #&gt; 2 0 0 1616 322 451 #&gt; 3 1 0 283 20 5 #&gt; 4 0 0 240 34 27 #&gt; 5 1 0 251 39 11 #&gt; 6 0 0 520 112 78 #&gt; metascore user_score #&gt; 1 95 90 #&gt; 2 94 82 #&gt; 3 94 90 #&gt; 4 91 87 #&gt; 5 90 84 #&gt; 6 90 85 7.1.7 Válogatás az sorokból A sorok leválogatatása nagyon fontos eszköz a kezünben ahhoz, hogy az elemzésünket a kívánt mintaelemekkel folytathassuk. 7.1.7.1 Sorok indexelése és a szűrés Alap R-ben A sorok indexelésére a [ operátort használhatjuk, a vessző előtti részbe, a sorkoordintátákba írhatunk neumerikus vektort, pozitív és negatív értékekkel, logikai vektort és karakteres vektort, bár ez utóbbi használta nagyon ritkkán fordul elő. A példákhoz a fivethirtyeight csomag unisex_names adattáblájából indulunk ki, amely amerikában használt uniszex neveket tartalmaz. data(&quot;unisex_names&quot;, package = &quot;fivethirtyeight&quot;) unisex_names #&gt; # A tibble: 919 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 #&gt; 4 Jackie 132929. 0.421 0.579 0.158 #&gt; 5 Avery 121797. 0.335 0.665 0.330 #&gt; 6 Jaime 109870. 0.562 0.438 0.124 #&gt; 7 Peyton 94896. 0.434 0.566 0.133 #&gt; 8 Kerry 88964. 0.484 0.516 0.0321 #&gt; 9 Jody 80401. 0.352 0.648 0.296 #&gt; 10 Kendall 79211. 0.372 0.628 0.255 #&gt; # … with 909 more rows A sorkoordinátákba írjuk a sorok válogatását biztosító lehetőségeket: unisex_names[2, ] #&gt; # A tibble: 1 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Riley 154861. 0.508 0.492 0.0153 unisex_names[1:3, ] #&gt; # A tibble: 3 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 unisex_names[-(1:3), ] #&gt; # A tibble: 916 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Jackie 132929. 0.421 0.579 0.158 #&gt; 2 Avery 121797. 0.335 0.665 0.330 #&gt; 3 Jaime 109870. 0.562 0.438 0.124 #&gt; 4 Peyton 94896. 0.434 0.566 0.133 #&gt; 5 Kerry 88964. 0.484 0.516 0.0321 #&gt; 6 Jody 80401. 0.352 0.648 0.296 #&gt; 7 Kendall 79211. 0.372 0.628 0.255 #&gt; 8 Payton 64152. 0.334 0.666 0.331 #&gt; 9 Skyler 53486. 0.646 0.354 0.292 #&gt; 10 Frankie 51288. 0.624 0.376 0.247 #&gt; # … with 906 more rows A head() és tail() függvény is a sorokból válogat, az első 6, illetve utolsó 3 sort így kaphatjuk meg: head(unisex_names, n = 6) #&gt; # A tibble: 6 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 #&gt; 4 Jackie 132929. 0.421 0.579 0.158 #&gt; 5 Avery 121797. 0.335 0.665 0.330 #&gt; 6 Jaime 109870. 0.562 0.438 0.124 tail(unisex_names, n = 3) #&gt; # A tibble: 3 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Gwin 101. 0.562 0.438 0.124 #&gt; 2 Yacine 100. 0.545 0.455 0.0892 #&gt; 3 Aeon 100. 0.465 0.535 0.0703 Bizonyos esetekben szükség lehet az adattábla soraiból véletlen módon néhányat kiválasztani. Ekkor a sample() függvényt használjuk: unisex_names[sample(x = 1:nrow(unisex_names), size = 10), ] #&gt; # A tibble: 10 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Torey 4059. 0.662 0.338 0.324 #&gt; 2 Jadis 248. 0.496 0.504 0.00889 #&gt; 3 Lenell 702. 0.642 0.358 0.284 #&gt; 4 Indy 501. 0.433 0.567 0.135 #&gt; 5 Codie 3999. 0.609 0.391 0.217 #&gt; 6 Manjot 226. 0.583 0.417 0.165 #&gt; 7 Kelechi 649. 0.656 0.344 0.313 #&gt; 8 Vernell 6729. 0.352 0.648 0.295 #&gt; 9 Terrin 911. 0.574 0.426 0.148 #&gt; 10 Micha 1928. 0.454 0.546 0.0911 A sample() függvény alapértelmezés szerint visszatevés nélküli választ véletlen értékeket az első paraméterből (esetünkben 919 számból 10-et), de ha a replace=TRUE argumentumot használjuk, akkor visszatevéssel fog választani: d.tbl &lt;- unisex_names[sample(x = 11:14, size = 5, replace = T), ] d.tbl #&gt; # A tibble: 5 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Frankie 51288. 0.624 0.376 0.247 #&gt; 2 Pat 44782. 0.369 0.631 0.262 #&gt; 3 Pat 44782. 0.369 0.631 0.262 #&gt; 4 Pat 44782. 0.369 0.631 0.262 #&gt; 5 Pat 44782. 0.369 0.631 0.262 A sample() függvény fenti paraméterezése mellett biztosan előfordul sorismétlés az új d.tbl adattáblában. Az sorismétléseket tartalmazó adattáblák kezelésére a duplicated() és a unique() függvényeket használhatjuk. A sorismétlések felderítésére a duplicated() függvényt használjuk: duplicated(d.tbl) #&gt; [1] FALSE FALSE TRUE TRUE TRUE d.tbl[duplicated(d.tbl), ] #&gt; # A tibble: 3 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Pat 44782. 0.369 0.631 0.262 #&gt; 2 Pat 44782. 0.369 0.631 0.262 #&gt; 3 Pat 44782. 0.369 0.631 0.262 A sorismétlések eltávolítására a unique() függvényt használhatjuk: unique(d.tbl) #&gt; # A tibble: 2 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Frankie 51288. 0.624 0.376 0.247 #&gt; 2 Pat 44782. 0.369 0.631 0.262 Ha a sorkoordítátákba logikai vektort írunk, akkor szűrést valósítunk meg: unisex_names[unisex_names$gap &lt; 0.003, ] #&gt; # A tibble: 10 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Kris 24956. 0.499 0.501 0.00275 #&gt; 2 Camdyn 3275. 0.500 0.500 0.000154 #&gt; 3 Christan 2685. 0.501 0.499 0.00227 #&gt; 4 Kam 729. 0.501 0.499 0.00235 #&gt; 5 Jonel 613. 0.499 0.501 0.00237 #&gt; 6 Kodee 533. 0.500 0.500 0.000316 #&gt; 7 Callaway 292. 0.500 0.500 0.000455 #&gt; 8 Bless 280. 0.500 0.500 0.0000717 #&gt; 9 Nike 206. 0.500 0.500 0.000782 #&gt; 10 Tkai 143. 0.500 0.500 0.000570 7.2 Adatkezelés Tidyverse R-ben Ebben a fejezetben: 7.2.1 A %&gt;% operátor Egy probléma megoldása több lépésben történik. A survey adatbázisból keressük ki a lányok testmagasságának az át gyakran függvényeket kell egymásba ágyaznunk. Ha például az 1, 2 és 3 számok természetes alapú logaritmusának az összegét szeretnénk kiszámolni, akkor a következő sorokat írhatjuk: x &lt;- c(1, 2, 3) # vektor előállítása out &lt;- log(x) # természetes alapú logaritmus kiszámolása out &lt;- sum(out) # átlag kiszámolása out # eredmény kírása #&gt; [1] 1.792 A részeredmények tárolására az out objektumot használtuk fel. A köztes eredmények tárolása azonos vagy eltérő nevek alatt szokásos gyakorlat a hagyományos R használata során. A fenti lehetőség mellett választhatjuk a függvények egymásba ágyazását is: x &lt;- c(1, 2, 3) # vektor előállítása sum(log(x)) # eredmény kiírása #&gt; [1] 1.792 A fenti példa jóval tömörebb és nem szükséges köztes objektumok létrehozása, a hagyományos R-ben nagyon gyakori összetett függvényhívásokkal (rész)problémák megoldása. A magrittr csomag kínál egy harmadik lehetőséget, a pipe operátor (%&gt;%) használatával. Az operátor egyben a Tidyverse R része is. library(tidyverse) x &lt;- c(1, 2, 3) # vektor előállítása x %&gt;% log() %&gt;% sum() # eredmény kiírása #&gt; [1] 1.792 A fenti sor olvasható úgy, hogy induljunk ki az x adatobjektumból, azután vegyük a 2-es alapú logaritmusát, azután vegyük az értékek összegét. A %&gt;% pipe operátor az azután lehetőséget kínálja, és egyben egy rendkívül jól olvasható és karbantarható kód létrehozását teszi lehetővé. A fentebb látott függvények egymásba ágyazásánál sokkal könyebben javítható ez a kód, az azt megelőző, köztes objektumokkal dolgozó esetnél pedig jóval egyszerűbb és elegánsabb. A pipe operátort használó parancsok tipikusan adatobjektummal, vagy az azt létrehozó függvénnyel indítanak, majd azoknak a tevékenységeknek a felsorolása történik függvényhívások egymásutánjának megadásával, amelyeket a felsorolás sorrendjében az adatokkal tenni szeretnénk. Az adat rész ezekből a függvényhívásokból hiányzik, ugyanis a pipe operátor biztosítja, hogy mindegyik függvény első argumentumába megkapja azt. 10 %&gt;% log() # ekvivalens alak: log(x=10) #&gt; [1] 2.303 c(10, 100) %&gt;% log() # ekvivalens alak: log(x=c(10, 100)) #&gt; [1] 2.303 4.605 c(10, 100) %&gt;% log(base=10) # ekvivalens alak: log(x=c(10, 100), base=10) #&gt; [1] 1 2 A fenti példában, látható, hogyan gondoskodik a pipe oprátor arról, hogy log() függvény első argumentuma (x=) megkapja a szükséges értékét. Néhány függvény esetében előfordul, hogy a kiinduló adat apaértelmezés szerint nem az első paraméter. Ekkor a pont . helyörző segítségével expliciten jelezzük, hogy hová kerül a pipe operátor bal oldaláról eérkező adat. Például a karakterstring cserére használatos sub() függvény x= argumentuma alapértelmezés szerint a harmadik: sub(pattern = &quot;s&quot;, replacement = &quot;z&quot;, x = letters) # s cseréje z-re #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;z&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; A következő függvényhívás az argumentumok nevesítése miatt szintén működőképes, az pipe-ban x=letters argumentumhívás valósul meg. letters %&gt;% sub(pattern = &quot;s&quot;, replacement = &quot;z&quot;) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;z&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Azonban ha nem használunk argumentumneveket, akkor ez a hívás már nem kívánt eredményre vezet, mert alapértelmezés szerint az első argumentumba kerül az adat, amelyik a sub() esetében a pattern= argumentum. letters %&gt;% sub(&quot;s&quot;, &quot;z&quot;) # Nem ezt akartuk. Valójában ez hívódik: sub(pattern=letters, replacement=&quot;s&quot;, x=&quot;z&quot;) #&gt; [1] &quot;z&quot; Ha tehát nem az első argumentumban szeretnénk szerepeltetni a pipe bal oldaláról érkező adatot, akkor a . helyörzőt kell használnunk: letters %&gt;% sub(&quot;s&quot;, &quot;z&quot;, .) # letters %&gt;% sub(pattern = &quot;s&quot;, replacement = &quot;z&quot;, x=letters) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;z&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; unisex_names %&gt;% slice(1:3) #&gt; # A tibble: 3 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 unisex_names %&gt;% slice(n()) # csak az utolsó sor #&gt; # A tibble: 1 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Aeon 100. 0.465 0.535 0.0703 unisex_names %&gt;% slice((n()-4):n()) # utolsó 5 sor #&gt; # A tibble: 5 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Eaden 102. 0.573 0.427 0.146 #&gt; 2 Inioluwa 101. 0.353 0.647 0.295 #&gt; 3 Gwin 101. 0.562 0.438 0.124 #&gt; 4 Yacine 100. 0.545 0.455 0.0892 #&gt; 5 Aeon 100. 0.465 0.535 0.0703 unisex_names %&gt;% slice(sample(1:n(), size=4)) # véletlen 4 sor #&gt; # A tibble: 4 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Tahjae 224. 0.460 0.540 0.0806 #&gt; 2 Onnie 664. 0.399 0.601 0.202 #&gt; 3 Zannie 143. 0.613 0.387 0.226 #&gt; 4 Zaiah 141. 0.457 0.543 0.0853 d.tbl &lt;- unisex_names %&gt;% slice(sample(21:24, size=5, replace = T )) # véletlen 4 sor d.tbl #&gt; # A tibble: 5 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Kris 24956. 0.499 0.501 0.00275 #&gt; 2 Carey 24790. 0.523 0.477 0.0465 #&gt; 3 Carey 24790. 0.523 0.477 0.0465 #&gt; 4 Emerson 24167. 0.526 0.474 0.0511 #&gt; 5 Carey 24790. 0.523 0.477 0.0465 d.tbl %&gt;% distinct() # a sorok egyedivé tétele #&gt; # A tibble: 3 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Kris 24956. 0.499 0.501 0.00275 #&gt; 2 Carey 24790. 0.523 0.477 0.0465 #&gt; 3 Emerson 24167. 0.526 0.474 0.0511 unisex_names %&gt;% sample_n(3) # véletlen 3 sor #&gt; # A tibble: 3 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Teegan 1946. 0.517 0.483 0.0343 #&gt; 2 Royale 457. 0.468 0.532 0.0639 #&gt; 3 Brittain 598. 0.571 0.429 0.143 unisex_names %&gt;% sample_frac(0.01) # véletlen 1%-nyi sor #&gt; # A tibble: 9 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Deshay 460. 0.390 0.610 0.220 #&gt; 2 Giani 376. 0.575 0.425 0.150 #&gt; 3 Emanuelle 333. 0.583 0.417 0.165 #&gt; 4 Artie 4230. 0.592 0.408 0.184 #&gt; 5 Da 298. 0.615 0.385 0.229 #&gt; 6 Aarin 693. 0.588 0.412 0.176 #&gt; 7 Jodeci 608. 0.468 0.532 0.0639 #&gt; 8 Monta 941. 0.453 0.547 0.0935 #&gt; 9 Dwan 1991. 0.565 0.435 0.129 unisex_names %&gt;% filter(gap&lt;0.003, grepl(pattern = &quot;^C&quot;, x = name) | grepl(pattern = &quot;^K&quot;, x = name)) #&gt; # A tibble: 6 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Kris 24956. 0.499 0.501 0.00275 #&gt; 2 Camdyn 3275. 0.500 0.500 0.000154 #&gt; 3 Christan 2685. 0.501 0.499 0.00227 #&gt; 4 Kam 729. 0.501 0.499 0.00235 #&gt; 5 Kodee 533. 0.500 0.500 0.000316 #&gt; 6 Callaway 292. 0.500 0.500 0.000455 unisex_names %&gt;% filter_all(any_vars(.&gt;0.4)) #&gt; # A tibble: 919 × 5 #&gt; name total male_share female_share gap #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Casey 176544. 0.584 0.416 0.169 #&gt; 2 Riley 154861. 0.508 0.492 0.0153 #&gt; 3 Jessie 136382. 0.478 0.522 0.0443 #&gt; 4 Jackie 132929. 0.421 0.579 0.158 #&gt; 5 Avery 121797. 0.335 0.665 0.330 #&gt; 6 Jaime 109870. 0.562 0.438 0.124 #&gt; 7 Peyton 94896. 0.434 0.566 0.133 #&gt; 8 Kerry 88964. 0.484 0.516 0.0321 #&gt; 9 Jody 80401. 0.352 0.648 0.296 #&gt; 10 Kendall 79211. 0.372 0.628 0.255 #&gt; # … with 909 more rows smiths %&gt;% select(kor=age, suly=weight) #&gt; # A tibble: 2 × 2 #&gt; kor suly #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 33 90 #&gt; 2 NA NA smiths %&gt;% rename(kor=age, suly=weight) #&gt; # A tibble: 2 × 5 #&gt; subject time kor suly height #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 John Smith 1 33 90 1.87 #&gt; 2 Mary Smith 1 NA NA 1.54 library(fivethirtyeight) 7.2.1.1 Oszlopok válogatása a Tidyverse R-ben A Tidyverse R a select() függvényt kínálja az oszlopok indexelése. A select() függvény argumentumába az Alap R-ben látott fenti lehetőség mindegyikét használhatjuk, némi könnyítéssel: # library(tidyverse) # smiths.tbl %&gt;% select(1:3) # smiths.tbl %&gt;% select(1, 3, 5) # smiths.tbl %&gt;% select(-1, -3, -5) # smiths.tbl %&gt;% select(subject, height) Láthatjuk a select() elbírja a pozitív vagy negatív indexek közvetlen megadását, nem kell vektorban felsorolni őket, illetve az oszlopneveket idézőjel nélkül is megadhatjuk. További lehetőség, hogy az oszlopneveket úgy ishasználhatjuk, mintha számok lennének, a kettőspont operátor és a negtív előjel is használható velük: # smiths.tbl %&gt;% select(subject:age) # smiths.tbl %&gt;% select(-subject, -age) # smiths.tbl %&gt;% select(-(subject:age)) Az oszlopok között az oszlopnevek alapján is lehet válogatni, ehhez a Tidyverse R számos függvényt ajánl: # smiths.tbl %&gt;% select(starts_with(&quot;ti&quot;)) # smiths.tbl %&gt;% select(ends_with(&quot;t&quot;)) # smiths.tbl %&gt;% select(contains(&quot;ei&quot;)) # d.df &lt;- data.frame(id=1, kerd.1=10, kerd.2=20, kerd.3=30) # d.df # d.df %&gt;% select(num_range(&quot;kerd.&quot;,1:3)) Válogathatunk az oszlopok közül az oszlop adataira vonatkozó logikai értéket szolgáltató függvények segítségével. Erre a select_if() ad lehetőséget. # smiths.tbl %&gt;% select_if(is.numeric) # smiths.tbl %&gt;% select_if(is.character) 7.3 Haladó adatkezelés Ebben a fejezetben: "],["leiro-statisztika.html", "8 Leíró statisztika", " 8 Leíró statisztika Ebben a fejezetben áttekintjük: "],["grafika-az-r-ben.html", "9 Grafika az R-ben", " 9 Grafika az R-ben Ebben a fejezetben áttekintjük: az R grafikus rendszerei a hagyományos grafika alapfogalmai magasszintű és alacsonyszintű rajzfüggvények a hagyományos grafikában a ggplot2 rendszer alapelve ábrák létrehozása ggplot2-ben ábrák mentése háttértárra "],["hipotezisvizsgalatok.html", "10 Hipotézisvizsgálatok", " 10 Hipotézisvizsgálatok Ebben a fejezetben a statisztika azon klasszikus próbáit foglaltuk össze, amelyek jellemzően egy- vagy kétmintás hipotézisvizsgálatokat jelentenek. Az öt alfejezet a nullhipotézisben szereplő állításoknak és paramétereknek megfelelően a statisztikai próbák különböző csoportjait fedi le: várható értékre vonatkozó próbák mediánra vonatkozó nemparaméteres próbák valószínűségre vonatkozó próbák varianciára vonatkozó próbák az eloszlás egészére vonatkozó próbák. "],["publikacio.html", "11 Publikáció 11.1 Reprodukálható kutatás", " 11 Publikáció 11.1 Reprodukálható kutatás A kutatás és oktatás világában jelentős elmozdulás figyelhető meg a reprodukálható kutatás felé. igénye felé. „Az akadémiai kutatás végső terméke a papír, a laboratóriumi jegyzetfüzetekkel és a teljes számítási környezettel együtt az eredmények előállítása érdekében, mint például a kód, az adatok stb., Amelyek felhasználhatók az eredmények reprodukálására és új munka létrehozására a kutatás ”(Wikipedia). Ennek következménye az, hogy meg kell változtatnunk szokásainkat, és minden kéziratunkat, előadásainkat, házi feladatainkat stb. Tiszta és reprodukálható formában kell elkezdenünk, azaz ha valaki megadja a kódot, akkor ez a személy pontosan reprodukálhatja a dokumentumot. Ez a dokumentum megkönnyíti ezt az átmenetet az R Markdown segítségével. "],["megoldasok.html", "A Megoldások A.1 Megoldások az 1.1.2 feladatokhoz A.2 Megoldások az 1.2.2 feladatokhoz A.3 Megoldások az 1.3.2 feladatokhoz A.4 Megoldások az 2.1.5 feladatokhoz A.5 Megoldások az 2.2.2 feladatokhoz A.6 Megoldások az 2.3.5 feladatokhoz A.7 Megoldások az 3.1.5 feladatokhoz A.8 Megoldások az 3.2.2 feladatokhoz A.9 Megoldások az 3.3.5 feladatokhoz A.10 Megoldások az 4.1.11 feladatokhoz A.11 Megoldások az 4.2.2 feladatokhoz A.12 Megoldások az 4.3.6 feladatokhoz A.13 Megoldások az 5.1.5 feladatokhoz A.14 Megoldások az 5.2.4 feladatokhoz A.15 Megoldások az 5.3.1.5 feladatokhoz A.16 Megoldások az 5.3.2.2 feladatokhoz A.17 Megoldások az 5.3.3.12 feladatokhoz A.18 Megoldások az 5.3.4.6 feladatokhoz A.19 Megoldások az 5.3.5.7 feladatokhoz A.20 Megoldások az 5.3.6.5 feladatokhoz A.21 Megoldások az 5.3.7.7 feladatokhoz A.22 Megoldások az 5.4.4 feladatokhoz A.23 Megoldások az 6.1.4 feladatokhoz A.24 Megoldások az 6.3.7 feladatokhoz", " A Megoldások A.1 Megoldások az 1.1.2 feladatokhoz Milyen online vagy nyomtat könyvek segítik az R elsajátítását? Próbáljuk összegyűjteni a magyar nyelvű könyveket is! Az R könyvekkel kapcsolatban könnyen az lehet az érzésünk, hogy túl sok a könyv, és túl kevés az idő. Valóban tengernyi R könyv vásárolható meg, melyek többsége angol nyelvű. Elegendő a Springer Use R! könyvsorozatára gondolni, amely önmagában több mint 80 címet tartalmaz. Az Amazon-ról elérhető, 2020. januárja után megjelent könyvek száma is túl van a kétszázon. Különösen értékesek lehetnek az online elérhető könyvek. Az idegen nyelvű könyvek tematikus gyűjteménye a Big Book of R, míg az R erőforrásokról saját listát is karbantartok. A magyar nyelvű könyvek közül külön is felsorolunk néhányat: Reiczigel Jenő, Harnos Andrea, Solymosi Norbert (2021). Biostatisztika nem statisztikusoknak. Pars Kft., Nagykovácsi. Dinya Elek, Solymosi Norbert (2016). Biometria a klinikumban 2. Feladatok megoldása R-környezetben. Medicina Kiadó. Münnich Ákos, Nagy Ágnes, Abari Kálmán. Többváltozós statisztika pszichológus hallgatók számára. Bölcsész Konzorcium, Debrecen, 2006. (http://psycho.unideb.hu/statisztika) ISBN 963 9704 04 0 Térképezzük fel az online videókurzusokat is az R tanulásához! A videókurzusok többsége is angol nyelvű, a Youtube-ról ingyenesen, de a Udemy vagy a datacamp oldaláról előfizetés ellenében több száz kurzust is elérhetünk. Az R-rel való ismerkedést kezdhetjük az R a gyakorlatban videósorozatommal is. A bevezető példa (Két tanítási módszer összehasonlítása) megoldásában a hipotézisvizsgálat alapján adjunk szöveges értékelést! A Mann-Whitney-próba alapján azt mondhatjuk, elegendő bizonyítékot találtunk arra, hogy a modern (Sprego) módszer eredményesebb (Med=65%), mint a hagyományos (Med=38%) tanítási módszer (W=24; p=0,001). A.2 Megoldások az 1.2.2 feladatokhoz Az adatfeldolgozás 4 lépése a következő: (1) adatok beolvasása, (2) adatok előkészítése elemzésre, (3) adatok elemzése és (4) az eredmények publikálása. A könyv mely fejezetei tartoznak az adatfeldolgozás fenti lépéseihez? Adatok beolvasása: 6 fejezet Adatok előkészítése elemzésre: 7 fejezet, Az adatok elemzése: 8, 9, 10 fejezet Az eredmények publikálása: 11 fejezet Az R-rel való munka általunk javasolt módja: RStudio-ban, projektmódban, R vagy RMarkdown állományokat szerkesztünk és hajtunk végre. Mely fejezetekben találunk hasznos információkat az R ezen használatával kapcsolatban? Az Alap R telepítése: @ref(az-alap-r-tele = tese) fejezet Az RStudio telepítése: 3.1.2 fejezet Az RStudio felépítése: 4.1.2 fejezet Parancsállományok használata RStudio-ban: 4.1.5, 4.1.6 fejezet RMarkdown állományok használata RStudio-ban: 4.1.7 fejezet Projektek használata RStudio-ban: 4.1.8 fejezet A.3 Megoldások az 1.3.2 feladatokhoz Minden statisztikai próba esetében négy dolgot érdemes tudni: (1) a statisztikai próba neve, (2) null- és ellenhipotézise, (3) alkalmazási feltételei, és (4) a próba végrehajtásának módja valamely statisztikai programcsomagban. A 10. fejezetben a statisztikai próbák végrehajtását természetesen R-beli eszközökkel mutatjuk be. Ismerjük a fenti táblázatokban megnevezett próbák null- és ellenhipotézisét, valamint az alkalmazási feltételeit? Próbáljuk ezeket felidézni! Hol találunk ezekről információt? Számos kiváló statisztika könyv érhető el, akár magyar nyelven is. A teljesség igénye nélkül: Freedman, D., Pisani, R., és Roger, P. (2005). Statisztika - Statisztikai módszerek a társadalomkutatásban. TYPOTEX, Budapest. Hajtman B. (1968a). Bevezetés a matematikai statisztikába pszichológusok számára. Akadémiai Kiadó, Budapest. Hajtman B. (1968b). Matematikai statisztika pszichológus szakos hallgatók részére. Akadémiai Kiadó, Budapest. Reiczigel J., Harnos A. és Solymosi N. (2018). Biostatisztika nem statisztikusoknak. Pars Kft., Budapest. Vargha A. (1978). Pszichológiai statisztikai gyakorlat I. Tankönyvkiadó, Budapest. Vargha A. (1985). Valószínűségszámítás pszichológus hallgatók számára. Tankönyvkiadó, Budapest. Vargha A. (1989). Pszichológiai statisztikai gyakorlat II. Tankönyvkiadó, Budapest. Vargha A. (2015). Matematikai statisztika pszichológiai, nyelvészeti és biológiai alkalmazásokkal. Pólya Kiadó, Budapest. Mely próbák maradtak ki ebből a könyvből? Hol találunk ezek R-beli végrehajtására példát? A statisztikai próbák számtalan elv alaján csoportosíthatók. Az egyik szerint megkülönböztetünk egyváltozós és többváltozós elemzéseket. Ez a könyv az egyváltozós elemzésekről ad, egy többé-kevésbé teljes képet. A többváltozós elemzések R-beli végrehajtásához a következő könyvet ajánljuk: Münnich Ákos, Nagy Ágnes, Abari Kálmán. Többváltozós statisztika pszichológus hallgatók számára. Bölcsész Konzorcium, Debrecen, 2006. (http://psycho.unideb.hu/statisztika) ISBN 963 9704 04 0 A.4 Megoldások az 2.1.5 feladatokhoz Keressünk weboldalakat, amelyek az R előnyeit és hátrányait listázzák! Például: Should you start learning R? Weigh the Pros and Cons of R programming Pros and Cons of R Programming Language – Unveil the Essential Aspects! What’s the Best Statistical Software? A Comparison of R, Python, SAS, SPSS and STATA Keressük meg, hogy az R optimális futtatásához, milyen hardver követelmények szükségesek! A néhány száz elemű minta feldolgozásához egyszerű, irodai követelményeknek megfelelő teljesítményű számítógép elegendő lehet. Könyvünkben az R környezetet RStudio-n keresztül érjük el, de mind az R, mind az RStudio rendszerkövetelményeiről kevés információ áll rendelkezésre: What are your system recommendations for the RStudio IDE? Nézzünk utána, hogy ma kb. hány csomag érhető el az R-hez? Keressünk ábrát, amely bemutatja, hogy az évek során hány csomag volt elérhető az R-hez? A két legnagyobb szolgáltató a CRAN és a Bioconductor, a következő linkeken elérhető csomagszámokat érdemes összeadni: CRAN Bioconductor Természetesen a GitHub-on bárki publikálhat saját csomagot, ezek száma is több százra tehető. Az aktuálisan elérhető CRAN csomagok számát R függvénnyel is meghatározhatjuk: Sys.Date() # aktuális dátum #&gt; [1] &quot;2022-07-13&quot; nrow(available.packages(repos = &quot;https://cran.rstudio.com/&quot;)) #&gt; [1] 18314 A BiocManager available() függvénye a CRAN és Bioconductor összes elérhető csomagját is listázza. length(BiocManager::available()) #&gt; [1] 21784 A csomagok számának hihetetlen növekedését mutatja ez az ábra: CRAN now has 10,000 R packages. Here’s how to find the ones you need Hol áll az R népszerűsége a többi programozási nyelvhez, illetve statisztikai programcsomaghoz képest? Például: TIOBE Index for December 2021 Statistical Software Popularity in 40,582 Research Papers Milyen ingyenesen elérhető, grafikus felhasználói felülettel rendelkező statisztikai programcsomagok építenek az R-re? Ilyenek például: R Commander jamovi JASP További források: R Graphical User Interface Comparison The Popularity of Point-and-Click GUIs for R Említettük, hogy az adatelmezési munka nem igényli az R programozói fokú ismeretét, de soroljunk fel néhány könyvet, amelyből az R programozása is megtanulható! Például: Solymosi Norbert: R &lt;- …erre, …erre! Bevezetés az R-nyelv és környezet használatába Oscar Baruffa: Big Book of R. 22 R programming A.5 Megoldások az 2.2.2 feladatokhoz Ki Hadley Wickham? Hadley Wickham több R könyv és csomag szerzője, a Tidyverse R egyik megalkotója. Több információt itt találunk: https://hadley.nz/ Mikor történt az egyik legjobb dolog az R-rel? 2014-ben: magrittr: The best thing to have ever happened to R? A.6 Megoldások az 2.3.5 feladatokhoz Keressünk olyan statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet? Érdemes körülnézni a CRAN Task Views oldalon, a csomagok tematikus gyűjteményében. Keressünk olyan nem-statisztikai jellegű témaköröket, amelyekben az R segítségünkre lehet? Érdemes körülnézni a CRAN Task Views oldalon, a csomagok tematikus gyűjteményében. Nézzünk át néhány online elérhető R könyvet, és hasonlítsuk össze az R alaptudás egyes elemeivel! Melyek az átfedő részek, és hol vannak különbségek? Példa online elérhető könyvekre: Sakir, Benjamin (2011). Introduction to Statistical Thinking (With R, Without Calculus) Crawley, Michael J. (2012). The R Book. Navarro, Danielle (2020). Learning Statistics with R. Verzani, John (2002). simpleR Using R for Introductory Statistics. Melyek a fontosabb lépcsőfokok az R fejlődősében? The History of R (updated for 2020) A.7 Megoldások az 3.1.5 feladatokhoz Melyik az R legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest? A jelenleg aktuális R verziószáma és az újdonságok itt elérhetők: https://cran.r-project.org/doc/manuals/r-release/NEWS.html Melyik az RStudio legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest? Az RStudio aktuális verziójáról itt olvashatunk: https://www.rstudio.com/products/rstudio/ Hogyan deríthető ki, hogy egy csomagban (például a MASS) csomagban, hány adatobjektum, és hány függvény található? Használhatjuk a beépített súgót: help(package = &quot;MASS&quot;) Vagy használhatunk más R függvényeket: library(MASS) # a MASS csomag tartalmának feltárása table(sapply(ls(pos = &quot;package:MASS&quot;), function(x) class(get(x))[1])) #&gt; #&gt; data.frame function list numeric ts #&gt; 75 78 2 7 3 A.8 Megoldások az 3.2.2 feladatokhoz Keressünk rá a Tidyverse R csomagjaira, és próbáljuk kideríteni az egyes csomagok fő célját, alkalmazási területeit! Egy lehetséges oldal a válaszhoz: Tidyverse R Derítsük ki, hogy az R Core Team vagy Hadley Wickham több R csomag szerzője! Az R Core Team a következő csomagok szerzője a standard csomagok közül: base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils, míg az ajánlott csomagok közül foreign és az nlme. Ez összesen 16 csomag. Hadley Wickham csomagjairól a saját weboldalán, vagy a github oldalán tájékozódhatunk. A csomagok száma jóval meghaladja a 16-ot. Egy adott csomag szerzőjéről a packageDescription() függvény ad információt: packageDescription(&quot;base&quot;)$Author # R Core Team csomag #&gt; [1] &quot;R Core Team and contributors worldwide&quot; packageDescription(&quot;ggplot2&quot;)$Author # Hadley Wickham csomag #&gt; [1] &quot;Hadley Wickham [aut] (&lt;https://orcid.org/0000-0003-4757-117X&gt;),\\n Winston Chang [aut] (&lt;https://orcid.org/0000-0002-1576-2126&gt;),\\n Lionel Henry [aut],\\n Thomas Lin Pedersen [aut, cre]\\n (&lt;https://orcid.org/0000-0002-5147-4711&gt;),\\n Kohske Takahashi [aut],\\n Claus Wilke [aut] (&lt;https://orcid.org/0000-0002-7470-9261&gt;),\\n Kara Woo [aut] (&lt;https://orcid.org/0000-0002-5125-4188&gt;),\\n Hiroaki Yutani [aut] (&lt;https://orcid.org/0000-0002-3385-7233&gt;),\\n Dewey Dunnington [aut] (&lt;https://orcid.org/0000-0002-9415-4582&gt;),\\n RStudio [cph, fnd]&quot; A.9 Megoldások az 3.3.5 feladatokhoz Az RStudio Tools/Check for Package Updates menüpontjával tájékozódjunk a telepített csomagjaink állapotáról. Végezzük el a szükséges frissítéseket! Mit tegyünk, ha nem sikerül valamelyik csomag telepítése? A frissítések elvégzését a fenti menüpont kiválasztásával kezdjük. Válasszuk ki a frissítendő csomagokat, akár az összeset, majd indítsuk el a frissítés folyamatát. Hibaüzenet esetén érdemes a következő lehetőségeket megfontolni: a hibaüzenetből kiolvasható lehet annak a csomagnak neve, amelynek előzetes telepítése szükséges RStudio helyett végezzük el az Alap R-ben az adott csomag telepítését végezzük adminisztrátori jogosultsággal a telepítést Windows operációs rendszer alatt ne legyen ékezetes vagy szóközt tartalmazó a felhasználói nevünk a forrásszövegben megjelenő csomagokhoz a megfelelő RTools verzióra lehet szükség Windows operációs rendszer alatt frissítsük meg az Alap R és RStudio komponenseket Ismerjük meg a telepített csomagjaink számát és forrását (CRAN vagy Bioconductor vagy GitHub)! A következő parancsok segítenek: library(tidyverse) inst.pckgs &lt;- installed.packages() pckgs.info &lt;- devtools::package_info(rownames(inst.pckgs)) # A csomagok száma forrásonként pckgs.info %&gt;% group_by(source) %&gt;% summarise(n=n()) #&gt; # A tibble: 7 × 2 #&gt; source n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Bioconductor 25 #&gt; 2 CRAN (R 4.2.0) 270 #&gt; 3 CRAN (R 4.2.1) 82 #&gt; 4 Github (achetverikov/apastats@448bb214274ee3837c58fd1238b336076552d918) 1 #&gt; 5 Github (matherion/userfriendlyscience@46acf718d692a42aeebdbe9a6e559a7a5… 1 #&gt; 6 Github (rempsyc/rempsyc@cab4ae0c79de9ddc6534065e937fa7f7255c895b) 1 #&gt; 7 local 1 # Az egyes forrásokhoz tartozó csomagok neve pckgs.info %&gt;% filter(grepl(&quot;CRAN&quot;, source)) #&gt; ! package * version date (UTC) lib source #&gt; abind 1.4-5 2016-07-21 [1] CRAN (R 4.2.0) #&gt; afex 1.1-1 2022-04-29 [1] CRAN (R 4.2.0) #&gt; anytime 0.3.9 2020-08-27 [1] CRAN (R 4.2.1) #&gt; apa 0.3.3 2020-04-21 [1] CRAN (R 4.2.1) #&gt; apaTables 2.0.8 2021-01-04 [1] CRAN (R 4.2.0) #&gt; arm 1.12-2 2021-10-15 [1] CRAN (R 4.2.0) #&gt; arrow 8.0.0 2022-05-09 [1] CRAN (R 4.2.1) #&gt; askpass 1.1 2019-01-13 [1] CRAN (R 4.2.0) #&gt; assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.2.0) #&gt; backports 1.4.1 2021-12-13 [1] CRAN (R 4.2.0) #&gt; base64enc 0.1-3 2015-07-28 [1] CRAN (R 4.2.0) #&gt; BayesFactor 0.9.12-4.4 2022-07-05 [1] CRAN (R 4.2.1) #&gt; bayestestR 0.12.1 2022-05-02 [1] CRAN (R 4.2.0) #&gt; BH 1.78.0-0 2021-12-15 [1] CRAN (R 4.2.0) #&gt; BiasedUrn 1.07 2015-12-28 [1] CRAN (R 4.2.0) #&gt; BiocManager 1.30.18 2022-05-18 [1] CRAN (R 4.2.1) #&gt; bit 4.0.4 2020-08-04 [1] CRAN (R 4.2.0) #&gt; bit64 4.0.5 2020-08-30 [1] CRAN (R 4.2.0) #&gt; bitops 1.0-7 2021-04-24 [1] CRAN (R 4.2.0) #&gt; blob 1.2.3 2022-04-10 [1] CRAN (R 4.2.0) #&gt; blogdown 1.10 2022-05-10 [1] CRAN (R 4.2.0) #&gt; bookdown 0.27 2022-06-14 [1] CRAN (R 4.2.1) #&gt; boot 1.3-28 2021-05-03 [2] CRAN (R 4.2.1) #&gt; brew 1.0-7 2022-02-04 [1] CRAN (R 4.2.0) #&gt; brio 1.1.3 2021-11-30 [1] CRAN (R 4.2.0) #&gt; broom 1.0.0 2022-07-01 [1] CRAN (R 4.2.1) #&gt; broom.mixed 0.2.9.4 2022-04-17 [1] CRAN (R 4.2.0) #&gt; broomExtra 4.3.2 2022-04-02 [1] CRAN (R 4.2.0) #&gt; BSDA 1.2.1 2021-09-05 [1] CRAN (R 4.2.1) #&gt; bslib 0.3.1 2021-10-06 [1] CRAN (R 4.2.0) #&gt; ca 0.71.1 2020-01-24 [1] CRAN (R 4.2.0) #&gt; cachem 1.0.6 2021-08-19 [1] CRAN (R 4.2.0) #&gt; callr 3.7.0 2021-04-20 [1] CRAN (R 4.2.0) #&gt; car 3.1-0 2022-06-15 [1] CRAN (R 4.2.0) #&gt; carData 3.0-5 2022-01-06 [1] CRAN (R 4.2.0) #&gt; caTools 1.18.2 2021-03-28 [1] CRAN (R 4.2.0) #&gt; cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.2.0) #&gt; checkmate 2.1.0 2022-04-21 [1] CRAN (R 4.2.0) #&gt; class 7.3-20 2022-01-16 [2] CRAN (R 4.2.1) #&gt; cli 3.3.0 2022-04-25 [1] CRAN (R 4.2.0) #&gt; clipr 0.8.0 2022-02-22 [1] CRAN (R 4.2.0) #&gt; cluster 2.1.3 2022-03-28 [2] CRAN (R 4.2.1) #&gt; coda 0.19-4 2020-09-30 [1] CRAN (R 4.2.0) #&gt; codetools 0.2-18 2020-11-04 [2] CRAN (R 4.2.1) #&gt; colorspace 2.0-3 2022-02-21 [1] CRAN (R 4.2.0) #&gt; commonmark 1.8.0 2022-03-09 [1] CRAN (R 4.2.0) #&gt; contfrac 1.1-12 2018-05-17 [1] CRAN (R 4.2.0) #&gt; corrplot 0.92 2021-11-18 [1] CRAN (R 4.2.0) #&gt; cowplot 1.1.1 2020-12-30 [1] CRAN (R 4.2.0) #&gt; cpp11 0.4.2 2021-11-30 [1] CRAN (R 4.2.0) #&gt; crayon 1.5.1 2022-03-26 [1] CRAN (R 4.2.0) #&gt; credentials 1.3.2 2021-11-29 [1] CRAN (R 4.2.0) #&gt; curl 4.3.2 2021-06-23 [1] CRAN (R 4.2.0) #&gt; data.table 1.14.2 2021-09-27 [1] CRAN (R 4.2.0) #&gt; data.tree 1.0.0 2020-08-03 [1] CRAN (R 4.2.0) #&gt; datawizard 0.4.1 2022-05-16 [1] CRAN (R 4.2.0) #&gt; DBI 1.1.3 2022-06-18 [1] CRAN (R 4.2.0) #&gt; dbplyr 2.2.1 2022-06-27 [1] CRAN (R 4.2.1) #&gt; deldir 1.0-6 2021-10-23 [1] CRAN (R 4.2.0) #&gt; DEoptimR 1.0-11 2022-04-03 [1] CRAN (R 4.2.0) #&gt; desc 1.4.1 2022-03-06 [1] CRAN (R 4.2.0) #&gt; DescTools 0.99.45 2022-05-09 [1] CRAN (R 4.2.1) #&gt; deSolve 1.32 2022-04-14 [1] CRAN (R 4.2.0) #&gt; devtools 2.4.3 2021-11-30 [1] CRAN (R 4.2.1) #&gt; DiagrammeR 1.0.9 2022-03-05 [1] CRAN (R 4.2.0) #&gt; dichromat 2.0-0.1 2022-05-02 [1] CRAN (R 4.2.0) #&gt; diffobj 0.3.5 2021-10-05 [1] CRAN (R 4.2.0) #&gt; digest 0.6.29 2021-12-01 [1] CRAN (R 4.2.0) #&gt; diptest 0.76-0 2021-05-04 [1] CRAN (R 4.2.0) #&gt; downlit 0.4.2 2022-07-05 [1] CRAN (R 4.2.1) #&gt; downloader 0.4 2015-07-09 [1] CRAN (R 4.2.0) #&gt; dplyr * 1.0.9 2022-04-28 [1] CRAN (R 4.2.1) #&gt; dtplyr 1.2.1 2022-01-19 [1] CRAN (R 4.2.0) #&gt; e1071 1.7-11 2022-06-07 [1] CRAN (R 4.2.0) #&gt; effects 4.2-1 2022-01-06 [1] CRAN (R 4.2.1) #&gt; effectsize 0.7.0 2022-05-26 [1] CRAN (R 4.2.0) #&gt; ellipsis 0.3.2 2021-04-29 [1] CRAN (R 4.2.0) #&gt; elliptic 1.4-0 2019-03-14 [1] CRAN (R 4.2.0) #&gt; emmeans 1.7.5 2022-06-22 [1] CRAN (R 4.2.0) #&gt; estimability 1.4 2022-07-03 [1] CRAN (R 4.2.1) #&gt; evaluate 0.15 2022-02-18 [1] CRAN (R 4.2.0) #&gt; Exact 3.1 2021-11-26 [1] CRAN (R 4.2.0) #&gt; expm 0.999-6 2021-01-13 [1] CRAN (R 4.2.0) #&gt; fansi 1.0.3 2022-03-24 [1] CRAN (R 4.2.0) #&gt; farver 2.1.1 2022-07-06 [1] CRAN (R 4.2.1) #&gt; fastmap 1.1.0 2021-01-25 [1] CRAN (R 4.2.0) #&gt; feather 0.3.5 2019-09-15 [1] CRAN (R 4.2.1) #&gt; filelock 1.0.2 2018-10-05 [1] CRAN (R 4.2.1) #&gt; fivethirtyeight 0.6.2 2021-10-07 [1] CRAN (R 4.2.1) #&gt; flextable 0.7.2 2022-06-12 [1] CRAN (R 4.2.1) #&gt; fontawesome 0.2.2 2021-07-02 [1] CRAN (R 4.2.1) #&gt; forcats * 0.5.1 2021-01-27 [1] CRAN (R 4.2.0) #&gt; foreign 0.8-82 2022-01-16 [2] CRAN (R 4.2.1) #&gt; formatR 1.12 2022-03-31 [1] CRAN (R 4.2.1) #&gt; Formula 1.2-4 2020-10-16 [1] CRAN (R 4.2.0) #&gt; fs 1.5.2 2021-12-08 [1] CRAN (R 4.2.0) #&gt; fst 0.9.8 2022-02-08 [1] CRAN (R 4.2.1) #&gt; fstcore 0.9.12 2022-03-23 [1] CRAN (R 4.2.1) #&gt; fun 0.3 2020-10-23 [1] CRAN (R 4.2.0) #&gt; furrr 0.3.0 2022-05-04 [1] CRAN (R 4.2.0) #&gt; futile.logger 1.4.3 2016-07-10 [1] CRAN (R 4.2.1) #&gt; futile.options 1.0.1 2018-04-20 [1] CRAN (R 4.2.0) #&gt; future 1.26.1 2022-05-27 [1] CRAN (R 4.2.0) #&gt; gargle 1.2.0 2021-07-02 [1] CRAN (R 4.2.0) #&gt; gdata 2.18.0.1 2022-05-10 [1] CRAN (R 4.2.0) #&gt; gdtools 0.2.4 2022-02-14 [1] CRAN (R 4.2.1) #&gt; generics 0.1.3 2022-07-05 [1] CRAN (R 4.2.1) #&gt; gert 1.6.0 2022-03-29 [1] CRAN (R 4.2.0) #&gt; GGally 2.1.2 2021-06-21 [1] CRAN (R 4.2.0) #&gt; ggcorrplot 0.1.3 2019-05-19 [1] CRAN (R 4.2.0) #&gt; ggplot2 * 3.3.6 2022-05-03 [1] CRAN (R 4.2.0) #&gt; ggpubr 0.4.0 2020-06-27 [1] CRAN (R 4.2.0) #&gt; ggrepel 0.9.1 2021-01-15 [1] CRAN (R 4.2.0) #&gt; ggridges 0.5.3 2021-01-08 [1] CRAN (R 4.2.0) #&gt; ggsci 2.9 2018-05-14 [1] CRAN (R 4.2.0) #&gt; ggsignif 0.6.3 2021-09-09 [1] CRAN (R 4.2.0) #&gt; gh 1.3.0 2021-04-30 [1] CRAN (R 4.2.0) #&gt; gitcreds 0.1.1 2020-12-04 [1] CRAN (R 4.2.0) #&gt; gld 2.6.5 2022-06-29 [1] CRAN (R 4.2.1) #&gt; globals 0.15.1 2022-06-24 [1] CRAN (R 4.2.1) #&gt; glue 1.6.2 2022-02-24 [1] CRAN (R 4.2.0) #&gt; gmodels 2.18.1.1 2022-05-17 [1] CRAN (R 4.2.0) #&gt; gnm 1.1-2 2022-04-29 [1] CRAN (R 4.2.0) #&gt; googledrive 2.0.0 2021-07-08 [1] CRAN (R 4.2.0) #&gt; googlesheets4 1.0.0 2021-07-21 [1] CRAN (R 4.2.0) #&gt; GPArotation 2022.4-1 2022-04-16 [1] CRAN (R 4.2.0) #&gt; gplots 3.1.3 2022-04-25 [1] CRAN (R 4.2.0) #&gt; gridExtra 2.3 2017-09-09 [1] CRAN (R 4.2.0) #&gt; gtable 0.3.0 2019-03-25 [1] CRAN (R 4.2.0) #&gt; gtools 3.9.2.2 2022-06-13 [1] CRAN (R 4.2.0) #&gt; haven 2.5.0 2022-04-15 [1] CRAN (R 4.2.0) #&gt; hexView 0.3-4 2019-03-13 [1] CRAN (R 4.2.0) #&gt; highr 0.9 2021-04-16 [1] CRAN (R 4.2.0) #&gt; Hmisc 4.7-0 2022-04-19 [1] CRAN (R 4.2.1) #&gt; hms 1.1.1 2021-09-26 [1] CRAN (R 4.2.0) #&gt; HSAUR3 1.0-13 2022-04-26 [1] CRAN (R 4.2.1) #&gt; htmlTable 2.4.1 2022-07-07 [1] CRAN (R 4.2.1) #&gt; htmltools 0.5.2 2021-08-25 [1] CRAN (R 4.2.0) #&gt; htmlwidgets 1.5.4 2021-09-08 [1] CRAN (R 4.2.0) #&gt; httpuv 1.6.5 2022-01-05 [1] CRAN (R 4.2.0) #&gt; httr 1.4.3 2022-05-04 [1] CRAN (R 4.2.0) #&gt; hypergeo 1.2-13 2016-04-07 [1] CRAN (R 4.2.0) #&gt; ids 1.0.1 2017-05-31 [1] CRAN (R 4.2.0) #&gt; igraph 1.3.2 2022-06-13 [1] CRAN (R 4.2.0) #&gt; influenceR 0.1.0.1 2021-09-25 [1] CRAN (R 4.2.0) #&gt; ini 0.3.1 2018-05-20 [1] CRAN (R 4.2.0) #&gt; insight 0.18.0 2022-07-05 [1] CRAN (R 4.2.1) #&gt; installr 0.23.2 2021-05-08 [1] CRAN (R 4.2.1) #&gt; interp 1.1-2 2022-05-10 [1] CRAN (R 4.2.1) #&gt; isoband 0.2.5 2021-07-13 [1] CRAN (R 4.2.0) #&gt; jcolors 0.0.4 2019-05-22 [1] CRAN (R 4.2.0) #&gt; jmv 2.3.4 2022-03-29 [1] CRAN (R 4.2.0) #&gt; jmvcore 2.3.12 2022-05-31 [1] CRAN (R 4.2.0) #&gt; jmvReadWrite 0.3.2 2022-05-21 [1] CRAN (R 4.2.0) #&gt; jpeg 0.1-9 2021-07-24 [1] CRAN (R 4.2.0) #&gt; jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.2.0) #&gt; jsonlite 1.8.0 2022-02-22 [1] CRAN (R 4.2.0) #&gt; kableExtra 1.3.4 2021-02-20 [1] CRAN (R 4.2.0) #&gt; KernSmooth 2.23-20 2021-05-03 [2] CRAN (R 4.2.1) #&gt; knitr 1.39 2022-04-26 [1] CRAN (R 4.2.1) #&gt; labeling 0.4.2 2020-10-20 [1] CRAN (R 4.2.0) #&gt; lambda.r 1.2.4 2019-09-18 [1] CRAN (R 4.2.1) #&gt; later 1.3.0 2021-08-18 [1] CRAN (R 4.2.0) #&gt; lattice 0.20-45 2021-09-22 [2] CRAN (R 4.2.1) #&gt; latticeExtra 0.6-30 2022-07-04 [1] CRAN (R 4.2.1) #&gt; lavaan 0.6-12 2022-07-04 [1] CRAN (R 4.2.1) #&gt; lavaanPlot 0.6.2 2021-08-13 [1] CRAN (R 4.2.0) #&gt; lifecycle 1.0.1 2021-09-24 [1] CRAN (R 4.2.0) #&gt; listenv 0.8.0 2019-12-05 [1] CRAN (R 4.2.0) #&gt; lme4 1.1-29 2022-04-07 [1] CRAN (R 4.2.1) #&gt; lmerTest 3.1-3 2020-10-23 [1] CRAN (R 4.2.0) #&gt; lmom 2.9 2022-05-29 [1] CRAN (R 4.2.0) #&gt; lmtest 0.9-40 2022-03-21 [1] CRAN (R 4.2.0) #&gt; lobstr 1.1.2 2022-06-22 [1] CRAN (R 4.2.0) #&gt; lsr 0.5.2 2021-12-01 [1] CRAN (R 4.2.0) #&gt; lubridate 1.8.0 2021-10-07 [1] CRAN (R 4.2.0) #&gt; magick 2.7.3 2021-08-18 [1] CRAN (R 4.2.0) #&gt; magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.2.0) #&gt; maptools 1.1-4 2022-04-17 [1] CRAN (R 4.2.0) #&gt; markdown 1.1 2019-08-07 [1] CRAN (R 4.2.0) #&gt; MASS * 7.3-57 2022-04-22 [2] CRAN (R 4.2.1) #&gt; Matrix 1.4-1 2022-03-23 [2] CRAN (R 4.2.1) #&gt; MatrixModels 0.5-0 2021-03-02 [1] CRAN (R 4.2.0) #&gt; matrixStats 0.62.0 2022-04-19 [1] CRAN (R 4.2.0) #&gt; MBESS 4.9.0 2022-02-09 [1] CRAN (R 4.2.0) #&gt; memoise 2.0.1 2021-11-26 [1] CRAN (R 4.2.0) #&gt; mgcv 1.8-40 2022-03-29 [2] CRAN (R 4.2.1) #&gt; mi 1.1 2022-06-06 [1] CRAN (R 4.2.0) #&gt; mime 0.12 2021-09-28 [1] CRAN (R 4.2.0) #&gt; miniUI 0.1.1.1 2018-05-18 [1] CRAN (R 4.2.0) #&gt; minpack.lm 1.2-2 2022-04-13 [1] CRAN (R 4.2.0) #&gt; minqa 1.2.4 2014-10-09 [1] CRAN (R 4.2.0) #&gt; mitools 2.4 2019-04-26 [1] CRAN (R 4.2.1) #&gt; mnormt 2.1.0 2022-06-07 [1] CRAN (R 4.2.0) #&gt; modelr 0.1.8 2020-05-19 [1] CRAN (R 4.2.0) #&gt; multcomp 1.4-19 2022-04-26 [1] CRAN (R 4.2.0) #&gt; multcompView 0.1-8 2019-12-19 [1] CRAN (R 4.2.0) #&gt; munsell 0.5.0 2018-06-12 [1] CRAN (R 4.2.0) #&gt; mvnormtest 0.1-9 2012-04-12 [1] CRAN (R 4.2.0) #&gt; mvtnorm 1.1-3 2021-10-08 [1] CRAN (R 4.2.0) #&gt; nlme 3.1-158 2022-06-15 [1] CRAN (R 4.2.1) #&gt; nloptr 2.0.3 2022-05-26 [1] CRAN (R 4.2.0) #&gt; nnet 7.3-17 2022-01-16 [2] CRAN (R 4.2.1) #&gt; nonpar 1.0.2 2020-04-29 [1] CRAN (R 4.2.0) #&gt; nortest 1.0-4 2015-07-30 [1] CRAN (R 4.2.0) #&gt; numDeriv 2016.8-1.1 2019-06-06 [1] CRAN (R 4.2.0) #&gt; officer 0.4.3 2022-06-12 [1] CRAN (R 4.2.1) #&gt; OpenMx 2.20.6 2022-03-09 [1] CRAN (R 4.2.0) #&gt; openssl 2.0.2 2022-05-24 [1] CRAN (R 4.2.0) #&gt; openxlsx 4.2.5 2021-12-14 [1] CRAN (R 4.2.0) #&gt; pacman 0.5.1 2019-03-11 [1] CRAN (R 4.2.0) #&gt; pander 0.6.5 2022-03-18 [1] CRAN (R 4.2.0) #&gt; papaja 0.1.1 2022-07-05 [1] CRAN (R 4.2.1) #&gt; parallelly 1.32.0 2022-06-07 [1] CRAN (R 4.2.0) #&gt; parameters 0.18.1 2022-05-29 [1] CRAN (R 4.2.0) #&gt; pbapply 1.5-0 2021-09-16 [1] CRAN (R 4.2.0) #&gt; pbivnorm 0.6.0 2015-01-23 [1] CRAN (R 4.2.0) #&gt; pbkrtest 0.5.1 2021-03-09 [1] CRAN (R 4.2.0) #&gt; performance 0.9.1 2022-06-20 [1] CRAN (R 4.2.0) #&gt; pillar 1.7.0 2022-02-01 [1] CRAN (R 4.2.0) #&gt; pkgbuild 1.3.1 2021-12-20 [1] CRAN (R 4.2.0) #&gt; pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.2.0) #&gt; pkgload 1.3.0 2022-06-27 [1] CRAN (R 4.2.1) #&gt; plogr 0.2.0 2018-03-25 [1] CRAN (R 4.2.1) #&gt; plyr 1.8.7 2022-03-24 [1] CRAN (R 4.2.0) #&gt; PMCMR 4.4 2021-10-02 [1] CRAN (R 4.2.0) #&gt; png 0.1-7 2013-12-03 [1] CRAN (R 4.2.0) #&gt; polynom 1.4-1 2022-04-11 [1] CRAN (R 4.2.0) #&gt; praise 1.0.0 2015-08-11 [1] CRAN (R 4.2.0) #&gt; prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.2.0) #&gt; processx 3.6.1 2022-06-17 [1] CRAN (R 4.2.1) #&gt; progress 1.2.2 2019-05-16 [1] CRAN (R 4.2.0) #&gt; promises 1.2.0.1 2021-02-11 [1] CRAN (R 4.2.0) #&gt; proxy 0.4-27 2022-06-09 [1] CRAN (R 4.2.0) #&gt; pryr 0.1.5 2021-07-26 [1] CRAN (R 4.2.0) #&gt; ps 1.7.1 2022-06-18 [1] CRAN (R 4.2.0) #&gt; psych 2.2.5 2022-05-10 [1] CRAN (R 4.2.1) #&gt; purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.2.0) #&gt; pwr 1.3-0 2020-03-17 [1] CRAN (R 4.2.0) #&gt; pzfx 0.3.0 2020-07-04 [1] CRAN (R 4.2.1) #&gt; qqplotr 0.0.5 2021-04-23 [1] CRAN (R 4.2.1) #&gt; quantreg 5.93 2022-05-02 [1] CRAN (R 4.2.0) #&gt; qvcalc 1.0.2 2020-02-15 [1] CRAN (R 4.2.0) #&gt; R6 2.5.1 2021-08-19 [1] CRAN (R 4.2.0) #&gt; rappdirs 0.3.3 2021-01-31 [1] CRAN (R 4.2.0) #&gt; rapportools 1.1 2022-03-22 [1] CRAN (R 4.2.0) #&gt; rcmdcheck 1.4.0 2021-09-27 [1] CRAN (R 4.2.0) #&gt; Rcmdr 2.7-2 2022-01-06 [1] CRAN (R 4.2.1) #&gt; RcmdrMisc 2.7-2 2022-01-05 [1] CRAN (R 4.2.1) #&gt; RColorBrewer 1.1-3 2022-04-03 [1] CRAN (R 4.2.0) #&gt; Rcpp 1.0.8.3 2022-03-17 [1] CRAN (R 4.2.0) #&gt; RcppEigen 0.3.3.9.2 2022-04-08 [1] CRAN (R 4.2.0) #&gt; D RcppParallel 5.1.5 2022-01-05 [1] CRAN (R 4.2.0) #&gt; RCurl 1.98-1.7 2022-06-09 [1] CRAN (R 4.2.0) #&gt; readODS 1.7.0 2020-07-10 [1] CRAN (R 4.2.1) #&gt; readr * 2.1.2 2022-01-30 [1] CRAN (R 4.2.0) #&gt; readstata13 0.10.0 2021-05-25 [1] CRAN (R 4.2.1) #&gt; readxl 1.4.0 2022-03-28 [1] CRAN (R 4.2.0) #&gt; relimp 1.0-5 2016-03-30 [1] CRAN (R 4.2.0) #&gt; rematch 1.0.1 2016-04-21 [1] CRAN (R 4.2.0) #&gt; rematch2 2.1.2 2020-05-01 [1] CRAN (R 4.2.0) #&gt; remotes 2.4.2 2021-11-30 [1] CRAN (R 4.2.0) #&gt; reprex 2.0.1 2021-08-05 [1] CRAN (R 4.2.0) #&gt; reshape 0.8.9 2022-04-12 [1] CRAN (R 4.2.0) #&gt; reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.2.0) #&gt; restfulr 0.0.15 2022-06-16 [1] CRAN (R 4.2.1) #&gt; rio 0.5.29 2021-11-22 [1] CRAN (R 4.2.1) #&gt; rjson 0.2.21 2022-01-09 [1] CRAN (R 4.2.0) #&gt; RJSONIO 1.3-1.6 2021-09-16 [1] CRAN (R 4.2.0) #&gt; rlang 1.0.3 2022-06-27 [1] CRAN (R 4.2.1) #&gt; rmarkdown 2.14 2022-04-25 [1] CRAN (R 4.2.0) #&gt; rmatio 0.16.0 2021-10-27 [1] CRAN (R 4.2.1) #&gt; rmdfiltr 0.1.3 2020-11-25 [1] CRAN (R 4.2.1) #&gt; rmdpartials 0.5.8 2020-06-04 [1] CRAN (R 4.2.0) #&gt; Rmisc 1.5.1 2022-05-02 [1] CRAN (R 4.2.1) #&gt; robustbase 0.95-0 2022-04-02 [1] CRAN (R 4.2.1) #&gt; ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.2.0) #&gt; rootSolve 1.8.2.3 2021-09-29 [1] CRAN (R 4.2.0) #&gt; roxygen2 7.2.0 2022-05-13 [1] CRAN (R 4.2.0) #&gt; rpart 4.1.16 2022-01-24 [2] CRAN (R 4.2.1) #&gt; rpf 1.0.11 2021-10-20 [1] CRAN (R 4.2.0) #&gt; rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.2.0) #&gt; RSQLite 2.2.14 2022-05-07 [1] CRAN (R 4.2.1) #&gt; rstatix 0.7.0 2021-02-13 [1] CRAN (R 4.2.0) #&gt; rstudioapi 0.13 2020-11-12 [1] CRAN (R 4.2.0) #&gt; rversions 2.1.1 2021-05-31 [1] CRAN (R 4.2.0) #&gt; rvest 1.0.2 2021-10-16 [1] CRAN (R 4.2.0) #&gt; RXKCD 1.9.2 2020-02-24 [1] CRAN (R 4.2.1) #&gt; sandwich 3.0-2 2022-06-15 [1] CRAN (R 4.2.0) #&gt; sass 0.4.1 2022-03-23 [1] CRAN (R 4.2.0) #&gt; scales * 1.2.0 2022-04-13 [1] CRAN (R 4.2.0) #&gt; SCRT 1.3.1 2020-01-09 [1] CRAN (R 4.2.0) #&gt; selectr 0.4-2 2019-11-20 [1] CRAN (R 4.2.0) #&gt; sem 3.1-15 2022-04-10 [1] CRAN (R 4.2.0) #&gt; semTools 0.5-6 2022-05-10 [1] CRAN (R 4.2.0) #&gt; servr 0.24 2021-11-16 [1] CRAN (R 4.2.0) #&gt; sessioninfo 1.2.2 2021-12-06 [1] CRAN (R 4.2.0) #&gt; shiny 1.7.1 2021-10-02 [1] CRAN (R 4.2.0) #&gt; sjlabelled 1.2.0 2022-04-10 [1] CRAN (R 4.2.0) #&gt; sjmisc 2.8.9 2021-12-03 [1] CRAN (R 4.2.0) #&gt; sjstats 0.18.1 2021-01-09 [1] CRAN (R 4.2.0) #&gt; snow 0.4-4 2021-10-27 [1] CRAN (R 4.2.0) #&gt; sourcetools 0.1.7 2018-04-25 [1] CRAN (R 4.2.0) #&gt; sp 1.5-0 2022-06-05 [1] CRAN (R 4.2.0) #&gt; SparseM 1.81 2021-02-18 [1] CRAN (R 4.2.0) #&gt; spatial 7.3-15 2022-01-16 [2] CRAN (R 4.2.1) #&gt; StanHeaders 2.21.0-7 2020-12-17 [1] CRAN (R 4.2.0) #&gt; stringi 1.7.6 2021-11-29 [1] CRAN (R 4.2.0) #&gt; stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.2.0) #&gt; summarytools 1.0.1 2022-05-20 [1] CRAN (R 4.2.1) #&gt; SuppDists 1.1-9.7 2022-01-03 [1] CRAN (R 4.2.0) #&gt; survey 4.1-1 2021-07-19 [1] CRAN (R 4.2.1) #&gt; survival 3.3-1 2022-03-03 [2] CRAN (R 4.2.1) #&gt; svglite 2.1.0 2022-02-03 [1] CRAN (R 4.2.0) #&gt; sys 3.4 2020-07-23 [1] CRAN (R 4.2.0) #&gt; systemfonts 1.0.4 2022-02-11 [1] CRAN (R 4.2.0) #&gt; tcltk2 1.2-11 2014-12-20 [1] CRAN (R 4.2.0) #&gt; TeachingDemos 2.12 2020-04-07 [1] CRAN (R 4.2.1) #&gt; testthat 3.1.4 2022-04-26 [1] CRAN (R 4.2.0) #&gt; TH.data 1.1-1 2022-04-26 [1] CRAN (R 4.2.0) #&gt; tibble * 3.1.7 2022-05-03 [1] CRAN (R 4.2.0) #&gt; tidyr * 1.2.0 2022-02-01 [1] CRAN (R 4.2.0) #&gt; tidyselect 1.1.2 2022-02-21 [1] CRAN (R 4.2.0) #&gt; tidyverse * 1.3.1 2021-04-15 [1] CRAN (R 4.2.1) #&gt; timeDate 3043.102 2018-02-21 [1] CRAN (R 4.2.0) #&gt; tinylabels 0.2.3 2022-02-06 [1] CRAN (R 4.2.1) #&gt; tinytex 0.40 2022-06-15 [1] CRAN (R 4.2.0) #&gt; tmvnsim 1.0-2 2016-12-15 [1] CRAN (R 4.2.0) #&gt; tzdb 0.3.0 2022-03-28 [1] CRAN (R 4.2.0) #&gt; ufs 0.5.2 2021-11-13 [1] CRAN (R 4.2.0) #&gt; usethis 2.1.6 2022-05-25 [1] CRAN (R 4.2.0) #&gt; utf8 1.2.2 2021-07-24 [1] CRAN (R 4.2.0) #&gt; uuid 1.1-0 2022-04-19 [1] CRAN (R 4.2.0) #&gt; vcd 1.4-10 2022-06-09 [1] CRAN (R 4.2.0) #&gt; vcdExtra 0.8-0 2022-04-21 [1] CRAN (R 4.2.0) #&gt; vctrs 0.4.1 2022-04-13 [1] CRAN (R 4.2.0) #&gt; viridis 0.6.2 2021-10-13 [1] CRAN (R 4.2.0) #&gt; viridisLite 0.4.0 2021-04-13 [1] CRAN (R 4.2.0) #&gt; visNetwork 2.1.0 2021-09-29 [1] CRAN (R 4.2.0) #&gt; vroom 1.5.7 2021-11-30 [1] CRAN (R 4.2.0) #&gt; waldo 0.4.0 2022-03-16 [1] CRAN (R 4.2.0) #&gt; webshot 0.5.3 2022-04-14 [1] CRAN (R 4.2.0) #&gt; whisker 0.4 2019-08-28 [1] CRAN (R 4.2.0) #&gt; withr 2.5.0 2022-03-03 [1] CRAN (R 4.2.0) #&gt; xfun 0.31 2022-05-10 [1] CRAN (R 4.2.0) #&gt; XML 3.99-0.10 2022-06-09 [1] CRAN (R 4.2.0) #&gt; xml2 1.3.3 2021-11-30 [1] CRAN (R 4.2.0) #&gt; xopen 1.0.0 2018-09-17 [1] CRAN (R 4.2.0) #&gt; xtable 1.8-4 2019-04-21 [1] CRAN (R 4.2.0) #&gt; yaml 2.3.5 2022-02-21 [1] CRAN (R 4.2.0) #&gt; zip 2.2.0 2021-05-31 [1] CRAN (R 4.2.0) #&gt; zoo 1.8-10 2022-04-15 [1] CRAN (R 4.2.0) #&gt; #&gt; [1] C:/Users/RStudio/AppData/Local/R/win-library/4.2 #&gt; [2] C:/Program Files/R/R-4.2.1/library #&gt; #&gt; D ── DLL MD5 mismatch, broken installation. pckgs.info %&gt;% filter(source == &quot;Bioconductor&quot;) #&gt; package * version date (UTC) lib source #&gt; AnnotationDbi 1.58.0 2022-04-26 [1] Bioconductor #&gt; Biobase 2.56.0 2022-04-26 [1] Bioconductor #&gt; BiocFileCache 2.4.0 2022-04-26 [1] Bioconductor #&gt; BiocGenerics 0.42.0 2022-04-26 [1] Bioconductor #&gt; BiocIO 1.6.0 2022-04-26 [1] Bioconductor #&gt; BiocParallel 1.30.3 2022-06-07 [1] Bioconductor #&gt; BiocVersion 3.15.2 2022-03-29 [1] Bioconductor #&gt; biomaRt 2.52.0 2022-04-26 [1] Bioconductor #&gt; Biostrings 2.64.0 2022-04-26 [1] Bioconductor #&gt; DelayedArray 0.22.0 2022-04-26 [1] Bioconductor #&gt; GenomeInfoDb 1.32.2 2022-05-15 [1] Bioconductor #&gt; GenomeInfoDbData 1.2.8 2022-07-06 [1] Bioconductor #&gt; GenomicAlignments 1.32.0 2022-04-26 [1] Bioconductor #&gt; GenomicFeatures 1.48.3 2022-05-31 [1] Bioconductor #&gt; GenomicRanges 1.48.0 2022-04-26 [1] Bioconductor #&gt; IRanges 2.30.0 2022-04-26 [1] Bioconductor #&gt; KEGGREST 1.36.2 2022-06-09 [1] Bioconductor #&gt; MatrixGenerics 1.8.1 2022-06-30 [1] Bioconductor #&gt; Rhtslib 1.28.0 2022-04-26 [1] Bioconductor #&gt; Rsamtools 2.12.0 2022-04-26 [1] Bioconductor #&gt; rtracklayer 1.56.1 2022-06-23 [1] Bioconductor #&gt; S4Vectors 0.34.0 2022-04-26 [1] Bioconductor #&gt; SummarizedExperiment 1.26.1 2022-04-29 [1] Bioconductor #&gt; XVector 0.36.0 2022-04-26 [1] Bioconductor #&gt; zlibbioc 1.42.0 2022-04-26 [1] Bioconductor #&gt; #&gt; [1] C:/Users/RStudio/AppData/Local/R/win-library/4.2 #&gt; [2] C:/Program Files/R/R-4.2.1/library pckgs.info %&gt;% filter(grepl(&quot;Github&quot;, source)) #&gt; package * version date (UTC) lib source #&gt; apastats 0.3 2022-07-04 [1] Github (achetverikov/apastats@448bb21) #&gt; rempsyc 0.0.4.5 2022-07-04 [1] Github (rempsyc/rempsyc@cab4ae0) #&gt; userfriendlyscience 0.7.2 2022-06-30 [1] Github (matherion/userfriendlyscience@46acf71) #&gt; #&gt; [1] C:/Users/RStudio/AppData/Local/R/win-library/4.2 #&gt; [2] C:/Program Files/R/R-4.2.1/library A.10 Megoldások az 4.1.11 feladatokhoz Bizonyosudjunk meg róla, hogy az alapvető szövegszerkesztési ismeretek birtokában vagyunk. Ismerjük az Insert billentyű funkcióját? Találjunk legalább 8 módszert, amely kizárólag a billentyű segítségével mozgatja a szövegkurzort! A szövegkijelölésnek milyen billentyűparancsait ismerjük? Milyen karaktertörlési lehetőségeket ismerünk? Ismerjük mindhárom vágóasztal-művelet billentyűparancsát? A szövegkurzor mozgatása billentyűvel: FEL/LE/JOBBRA/BALRA nyilak Ctrl+FEL/LE/JOBBRA/BALRA nyilak Page Up, Page Down Ctrl+Page Up, Ctrl+Page Down Home, End Ctrl+Home, Ctrl+End TAB Shift+TAB Karaktertörlései lehetőségek: Backspace Delete Vágóasztal műveletek: Másolás (Ctrl+C) Kivágás (Ctrl+X) Beillesztés (Ctrl+V) Az RStudio mellett milyen más intergrált fejlesztőeszközök léteznek az R-hez? Például: RKWard BlueSky Statistics Az Appearance menüpont Editor theme beállításával változtassunk az RStudio színösszeállításán. Keressük meg a legjobban hozzánk illőt! Vegyük figyelembe, hogy hosszútávon a minél sötétebb háttér a jó választás. Én a Tomorrow Night Bright témát használom. A.11 Megoldások az 4.2.2 feladatokhoz Keressünk magyar nyelvű leírásokat az R-hez! Például: Reiczigel Jenő, Harnos Andrea, Solymosi Norbert (2021). Biostatisztika nem statisztikusoknak. Pars Kft., Nagykovácsi. Dinya Elek, Solymosi Norbert (2016). Biometria a klinikumban 2. Feladatok megoldása R-környezetben. Medicina Kiadó. Münnich Ákos, Nagy Ágnes, Abari Kálmán. Többváltozós statisztika pszichológus hallgatók számára. Bölcsész Konzorcium, Debrecen, 2006. (http://psycho.unideb.hu/statisztika) ISBN 963 9704 04 0 A közösségi médiában melyek az R legfontosabb fórumai? Pélául: R-bloggers https://twitter.com/hashtag/rstat Hogyan indíthatjuk el egy csomag beépített súgóját? Ismerjük meg így a fun csomagot! # install.packages(&quot;fun&quot;) help(package=&quot;fun&quot;) library(fun) alzheimer_test() A.12 Megoldások az 4.3.6 feladatokhoz Foglaljuk össze az R használati módjait! Soroljuk fel mind a négy lehetőséget! Konzolos használat Parancsállományos használat (RGui, RStudio) Point-and-click használat (R Commander, jamovi, JASP stb.) Kötegelt használat Hasonlítsuk össze a parancsállományok használatát RGui-ban és RStudio-ban! Az RGui és a az RStudio is támogatja a parancsállományos használati módot. Valójában az RGui a Ctrl+R billentyűkombináción, és az *.R kiterjesztésű állományok mentésén/nyitásán kívül más segítséget nem ad a a parancsállományos használathoz, míg az RStudio a ma elérhető legkényelmesebb felület nyújtja a parancsállományok szerkesztéséhez. Hasonlítsuk össze a parancsállományok és az RMarkdown használatát R Commander-ben és RStudio-ban! Az R Commander a menüből kiválasztott műveletek R parancsait parancsállományban és RMarkdown állományban is rögzíti, így, utóbbi esetben HTML formátumú állományt generálhatunk az elemzésünk végén. Az R Commander-ben tehát akár parancsok gépelése nélkül hosszabb távon is eltárolhatjuk elemző parancsainkat, amelyet *.R vagy *.Rmd állományban is rögzíthetünk. Az RStudio-ban minden parancsot magunknak kell begépelnünk, de a gépelés során számos segítség áll rendelkezésre. Az RMarkdown összes lehetőségét valójában csak az RStudio-ban használhatjuk ki. Töltsük le és telepítsük az ingyenesen elérhető jamovi és a JASP statisztikai programokat, majd nyissuk meg a beépített adatbázisait, és végezzünk néhány egyszerűbb elemzést! Ha elakadunk, keressünk videó tutoriált az eszközök használatáról. Melyik eszköz tetszik jobban? Miben hasonlítanak és miben térnek el? A két eszköz honlapján a letöltés is elvégezhető és a szoftverek részletes dokumentációját is elérhetjük: jamovi JASP A.13 Megoldások az 5.1.5 feladatokhoz Gondoljuk át, mi lehet a következő algebrai kifejezés eredménye, majd ellenőrizzük R-ben is: \\(8/2(2+2)\\). 8/2*(2+2) #&gt; [1] 16 Alternatív válasz. Gondoljuk át, hogy a .342e1 név miért nem lehet érvényes objektumnév? Próbáljuk ki a make.names(\".342e1\") parancsot, majd tanulmányozzuk a ?make.names leírást! A make.names() függvény egy tetszőleges karaktersorozatból szabályos objektumnevet hoz létre. Önmagában a .342e1 nem szabályos objektumnév, hiszen egy exponenciális alakú számról van szó. .342e1 #&gt; [1] 3.42 make.names(&quot;.342e1&quot;) #&gt; [1] &quot;X.342e1&quot; Magyarázzuk meg a make.names(c(\"\", \"\", \"\")) és a make.names(c(\"\", \"\", \"\"), unique = T) parancsok közötti különbséget! make.names(c(&quot;&quot;, &quot;&quot;, &quot;&quot;)) #&gt; [1] &quot;X&quot; &quot;X&quot; &quot;X&quot; make.names(c(&quot;&quot;, &quot;&quot;, &quot;&quot;), unique = T) #&gt; [1] &quot;X&quot; &quot;X.1&quot; &quot;X.2&quot; A make.names() függvényben szereplő unique=T a létrehozandó objektumnevek egyediségéről is gondoskodik. Gondoljuk át, hogy egy parancsállomány mely pontjain érdemes feltétlenül megjegyzéseket használni! A lehető legtöbb ponton használjunk megjegyzést, de mindenképp alakítsuk ki megjegyzésekkel a négyes tagolást: Beolvasás Előkészítés Elemzés Publikálás Jelentősen segíthetjük a navigációt az RStudio parancsállományaiban, ha bizonyos megjegyzések végére ezt írjuk: ---- (szóköz és négy mínusz jel). Hogyan használhatjuk ezt a lehetőséget az RStudio-ban, és milyen előnyei vannak? A címsorok végén, szóköz után, ha szerepeltetjük a ---- (négy mínusz jel) karaktersorozatot, akkor a Code / Show document outline menüpontból elérhető válik a megjelölt címsorok tartalomjegyzéke. Így hozunk létre szakaszokat az .R parancsállományokban. Az RStudio-ban parancsállomány (.R) szerkesztése közben próbáljuk ki a Ctrl+Alt+R billentyűparancsot, és a hozzá kapcsolódó Shift+Alt+J billentyűparancsot is. Mi a jelentése az Alt+L, Shift+Alt+L, Alt+O és Shift+Alt+O billentyűparancsoknak? A most megismert funkciók hogyan válthatók ki RMarkdown (.Rmd) állomány szerkesztése közben? A parancsállományok (.R) szerkesztése közben: Ctrl+Alt+R - az összes sor futtatása Shift+Alt+J - választás a ---- (négy mínusz jel) karakterekkel megjelölt címekből, vagyis ugrás a megjelölt a szakaszra. Alt+L - az aktuális szakasz bezárása Shift+Alt+L - az aktuális szakasz kinyitása Alt+O - minden szakasz bezárása Shift+Alt+O - minden szakasz kinyitása Az RMarkdown (.Rmd) szerkesztése közben szintén használhatók a fenti billentyűkombinációk. Az egyetlen eltérés, hogy a ---- (négy mínusz jel) karakterekre nincs szükség, a Markdown címsorok és az R csonkok automatikusan szakasszá válnak. A.14 Megoldások az 5.2.4 feladatokhoz Tekintsük át az 5.2. táblázat utolsó oszlopában szereplő R függvényeket. Próbáljuk megjósolni a függvények visszatérési értékét. Végezzünk ellenőrzést: gépeljük be, és hajtsuk végre a matematikai függvényeket! Egészítsük ki a begépelt matematikai függvényeket az argumentumok nevével, mindegyik argumentumnak adjunk nevet az 5.2. táblázat első oszlopa alapján! abs(x = -1) #&gt; [1] 1 sign(x = pi) #&gt; [1] 1 sqrt(x = 9+16) #&gt; [1] 5 exp(x = 1) #&gt; [1] 2.718 log(x = exp(3)) #&gt; [1] 3 log(x = 8,base = 10) #&gt; [1] 0.9031 log10(x = 1000) #&gt; [1] 3 log2(x = 256) #&gt; [1] 8 cos(x = pi) #&gt; [1] -1 sin(x = 0) #&gt; [1] 0 tan(x = 0) #&gt; [1] 0 round(x = c(1.5,-1.5)) #&gt; [1] 2 -2 floor(x = c(1.5,-1.5)) #&gt; [1] 1 -2 ceiling(x = c(1.5,-1.5)) #&gt; [1] 2 -1 trunc(x = c(1.5,-1.5)) #&gt; [1] 1 -1 Az előző feladatban a matematikai függvények gépelése során milyen RStudio kényelmi funkciókat fedeztünk fel. Soroljunk fel legalább hármat! függvény nevének kiegészítése kerek zárójelek elhelyezése a függvénynév után argumentumnevek felajánlása Az aranymetszés arányait tartalmazó épületek, képzőművészeti alkotások máig nagy esztétikai értékkel bírnak. Határozzuk meg ezt az arányt a \\(\\phi=\\frac{1+\\sqrt{5}}{2}\\) képlet segítségével! Egy A/4-es oldalra kb. 47 sort írhatunk 12-es betűmérettel, és kb. 35 sort 16-os betűmérettel. Egy üres lap hanyadik sorába írnánk címet 12-es és 16-os betűméret esetén? Próbáljuk ki mindezt egy szövegszerkesztőben is! fi &lt;- (1+sqrt(5))/2 fi #&gt; [1] 1.618 c(47, 35)/(1+fi) #&gt; [1] 17.95 13.37 A 47 soros A/4-es oldal 18. sorába, illetve a 35 soros A/4-es oldal 13. sorába kerülhetne a cím. A trigonometrikus függvények argumentumában radiánban kell megadni a szög értékét, és nem fokban. Ezt figyelembe véve határozzuk meg a 0, 30, 45, 60, 90 és 180 fok szinuszát, koszinuszát és tangensét! fokok &lt;- c(0, 30, 45, 60, 90, 180) sin(pi*fokok/180) #&gt; [1] 0.000e+00 5.000e-01 7.071e-01 8.660e-01 1.000e+00 1.225e-16 cos(pi*fokok/180) #&gt; [1] 1.000e+00 8.660e-01 7.071e-01 5.000e-01 6.123e-17 -1.000e+00 tan(pi*fokok/180) #&gt; [1] 0.000e+00 5.774e-01 1.000e+00 1.732e+00 1.633e+16 -1.225e-16 A.15 Megoldások az 5.3.1.5 feladatokhoz Mi a hasonlóság a következő három numerikus konstans között: 0xabc, 2748, .2748e4. Mindhárom szám értéke azonos, 2748. 0xabc #&gt; [1] 2748 2748 #&gt; [1] 2748 .2748e4 #&gt; [1] 2748 Az R öt előre definiált konstassal rendelkezik (?Constants). Írassuk ki ezek értékeit, állapítsuk meg típusukat! LETTERS #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; #&gt; [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; letters #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; month.abb #&gt; [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; month.name #&gt; [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; #&gt; [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; pi #&gt; [1] 3.142 A pi double, a többi karakteres típusú. Az aranymetszés arányszámát (\\(\\phi=\\frac{1+\\sqrt{5}}{2}\\)) írassuk a konzolba legalább 8 tizedes pontossággal! fi &lt;- (1+sqrt(5))/2 # 1. megoldás options(digits=10) # megnöveljük az értékes jegyek kiírását fi # fi kiírása #&gt; [1] 1.618033989 options(digits=7) # alapértelmezés visszaállítása # 2. megoldás print(fi, digits=10) #&gt; [1] 1.618033989 Az r\"(tetszőleges karakterek)\" formájú karakteres konstans megadásnak több válozata is létezik, soroljunk fel még legalább öt lehetőséget (?Quotes)! Milyen előnyökkel rendelkezik ez a megadási forma az idézőjelek és a fordított perjel tekintetében? r&quot;(Alapértelmezett alak)&quot; #&gt; [1] &quot;Alapértelmezett alak&quot; r&#39;(Így is jó)&#39; #&gt; [1] &quot;Így is jó&quot; r&quot;{Használhatunk kapcsos zárójeleket is}&quot; #&gt; [1] &quot;Használhatunk kapcsos zárójeleket is&quot; r&quot;[Vagy szögletest]&quot; #&gt; [1] &quot;Vagy szögletest&quot; r&quot;---(Vagy körbevehetjük azonos számú gondolatjellel is)---&quot; #&gt; [1] &quot;Vagy körbevehetjük azonos számú gondolatjellel is&quot; r&quot;-(Akár eggyel is)-&quot; #&gt; [1] &quot;Akár eggyel is&quot; r&quot;(Ne feledjük, két előnye van ennek a formának:)&quot; #&gt; [1] &quot;Ne feledjük, két előnye van ennek a formának:&quot; r&quot;((1) könnyebb egyszerre használni a szimpla (&#39;) és dupla (&quot;) idéző jeleket)&quot; #&gt; [1] &quot;(1) könnyebb egyszerre használni a szimpla (&#39;) és dupla (\\&quot;) idéző jeleket&quot; r&quot;((2) a Windows-os elérési utak könyebben másolhatók az op. renszerből:)&quot; #&gt; [1] &quot;(2) a Windows-os elérési utak könyebben másolhatók az op. renszerből:&quot; r&quot;(C:\\Program Files\\Android)&quot; #&gt; [1] &quot;C:\\\\Program Files\\\\Android&quot; Helyezzünk el idézőjeleket karakteres konstansokban, mindhárom megadási forma mellett! &quot;szimpla (&#39;) és dupla (\\&quot;)&quot; #&gt; [1] &quot;szimpla (&#39;) és dupla (\\&quot;)&quot; &#39;szimpla (\\&#39;) és dupla (&quot;)&#39; #&gt; [1] &quot;szimpla (&#39;) és dupla (\\&quot;)&quot; r&quot;(szimpla (&#39;) és dupla (&quot;))&quot; #&gt; [1] &quot;szimpla (&#39;) és dupla (\\&quot;)&quot; Próbáljuk ki az 5.5. táblázat karakterkezelő függvényeit! Gépeljük be az utolsó oszlopban lévő példákat, és vizsgáljuk meg a függvények visszatérési értékét. paste(&quot;a&quot;,&quot;b&quot;,sep=&quot;=&quot;) #&gt; [1] &quot;a=b&quot; nchar(&quot;alma&quot;) #&gt; [1] 4 substr(&quot;alma&quot;, 3, 5) #&gt; [1] &quot;ma&quot; tolower(&quot;Kiss Géza&quot;) #&gt; [1] &quot;kiss géza&quot; toupper(&quot;Kiss Géza&quot;) #&gt; [1] &quot;KISS GÉZA&quot; chartr(&quot;it&quot;,&quot;ál&quot;,&quot;titik&quot;) #&gt; [1] &quot;lálák&quot; cat(&quot;alma&quot;,&quot;fa&quot;, sep=&quot;&quot;) #&gt; almafa grepl(pattern=&quot;lm&quot;,x=&quot;alma&quot;) #&gt; [1] TRUE gsub(&quot;lm&quot;,repl=&quot;nyj&quot;,x=&quot;alma&quot;) #&gt; [1] &quot;anyja&quot; Próbáljuk ki az 5.6. táblázat relációs operátorait! Gépeljük be a példákat és ellenőrizzük az eredményeket. 1&lt;2 #&gt; [1] TRUE &quot;alma&quot;&lt;&quot;körte&quot; #&gt; [1] TRUE 3&gt;(1+2) #&gt; [1] FALSE &quot;abc&quot;&gt;&quot;ab&quot; #&gt; [1] TRUE 1&lt;=-.3 #&gt; [1] FALSE &quot;él&quot;&lt;=&quot;elő&quot; #&gt; [1] TRUE 3/4&gt;=7/9 #&gt; [1] FALSE &quot;aki&quot;&gt;=&quot;Ági&quot; #&gt; [1] TRUE 20==2e1 #&gt; [1] TRUE &quot;Len&quot;==&quot;len&quot; #&gt; [1] FALSE exp(1)!=pi #&gt; [1] TRUE &quot;Len&quot;!=&quot;len&quot; #&gt; [1] TRUE c(8, 12) %in% 1:10 #&gt; [1] TRUE FALSE A logikai operátorok működéséről teljes képet kaphatunk az 5.7. táblázatból. Próbáljuk ki ezeket a parancsokat is! # logikai NEM !(1&lt;2) #&gt; [1] FALSE !T #&gt; [1] FALSE !F #&gt; [1] TRUE # logikai ÉS (csak egy esetben igaz) T &amp; T #&gt; [1] TRUE T &amp; F #&gt; [1] FALSE F &amp; T #&gt; [1] FALSE F &amp; F #&gt; [1] FALSE # logikai VAGY (csak egy esetben hamis) T | T #&gt; [1] TRUE T | F #&gt; [1] TRUE F | T #&gt; [1] TRUE F | F #&gt; [1] FALSE A.16 Megoldások az 5.3.2.2 feladatokhoz Próbáljuk ki az 5.8. táblázatban szereplő példákat. Hozzuk létre a különböző típusú objektumokat és vizsgáljuk meg a typeof() és class() függvényekkel az objektumok típusát. x &lt;- c(12L, 14L) typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; x &lt;- c(12, 14) typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; x &lt;- c(&quot;a&quot;, &quot;az&quot;, &quot;egy&quot;) typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; x &lt;- c(T, TRUE, FALSE, F) typeof(x) #&gt; [1] &quot;logical&quot; class(x) #&gt; [1] &quot;logical&quot; x &lt;- matrix(1L, nrow=2, ncol = 3) typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; x &lt;- matrix(1.3, nrow=2, ncol = 3) typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; x &lt;- matrix(&quot;az&quot;, nrow=2,ncol=3) typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; x &lt;- factor(c(&quot;D&quot;, &quot;D&quot;, &quot;ND&quot;), level=c(&quot;ND&quot;, &quot;D&quot;, &quot;ED&quot;)) typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;factor&quot; x &lt;- list(A=&#39;Pék&#39;, B=1:2) typeof(x) #&gt; [1] &quot;list&quot; class(x) #&gt; [1] &quot;list&quot; x &lt;- data.frame(nev=c(&quot;a&quot;, &quot;b&quot;), pont=c(11, 9)) typeof(x) #&gt; [1] &quot;list&quot; class(x) #&gt; [1] &quot;data.frame&quot; A.17 Megoldások az 5.3.3.12 feladatokhoz Hozzuk létre a következő numerikus vektort: 12, 14, 17. x &lt;- c(12, 14, 17) x #&gt; [1] 12 14 17 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 3 Hozzuk létre a következő karakteres vektort: “Vác”, “Eger”, “Pécs”. x &lt;- c(&quot;Vác&quot;, &quot;Eger&quot;, &quot;Pécs&quot;) x #&gt; [1] &quot;Vác&quot; &quot;Eger&quot; &quot;Pécs&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 3 Hozzuk létre a következő logikai vektort: TRUE, FALSE, FALSE. x &lt;- c(T, F, F) x #&gt; [1] TRUE FALSE FALSE typeof(x) #&gt; [1] &quot;logical&quot; class(x) #&gt; [1] &quot;logical&quot; length(x) #&gt; [1] 3 Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és a különbség 1. x &lt;- 8:102 x #&gt; [1] 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [20] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #&gt; [39] 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #&gt; [58] 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #&gt; [77] 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; length(x) #&gt; [1] 95 Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 102, az utolsó 8 és a különbség -1. x &lt;- 102:8 x #&gt; [1] 102 101 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 #&gt; [20] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 #&gt; [39] 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 #&gt; [58] 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 #&gt; [77] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; length(x) #&gt; [1] 95 Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és a különbség 2. x &lt;- seq(from=8, to=102, by=2) x #&gt; [1] 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 #&gt; [20] 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 #&gt; [39] 84 86 88 90 92 94 96 98 100 102 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 48 Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, a különbség 3 és a vektor 25 elemű. x &lt;- seq(from=8, by=3, length.out=25) x #&gt; [1] 8 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 25 Hozzuk létre azt a numerikus vektort, amely 12 elemű, és minden elemének -2 az értéke! x &lt;- rep(-2, times=12) x #&gt; [1] -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 12 Hozzuk létre azt a karakteres vektort, amely 7 elemű, és minden elemének “Péntek” az értéke! x &lt;- rep(&quot;Péntek&quot;, times=7) x #&gt; [1] &quot;Péntek&quot; &quot;Péntek&quot; &quot;Péntek&quot; &quot;Péntek&quot; &quot;Péntek&quot; &quot;Péntek&quot; &quot;Péntek&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 7 Hozzuk létre azt a logikai vektort, amely 7 elemű, és minden elemének TRUE az értéke! x &lt;- rep(T, times=7) x #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE typeof(x) #&gt; [1] &quot;logical&quot; class(x) #&gt; [1] &quot;logical&quot; length(x) #&gt; [1] 7 Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket háromszor egymás után megismétli! Hány elemű az így létrejött vektor? x &lt;- rep(c(2, 3, 5), times=3) x #&gt; [1] 2 3 5 2 3 5 2 3 5 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 9 Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket háromszor helyben megismétli! Hány elemű az így létrejött vektor? x &lt;- rep(c(2, 3, 5), each=3) x #&gt; [1] 2 2 2 3 3 3 5 5 5 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 9 Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket helyben megismétli úgy, hogy a 2-őt 4-szer, a 3-at 5-ször és az 5-öt 7-szer ismétli meg! Hány elemű az így létrejött vektor? x &lt;- rep(c(2, 3, 5), times=c(4, 5, 7)) x #&gt; [1] 2 2 2 2 3 3 3 3 3 5 5 5 5 5 5 5 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 16 Szabályos vektorok létrehozásának van egy korábban még nem említett módja: a sequence() függvény. Ismerjük meg a súgóból ezt a függvényt, és értelmezzük a sequence(4) és sequence(c(4,5)) függvényhívásokat! x &lt;- sequence(4) # 1:4 vektor x #&gt; [1] 1 2 3 4 typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; length(x) #&gt; [1] 4 x &lt;- sequence(c(4,5)) # c(1:4, 1:5) vektor x #&gt; [1] 1 2 3 4 1 2 3 4 5 typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; length(x) #&gt; [1] 9 Vektorok létrehozásának számos módját megismertük ebben a fejezetben, de elemek megadása nélkül, vagy akár nulla hosszúsággal is létrehozhatunk vektort. A double(), integer(), character() és logical() függvények közvetlenül az adott típusnak megfelelő vektort hozzák létre. A súgó tanulmányozásával állítsunk elő 0 és 10 elemű vektor objektumokat mind a négy típus esetén. x &lt;- double() x #&gt; numeric(0) typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 0 x &lt;- double(10) x #&gt; [1] 0 0 0 0 0 0 0 0 0 0 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 10 x &lt;- integer() x #&gt; integer(0) typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; length(x) #&gt; [1] 0 x &lt;- integer(10) x #&gt; [1] 0 0 0 0 0 0 0 0 0 0 typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;integer&quot; length(x) #&gt; [1] 10 x &lt;- character() x #&gt; character(0) typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 0 x &lt;- character(10) x #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 10 x &lt;- logical() x #&gt; logical(0) typeof(x) #&gt; [1] &quot;logical&quot; class(x) #&gt; [1] &quot;logical&quot; length(x) #&gt; [1] 0 x &lt;- logical(10) x #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE typeof(x) #&gt; [1] &quot;logical&quot; class(x) #&gt; [1] &quot;logical&quot; length(x) #&gt; [1] 10 Próbáljuk ki az 5.9. táblázatban szereplő példákat. max(1:10) #&gt; [1] 10 min(11:20) #&gt; [1] 11 sum(1:5) #&gt; [1] 15 prod(1:5) #&gt; [1] 120 mean(1:10) #&gt; [1] 5.5 median(1:10) #&gt; [1] 5.5 range(1:10) #&gt; [1] 1 10 sd(1:10) #&gt; [1] 3.02765 var(1:10) #&gt; [1] 9.166667 cor(1:10,11:20) #&gt; [1] 1 Hozzuk létre a 'Peti'=5, 'Bori'=NA, 'Éva'=3, 'Pál'=NA, 'Gergő'=5, 'Ili'=4 adatokat tartalmazó vektort, majd rendezzük, indexeljük az első és az utolsó elemét, válogassuk le az 5-ös értékeket, csökkentsük mindegyik értéket 1-gyel, csak az 5-öket csökkentsük 1-gyel. x &lt;- c(&#39;Peti&#39;=5, &#39;Bori&#39;=NA, &#39;Éva&#39;=3, &#39;Pál&#39;=NA, &#39;Gergő&#39;=5, &#39;Ili&#39;=4) x #&gt; Peti Bori Éva Pál Gergő Ili #&gt; 5 NA 3 NA 5 4 sort(x) # rendezések #&gt; Éva Ili Peti Gergő #&gt; 3 4 5 5 sort(x, decreasing = T) #&gt; Peti Gergő Ili Éva #&gt; 5 5 4 3 x[order(x)] #&gt; Éva Ili Peti Gergő Bori Pál #&gt; 3 4 5 5 NA NA x[order(x, decreasing = T)] #&gt; Peti Gergő Ili Éva Bori Pál #&gt; 5 5 4 3 NA NA x[c(1, length(x))] # az első és utolsó elem #&gt; Peti Ili #&gt; 5 4 x[x == 5] # szűrés #&gt; Peti &lt;NA&gt; &lt;NA&gt; Gergő #&gt; 5 NA NA 5 x[x %in% 5] # szűrés (használjuk == helyett a %in% operátort) #&gt; Peti Gergő #&gt; 5 5 y &lt;- x - 1 # mindegyik értéket csökkentjük 1-gyel, új vektorban y #&gt; Peti Bori Éva Pál Gergő Ili #&gt; 4 NA 2 NA 4 3 z &lt;- x # 5-öket csökkentjük 1-gyel, új vektorban z[z %in% 5 &amp; !is.na(z)] &lt;- z[z %in% 5 &amp; !is.na(z)] - 1 z #&gt; Peti Bori Éva Pál Gergő Ili #&gt; 4 NA 3 NA 4 4 A.18 Megoldások az 5.3.4.6 feladatokhoz Hozzunk létre egy csupa 1-ből álló mátrixot, amelynek 3 sora és 2 oszlopa van! x &lt;- matrix(1, nrow=3, ncol=2) x #&gt; [,1] [,2] #&gt; [1,] 1 1 #&gt; [2,] 1 1 #&gt; [3,] 1 1 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; length(x) #&gt; [1] 6 Hozzunk létre egy 3 \\(\\times\\) 4-es karakteres mátrixot, amely 12 különbüző keresztnevet tartalmaz! nevek &lt;- c(&quot;Ibrahim&quot;, &quot;Ibrány&quot;, &quot;Idrisz&quot;, &quot;Ignác&quot;, &quot;Igor&quot;, &quot;Iláj&quot;, &quot;Ilán&quot;, &quot;Ilárion&quot;, &quot;Ildár&quot;, &quot;Ildefonz&quot;, &quot;Ilián&quot;, &quot;Iliász&quot;) x &lt;- matrix(nevek, nrow=3, ncol=4, byrow=T) x #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] &quot;Ibrahim&quot; &quot;Ibrány&quot; &quot;Idrisz&quot; &quot;Ignác&quot; #&gt; [2,] &quot;Igor&quot; &quot;Iláj&quot; &quot;Ilán&quot; &quot;Ilárion&quot; #&gt; [3,] &quot;Ildár&quot; &quot;Ildefonz&quot; &quot;Ilián&quot; &quot;Iliász&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; length(x) #&gt; [1] 12 Hozzunk létre egy 3 \\(\\times\\) 4-es logikai mátrixot, amelynek 1. és 3. sora TURE a 2. sora pedig FALSE értékeket tartalmaz! x &lt;- matrix(c(T, F, T), nrow=3, ncol=4, byrow=F) x #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] TRUE TRUE TRUE TRUE #&gt; [2,] FALSE FALSE FALSE FALSE #&gt; [3,] TRUE TRUE TRUE TRUE typeof(x) #&gt; [1] &quot;logical&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; length(x) #&gt; [1] 12 Mátrixok indexelésére olyan speciális indexmátrix is használható, amelynek két oszlopa van, és az elérendő elemek sor- és oszlopkoordinátáit tartalmazza. Mutassunk példát erre a mátrix[indexmátrix] alakú mátrixindexelésre! x &lt;- matrix(1:12, nrow=3, ncol=4, byrow=F) x #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 typeof(x) #&gt; [1] &quot;integer&quot; class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; length(x) #&gt; [1] 12 im &lt;- rbind(c(2,1), c(2,2)) # indexmátrix im #&gt; [,1] [,2] #&gt; [1,] 2 1 #&gt; [2,] 2 2 typeof(im) #&gt; [1] &quot;double&quot; class(im) #&gt; [1] &quot;matrix&quot; &quot;array&quot; length(im) #&gt; [1] 4 x[im] # mátrix indexelése indexmátrix-szal #&gt; [1] 2 5 x[2, c(1,2)] # mátrix hagyományos indexelése #&gt; [1] 2 5 A.19 Megoldások az 5.3.5.7 feladatokhoz Hozzuk létre azt a karakteres vektort, amely a férfi, nő karakteres konstansokat, úgy helyezi el egymás mellett, hogy a 7 darab férfi érték után 13 db nő címke következik! Hány elemű az így létrejött vektor? x &lt;- rep(c(&quot;férfi&quot;, &quot;nő&quot;), times=c(7, 13)) x #&gt; [1] &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;nő&quot; &quot;nő&quot; #&gt; [10] &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; #&gt; [19] &quot;nő&quot; &quot;nő&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 20 x.f &lt;- factor(x, levels=c(&quot;férfi&quot;, &quot;nő&quot;)) x.f #&gt; [1] férfi férfi férfi férfi férfi férfi férfi nő nő nő nő nő #&gt; [13] nő nő nő nő nő nő nő nő #&gt; Levels: férfi nő typeof(x.f) #&gt; [1] &quot;integer&quot; class(x.f) #&gt; [1] &quot;factor&quot; length(x.f) #&gt; [1] 20 Egy vizsgálatban az első 10 személy neme férfi, a többi 8 neme nő volt. Hozzuk létre azt a faktort, amely leírja a neme változót! x &lt;- rep(c(&quot;férfi&quot;, &quot;nő&quot;), times=c(10, 8)) x #&gt; [1] &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; &quot;férfi&quot; #&gt; [10] &quot;férfi&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; &quot;nő&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 18 x.f &lt;- factor(x, levels=c(&quot;férfi&quot;, &quot;nő&quot;)) x.f #&gt; [1] férfi férfi férfi férfi férfi férfi férfi férfi férfi férfi nő nő #&gt; [13] nő nő nő nő nő nő #&gt; Levels: férfi nő typeof(x.f) #&gt; [1] &quot;integer&quot; class(x.f) #&gt; [1] &quot;factor&quot; length(x.f) #&gt; [1] 18 Egy vizsgálatban városi (“V”) és falusi (“F”) fiatalok vettek részt! A megkérdezettek településtípusa rendre a következő volt: F, F, V, F, V, V, V, F. Hozzuk létre azt a faktort, amely leírja a településtípus változót! x &lt;- c(&quot;F&quot;, &quot;F&quot;, &quot;V&quot;, &quot;F&quot;, &quot;V&quot;, &quot;V&quot;, &quot;V&quot;, &quot;F&quot;) x #&gt; [1] &quot;F&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; &quot;V&quot; &quot;V&quot; &quot;V&quot; &quot;F&quot; typeof(x) #&gt; [1] &quot;character&quot; class(x) #&gt; [1] &quot;character&quot; length(x) #&gt; [1] 8 x.f &lt;- factor(x, levels=c(&quot;F&quot;, &quot;V&quot;)) x.f #&gt; [1] F F V F V V V F #&gt; Levels: F V typeof(x.f) #&gt; [1] &quot;integer&quot; class(x.f) #&gt; [1] &quot;factor&quot; length(x.f) #&gt; [1] 8 Egy vizsgálatban a dohányzási szokást egy kétértékű skálán mérték: 0-nem dohányzik; 1-dohányzik. A megkérdezettek dohányzási szokása a következő volt: 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0. Hozzuk létre azt a faktort, amely leírja a dohányzási szokás változót! x &lt;- c(0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0) x #&gt; [1] 0 0 1 0 1 0 1 0 1 0 1 0 typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;numeric&quot; length(x) #&gt; [1] 12 x.f &lt;- factor(x, levels=c(&quot;0&quot;, &quot;1&quot;), labels = c(&quot;nem dohányzik&quot;, &quot;dohányzik&quot;)) x.f #&gt; [1] nem dohányzik nem dohányzik dohányzik nem dohányzik dohányzik #&gt; [6] nem dohányzik dohányzik nem dohányzik dohányzik nem dohányzik #&gt; [11] dohányzik nem dohányzik #&gt; Levels: nem dohányzik dohányzik typeof(x.f) #&gt; [1] &quot;integer&quot; class(x.f) #&gt; [1] &quot;factor&quot; length(x.f) #&gt; [1] 12 A.20 Megoldások az 5.3.6.5 feladatokhoz Hozzunk létre egy háromelemű listát a TRUE, 12, és “Verseny” konstansokból! lista &lt;- list(T, 12, &quot;Verseny&quot;) lista #&gt; [[1]] #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 12 #&gt; #&gt; [[3]] #&gt; [1] &quot;Verseny&quot; typeof(lista) #&gt; [1] &quot;list&quot; class(lista) #&gt; [1] &quot;list&quot; length(lista) #&gt; [1] 3 Hozzunk létre egy háromelemű listát a TRUE, 12, és “Verseny” konstansokból, de gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve”, “indulok” és “leiras”! lista &lt;- list(&quot;befejezve&quot;=T, &quot;indulok&quot;=12, &quot;leiras&quot;=&quot;Verseny&quot;) lista #&gt; $befejezve #&gt; [1] TRUE #&gt; #&gt; $indulok #&gt; [1] 12 #&gt; #&gt; $leiras #&gt; [1] &quot;Verseny&quot; typeof(lista) #&gt; [1] &quot;list&quot; class(lista) #&gt; [1] &quot;list&quot; length(lista) #&gt; [1] 3 Hozzunk létre egy háromelemű listát a TRUE, 12 és “Verseny” konstansokból, valamint az induló versenyzők végső pontszámaiból, amelyek rendre: 89, 78, 23, 67, 99, 69, 85, 77, 58, 72, 48, 81. Gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: “befejezve”, “indulok”, “leiras” és “pontszam”! lista &lt;- list(&quot;befejezve&quot;=T, &quot;indulok&quot;=12, &quot;leiras&quot;=&quot;Verseny&quot;, pontszam=c(89, 78, 23, 67, 99, 69, 85, 77, 58, 72, 48, 81)) lista #&gt; $befejezve #&gt; [1] TRUE #&gt; #&gt; $indulok #&gt; [1] 12 #&gt; #&gt; $leiras #&gt; [1] &quot;Verseny&quot; #&gt; #&gt; $pontszam #&gt; [1] 89 78 23 67 99 69 85 77 58 72 48 81 typeof(lista) #&gt; [1] &quot;list&quot; class(lista) #&gt; [1] &quot;list&quot; length(lista) #&gt; [1] 4 A.21 Megoldások az 5.3.7.7 feladatokhoz Hozzunk létre egy 30 \\(\\times\\) 3-as adattáblát, csoport, matematika és magyar oszlopnevekkel. A csoport változó legyen egy 5.a, 5.b és 5.c címkéket tetszőleges sorrendben tartalmazó faktor, a matematika és a magyar pedig 1-5 osztályzatokat tartalmazó numerikus vektor. df &lt;- data.frame( csoport=factor(rep(c(&quot;5.a&quot;, &quot;5.b&quot;, &quot;5.c&quot;), times=10)), matematika=sample(x = 1:5, size = 30, replace = T), magyar=sample(x = 1:5, size = 30, replace = T) ) df #&gt; csoport matematika magyar #&gt; 1 5.a 1 5 #&gt; 2 5.b 1 2 #&gt; 3 5.c 2 1 #&gt; 4 5.a 3 2 #&gt; 5 5.b 1 3 #&gt; 6 5.c 2 4 #&gt; 7 5.a 2 5 #&gt; 8 5.b 3 1 #&gt; 9 5.c 2 4 #&gt; 10 5.a 4 5 #&gt; 11 5.b 4 3 #&gt; 12 5.c 2 2 #&gt; 13 5.a 1 2 #&gt; 14 5.b 2 1 #&gt; 15 5.c 5 3 #&gt; 16 5.a 1 3 #&gt; 17 5.b 5 2 #&gt; 18 5.c 2 1 #&gt; 19 5.a 5 4 #&gt; 20 5.b 1 2 #&gt; 21 5.c 1 2 #&gt; 22 5.a 1 1 #&gt; 23 5.b 5 2 #&gt; 24 5.c 2 4 #&gt; 25 5.a 3 1 #&gt; 26 5.b 1 2 #&gt; 27 5.c 2 3 #&gt; 28 5.a 2 5 #&gt; 29 5.b 3 3 #&gt; 30 5.c 3 4 str(df) #&gt; &#39;data.frame&#39;: 30 obs. of 3 variables: #&gt; $ csoport : Factor w/ 3 levels &quot;5.a&quot;,&quot;5.b&quot;,&quot;5.c&quot;: 1 2 3 1 2 3 1 2 3 1 ... #&gt; $ matematika: int 1 1 2 3 1 2 2 3 2 4 ... #&gt; $ magyar : int 5 2 1 2 3 4 5 1 4 5 ... typeof(df) #&gt; [1] &quot;list&quot; class(df) #&gt; [1] &quot;data.frame&quot; length(df) #&gt; [1] 3 Írassuk ki a MASS csomag survey adattáblájának 3. sorában az 5. oszlopban lévő értéket! library(MASS) survey[3, 5] #&gt; [1] L on R #&gt; Levels: L on R Neither R on L Írassuk ki a MASS csomag survey adattáblájának 3. és 6. sorában sorában az 5. oszlopban lévő értékeket! Az adattábla típus maradjon meg! library(MASS) survey[c(3, 6), 5, drop=F] #&gt; Fold #&gt; 3 L on R #&gt; 6 L on R Írassuk ki a MASS csomag survey adattáblájának 3. és 6. sorából az összes adatértéket! library(MASS) survey[c(3, 6), ] #&gt; Sex Wr.Hnd NW.Hnd W.Hnd Fold Pulse Clap Exer Smoke Height M.I #&gt; 3 Male 18 13.3 Right L on R 87 Neither None Occas NA &lt;NA&gt; #&gt; 6 Female 18 17.7 Right L on R 64 Right Some Never 172.72 Imperial #&gt; Age #&gt; 3 16.917 #&gt; 6 21.000 Írassuk ki a MASS csomag survey adattábla Pulse oszlopát háromféle módszerrel! data(survey, package = &quot;MASS&quot;) # a `survey` beolvasása str(survey) #&gt; &#39;data.frame&#39;: 237 obs. of 12 variables: #&gt; $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 2 2 2 2 1 2 1 2 2 ... #&gt; $ Wr.Hnd: num 18.5 19.5 18 18.8 20 18 17.7 17 20 18.5 ... #&gt; $ NW.Hnd: num 18 20.5 13.3 18.9 20 17.7 17.7 17.3 19.5 18.5 ... #&gt; $ W.Hnd : Factor w/ 2 levels &quot;Left&quot;,&quot;Right&quot;: 2 1 2 2 2 2 2 2 2 2 ... #&gt; $ Fold : Factor w/ 3 levels &quot;L on R&quot;,&quot;Neither&quot;,..: 3 3 1 3 2 1 1 3 3 3 ... #&gt; $ Pulse : int 92 104 87 NA 35 64 83 74 72 90 ... #&gt; $ Clap : Factor w/ 3 levels &quot;Left&quot;,&quot;Neither&quot;,..: 1 1 2 2 3 3 3 3 3 3 ... #&gt; $ Exer : Factor w/ 3 levels &quot;Freq&quot;,&quot;None&quot;,..: 3 2 2 2 3 3 1 1 3 3 ... #&gt; $ Smoke : Factor w/ 4 levels &quot;Heavy&quot;,&quot;Never&quot;,..: 2 4 3 2 2 2 2 2 2 2 ... #&gt; $ Height: num 173 178 NA 160 165 ... #&gt; $ M.I : Factor w/ 2 levels &quot;Imperial&quot;,&quot;Metric&quot;: 2 1 NA 2 2 1 1 2 2 2 ... #&gt; $ Age : num 18.2 17.6 16.9 20.3 23.7 ... survey[, 6] # 1. módszer #&gt; [1] 92 104 87 NA 35 64 83 74 72 90 80 68 NA 66 60 NA 89 74 #&gt; [19] NA 78 72 72 64 62 64 90 90 62 76 79 76 78 72 70 54 66 #&gt; [37] NA 72 80 NA NA 72 60 80 70 NA 84 96 60 50 55 68 78 56 #&gt; [55] 65 NA 70 72 62 NA 66 72 70 NA 64 NA NA 64 NA 80 64 NA #&gt; [73] 68 40 88 68 76 NA 68 NA 66 76 98 NA 90 76 70 75 60 92 #&gt; [91] 75 NA 70 NA 65 NA 68 60 NA 68 NA 60 NA 72 80 80 NA 85 #&gt; [109] 64 67 76 80 75 60 60 70 70 83 100 100 80 76 92 59 66 NA #&gt; [127] 68 66 74 90 86 60 86 80 85 90 73 72 NA 68 84 NA 65 96 #&gt; [145] 68 75 64 60 92 64 76 80 92 69 68 76 NA 74 NA 84 80 NA #&gt; [163] 72 60 NA 81 70 65 NA 72 NA 80 50 48 68 104 76 84 NA 70 #&gt; [181] 68 87 79 70 90 72 79 65 62 63 92 60 68 72 NA 76 80 71 #&gt; [199] 80 80 61 48 76 86 80 83 76 84 97 NA 74 83 78 65 68 NA #&gt; [217] NA 88 NA 75 NA 70 88 NA NA 96 80 68 70 71 80 NA 85 88 #&gt; [235] NA 90 85 survey[, &quot;Pulse&quot;] # 2. módszer #&gt; [1] 92 104 87 NA 35 64 83 74 72 90 80 68 NA 66 60 NA 89 74 #&gt; [19] NA 78 72 72 64 62 64 90 90 62 76 79 76 78 72 70 54 66 #&gt; [37] NA 72 80 NA NA 72 60 80 70 NA 84 96 60 50 55 68 78 56 #&gt; [55] 65 NA 70 72 62 NA 66 72 70 NA 64 NA NA 64 NA 80 64 NA #&gt; [73] 68 40 88 68 76 NA 68 NA 66 76 98 NA 90 76 70 75 60 92 #&gt; [91] 75 NA 70 NA 65 NA 68 60 NA 68 NA 60 NA 72 80 80 NA 85 #&gt; [109] 64 67 76 80 75 60 60 70 70 83 100 100 80 76 92 59 66 NA #&gt; [127] 68 66 74 90 86 60 86 80 85 90 73 72 NA 68 84 NA 65 96 #&gt; [145] 68 75 64 60 92 64 76 80 92 69 68 76 NA 74 NA 84 80 NA #&gt; [163] 72 60 NA 81 70 65 NA 72 NA 80 50 48 68 104 76 84 NA 70 #&gt; [181] 68 87 79 70 90 72 79 65 62 63 92 60 68 72 NA 76 80 71 #&gt; [199] 80 80 61 48 76 86 80 83 76 84 97 NA 74 83 78 65 68 NA #&gt; [217] NA 88 NA 75 NA 70 88 NA NA 96 80 68 70 71 80 NA 85 88 #&gt; [235] NA 90 85 survey$Pulse # 3. módszer #&gt; [1] 92 104 87 NA 35 64 83 74 72 90 80 68 NA 66 60 NA 89 74 #&gt; [19] NA 78 72 72 64 62 64 90 90 62 76 79 76 78 72 70 54 66 #&gt; [37] NA 72 80 NA NA 72 60 80 70 NA 84 96 60 50 55 68 78 56 #&gt; [55] 65 NA 70 72 62 NA 66 72 70 NA 64 NA NA 64 NA 80 64 NA #&gt; [73] 68 40 88 68 76 NA 68 NA 66 76 98 NA 90 76 70 75 60 92 #&gt; [91] 75 NA 70 NA 65 NA 68 60 NA 68 NA 60 NA 72 80 80 NA 85 #&gt; [109] 64 67 76 80 75 60 60 70 70 83 100 100 80 76 92 59 66 NA #&gt; [127] 68 66 74 90 86 60 86 80 85 90 73 72 NA 68 84 NA 65 96 #&gt; [145] 68 75 64 60 92 64 76 80 92 69 68 76 NA 74 NA 84 80 NA #&gt; [163] 72 60 NA 81 70 65 NA 72 NA 80 50 48 68 104 76 84 NA 70 #&gt; [181] 68 87 79 70 90 72 79 65 62 63 92 60 68 72 NA 76 80 71 #&gt; [199] 80 80 61 48 76 86 80 83 76 84 97 NA 74 83 78 65 68 NA #&gt; [217] NA 88 NA 75 NA 70 88 NA NA 96 80 68 70 71 80 NA 85 88 #&gt; [235] NA 90 85 Írassuk ki a MASS csomag survey adattábla Pulse változójának első 3 elemét háromféle módszerrel! data(survey, package = &quot;MASS&quot;) # a `survey` beolvasása str(survey) #&gt; &#39;data.frame&#39;: 237 obs. of 12 variables: #&gt; $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 2 2 2 2 1 2 1 2 2 ... #&gt; $ Wr.Hnd: num 18.5 19.5 18 18.8 20 18 17.7 17 20 18.5 ... #&gt; $ NW.Hnd: num 18 20.5 13.3 18.9 20 17.7 17.7 17.3 19.5 18.5 ... #&gt; $ W.Hnd : Factor w/ 2 levels &quot;Left&quot;,&quot;Right&quot;: 2 1 2 2 2 2 2 2 2 2 ... #&gt; $ Fold : Factor w/ 3 levels &quot;L on R&quot;,&quot;Neither&quot;,..: 3 3 1 3 2 1 1 3 3 3 ... #&gt; $ Pulse : int 92 104 87 NA 35 64 83 74 72 90 ... #&gt; $ Clap : Factor w/ 3 levels &quot;Left&quot;,&quot;Neither&quot;,..: 1 1 2 2 3 3 3 3 3 3 ... #&gt; $ Exer : Factor w/ 3 levels &quot;Freq&quot;,&quot;None&quot;,..: 3 2 2 2 3 3 1 1 3 3 ... #&gt; $ Smoke : Factor w/ 4 levels &quot;Heavy&quot;,&quot;Never&quot;,..: 2 4 3 2 2 2 2 2 2 2 ... #&gt; $ Height: num 173 178 NA 160 165 ... #&gt; $ M.I : Factor w/ 2 levels &quot;Imperial&quot;,&quot;Metric&quot;: 2 1 NA 2 2 1 1 2 2 2 ... #&gt; $ Age : num 18.2 17.6 16.9 20.3 23.7 ... survey[1:3, 6] # 1. módszer #&gt; [1] 92 104 87 survey[1:3, &quot;Pulse&quot;] # 2. módszer #&gt; [1] 92 104 87 survey$Pulse[1:3] # 3. módszer #&gt; [1] 92 104 87 A HSAUR3 csomag Forbes2000 adattáblája 2000 vállalat adatát tartalmazza! Határozzuk meg a magyar cégek nevét és helyezését (country oszlop alapján)! Írassuk ki a képernyőre a 10 legnagyobb piaci értékkel (marketvalue oszlop) rendelkező cég nevét és piaci értékét! Határozzuk meg a legkisebb profittal (profits oszlop) rendelkező 5 cég minden adatát! Határozzuk meg a legnagyobb profittal (profits oszlop) rendelkező 10 amerikai vagy japán cég nevét, országát és profitját! # install.packages(&quot;HSAUR3&quot;) library(HSAUR3) str(Forbes2000) #&gt; &#39;data.frame&#39;: 2000 obs. of 8 variables: #&gt; $ rank : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ name : chr &quot;Citigroup&quot; &quot;General Electric&quot; &quot;American Intl Group&quot; &quot;ExxonMobil&quot; ... #&gt; $ country : Factor w/ 61 levels &quot;Africa&quot;,&quot;Australia&quot;,..: 60 60 60 60 56 60 56 28 60 60 ... #&gt; $ category : Factor w/ 27 levels &quot;Aerospace &amp; defense&quot;,..: 2 6 16 19 19 2 2 8 9 20 ... #&gt; $ sales : num 94.7 134.2 76.7 222.9 232.6 ... #&gt; $ profits : num 17.85 15.59 6.46 20.96 10.27 ... #&gt; $ assets : num 1264 627 648 167 178 ... #&gt; $ marketvalue: num 255 329 195 277 174 ... # a magyar cégek neve és helyezése Forbes2000[Forbes2000$country==&quot;Hungary&quot;,c(&quot;rank&quot;,&quot;name&quot;)] #&gt; rank name #&gt; 994 994 OTP Bank #&gt; 1002 1002 MOL # a 10 legnagyobb piaci értékkel rendelkező cég neve és piaci értéke Forbes2000[order(Forbes2000$marketvalue, decreasing=T)[1:10], c(&quot;name&quot;, &quot;marketvalue&quot;)] #&gt; name marketvalue #&gt; 2 General Electric 328.54 #&gt; 31 Microsoft 287.02 #&gt; 24 Pfizer 285.27 #&gt; 4 ExxonMobil 277.02 #&gt; 1 Citigroup 255.30 #&gt; 10 Wal-Mart Stores 243.74 #&gt; 58 Intel 196.87 #&gt; 3 American Intl Group 194.87 #&gt; 7 HSBC Group 177.96 #&gt; 354 Vodafone 174.61 # a legkisebb profittal rendelkező 5 cég minden adata Forbes2000[order(Forbes2000$profits)[1:5],] #&gt; rank name country category sales #&gt; 364 364 Deutsche Telekom Germany Telecommunications services 56.40 #&gt; 374 374 France Telecom France Telecommunications services 57.99 #&gt; 403 403 Mizuho Financial Japan Banking 24.40 #&gt; 687 687 mmO2 United Kingdom Telecommunications services 7.70 #&gt; 354 354 Vodafone United Kingdom Telecommunications services 47.99 #&gt; profits assets marketvalue #&gt; 364 -25.83 132.01 84.18 #&gt; 374 -21.78 107.86 64.36 #&gt; 403 -20.11 1115.90 30.87 #&gt; 687 -16.03 21.12 14.69 #&gt; 354 -15.51 256.28 174.61 # a legnagyobb profittal rendelkező 10 amerikai vagy japán cég neve, országa és profitja Forbes2000.USA.Japan &lt;- Forbes2000[Forbes2000$country == &quot;United States&quot; | Forbes2000$country == &quot;Japan&quot;,] Forbes2000.USA.Japan[order(Forbes2000.USA.Japan$profits,decreasing=T)[1:10], c(&quot;name&quot;,&quot;country&quot;,&quot;profits&quot;)] #&gt; name country profits #&gt; 4 ExxonMobil United States 20.96 #&gt; 1 Citigroup United States 17.85 #&gt; 2 General Electric United States 15.59 #&gt; 6 Bank of America United States 10.81 #&gt; 20 Freddie Mac United States 10.09 #&gt; 22 Altria Group United States 9.20 #&gt; 10 Wal-Mart Stores United States 9.05 #&gt; 31 Microsoft United States 8.88 #&gt; 8 Toyota Motor Japan 7.99 #&gt; 16 IBM United States 7.58 A.22 Megoldások az 5.4.4 feladatokhoz Konvertáljuk dátummá a következő két sztringet: \"6November2020\", \"2013-02-29\"! Utóbbi esetben mi lehet a hiba oka? as.Date(&quot;6November2020&quot;,&quot;%d%B%Y&quot;) # ez rendben van #&gt; [1] &quot;2020-11-06&quot; # as.Date(&quot;2013-02-29&quot;) # nem létező dátum !!! A seq() függvény from= és to= argumentuma a dátum típusú objektumokkal is működik. A by= argumentum értéke ilyenkor lehet numerikus (ekkor napokat jelent), de lehet x weeks, x months vagy x years, ahol x nullánál nagyobb egész lehet. Hozzunk létre egy dátum-vektort 2020 összes hétfőjének dátumával! d1 &lt;- as.Date(&quot;2020-01-06&quot;) d2 &lt;- as.Date(&quot;2020-12-28&quot;) x &lt;- seq(from=d1, to=d2, by=&quot;weeks&quot;) x #&gt; [1] &quot;2020-01-06&quot; &quot;2020-01-13&quot; &quot;2020-01-20&quot; &quot;2020-01-27&quot; &quot;2020-02-03&quot; #&gt; [6] &quot;2020-02-10&quot; &quot;2020-02-17&quot; &quot;2020-02-24&quot; &quot;2020-03-02&quot; &quot;2020-03-09&quot; #&gt; [11] &quot;2020-03-16&quot; &quot;2020-03-23&quot; &quot;2020-03-30&quot; &quot;2020-04-06&quot; &quot;2020-04-13&quot; #&gt; [16] &quot;2020-04-20&quot; &quot;2020-04-27&quot; &quot;2020-05-04&quot; &quot;2020-05-11&quot; &quot;2020-05-18&quot; #&gt; [21] &quot;2020-05-25&quot; &quot;2020-06-01&quot; &quot;2020-06-08&quot; &quot;2020-06-15&quot; &quot;2020-06-22&quot; #&gt; [26] &quot;2020-06-29&quot; &quot;2020-07-06&quot; &quot;2020-07-13&quot; &quot;2020-07-20&quot; &quot;2020-07-27&quot; #&gt; [31] &quot;2020-08-03&quot; &quot;2020-08-10&quot; &quot;2020-08-17&quot; &quot;2020-08-24&quot; &quot;2020-08-31&quot; #&gt; [36] &quot;2020-09-07&quot; &quot;2020-09-14&quot; &quot;2020-09-21&quot; &quot;2020-09-28&quot; &quot;2020-10-05&quot; #&gt; [41] &quot;2020-10-12&quot; &quot;2020-10-19&quot; &quot;2020-10-26&quot; &quot;2020-11-02&quot; &quot;2020-11-09&quot; #&gt; [46] &quot;2020-11-16&quot; &quot;2020-11-23&quot; &quot;2020-11-30&quot; &quot;2020-12-07&quot; &quot;2020-12-14&quot; #&gt; [51] &quot;2020-12-21&quot; &quot;2020-12-28&quot; typeof(x) #&gt; [1] &quot;double&quot; class(x) #&gt; [1] &quot;Date&quot; length(x) #&gt; [1] 52 A Halley-üstökös utoljára 1986-ban járt a Naprendszerünkben, így az előrejelzések szerint legközelebb 2061. július 26-ban tér vissza. Rögzítsük ezt dátumként, és számoljuk ki, hány napotot kell még várni az üstökös érkezésére. as.Date(&quot;2061-07-26&quot;)-Sys.Date() #&gt; Time difference of 14258 days # vagy as.Date(&quot;2061. július 26.&quot;, format=&quot;%Y. %B %d.&quot;)-Sys.Date() #&gt; Time difference of 14258 days A.23 Megoldások az 6.1.4 feladatokhoz Olvassuk be a https://onlinestatbook.com/2/case_studies/data/leniency.xls Excel állományt, állapítsuk meg hány sora és oszlopa van. library(rio) df &lt;- import(file = &quot;https://onlinestatbook.com/2/case_studies/data/leniency.xls&quot;) str(df) #&gt; &#39;data.frame&#39;: 136 obs. of 2 variables: #&gt; $ smile : num 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ leniency: num 2.5 5.5 6.5 3.5 3 3.5 6 5 4 4.5 ... Az adatbázisnak 136 sora és 2 oszlopa van. Olvassuk be a https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv tagolt szöveges állományt, állapítsuk meg hány sora és oszlopa van. library(rio) df &lt;- read.table(file = &quot;https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv&quot;, header=T, sep=&quot;,&quot;, dec=&quot;.&quot;) str(df) #&gt; &#39;data.frame&#39;: 95 obs. of 21 variables: #&gt; $ X : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ gender : chr &quot;male&quot; &quot;female&quot; &quot;male&quot; &quot;male&quot; ... #&gt; $ age : chr &quot;21-24&quot; &quot;21-24&quot; &quot;21-24&quot; &quot;18-20&quot; ... #&gt; $ country : chr &quot;australia&quot; &quot;australia&quot; &quot;australia&quot; &quot;australia&quot; ... #&gt; $ marital : chr &quot;other&quot; &quot;single&quot; &quot;single&quot; &quot;single&quot; ... #&gt; $ livewith : chr &quot;partner&quot; &quot;partner&quot; &quot;residences&quot; &quot;parents&quot; ... #&gt; $ employment : chr &quot;employed part-time&quot; &quot;parental support&quot; &quot;employed part-time&quot; &quot;employed part-time&quot; ... #&gt; $ firstyr : chr &quot;other&quot; &quot;other&quot; &quot;other&quot; &quot;first year&quot; ... #&gt; $ enrolment : chr &quot;full-time&quot; &quot;full-time&quot; &quot;full-time&quot; &quot;full-time&quot; ... #&gt; $ emotional : int 22 21 21 19 16 20 20 20 24 13 ... #&gt; $ emotionalsat: int 23 20 18 19 19 17 23 20 25 18 ... #&gt; $ tangible : int 17 12 16 20 11 16 20 16 20 6 ... #&gt; $ tangiblesat : int 18 10 16 17 15 15 20 16 20 14 ... #&gt; $ affect : int 15 10 15 11 6 12 14 12 15 6 ... #&gt; $ affectsat : int 15 6 15 11 10 14 15 12 15 12 ... #&gt; $ psi : int 12 9 13 13 11 12 15 12 12 6 ... #&gt; $ psisat : int 13 6 12 12 12 11 15 12 15 11 ... #&gt; $ esupport : int 13 12 14 15 9 13 15 13 16 10 ... #&gt; $ psupport : int 11 7 13 15 7 12 10 11 NA 8 ... #&gt; $ supsources : int 13 10 14 15 9 13 13 11 NA 9 ... #&gt; $ BDI : int 5 8 16 0 9 0 1 14 12 20 ... Az adatbázisnak 95 sora és 21 oszlopa van. A.24 Megoldások az 6.3.7 feladatokhoz 1 A cat() függvénnyel a dput()-hoz hasonlóan szöveges állományba írhatjuk egy karakteres, numerikus vagy logikai vektor értékét. Mindkét függvénnyel végezzük el a kiírást, és vessük össze a kapott szöveges állományok tartalmát! # karakteres, numerikus és logikai vektor előkészítése vekt.1 &lt;- &quot;Helló világ!&quot; vekt.2 &lt;- c(&quot;Péter&quot;, &quot;Károly&quot;) vekt.3 &lt;- 1:20 vekt.4 &lt;- c(T, F, T) # kiírás cat()-tel cat(vekt.1, vekt.2, vekt.3, vekt.4, file = &quot;output/adat/cat_out.txt&quot;, sep=&quot;\\n&quot;) # kiírás dput()-tal dput(x = vekt.1, file = &quot;output/adat/dput_1_out.txt&quot;) dput(x = vekt.2, file = &quot;output/adat/dput_2_out.txt&quot;) dput(x = vekt.3, file = &quot;output/adat/dput_3_out.txt&quot;) dput(x = vekt.4, file = &quot;output/adat/dput_4_out.txt&quot;) A cat() függvénynek igazán nincs jelentősége objektumok értékének megőrzésében (kiírásában és később visszaolvasásában), inkább csak az érdekesség miatt említettük. Láthatjuk, hogy a cat() függvénnyel egyetlen szöveges állományban több vektor értékét elhelyezhetjük, és a kutató könnyen áttekinthető ezeket az értékeket. Azonban ezek visszaolvasása már nehézségbe ütközik. A dput()-tal kiírt objektumok viszont könnyen visszaolvashatók a dget() segítségével. A cat() függvénnyel tipikusan a konzolba írunk. # visszaolvasás dget()-tel uj.vekt.1 &lt;- dget(file = &quot;output/adat/dput_1_out.txt&quot;) uj.vekt.2 &lt;- dget(file = &quot;output/adat/dput_2_out.txt&quot;) uj.vekt.3 &lt;- dget(file = &quot;output/adat/dput_3_out.txt&quot;) uj.vekt.4 &lt;- dget(file = &quot;output/adat/dput_4_out.txt&quot;) A Kaggle egyik adatbázisában 4000 videójáték értékelése található. Töltsük le a CSV adatállományt, és nyissuk meg. Keressük meg az R-bloggers oldalon az adatállományhoz kapcsolódó cikket, és próbáljunk ki néhány elemző parancsot. A blogger melyik csomag, melyik függvényével végezte a beolvasást? A blogger a datatable fread() függvényével olvasta be az adatokat. Mi az Alap R read.table() függvényét választjuk. df.meta &lt;- read.table(file = &quot;adat/metacritic_games.csv&quot;, header=T, sep=&quot;,&quot;, dec=&quot;.&quot;, quote = &quot;\\&quot;&quot;, comment.char = &quot;&quot;, fileEncoding = &quot;UTF-8&quot;) str(df.meta) #&gt; &#39;data.frame&#39;: 5699 obs. of 15 variables: #&gt; $ game : chr &quot;Portal 2&quot; &quot;The Elder Scrolls V: Skyrim&quot; &quot;The Legend of Zelda: Ocarina of Time 3D&quot; &quot;Batman: Arkham City&quot; ... #&gt; $ platform : chr &quot;PC&quot; &quot;PC&quot; &quot;3DS&quot; &quot;PC&quot; ... #&gt; $ developer : chr &quot;Valve Software&quot; &quot;Bethesda Game Studios&quot; &quot;GREZZO&quot; &quot;Rocksteady Studios&quot; ... #&gt; $ genre : chr &quot;Action&quot; &quot;Role-Playing&quot; &quot;Miscellaneous&quot; &quot;Action Adventure&quot; ... #&gt; $ number_players : chr &quot;&quot; &quot;No Online Multiplayer&quot; &quot;No Online Multiplayer&quot; &quot;&quot; ... #&gt; $ rating : chr &quot;E10+&quot; &quot;M&quot; &quot;E10+&quot; &quot;T&quot; ... #&gt; $ release_date : chr &quot;Apr 18, 2011&quot; &quot;Nov 10, 2011&quot; &quot;Jun 19, 2011&quot; &quot;Nov 21, 2011&quot; ... #&gt; $ positive_critics: int 51 32 84 27 81 52 31 62 14 60 ... #&gt; $ neutral_critics : int 1 0 1 0 1 0 0 0 0 1 ... #&gt; $ negative_critics: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ positive_users : int 1700 1616 283 240 251 520 34 187 33 1061 ... #&gt; $ neutral_users : int 107 322 20 34 39 112 4 44 8 191 ... #&gt; $ negative_users : int 19 451 5 27 11 78 2 29 10 271 ... #&gt; $ metascore : int 95 94 94 91 90 90 90 90 89 89 ... #&gt; $ user_score : int 90 82 90 87 84 85 83 84 71 76 ... Keressük fel és tanulmányozzuk a Great R packages for data import, wrangling and visualization oldalt! A bevezetésben lefektetett alapelvek közül melyiket erősíti meg ez az oldal? Az oldalon számos lehetőséget találunk adatok beolvasására és kezelésére. Ugyanarra a problémára számos eltérő megoldás van, például egy tagolt szöveges állományt beolvashatjuk a base, tidyr, rio vagy datatable csomag megfelelő függvényével is (Svájci bicska). Ha átböngésszük az oldalt felfedezhetünk olyan megoldásokat, amelyek kiegészítik az alaptudásunkat (Magabiztosság), de egy bizonyos idő után ezek az újdonságok is beépülhetnek a saját eszköztárunkba (Gyakorlás). Töltsünk le 10 érdekesnek tűnő adatállományt a 19 Places to Find Free Data Sets for Data Science Projects oldalról, és nyissuk meg őket! "],["szinek.html", "B Színek B.1 Az előre definiált paletta színei B.2 Színek választása az RColorBrewer csomag segítségével B.3 Színek választása a dichromat csomag segítségével B.4 Színek választása egyéb paletta segítségével B.5 A 657 színnév", " B Színek Az R grafikus elemeinek a színét magunk is megválaszthatjuk. Ehhez nyújt segítséget ez a függelék. Megismerjük az előre definiált paletta színeit (B.1 fejezet), színek választását az RColorBrewer csomag segítségével (B.2 fejezet), színek választása a dichromat csomag segítségével (B.3 fejezet), színek választását egyéb paletták segítségével (B.4 fejezet), és végül az előre definiált 657 színnevet (B.5 fejezet). B.1 Az előre definiált paletta színei Az előre definiált paletta 8 színt tartalmaz. A B.1 ábra az alapértelmezett színeket tartalmazza. Az előre definiált paletta egyes színeit sorszámokkal (1, 2 stb.) tudjuk elérni, amelyeket rendszerint a rajzfüggvények col= argumentumában kell elhelyezni. Az 1. szín a palettán a fekete, a második a piros, és így tovább. set.seed(0) x &lt;- rpois(n = 50, lambda = 100) par(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1)) bar &lt;- barplot(x[1:8], col = 1:8, names.arg = 1:8) mtext(side = 1, at = bar, text = palette(), line = 1) ÁBRA B.1: Az alapértelmezett paletta 8 színének sorszáma és neve Más színeket is alapértelmezetté tehetünk, sőt a színek számát is megnövelhetjük a palettán. Ennek a legegyszerűbb módja, ha a palette() függvény argumentumában színkódokat tartalmazó karakteres vektort adunk meg. szinek &lt;- c(&quot;#E84F2C&quot;, &quot;#E31307&quot;, &quot;#E84F2C&quot;, &quot;#E4BA51&quot;, &quot;#E3B786&quot;, &quot;#825846&quot;, &quot;#59392A&quot;, &quot;#564C30&quot;, &quot;#897D6E&quot;, &quot;#627C82&quot;, &quot;#93AF8A&quot;, &quot;#A0BA5E&quot;, &quot;#63BA5E&quot;, &quot;#5EBAB2&quot;, &quot;#6596B7&quot;) palette(value = szinek) A rajzfüggvények ezután a paletta új színeit használják. barplot(x[1:15], col = 1:15) Ha megváltoztattuk a paletta színeit, akkor az alapértelmezett színekhez a palette(\"default\") paranccsal térhetünk vissza. palette(value = &quot;default&quot;) # alapértelmezett paletta visszaállítása B.2 Színek választása az RColorBrewer csomag segítségével Az RColorBrewer csomag brewer.pal() függvénye szolgál az előre definiált színpaletták alapján színkódokat tartalmazó vektor létrehozására. A függvény általános alakja: library(RColorBrewer) brewer.pal(n, name) Az n= a kívánt színek számát határozza meg, amely háromnál nem lehet kevesebb. A name= a színpaletta nevét tartalmazza. A választható neveket a brewer.pal.info adattábla tartalmazza, amely a palettából elérhető összes szín számát és a paletta típusát is tartalmazza. Ez utóbbi a category oszlopban olvasható, amelynek lehetséges értékei: seq, div és qual. A szekvenciális palettákat (seq) rendezett adatok ábrázolására használhatjuk: a világosabb színek a kisebb értékeket, a sötétebbek a nagyobbakat szemléltethetik. A divergens (div) paletták a középső részt világosabb színekkel, a szélső értékeket sötétebb színekkel jelenítik meg. A kvalitatív (qual) paletta kategorikus változók megjelenítésére használható. library(RColorBrewer) brewer.pal.info #&gt; maxcolors category colorblind #&gt; BrBG 11 div TRUE #&gt; PiYG 11 div TRUE #&gt; PRGn 11 div TRUE #&gt; PuOr 11 div TRUE #&gt; RdBu 11 div TRUE #&gt; RdGy 11 div FALSE #&gt; RdYlBu 11 div TRUE #&gt; RdYlGn 11 div FALSE #&gt; Spectral 11 div FALSE #&gt; Accent 8 qual FALSE #&gt; Dark2 8 qual TRUE #&gt; Paired 12 qual TRUE #&gt; Pastel1 9 qual FALSE #&gt; Pastel2 8 qual FALSE #&gt; Set1 9 qual FALSE #&gt; Set2 8 qual TRUE #&gt; Set3 12 qual FALSE #&gt; Blues 9 seq TRUE #&gt; BuGn 9 seq TRUE #&gt; BuPu 9 seq TRUE #&gt; GnBu 9 seq TRUE #&gt; Greens 9 seq TRUE #&gt; Greys 9 seq TRUE #&gt; Oranges 9 seq TRUE #&gt; OrRd 9 seq TRUE #&gt; PuBu 9 seq TRUE #&gt; PuBuGn 9 seq TRUE #&gt; PuRd 9 seq TRUE #&gt; Purples 9 seq TRUE #&gt; RdPu 9 seq TRUE #&gt; Reds 9 seq TRUE #&gt; YlGn 9 seq TRUE #&gt; YlGnBu 9 seq TRUE #&gt; YlOrBr 9 seq TRUE #&gt; YlOrRd 9 seq TRUE A továbbiakban a brewer.pal() függvény használatára mutatunk példát: # az x adatvektor beállítása set.seed(0) x &lt;- rpois(n = 50, lambda = 100) # grafikus paraméterek beállítása par(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1)) library(RColorBrewer) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;BrBG&quot;), names.arg = 1:11, main = &quot;BrBG, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;BrBG&quot;), names.arg = 1:11, main = &quot;BrBG, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;PiYG&quot;), names.arg = 1:11, main = &quot;PiYG, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;PiYG&quot;), names.arg = 1:11, main = &quot;PiYG, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;PRGn&quot;), names.arg = 1:11, main = &quot;PRGn, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;PRGn&quot;), names.arg = 1:11, main = &quot;PRGn, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;PuOr&quot;), names.arg = 1:11, main = &quot;PuOr, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;PuOr&quot;), names.arg = 1:11, main = &quot;PuOr, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdBu&quot;), names.arg = 1:11, main = &quot;RdBu, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdBu&quot;), names.arg = 1:11, main = &quot;RdBu, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdGy&quot;), names.arg = 1:11, main = &quot;RdGy, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdGy&quot;), names.arg = 1:11, main = &quot;RdGy, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdYlBu&quot;), names.arg = 1:11, main = &quot;RdYlBu, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdYlBu&quot;), names.arg = 1:11, main = &quot;RdYlBu, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdYlGn&quot;), names.arg = 1:11, main = &quot;RdYlGn, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;RdYlGn&quot;), names.arg = 1:11, main = &quot;RdYlGn, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;Spectral&quot;), names.arg = 1:11, main = &quot;Spectral, div&quot;) barplot(x[1:11], col = brewer.pal(n = 11, name = &quot;Spectral&quot;), names.arg = 1:11, main = &quot;Spectral, div&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Accent&quot;), names.arg = 1:8, main = &quot;Accent, qual&quot;) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Accent&quot;), names.arg = 1:8, main = &quot;Accent, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Dark2&quot;), names.arg = 1:8, main = &quot;Dark2, qual&quot;) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Dark2&quot;), names.arg = 1:8, main = &quot;Dark2, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:12], col = brewer.pal(n = 12, name = &quot;Paired&quot;), names.arg = 1:12, main = &quot;Paired, qual&quot;) barplot(x[1:12], col = brewer.pal(n = 12, name = &quot;Paired&quot;), names.arg = 1:12, main = &quot;Paired, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Pastel1&quot;), names.arg = 1:9, main = &quot;Pastel1, qual&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Pastel1&quot;), names.arg = 1:9, main = &quot;Pastel1, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Pastel2&quot;), names.arg = 1:8, main = &quot;Pastel2, qual&quot;) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Pastel2&quot;), names.arg = 1:8, main = &quot;Pastel2, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Set1&quot;), names.arg = 1:9, main = &quot;Set1, qual&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Set1&quot;), names.arg = 1:9, main = &quot;Set1, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Set2&quot;), names.arg = 1:8, main = &quot;Set2, qual&quot;) barplot(x[1:8], col = brewer.pal(n = 8, name = &quot;Set2&quot;), names.arg = 1:8, main = &quot;Set2, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:12], col = brewer.pal(n = 12, name = &quot;Set3&quot;), names.arg = 1:12, main = &quot;Set3, qual&quot;) barplot(x[1:12], col = brewer.pal(n = 12, name = &quot;Set3&quot;), names.arg = 1:12, main = &quot;Set3, qual&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Blues&quot;), names.arg = 1:9, main = &quot;Blues, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Blues&quot;), names.arg = 1:9, main = &quot;Blues, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;BuGn&quot;), names.arg = 1:9, main = &quot;BuGn, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;BuGn&quot;), names.arg = 1:9, main = &quot;BuGn, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;BuPu&quot;), names.arg = 1:9, main = &quot;BuPu, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;BuPu&quot;), names.arg = 1:9, main = &quot;BuPu, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;GnBu&quot;), names.arg = 1:9, main = &quot;GnBu, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;GnBu&quot;), names.arg = 1:9, main = &quot;GnBu, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Greens&quot;), names.arg = 1:9, main = &quot;Greens, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Greens&quot;), names.arg = 1:9, main = &quot;Greens, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Greys&quot;), names.arg = 1:9, main = &quot;Greys, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Greys&quot;), names.arg = 1:9, main = &quot;Greys, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Oranges&quot;), names.arg = 1:9, main = &quot;Oranges, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Oranges&quot;), names.arg = 1:9, main = &quot;Oranges, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;OrRd&quot;), names.arg = 1:9, main = &quot;OrRd, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;OrRd&quot;), names.arg = 1:9, main = &quot;OrRd, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;PuBu&quot;), names.arg = 1:9, main = &quot;PuBu, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;PuBu&quot;), names.arg = 1:9, main = &quot;PuBu, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;PuBuGn&quot;), names.arg = 1:9, main = &quot;PuBuGn, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;PuBuGn&quot;), names.arg = 1:9, main = &quot;PuBuGn, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;PuRd&quot;), names.arg = 1:9, main = &quot;PuRd, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;PuRd&quot;), names.arg = 1:9, main = &quot;PuRd, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Purples&quot;), names.arg = 1:9, main = &quot;Purples, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Purples&quot;), names.arg = 1:9, main = &quot;Purples, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;RdPu&quot;), names.arg = 1:9, main = &quot;RdPu, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;RdPu&quot;), names.arg = 1:9, main = &quot;RdPu, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Reds&quot;), names.arg = 1:9, main = &quot;Reds, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;Reds&quot;), names.arg = 1:9, main = &quot;Reds, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlGn&quot;), names.arg = 1:9, main = &quot;YlGn, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlGn&quot;), names.arg = 1:9, main = &quot;YlGn, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlGnBu&quot;), names.arg = 1:9, main = &quot;YlGnBu, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlGnBu&quot;), names.arg = 1:9, main = &quot;YlGnBu, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlOrBr&quot;), names.arg = 1:9, main = &quot;YlOrBr, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlOrBr&quot;), names.arg = 1:9, main = &quot;YlOrBr, seq&quot;, border = NA) par(mfrow = c(1, 2)) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlOrRd&quot;), names.arg = 1:9, main = &quot;YlOrRd, seq&quot;) barplot(x[1:9], col = brewer.pal(n = 9, name = &quot;YlOrRd&quot;), names.arg = 1:9, main = &quot;YlOrRd, seq&quot;, border = NA) B.3 Színek választása a dichromat csomag segítségével A dichromat csomag színsémai közül is választhatunk. A színsémákat a colorschemes lista tartalmazza. A lisatelemek neve: library(dichromat) names(colorschemes) #&gt; [1] &quot;BrowntoBlue.10&quot; &quot;BrowntoBlue.12&quot; &quot;BluetoDarkOrange.12&quot; #&gt; [4] &quot;BluetoDarkOrange.18&quot; &quot;DarkRedtoBlue.12&quot; &quot;DarkRedtoBlue.18&quot; #&gt; [7] &quot;BluetoGreen.14&quot; &quot;BluetoGray.8&quot; &quot;BluetoOrangeRed.14&quot; #&gt; [10] &quot;BluetoOrange.10&quot; &quot;BluetoOrange.12&quot; &quot;BluetoOrange.8&quot; #&gt; [13] &quot;LightBluetoDarkBlue.10&quot; &quot;LightBluetoDarkBlue.7&quot; &quot;Categorical.12&quot; #&gt; [16] &quot;GreentoMagenta.16&quot; &quot;SteppedSequential.5&quot; Példák színek választására: # az x adatvektor beállítása set.seed(0) x &lt;- rpois(n = 50, lambda = 100) # grafikus paraméterek beállítása par(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1)) library(dichromat) par(mfrow=c(1,2)) barplot(x[1:10], col = colorschemes$BrowntoBlue.10, names.arg = 1:10, main = &quot;BrowntoBlue.10&quot;) barplot(x[1:10], col = colorschemes$BrowntoBlue.10, names.arg = 1:10, main = &quot;BrowntoBlue.10&quot;, border=NA) par(mfrow=c(1,2)) barplot(x[1:12], col = colorschemes$BrowntoBlue.12, names.arg = 1:12, main = &quot;BrowntoBlue.12&quot;) barplot(x[1:12], col = colorschemes$BrowntoBlue.12, names.arg = 1:12, main = &quot;BrowntoBlue.12&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:12], col = colorschemes$BluetoDarkOrange.12, names.arg = 1:12, main = &quot;BluetoDarkOrange.12&quot;) barplot(x[1:12], col = colorschemes$BluetoDarkOrange.12, names.arg = 1:12, main = &quot;BluetoDarkOrange.12&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:18], col = colorschemes$BluetoDarkOrange.18, names.arg = 1:18, main = &quot;BluetoDarkOrange.18&quot;) barplot(x[1:18], col = colorschemes$BluetoDarkOrange.18, names.arg = 1:18, main = &quot;BluetoDarkOrange.18&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:12], col = colorschemes$DarkRedtoBlue.12, names.arg = 1:12, main = &quot;DarkRedtoBlue.12&quot;) barplot(x[1:12], col = colorschemes$DarkRedtoBlue.12, names.arg = 1:12, main = &quot;DarkRedtoBlue.12&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:18], col = colorschemes$DarkRedtoBlue.18, names.arg = 1:18, main = &quot;DarkRedtoBlue.18&quot;) barplot(x[1:18], col = colorschemes$DarkRedtoBlue.18, names.arg = 1:18, main = &quot;DarkRedtoBlue.18&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:14], col = colorschemes$BluetoGreen.14, names.arg = 1:14, main = &quot;BluetoGreen.14&quot;) barplot(x[1:14], col = colorschemes$BluetoGreen.14, names.arg = 1:14, main = &quot;BluetoGreen.14&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:8], col = colorschemes$BluetoGray.8, names.arg = 1:8, main = &quot;BluetoGray.8&quot;) barplot(x[1:8], col = colorschemes$BluetoGray.8, names.arg = 1:8, main = &quot;BluetoGray.8&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:14], col = colorschemes$BluetoOrangeRed.14, names.arg = 1:14, main = &quot;BluetoOrangeRed.14&quot;) barplot(x[1:14], col = colorschemes$BluetoOrangeRed.14, names.arg = 1:14, main = &quot;BluetoOrangeRed.14&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:10], col = colorschemes$BluetoOrange.10, names.arg = 1:10, main = &quot;BluetoOrange.10&quot;) barplot(x[1:10], col = colorschemes$BluetoOrange.10, names.arg = 1:10, main = &quot;BluetoOrange.10&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:12], col = colorschemes$BluetoOrange.12, names.arg = 1:12, main = &quot;BluetoOrange.12&quot;) barplot(x[1:12], col = colorschemes$BluetoOrange.12, names.arg = 1:12, main = &quot;BluetoOrange.12&quot;, border = T) par(mfrow=c(1,2)) barplot(x[1:8], col = colorschemes$BluetoOrange.8, names.arg = 1:8, main = &quot;BluetoOrange.8&quot;) barplot(x[1:8], col = colorschemes$BluetoOrange.8, names.arg = 1:8, main = &quot;BluetoOrange.8&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:10], col = colorschemes$LightBluetoDarkBlue.10, names.arg = 1:10, main = &quot;LightBluetoDarkBlue.10&quot;) barplot(x[1:10], col = colorschemes$LightBluetoDarkBlue.10, names.arg = 1:10, main = &quot;LightBluetoDarkBlue.10&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:7], col = colorschemes$LightBluetoDarkBlue.7, names.arg = 1:7, main = &quot;LightBluetoDarkBlue.7&quot;) barplot(x[1:7], col = colorschemes$LightBluetoDarkBlue.7, names.arg = 1:7, main = &quot;LightBluetoDarkBlue.7&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:12], col = colorschemes$Categorical.12, names.arg = 1:12, main = &quot;Categorical.12&quot;) barplot(x[1:12], col = colorschemes$Categorical.12, names.arg = 1:12, main = &quot;Categorical.12&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = colorschemes$GreentoMagenta.16, names.arg = 1:16, main = &quot;GreentoMagenta.16&quot;) barplot(x[1:16], col = colorschemes$GreentoMagenta.16, names.arg = 1:16, main = &quot;GreentoMagenta.16&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:25], col = colorschemes$SteppedSequential.5, names.arg = 1:25, main = &quot;SteppedSequential.5&quot;) barplot(x[1:25], col = colorschemes$SteppedSequential.5, names.arg = 1:25, main = &quot;SteppedSequential.5&quot;, border = NA) B.4 Színek választása egyéb paletta segítségével Színpaletta létrehozásához több beépített lehetőségek közül is választhatunk. rainbow(n, start=0, end, alpha = 1) heat.colors(n, alpha = 1) terrain.colors(n, alpha = 1) topo.colors(n, alpha = 1) cm.colors(n, alpha = 1) Az n= argumentum a létrehozandó színek számát jelenti. Példák színpaletta létrehozására: # az x adatvektor beállítása set.seed(0) x &lt;- rpois(n = 50, lambda = 100) # grafikus paraméterek beállítása par(las = 1, mgp = c(0, 0.2, 0), tcl = -0.2, mar = c(3, 2, 1, 1)) par(mfrow=c(1,2)) barplot(x[1:16], col = rainbow(16), names.arg = 1:16, main = &quot;rainbow(n=16)&quot;) barplot(x[1:16], col = rainbow(16), names.arg = 1:16, main = &quot;rainbow(n=16)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = rainbow(16, start = 0, end = 0.2), names.arg = 1:16, main = &quot;rainbow(n=16, start=0, end=0.2)&quot;) barplot(x[1:16], col = rainbow(16, start = 0, end = 0.2), names.arg = 1:16, main = &quot;rainbow(n=16, start=0, end=0.2)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = rainbow(16, start = 0, end = 0.5), names.arg = 1:16, main = &quot;rainbow(n=16, start=0, end=0.5)&quot;) barplot(x[1:16], col = rainbow(16, start = 0, end = 0.5), names.arg = 1:16, main = &quot;rainbow(n=16, start=0, end=0.5)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = rainbow(16, start = 0, end = 0.8), names.arg = 1:16, main = &quot;rainbow(n=16, start=0, end=0.8)&quot;) barplot(x[1:16], col = rainbow(16, start = 0, end = 0.8), names.arg = 1:16, main = &quot;rainbow(n=16, start=0, end=0.8)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = heat.colors(16), names.arg = 1:16, main = &quot;heat.colors(n=16)&quot;) barplot(x[1:16], col = heat.colors(16), names.arg = 1:16, main = &quot;heat.colors(n=16)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = terrain.colors(16), names.arg = 1:16, main = &quot;terrain.colors(n=16)&quot;) barplot(x[1:16], col = terrain.colors(16), names.arg = 1:16, main = &quot;terrain.colors(n=16)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = topo.colors(16), names.arg = 1:16, main = &quot;topo.colors(n=16)&quot;) barplot(x[1:16], col = topo.colors(16), names.arg = 1:16, main = &quot;topo.colors(n=16)&quot;, border = NA) par(mfrow=c(1,2)) barplot(x[1:16], col = cm.colors(16), names.arg = 1:16, main = &quot;cm.colors(n=16)&quot;) barplot(x[1:16], col = cm.colors(16), names.arg = 1:16, main = &quot;cm.colors(n=16)&quot;, border = NA) B.5 A 657 színnév colors() #&gt; [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; #&gt; [4] &quot;antiquewhite1&quot; &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; #&gt; [7] &quot;antiquewhite4&quot; &quot;aquamarine&quot; &quot;aquamarine1&quot; #&gt; [10] &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; #&gt; [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; #&gt; [16] &quot;azure3&quot; &quot;azure4&quot; &quot;beige&quot; #&gt; [19] &quot;bisque&quot; &quot;bisque1&quot; &quot;bisque2&quot; #&gt; [22] &quot;bisque3&quot; &quot;bisque4&quot; &quot;black&quot; #&gt; [25] &quot;blanchedalmond&quot; &quot;blue&quot; &quot;blue1&quot; #&gt; [28] &quot;blue2&quot; &quot;blue3&quot; &quot;blue4&quot; #&gt; [31] &quot;blueviolet&quot; &quot;brown&quot; &quot;brown1&quot; #&gt; [34] &quot;brown2&quot; &quot;brown3&quot; &quot;brown4&quot; #&gt; [37] &quot;burlywood&quot; &quot;burlywood1&quot; &quot;burlywood2&quot; #&gt; [40] &quot;burlywood3&quot; &quot;burlywood4&quot; &quot;cadetblue&quot; #&gt; [43] &quot;cadetblue1&quot; &quot;cadetblue2&quot; &quot;cadetblue3&quot; #&gt; [46] &quot;cadetblue4&quot; &quot;chartreuse&quot; &quot;chartreuse1&quot; #&gt; [49] &quot;chartreuse2&quot; &quot;chartreuse3&quot; &quot;chartreuse4&quot; #&gt; [52] &quot;chocolate&quot; &quot;chocolate1&quot; &quot;chocolate2&quot; #&gt; [55] &quot;chocolate3&quot; &quot;chocolate4&quot; &quot;coral&quot; #&gt; [58] &quot;coral1&quot; &quot;coral2&quot; &quot;coral3&quot; #&gt; [61] &quot;coral4&quot; &quot;cornflowerblue&quot; &quot;cornsilk&quot; #&gt; [64] &quot;cornsilk1&quot; &quot;cornsilk2&quot; &quot;cornsilk3&quot; #&gt; [67] &quot;cornsilk4&quot; &quot;cyan&quot; &quot;cyan1&quot; #&gt; [70] &quot;cyan2&quot; &quot;cyan3&quot; &quot;cyan4&quot; #&gt; [73] &quot;darkblue&quot; &quot;darkcyan&quot; &quot;darkgoldenrod&quot; #&gt; [76] &quot;darkgoldenrod1&quot; &quot;darkgoldenrod2&quot; &quot;darkgoldenrod3&quot; #&gt; [79] &quot;darkgoldenrod4&quot; &quot;darkgray&quot; &quot;darkgreen&quot; #&gt; [82] &quot;darkgrey&quot; &quot;darkkhaki&quot; &quot;darkmagenta&quot; #&gt; [85] &quot;darkolivegreen&quot; &quot;darkolivegreen1&quot; &quot;darkolivegreen2&quot; #&gt; [88] &quot;darkolivegreen3&quot; &quot;darkolivegreen4&quot; &quot;darkorange&quot; #&gt; [91] &quot;darkorange1&quot; &quot;darkorange2&quot; &quot;darkorange3&quot; #&gt; [94] &quot;darkorange4&quot; &quot;darkorchid&quot; &quot;darkorchid1&quot; #&gt; [97] &quot;darkorchid2&quot; &quot;darkorchid3&quot; &quot;darkorchid4&quot; #&gt; [100] &quot;darkred&quot; &quot;darksalmon&quot; &quot;darkseagreen&quot; #&gt; [103] &quot;darkseagreen1&quot; &quot;darkseagreen2&quot; &quot;darkseagreen3&quot; #&gt; [106] &quot;darkseagreen4&quot; &quot;darkslateblue&quot; &quot;darkslategray&quot; #&gt; [109] &quot;darkslategray1&quot; &quot;darkslategray2&quot; &quot;darkslategray3&quot; #&gt; [112] &quot;darkslategray4&quot; &quot;darkslategrey&quot; &quot;darkturquoise&quot; #&gt; [115] &quot;darkviolet&quot; &quot;deeppink&quot; &quot;deeppink1&quot; #&gt; [118] &quot;deeppink2&quot; &quot;deeppink3&quot; &quot;deeppink4&quot; #&gt; [121] &quot;deepskyblue&quot; &quot;deepskyblue1&quot; &quot;deepskyblue2&quot; #&gt; [124] &quot;deepskyblue3&quot; &quot;deepskyblue4&quot; &quot;dimgray&quot; #&gt; [127] &quot;dimgrey&quot; &quot;dodgerblue&quot; &quot;dodgerblue1&quot; #&gt; [130] &quot;dodgerblue2&quot; &quot;dodgerblue3&quot; &quot;dodgerblue4&quot; #&gt; [133] &quot;firebrick&quot; &quot;firebrick1&quot; &quot;firebrick2&quot; #&gt; [136] &quot;firebrick3&quot; &quot;firebrick4&quot; &quot;floralwhite&quot; #&gt; [139] &quot;forestgreen&quot; &quot;gainsboro&quot; &quot;ghostwhite&quot; #&gt; [142] &quot;gold&quot; &quot;gold1&quot; &quot;gold2&quot; #&gt; [145] &quot;gold3&quot; &quot;gold4&quot; &quot;goldenrod&quot; #&gt; [148] &quot;goldenrod1&quot; &quot;goldenrod2&quot; &quot;goldenrod3&quot; #&gt; [151] &quot;goldenrod4&quot; &quot;gray&quot; &quot;gray0&quot; #&gt; [154] &quot;gray1&quot; &quot;gray2&quot; &quot;gray3&quot; #&gt; [157] &quot;gray4&quot; &quot;gray5&quot; &quot;gray6&quot; #&gt; [160] &quot;gray7&quot; &quot;gray8&quot; &quot;gray9&quot; #&gt; [163] &quot;gray10&quot; &quot;gray11&quot; &quot;gray12&quot; #&gt; [166] &quot;gray13&quot; &quot;gray14&quot; &quot;gray15&quot; #&gt; [169] &quot;gray16&quot; &quot;gray17&quot; &quot;gray18&quot; #&gt; [172] &quot;gray19&quot; &quot;gray20&quot; &quot;gray21&quot; #&gt; [175] &quot;gray22&quot; &quot;gray23&quot; &quot;gray24&quot; #&gt; [178] &quot;gray25&quot; &quot;gray26&quot; &quot;gray27&quot; #&gt; [181] &quot;gray28&quot; &quot;gray29&quot; &quot;gray30&quot; #&gt; [184] &quot;gray31&quot; &quot;gray32&quot; &quot;gray33&quot; #&gt; [187] &quot;gray34&quot; &quot;gray35&quot; &quot;gray36&quot; #&gt; [190] &quot;gray37&quot; &quot;gray38&quot; &quot;gray39&quot; #&gt; [193] &quot;gray40&quot; &quot;gray41&quot; &quot;gray42&quot; #&gt; [196] &quot;gray43&quot; &quot;gray44&quot; &quot;gray45&quot; #&gt; [199] &quot;gray46&quot; &quot;gray47&quot; &quot;gray48&quot; #&gt; [202] &quot;gray49&quot; &quot;gray50&quot; &quot;gray51&quot; #&gt; [205] &quot;gray52&quot; &quot;gray53&quot; &quot;gray54&quot; #&gt; [208] &quot;gray55&quot; &quot;gray56&quot; &quot;gray57&quot; #&gt; [211] &quot;gray58&quot; &quot;gray59&quot; &quot;gray60&quot; #&gt; [214] &quot;gray61&quot; &quot;gray62&quot; &quot;gray63&quot; #&gt; [217] &quot;gray64&quot; &quot;gray65&quot; &quot;gray66&quot; #&gt; [220] &quot;gray67&quot; &quot;gray68&quot; &quot;gray69&quot; #&gt; [223] &quot;gray70&quot; &quot;gray71&quot; &quot;gray72&quot; #&gt; [226] &quot;gray73&quot; &quot;gray74&quot; &quot;gray75&quot; #&gt; [229] &quot;gray76&quot; &quot;gray77&quot; &quot;gray78&quot; #&gt; [232] &quot;gray79&quot; &quot;gray80&quot; &quot;gray81&quot; #&gt; [235] &quot;gray82&quot; &quot;gray83&quot; &quot;gray84&quot; #&gt; [238] &quot;gray85&quot; &quot;gray86&quot; &quot;gray87&quot; #&gt; [241] &quot;gray88&quot; &quot;gray89&quot; &quot;gray90&quot; #&gt; [244] &quot;gray91&quot; &quot;gray92&quot; &quot;gray93&quot; #&gt; [247] &quot;gray94&quot; &quot;gray95&quot; &quot;gray96&quot; #&gt; [250] &quot;gray97&quot; &quot;gray98&quot; &quot;gray99&quot; #&gt; [253] &quot;gray100&quot; &quot;green&quot; &quot;green1&quot; #&gt; [256] &quot;green2&quot; &quot;green3&quot; &quot;green4&quot; #&gt; [259] &quot;greenyellow&quot; &quot;grey&quot; &quot;grey0&quot; #&gt; [262] &quot;grey1&quot; &quot;grey2&quot; &quot;grey3&quot; #&gt; [265] &quot;grey4&quot; &quot;grey5&quot; &quot;grey6&quot; #&gt; [268] &quot;grey7&quot; &quot;grey8&quot; &quot;grey9&quot; #&gt; [271] &quot;grey10&quot; &quot;grey11&quot; &quot;grey12&quot; #&gt; [274] &quot;grey13&quot; &quot;grey14&quot; &quot;grey15&quot; #&gt; [277] &quot;grey16&quot; &quot;grey17&quot; &quot;grey18&quot; #&gt; [280] &quot;grey19&quot; &quot;grey20&quot; &quot;grey21&quot; #&gt; [283] &quot;grey22&quot; &quot;grey23&quot; &quot;grey24&quot; #&gt; [286] &quot;grey25&quot; &quot;grey26&quot; &quot;grey27&quot; #&gt; [289] &quot;grey28&quot; &quot;grey29&quot; &quot;grey30&quot; #&gt; [292] &quot;grey31&quot; &quot;grey32&quot; &quot;grey33&quot; #&gt; [295] &quot;grey34&quot; &quot;grey35&quot; &quot;grey36&quot; #&gt; [298] &quot;grey37&quot; &quot;grey38&quot; &quot;grey39&quot; #&gt; [301] &quot;grey40&quot; &quot;grey41&quot; &quot;grey42&quot; #&gt; [304] &quot;grey43&quot; &quot;grey44&quot; &quot;grey45&quot; #&gt; [307] &quot;grey46&quot; &quot;grey47&quot; &quot;grey48&quot; #&gt; [310] &quot;grey49&quot; &quot;grey50&quot; &quot;grey51&quot; #&gt; [313] &quot;grey52&quot; &quot;grey53&quot; &quot;grey54&quot; #&gt; [316] &quot;grey55&quot; &quot;grey56&quot; &quot;grey57&quot; #&gt; [319] &quot;grey58&quot; &quot;grey59&quot; &quot;grey60&quot; #&gt; [322] &quot;grey61&quot; &quot;grey62&quot; &quot;grey63&quot; #&gt; [325] &quot;grey64&quot; &quot;grey65&quot; &quot;grey66&quot; #&gt; [328] &quot;grey67&quot; &quot;grey68&quot; &quot;grey69&quot; #&gt; [331] &quot;grey70&quot; &quot;grey71&quot; &quot;grey72&quot; #&gt; [334] &quot;grey73&quot; &quot;grey74&quot; &quot;grey75&quot; #&gt; [337] &quot;grey76&quot; &quot;grey77&quot; &quot;grey78&quot; #&gt; [340] &quot;grey79&quot; &quot;grey80&quot; &quot;grey81&quot; #&gt; [343] &quot;grey82&quot; &quot;grey83&quot; &quot;grey84&quot; #&gt; [346] &quot;grey85&quot; &quot;grey86&quot; &quot;grey87&quot; #&gt; [349] &quot;grey88&quot; &quot;grey89&quot; &quot;grey90&quot; #&gt; [352] &quot;grey91&quot; &quot;grey92&quot; &quot;grey93&quot; #&gt; [355] &quot;grey94&quot; &quot;grey95&quot; &quot;grey96&quot; #&gt; [358] &quot;grey97&quot; &quot;grey98&quot; &quot;grey99&quot; #&gt; [361] &quot;grey100&quot; &quot;honeydew&quot; &quot;honeydew1&quot; #&gt; [364] &quot;honeydew2&quot; &quot;honeydew3&quot; &quot;honeydew4&quot; #&gt; [367] &quot;hotpink&quot; &quot;hotpink1&quot; &quot;hotpink2&quot; #&gt; [370] &quot;hotpink3&quot; &quot;hotpink4&quot; &quot;indianred&quot; #&gt; [373] &quot;indianred1&quot; &quot;indianred2&quot; &quot;indianred3&quot; #&gt; [376] &quot;indianred4&quot; &quot;ivory&quot; &quot;ivory1&quot; #&gt; [379] &quot;ivory2&quot; &quot;ivory3&quot; &quot;ivory4&quot; #&gt; [382] &quot;khaki&quot; &quot;khaki1&quot; &quot;khaki2&quot; #&gt; [385] &quot;khaki3&quot; &quot;khaki4&quot; &quot;lavender&quot; #&gt; [388] &quot;lavenderblush&quot; &quot;lavenderblush1&quot; &quot;lavenderblush2&quot; #&gt; [391] &quot;lavenderblush3&quot; &quot;lavenderblush4&quot; &quot;lawngreen&quot; #&gt; [394] &quot;lemonchiffon&quot; &quot;lemonchiffon1&quot; &quot;lemonchiffon2&quot; #&gt; [397] &quot;lemonchiffon3&quot; &quot;lemonchiffon4&quot; &quot;lightblue&quot; #&gt; [400] &quot;lightblue1&quot; &quot;lightblue2&quot; &quot;lightblue3&quot; #&gt; [403] &quot;lightblue4&quot; &quot;lightcoral&quot; &quot;lightcyan&quot; #&gt; [406] &quot;lightcyan1&quot; &quot;lightcyan2&quot; &quot;lightcyan3&quot; #&gt; [409] &quot;lightcyan4&quot; &quot;lightgoldenrod&quot; &quot;lightgoldenrod1&quot; #&gt; [412] &quot;lightgoldenrod2&quot; &quot;lightgoldenrod3&quot; &quot;lightgoldenrod4&quot; #&gt; [415] &quot;lightgoldenrodyellow&quot; &quot;lightgray&quot; &quot;lightgreen&quot; #&gt; [418] &quot;lightgrey&quot; &quot;lightpink&quot; &quot;lightpink1&quot; #&gt; [421] &quot;lightpink2&quot; &quot;lightpink3&quot; &quot;lightpink4&quot; #&gt; [424] &quot;lightsalmon&quot; &quot;lightsalmon1&quot; &quot;lightsalmon2&quot; #&gt; [427] &quot;lightsalmon3&quot; &quot;lightsalmon4&quot; &quot;lightseagreen&quot; #&gt; [430] &quot;lightskyblue&quot; &quot;lightskyblue1&quot; &quot;lightskyblue2&quot; #&gt; [433] &quot;lightskyblue3&quot; &quot;lightskyblue4&quot; &quot;lightslateblue&quot; #&gt; [436] &quot;lightslategray&quot; &quot;lightslategrey&quot; &quot;lightsteelblue&quot; #&gt; [439] &quot;lightsteelblue1&quot; &quot;lightsteelblue2&quot; &quot;lightsteelblue3&quot; #&gt; [442] &quot;lightsteelblue4&quot; &quot;lightyellow&quot; &quot;lightyellow1&quot; #&gt; [445] &quot;lightyellow2&quot; &quot;lightyellow3&quot; &quot;lightyellow4&quot; #&gt; [448] &quot;limegreen&quot; &quot;linen&quot; &quot;magenta&quot; #&gt; [451] &quot;magenta1&quot; &quot;magenta2&quot; &quot;magenta3&quot; #&gt; [454] &quot;magenta4&quot; &quot;maroon&quot; &quot;maroon1&quot; #&gt; [457] &quot;maroon2&quot; &quot;maroon3&quot; &quot;maroon4&quot; #&gt; [460] &quot;mediumaquamarine&quot; &quot;mediumblue&quot; &quot;mediumorchid&quot; #&gt; [463] &quot;mediumorchid1&quot; &quot;mediumorchid2&quot; &quot;mediumorchid3&quot; #&gt; [466] &quot;mediumorchid4&quot; &quot;mediumpurple&quot; &quot;mediumpurple1&quot; #&gt; [469] &quot;mediumpurple2&quot; &quot;mediumpurple3&quot; &quot;mediumpurple4&quot; #&gt; [472] &quot;mediumseagreen&quot; &quot;mediumslateblue&quot; &quot;mediumspringgreen&quot; #&gt; [475] &quot;mediumturquoise&quot; &quot;mediumvioletred&quot; &quot;midnightblue&quot; #&gt; [478] &quot;mintcream&quot; &quot;mistyrose&quot; &quot;mistyrose1&quot; #&gt; [481] &quot;mistyrose2&quot; &quot;mistyrose3&quot; &quot;mistyrose4&quot; #&gt; [484] &quot;moccasin&quot; &quot;navajowhite&quot; &quot;navajowhite1&quot; #&gt; [487] &quot;navajowhite2&quot; &quot;navajowhite3&quot; &quot;navajowhite4&quot; #&gt; [490] &quot;navy&quot; &quot;navyblue&quot; &quot;oldlace&quot; #&gt; [493] &quot;olivedrab&quot; &quot;olivedrab1&quot; &quot;olivedrab2&quot; #&gt; [496] &quot;olivedrab3&quot; &quot;olivedrab4&quot; &quot;orange&quot; #&gt; [499] &quot;orange1&quot; &quot;orange2&quot; &quot;orange3&quot; #&gt; [502] &quot;orange4&quot; &quot;orangered&quot; &quot;orangered1&quot; #&gt; [505] &quot;orangered2&quot; &quot;orangered3&quot; &quot;orangered4&quot; #&gt; [508] &quot;orchid&quot; &quot;orchid1&quot; &quot;orchid2&quot; #&gt; [511] &quot;orchid3&quot; &quot;orchid4&quot; &quot;palegoldenrod&quot; #&gt; [514] &quot;palegreen&quot; &quot;palegreen1&quot; &quot;palegreen2&quot; #&gt; [517] &quot;palegreen3&quot; &quot;palegreen4&quot; &quot;paleturquoise&quot; #&gt; [520] &quot;paleturquoise1&quot; &quot;paleturquoise2&quot; &quot;paleturquoise3&quot; #&gt; [523] &quot;paleturquoise4&quot; &quot;palevioletred&quot; &quot;palevioletred1&quot; #&gt; [526] &quot;palevioletred2&quot; &quot;palevioletred3&quot; &quot;palevioletred4&quot; #&gt; [529] &quot;papayawhip&quot; &quot;peachpuff&quot; &quot;peachpuff1&quot; #&gt; [532] &quot;peachpuff2&quot; &quot;peachpuff3&quot; &quot;peachpuff4&quot; #&gt; [535] &quot;peru&quot; &quot;pink&quot; &quot;pink1&quot; #&gt; [538] &quot;pink2&quot; &quot;pink3&quot; &quot;pink4&quot; #&gt; [541] &quot;plum&quot; &quot;plum1&quot; &quot;plum2&quot; #&gt; [544] &quot;plum3&quot; &quot;plum4&quot; &quot;powderblue&quot; #&gt; [547] &quot;purple&quot; &quot;purple1&quot; &quot;purple2&quot; #&gt; [550] &quot;purple3&quot; &quot;purple4&quot; &quot;red&quot; #&gt; [553] &quot;red1&quot; &quot;red2&quot; &quot;red3&quot; #&gt; [556] &quot;red4&quot; &quot;rosybrown&quot; &quot;rosybrown1&quot; #&gt; [559] &quot;rosybrown2&quot; &quot;rosybrown3&quot; &quot;rosybrown4&quot; #&gt; [562] &quot;royalblue&quot; &quot;royalblue1&quot; &quot;royalblue2&quot; #&gt; [565] &quot;royalblue3&quot; &quot;royalblue4&quot; &quot;saddlebrown&quot; #&gt; [568] &quot;salmon&quot; &quot;salmon1&quot; &quot;salmon2&quot; #&gt; [571] &quot;salmon3&quot; &quot;salmon4&quot; &quot;sandybrown&quot; #&gt; [574] &quot;seagreen&quot; &quot;seagreen1&quot; &quot;seagreen2&quot; #&gt; [577] &quot;seagreen3&quot; &quot;seagreen4&quot; &quot;seashell&quot; #&gt; [580] &quot;seashell1&quot; &quot;seashell2&quot; &quot;seashell3&quot; #&gt; [583] &quot;seashell4&quot; &quot;sienna&quot; &quot;sienna1&quot; #&gt; [586] &quot;sienna2&quot; &quot;sienna3&quot; &quot;sienna4&quot; #&gt; [589] &quot;skyblue&quot; &quot;skyblue1&quot; &quot;skyblue2&quot; #&gt; [592] &quot;skyblue3&quot; &quot;skyblue4&quot; &quot;slateblue&quot; #&gt; [595] &quot;slateblue1&quot; &quot;slateblue2&quot; &quot;slateblue3&quot; #&gt; [598] &quot;slateblue4&quot; &quot;slategray&quot; &quot;slategray1&quot; #&gt; [601] &quot;slategray2&quot; &quot;slategray3&quot; &quot;slategray4&quot; #&gt; [604] &quot;slategrey&quot; &quot;snow&quot; &quot;snow1&quot; #&gt; [607] &quot;snow2&quot; &quot;snow3&quot; &quot;snow4&quot; #&gt; [610] &quot;springgreen&quot; &quot;springgreen1&quot; &quot;springgreen2&quot; #&gt; [613] &quot;springgreen3&quot; &quot;springgreen4&quot; &quot;steelblue&quot; #&gt; [616] &quot;steelblue1&quot; &quot;steelblue2&quot; &quot;steelblue3&quot; #&gt; [619] &quot;steelblue4&quot; &quot;tan&quot; &quot;tan1&quot; #&gt; [622] &quot;tan2&quot; &quot;tan3&quot; &quot;tan4&quot; #&gt; [625] &quot;thistle&quot; &quot;thistle1&quot; &quot;thistle2&quot; #&gt; [628] &quot;thistle3&quot; &quot;thistle4&quot; &quot;tomato&quot; #&gt; [631] &quot;tomato1&quot; &quot;tomato2&quot; &quot;tomato3&quot; #&gt; [634] &quot;tomato4&quot; &quot;turquoise&quot; &quot;turquoise1&quot; #&gt; [637] &quot;turquoise2&quot; &quot;turquoise3&quot; &quot;turquoise4&quot; #&gt; [640] &quot;violet&quot; &quot;violetred&quot; &quot;violetred1&quot; #&gt; [643] &quot;violetred2&quot; &quot;violetred3&quot; &quot;violetred4&quot; #&gt; [646] &quot;wheat&quot; &quot;wheat1&quot; &quot;wheat2&quot; #&gt; [649] &quot;wheat3&quot; &quot;wheat4&quot; &quot;whitesmoke&quot; #&gt; [652] &quot;yellow&quot; &quot;yellow1&quot; &quot;yellow2&quot; #&gt; [655] &quot;yellow3&quot; &quot;yellow4&quot; &quot;yellowgreen&quot; "],["oravazlat-az-r-tanitasahoz.html", "C Óravázlat az R tanításához 1. félév 2. félév", " C Óravázlat az R tanításához Az R oktatásához és tanulásához egy lehetséges tanmenet vázlatát mutatjuk be. Az R tanulmányozását két féléves rendszerben, félévenként 10 duplaórában képzeltük el. A lent felsorolt óravázlat összesen 20 duplaórában sorolja fel azokat az ismeretelemeket, amelyek az R gyakorlati felhasználásához nem nélkülözhetők. 1. félév 1. óra Az Alap R és az RStudio letöltése és telepítése, dokumentációk az R használatához. Az RGui áttekintése, a konzol használata, a szkriptablak használata, parancsok végrehajtása. Az RStudio használata. 2. óra Számok írása, numerikus operátorok. Karakteres konstansok az R-ben. Logikai konstansok és a logikai műveletek. Objektum létrehozása, értékének megváltoztatása. Objektumokat is tartalmazó kifejezések. 3. óra Függvények hívása, például a log() és exp() függvények bemutatása, egyéb matematikai függvények. Függvényparaméterek elnevezése, sorrendjük cseréje. Kifejezés definíciója. Vektor adatszerkezet definíciója. Vektor létrehozása: c(), : (kettőspont operátor), seq(), rep() 4. óra A faktor adatszerkezet definíciója, faktor létrehozása a factor() függvénnyel. Objektumok adattípusának megtekintése és az objektum hossza: class(), typeof(), length(). Adattábla definíciója, létrehozása a data.frame() függvénnyel. Mátrix adatszerkezet, létrehozása a matrix() függvénnyel. Tömb adatszerkezet, létrehozása az array() függvénnyel. Lista adatszerkezet, létrehozása a list() függvénnyel. Indexelés vektor, mátrix, tömb és adattábla esetén. Hivatkozás listaelemekre lista és adattábla esetén. 5. óra Tagolt szöveges állomány létrehozása táblázatkezelővel és szövegszerkesztővel. Tagolt szöveges állomány beolvasása a read.table() függvénnyel. A paraméterek megbeszélése (file=, sep=, header=, dec=, quote=, stringsAsFactors=, comment.char=, na.strings=, strip.white=, fileEncode=). Táblázatkezelők és más statisztikai programcsomagok saját formátomú állományainak beolvasása a rio::import() segítségével. A beolvasás helyességének ellenőrzése az str() függvénnyel A read.table() argumentumainak hatása az str() outputjára. Adatállomány kiírása a write.table() és a rio::export() segítségével. 6. óra Egyszerű típuskonverziók (numerikus vektorból faktor és karakteres vektorból faktor előállítása a factor() függvénnyel, valamint az as.character() és as.numeric() használata). Kapcsolat a statisztikai skálák és a változók típusai között. Faktor szintjeinek átnevezése, a szintek sorrendjének meghatározása. Vektor rendezése a sort() és order() függvénnyel. Adattábla rendezése az order() függvénnyel. Adattábla szűrése egyszerű logikai kifejezéssel és összetett logikai kifejezéssel. 7. óra Az R környezet fogalmai: munkakönyvtár, munkaterület, csomag. Munkakönyvtár kezelése Objektum létrehozása és eltávolítása a munkaterületről, objektumok listája. Csomag telepítése, telepített csomagok listája, csomag betöltése, csomag eltávolítása, betöltött csomagok listája. Az R Commander telepítése és használatának bemutatása. A jamovi telepítése és használata. Az RGUI, RStudio, jamovi és az R Commander összehasonlítása. 8. óra Leíró statisztikai mérőszámok meghatározása: summary(), mean(), median(), sd() stb. Hiányzó értékek kezelése (na.rm=T, is.na(), na.ommit()). Műveletek több változóra és csoportra (apply(), sapply(), tapply(), aggregate(), by()). A psych::describe(), psych::describeBy() és a DescTools::Desc() függvényének bemutatása. 9. óra Gyakorisági táblázatok létrehozása a table() és xtabs() függvénnyel. Hiányzó értékek kezelése (useNA=\"ifany\"). Relatív gyakorisági táblázatok. Kumulált gyakorisági táblázatok. Soronként vagy oszloponként vett kétdimenziós gyakorisági táblázatok. Három vagy többdimenziós táblázatok (array() és ftable()). Gyakorisági táblázatok a DescTools::Desc() függvénnyel. 10. óra A hagyományos grafika magasszintű függvényei. Oszlopdiagram rajzolása (barplot()). Egydimenziós pontdiagram létrehozása (stripchart()). Grafikus paraméterek fogalma és beállítása a par() függvénnyel. Feliratok (main=, sub=, xlab=, ylab=, las=), tengelyek (xlim=, ylim=, mgp=, tcl=), pontkarakterek (pch=), margók (mar=), színek (col=) beállítása. Pontdiagram és vonaldiagram rajzolása (plot()). Dobozdiagram rajzolása (boxplot()). Hisztogram rajzolása (hist()). További grafikus paraméterek: rajzterület felosztása (mfrow=, mfcol=). Grafikus eszközök típusai (windows(), png(), jpeg(), pdf()). Képállományok létrehozása és beállítási lehetőségek (res=, width=, height=). Grafikus eszközök bezárása. 2. félév 11. óra A reprodukálható kutatás elvének bemutatása. Az RStudio és a jamovi lehetőségei a reprodukálható kutatásban. RMarkdown állomány (*.Rmd) létrehozása, szintaxisának bemutatása. A fejléc lehetőségei. A szöveges rész formázása Markdown segítségével. Az R csonkok lehetőségei. PDF, Word és HTML állomány generálása. Egyedi template-ek használata. 12. óra Információk az adatobjektumokról (str(), head(), dim(), nrow(), ncol(), names(), colnames(), rownames(), levels(), nlevels()). Egyszerű típuskonverzió a karakters, numerikus, logikai és faktor típusok között (factor(), as.factor(), as.numeric(), as.character(), as.logical()). Mátrix és adattábla sor- és oszlopmanipulációja: sor és oszlopnevek megadása, átnevezése, sorok és oszlopok törlése, beszúrása és cseréje (pl. rbind(), cbind()) Numerikusból numerikus transzformáció (tetszőleges matematikai függvény, transform(), recode()). Numerikusból faktor transzformáció (cut(), car::recode()). Faktorból faktor transzformáció (car::recode()). 13. óra Adatelőkészítés egy- és kétmintás próbákhoz. Adatbázis létrehozás a data.frame() függvénnyel a varianciaelemzés számára (kiegyensúlyozott és nem kiegyensúlyozott esetek). A hosszú és széles adatbázisok fogalma Adatbázis átalakítása a két formátum között (reshape(), melt(), dcast()) Adattáblák összefűzése (merge()). 14. óra Egymintás és kétmintás próbák végrehajtása Argumentumok és outputok értelmezése. Például a BSDA::z.test(), t.test(), prop.test(), binom.test(), fisher.test(), mcnemar.test(), wilcox.test(), kruskal.test() és friedman.test() függvényekkel. A varianciaelemzés különböző változatainak végrehajtása. Argumentumok és outputok értelmezése az aov() és lm() függvények esetében. Korreláció- és regressziószámítás végrehajtása. Argumentumok és outputok értelmezése a cor(), cor.test() és lm() esetében. 15. óra Véletlen a sample() függvény segítségével. Eloszlások függvényei (r...(), d...(), q...(), p...()). Kritikus értékek és p-értékek meghatározása a q...(), p...() függvényekkel. Eloszlások sűrűségfüggvényeinek rajzolása a curve() függvény segítségével. 16. óra A Tidyverse R bemutatása. A pipe operátor (%&gt;%) használata. A tibble adatobjektumok kezelése. Adatállományok beolvasás és kiírása. Adatobjektom vizsgálata, sor- és oszlopnevek manipulációja. Oszlopok leválogatása, beszúrása és törlése. Adatobjektum rendezése. 17. óra A Tidyverse R bemutatása. Sorok szűrése, törlése és beszúrása. Adatok összesítése, csoportosítása és transzformációja, valamint adattáblák összefűzése a dplyr csomag segítségével. Kategorikus változók kezelése a forcats csomag segítségével. 18. óra A Tidyverse R bemutatása. Széles-hosszú átalakítás a tidyr csomag segítségével (pivot_wider(), pivot_longer()). Hiányzó, duplikált és kiugró értékek kezelése a dplyr csomag segítségével. Karakterláncok kezelése a stringr csomag segítségével. 19. óra A ggplot2 grafikus rendszer elemei: az adat, az alakzat (geom) és a megjelenés (aes) rétegek. Az x=, y=, alpha=, colour=, fill=, group=, shape= és size= paraméterek használata az aes() függvényben. Jelmagyarázat megjelenítése. Több ábra megjelenítése kategorikus változó alapján (faceting). Ábra elemeinek beállítása: feliratok, tengelyek, színek és témák. Ábrák mentése. 20. óra Az alavető ábratípusok megjelenítése és paraméterezései: oszlopdiagram, egydimenziós pontdiagram, hisztogram, dobozdiagram, pontdiagram, vonaldiagram, Q-Q ábra, hegedűdiagram, lollipop ábra és terület diagram. 20+1. óra Az R programozási lehetőségei: szekvencia, feltételes utasítások, ciklusok. Függvények létrehozása. Objektum-orientált lehetőségek. "],["probak.html", "D Próbák", " D Próbák A könyvben szereplő próba összes próba bemutatása. library(tidyverse) library(broom) library(knitr) library(apa) # install.packages(&quot;devtools&quot;) # devtools::install_github(&#39;achetverikov/apastats&#39;,subdir=&#39;apastats&#39;) library(apastats) # devtools::install_github(&quot;rempsyc/rempsyc&quot;) # library(rempsyc) # install.packages(&quot;papaja&quot;) library(papaja) library(DescTools) library(BSDA) library(nonpar) library(TeachingDemos) library(MASS) str(survey) #&gt; &#39;data.frame&#39;: 237 obs. of 12 variables: #&gt; $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 2 2 2 2 1 2 1 2 2 ... #&gt; $ Wr.Hnd: num 18.5 19.5 18 18.8 20 18 17.7 17 20 18.5 ... #&gt; $ NW.Hnd: num 18 20.5 13.3 18.9 20 17.7 17.7 17.3 19.5 18.5 ... #&gt; $ W.Hnd : Factor w/ 2 levels &quot;Left&quot;,&quot;Right&quot;: 2 1 2 2 2 2 2 2 2 2 ... #&gt; $ Fold : Factor w/ 3 levels &quot;L on R&quot;,&quot;Neither&quot;,..: 3 3 1 3 2 1 1 3 3 3 ... #&gt; $ Pulse : int 92 104 87 NA 35 64 83 74 72 90 ... #&gt; $ Clap : Factor w/ 3 levels &quot;Left&quot;,&quot;Neither&quot;,..: 1 1 2 2 3 3 3 3 3 3 ... #&gt; $ Exer : Factor w/ 3 levels &quot;Freq&quot;,&quot;None&quot;,..: 3 2 2 2 3 3 1 1 3 3 ... #&gt; $ Smoke : Factor w/ 4 levels &quot;Heavy&quot;,&quot;Never&quot;,..: 2 4 3 2 2 2 2 2 2 2 ... #&gt; $ Height: num 173 178 NA 160 165 ... #&gt; $ M.I : Factor w/ 2 levels &quot;Imperial&quot;,&quot;Metric&quot;: 2 1 NA 2 2 1 1 2 2 2 ... #&gt; $ Age : num 18.2 17.6 16.9 20.3 23.7 ... options(OutDec=&quot;,&quot;) # egymintás u-próba test.result &lt;- BSDA::z.test(x = survey$Wr.Hnd, mu = 16, sigma.x = 3) test.result # hagyományos R output #&gt; #&gt; One-sample z-Test #&gt; #&gt; data: survey$Wr.Hnd #&gt; z = 14, p-value &lt;2e-16 #&gt; alternative hypothesis: true mean is not equal to 16 #&gt; 95 percent confidence interval: #&gt; 18,29 19,05 #&gt; sample estimates: #&gt; mean of x #&gt; 18,67 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate statistic p.value conf.low conf.high method alternative 18,67 13,67 0 18,29 19,05 One-sample z-Test two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$M = 18,67$, 95\\\\% CI $[18,29, 19,05]$, $z = 13,67$, $p &lt; 0,001$&quot; # egymintás t-próba test.result &lt;- t.test(x = survey$Wr.Hnd, mu = 16) test.result # hagyományos R output #&gt; #&gt; One Sample t-test #&gt; #&gt; data: survey$Wr.Hnd #&gt; t = 22, df = 235, p-value &lt;2e-16 #&gt; alternative hypothesis: true mean is not equal to 16 #&gt; 95 percent confidence interval: #&gt; 18,43 18,91 #&gt; sample estimates: #&gt; mean of x #&gt; 18,67 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate statistic p.value parameter conf.low conf.high method alternative 18,67 21,82 0 235 18,43 18,91 One Sample t-test two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$M = 18,67$, 95\\\\% CI $[18,43, 18,91]$, $t(235) = 21,82$, $p &lt; 0,001$&quot; # előjel-próba test.result &lt;- DescTools::SignTest(x = survey$Pulse, md = 56) test.result # hagyományos R output #&gt; #&gt; One-sample Sign-Test #&gt; #&gt; data: survey$Pulse #&gt; S = 192, number of differences = 192, p-value &lt;2e-16 #&gt; alternative hypothesis: true median is not equal to 0 #&gt; 96,4 percent confidence interval: #&gt; 71 76 #&gt; sample estimates: #&gt; median of the differences #&gt; 72,5 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate statistic p.value parameter conf.low.lwr.ci conf.high.upr.ci method alternative 72,5 192 0 192 71 76 One-sample Sign-Test two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$S = 192,00$, $p &lt; 0,001$&quot; # Wilcoxon-próba test.result &lt;- wilcox.test(x = survey$Pulse, md = 56) test.result # hagyományos R output #&gt; #&gt; Wilcoxon signed rank test with continuity correction #&gt; #&gt; data: survey$Pulse #&gt; V = 18528, p-value &lt;2e-16 #&gt; alternative hypothesis: true location is not equal to 0 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value method alternative 18528 0 Wilcoxon signed rank test with continuity correction two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$V = 18,528,00$, $p &lt; 0,001$&quot; # Khí-négyzet próba az egymintás varianciára test.result &lt;- TeachingDemos::sigma.test(x = survey$Wr.Hnd, sigma = 10) test.result # hagyományos R output #&gt; #&gt; One sample Chi-squared test for variance #&gt; #&gt; data: survey$Wr.Hnd #&gt; X-squared = NA, df = 236, p-value = NA #&gt; alternative hypothesis: true variance is not equal to 100 #&gt; 95 percent confidence interval: #&gt; NA NA #&gt; sample estimates: #&gt; var of survey$Wr.Hnd #&gt; NA # test.result %&gt;% broom::tidy() %&gt;% knitr::kable() # test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) # Khí-négyzet próba a valószínűségre test.result &lt;- TeachingDemos::sigma.test(x = survey$Wr.Hnd, sigma = 10) test.result # hagyományos R output #&gt; #&gt; One sample Chi-squared test for variance #&gt; #&gt; data: survey$Wr.Hnd #&gt; X-squared = NA, df = 236, p-value = NA #&gt; alternative hypothesis: true variance is not equal to 100 #&gt; 95 percent confidence interval: #&gt; NA NA #&gt; sample estimates: #&gt; var of survey$Wr.Hnd #&gt; NA # test.result %&gt;% broom::tidy() %&gt;% knitr::kable() # test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) # Shapiro-Wilk-próba test.result &lt;- shapiro.test(x = survey$Pulse) test.result # hagyományos R output #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: survey$Pulse #&gt; W = 0,99, p-value = 0,09 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value method 0,9874 0,0863 Shapiro-Wilk normality test test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$W = 0,99$, $p = 0,086$&quot; # Kolmogorov-Szmirnov-próba test.result &lt;- DescTools::LillieTest(x = survey$Pulse) test.result # hagyományos R output #&gt; #&gt; Lilliefors (Kolmogorov-Smirnov) normality test #&gt; #&gt; data: survey$Pulse #&gt; D = 0,073, p-value = 0,01 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value method 0,073 0,0145 Lilliefors (Kolmogorov-Smirnov) normality test # test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) # Arány-próba test.result &lt;- prop.test(x = 61, n = 500, p = 0.108) test.result # hagyományos R output #&gt; #&gt; 1-sample proportions test with continuity correction #&gt; #&gt; data: 61 out of 500, null probability 0.108 #&gt; X-squared = 0,88, df = 1, p-value = 0,3 #&gt; alternative hypothesis: true p is not equal to 0,108 #&gt; 95 percent confidence interval: #&gt; 0,09527 0,15470 #&gt; sample estimates: #&gt; p #&gt; 0,122 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate statistic p.value parameter conf.low conf.high method alternative 0,122 0,8771 0,349 1 0,0953 0,1547 1-sample proportions test with continuity correction two.sided # test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) # Binomiális-próba test.result &lt;- binom.test(x = 61, n = 500, p = 0.108) test.result # hagyományos R output #&gt; #&gt; Exact binomial test #&gt; #&gt; data: 61 and 500 #&gt; number of successes = 61, number of trials = 500, p-value = 0,3 #&gt; alternative hypothesis: true probability of success is not equal to 0,108 #&gt; 95 percent confidence interval: #&gt; 0,09462 0,15394 #&gt; sample estimates: #&gt; probability of success #&gt; 0,122 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate statistic p.value parameter conf.low conf.high method alternative 0,122 61 0,3129 500 0,0946 0,1539 Exact binomial test two.sided # test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) # Bartlett-próba test.result &lt;- bartlett.test(Wr.Hnd~Smoke, data=survey) test.result # hagyományos R output #&gt; #&gt; Bartlett test of homogeneity of variances #&gt; #&gt; data: Wr.Hnd by Smoke #&gt; Bartlett&#39;s K-squared = 9,8, df = 3, p-value = 0,02 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value parameter method 9,817 0,0202 3 Bartlett test of homogeneity of variances test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$K^2(3) = 9,82$, $p = 0,020$&quot; # Levene-próba test.result &lt;- DescTools::LeveneTest(Wr.Hnd~Smoke, data=survey, center=median) test.result # hagyományos R output #&gt; Levene&#39;s Test for Homogeneity of Variance (center = median) #&gt; Df F value Pr(&gt;F) #&gt; group 3 3,09 0,028 * #&gt; 231 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value df df.residual 3,086 0,028 3 231 test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$F(3, 231) = 3,09$, $p = 0,028$&quot; # Kruskal-Wallis-próba test.result &lt;- kruskal.test(Wr.Hnd~Smoke, data=survey) test.result # hagyományos R output #&gt; #&gt; Kruskal-Wallis rank sum test #&gt; #&gt; data: Wr.Hnd by Smoke #&gt; Kruskal-Wallis chi-squared = 3,1, df = 3, p-value = 0,4 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value parameter method 3,089 0,3781 3 Kruskal-Wallis rank sum test # test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) # Mann-Whitney-próba test.result &lt;- wilcox.test(Wr.Hnd~Sex, data=survey) test.result # hagyományos R output #&gt; #&gt; Wilcoxon rank sum test with continuity correction #&gt; #&gt; data: Wr.Hnd by Sex #&gt; W = 2138, p-value &lt;2e-16 #&gt; alternative hypothesis: true location shift is not equal to 0 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() statistic p.value method alternative 2138 0 Wilcoxon rank sum test with continuity correction two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$W = 2,137,50$, $p &lt; 0,001$&quot; # F-próba test.result &lt;- var.test(Wr.Hnd~Sex, data=survey) test.result # hagyományos R output #&gt; #&gt; F test to compare two variances #&gt; #&gt; data: Wr.Hnd by Sex #&gt; F = 0,56, num df = 117, denom df = 116, p-value = 0,002 #&gt; alternative hypothesis: true ratio of variances is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0,3914 0,8122 #&gt; sample estimates: #&gt; ratio of variances #&gt; 0,5639 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate num.df den.df statistic p.value conf.low conf.high method alternative 0,5639 117 116 0,5639 0,0022 0,3914 0,8122 F test to compare two variances two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$F(117, 116) = 0,56$, $p = 0,002$&quot; # kétmintás t-próba test.result &lt;- t.test(Wr.Hnd~Sex, data=survey, var.equal=T) test.result # hagyományos R output #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: Wr.Hnd by Sex #&gt; t = -11, df = 233, p-value &lt;2e-16 #&gt; alternative hypothesis: true difference in means between group Female and group Male is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -2,544 -1,748 #&gt; sample estimates: #&gt; mean in group Female mean in group Male #&gt; 17,60 19,74 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() estimate estimate1 estimate2 statistic p.value parameter conf.low conf.high method alternative -2,146 17,6 19,74 -10,63 0 233 -2,544 -1,748 Two Sample t-test two.sided test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$\\\\Delta M = -2,15$, 95\\\\% CI $[-2,54, -1,75]$, $t(233) = -10,63$, $p &lt; 0,001$&quot; # AOV test.result &lt;- aov(Wr.Hnd~Smoke, data=survey) summary(test.result) # hagyományos R output #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; Smoke 3 17 5,51 1,58 0,2 #&gt; Residuals 231 808 3,50 #&gt; 2 observations deleted due to missingness test.result %&gt;% broom::tidy() %&gt;% knitr::kable() term df sumsq meansq statistic p.value Smoke 3 16,54 5,514 1,577 0,1957 Residuals 231 807,69 3,497 NA NA test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; $Smoke #&gt; [1] &quot;$F(3, 231) = 1,58$, $p = 0,196$, $\\\\hat{\\\\eta}^2_G = 0,020$, 90\\\\% CI $[0,000, 0,049]$&quot; # AOV - Welch test.result &lt;- oneway.test(Wr.Hnd~Smoke, data=survey) test.result # hagyományos R output #&gt; #&gt; One-way analysis of means (not assuming equal variances) #&gt; #&gt; data: Wr.Hnd and Smoke #&gt; F = 0,89, num df = 3, denom df = 25, p-value = 0,5 test.result %&gt;% broom::tidy() %&gt;% knitr::kable() num.df den.df statistic p.value method 3 24,6 0,8948 0,4578 One-way analysis of means (not assuming equal variances) test.result %&gt;% papaja::apa_print() %&gt;% `[[`(&quot;full_result&quot;) #&gt; [1] &quot;$F(3, 24,60) = 0,89$, $p = 0,458$&quot; library(jmv) data(&#39;ToothGrowth&#39;) ancova(formula = len ~ supp + dose, data = ToothGrowth) #&gt; #&gt; ANCOVA #&gt; #&gt; ANCOVA - len #&gt; ───────────────────────────────────────────────────────────────────────── #&gt; Sum of Squares df Mean Square F p #&gt; ───────────────────────────────────────────────────────────────────────── #&gt; supp 205.4 1 205.35 11.45 0.0013 #&gt; dose 2224.3 1 2224.30 123.99 &lt; .0001 #&gt; Residuals 1022.6 57 17.94 #&gt; ───────────────────────────────────────────────────────────────────────── # # apastats::describe.ttest(t1, show.mean = T) # # # If devtools isn&#39;t already installed, install it with install.packages(&quot;devtools&quot;) # # if(!require(&#39;pubprint&#39;)) { # install.packages(&#39;pubprint&#39;) # library(&#39;pubprint&#39;) # } # # # # t1 %&gt;% tidy() %&gt;% kable() # "],["irodalomjegyzek.html", "Irodalomjegyzék", " Irodalomjegyzék "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
