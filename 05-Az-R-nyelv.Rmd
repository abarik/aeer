# Az R nyelv {#az-r-nyelv}

```{r results='asis', echo=FALSE, out.width = '70%'}
knitr::include_graphics(path = "images/ch_05_small.png")
```

Az előző fejezetekben megismertük az R környezetet, az *Alap R*, az *RStudio* és a csomagok telepítését, megtanultuk a projektek, parancsállományok és RMarkdown állományok létrehozását. Tudjuk, a különböző környezetekben eltérő módszerekkel hajthatjuk végre az R parancsokat: a konzolban az `Enter`, a Windows-os *RGui*-ban a `Ctrl+R`, míg az *RStudio*-ban a `Ctrl+Enter` billentyűkombinációt kell használnunk. A parancsok végrehajtása közben érdemes észben tartani, ha a folytatás prompt (`+`) feltűnik, akkor kattintsunk bele a konzolba, és nyomjuk meg az `Esc` billentyűt, így tudunk kilépni a befejezetlen sor szerkesztéséből

E fejezet példáinak kipróbáláshoz hozzunk létre egy `gyakorlas` nevű új projektet az *RStudio*-ban (`File / New Project`), majd készítsünk egy `gyakorlas.Rmd` RMarkdown állományt (`File / New File / R Markdown`) és egy `gyakorlas.R` parancsállományt (`File / New File / R Script`). A fejezet példáit egyaránt gépeljük az RMarkdown állomány R csonkjaiba, illetve a parancsállomány egymást követő soraiba. A fejezet további részében az R nyelvre koncentrálunk, arra, hogy mit írunk, és nem arra, hogy hová írjuk a parancsokat.

## Adatobjektumok

```{block2, type='rmdlevel1'}

Ebben a fejezetben:
  
* áttekintjük az egyszerű számolási lehetőségeket R-ben,
* bevezetjük az aritmetikai operátor és a kifejezés fogalmát,
* megismerjük az objektum létrehozását és elnevezését,
* több parancs elhelyezését egy sorban,
* és a megjegyzések használatát.

```


Az R nyelv megismerését számadatok írásával kezdjük. Az adatelemzés során a számszerű adatok kezelése a leggyakoribb, hiszen méréssel és számlálással is ilyen jellegű adatokhoz jutunk. Számszerű adat a testmagasságunk cm-ben kifejezve, az IQ-teszten elért pontszámunk, vagy a testvéreink és a Facebook ismerőseink száma is.   

### Számolás az R-ben

Kezdjük a számszerű adatok megismerését egy egyszerű sor begépelésével. 

```{r}
2+2 
```

Végrehajtás után a konzolban láthatjuk az összeadás eredményét, a 4-et. Az eredmény előtt egy szögletes zárójelben lévő sorszámot is láthatunk (`[1]`), amely bonyolultabb outputokban segít eligazodni. Később az \@ref(szabalyosvektorokalfejezet). fejezetben visszatérünk a `[1]` értelmezésére.

Látjuk, ebben az esetben az R úgy viselkedik, mint egy számológép. Kiszámolja a parancssorba gépelt algebrai kifejezés értékét, majd a képernyőn megjeleníti. Természetesen az összeadáson túl más műveletet is használhatunk.

```{r}
4+6*2
```

A fenti példából látható, hogy az R követi a műveletek elvégzésének matematikában megszokott sorrendjét. Azaz a szorzás műveletre (`*`) hamarabb sor kerül, ennek eredménye 12. Ezt követi az összeadás (`+`), most már a 4 és a 12 között. Ennek az összeadás műveletnek az eredménye 16, ami egyben a kifejezés értéke is, tehát ez jelenik meg a konzolban.

Természetesen a matematikában megszokott módon változtathatunk a műveletek végrehajtásának alapértelmezett sorrendjén, azaz használhatunk kerek zárójeleket. Ezeket az R a megszokott módon értelmezi: a zárójelben szereplő műveletek végrehajtását előreveszi.

```{r}
(4+6)*2
```

A fenti példában az összeadás művelet lesz az első, amelynek az eredménye 10. Ezt követi a szorzás, így kapjuk a kifejezés értékeként a 20-at.

Ezeket a matematikában megszokott algebrai kifejezéseket, az R-ben egyszerűen kifejezésnek vagy -- utalva arra, hogy a kifejezés értéke szám -- *aritmetikai kifejezésnek*\index{aritmetikai kifejezés} nevezünk. Az eddigiek alapján az aritmetikai kifejezések tehát a következő nyelvi elemeket tartalmazhatják:

* számok, amelyeket *numerikus konstans*oknak\index{numerikus konstans} nevezünk,
* műveleti jelek, amelyeket *aritmetikai operátor*oknak\index{aritmetikai operátor} nevezünk,
* és kerek zárójelek.

A fentiek alapján összetettebb aritmetikai kifejezéseket is megformálhatunk. Az R minden esetben kiszámolja a kifejezések értékét -- azaz *kiértékeli* a kifejezést --, és a kapott értéket megjeleníti a konzolban.


```{r}
4^2-3*2+1
(104-20)/6-4*7*10/(5**2-5)
```



```{r matoperatorok, echo=FALSE}
library(tidyverse)
table.kiir <- data.frame(A=c( "^ **",
                              "+ - ",
                              "%% %/%",
                              "* /",
                              "+ - "),
                         B=c( "hatványozás",
                              "előjelek",
                              "maradékos osztás és egész osztás",
                              "szorzás és osztás",
                              "összeadás és kivonás"
                         ),
                         C=c( "2^3;2**3",
                              "+3.3;-.5",
                              "13%%4;15%/%4",
                              "2*3;4/2",
                              "2+3;2-3"))

table.kiir %>%
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"),
                                 monospace = T)) %>%
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"),
                                 monospace = T)) %>%
  knitr::kable(escape = F, booktabs = T,
               col.names = c("Operátor",
                             "Művelet",
                             "Példa"),
               caption = 'Matematikai operátorok precedenciájuk csökkenő sorrendjében',
               format = ifelse(knitr:::is_html_output(),"html", "latex")) %>%
  kableExtra::kable_styling(full_width = F,
                            latex_options = "striped",
                            bootstrap_options = c("striped", "hover"))


```

Az aritmetikai kifejezések használata során ne felejtkezzünk el a műveletek alapértelmezett végrehajtási sorrendjéről. A műveletek megjelenítését most az operátorok végzik, melyeknek fontos tulajdonsága, hogy mennyire szorosan kötik magukhoz az adatokat (vagy más néven az operandusokat). Az operátorok ezen fonos tulajdonságát *precedenciának* nevezzük. Az R-ben használható aritmetikai operátorokat a precedenciájuk csökkenő sorrendjében az \@ref(tab:matoperatorok). táblázat tartalmazza.

Például a hatványozás és az előjel operátor precedenciája eltér egymástól, a hatványozás nagyobb precedenciájú, azaz szorosabban köti magához az adatokat, így végrehajtása megelőzi az előjel operátort. Ha nem vagyunk elég óvatosak, és plusz zárójelek segítségével nem biztosítjuk a kívánt végrehajtási sorrendet, akkor "váratlan" eredményhez juthatunk. A lenti példában láthatjuk, hogy zárójelek nélkül a nagyobb precedenciájú hatványozás az elsőként végrehajtott művelet.

```{r}
-2^2    # először hatványozás, majd előjel
(-2)^2  # először előjel, majd hatványozás
```

Eddig láthattuk, hogy kifejezéseinket operátorok, numerikus konstansok és zárójelek segítségével építettük fel. Ezek a kifejezések két alkotójukban is általánosíthatók: 

* általánosítható a kifejezés adat része, amelyet eddig a numerikus konstansok képviseltek (ezekből lesznek az *objektum*ok), 
* általánosíthatő a kifejezés művelet része, amelyet eddig az operátorok jelenítettek meg (ezek lesznek a *függvény*ek). 

Az adatrész általánosítása tehát az adatobjektum (vagy röviden objektum), a műveleteké pedig a függvényobjektum (vagy röviden függvény). Ezeket tekintjük át a következőkben.

### Objektumok

Ha egy kifejezés értéket nem egyszerűen a képernyőn szeretnénk megjeleníteni, hanem azt később is fel szeretnénk használni, akkor objektumot[^1] kell létrehoznunk. Az objektumok révén a memóriába rögzíthetünk tetszőleges értékeket, később pedig elővehetjük és felhasználhatjuk ezeket az értékeket. 
Tudjuk, ha a lenti aritmetikai kifejezést a parancssorba írjuk, az R miután kiértékelte a kifejezést, a kifejezés értékét megjeleníti a konzolban. Ez az érték azonban a megjelenítés után rögtön el is vész, többször nem használhatjuk fel.

```{r}
1157/13+2^3 
```

Ha létrehozunk egy `x` nevű objektumot, akkor ezt az értéket további kifejezésekben is szerepeltethetjük. Minden olyan helyen, ahol eddig számok jelentek meg a kifejezésekben, oda ez az `x` objektumnév is beírható.

```{r}
x <- 1157/13+2^3 
```

A fenti sor végrehajtása után írhatjuk a következőket, hiszen a kifejezések kiértékelése során az `x` objektum memóriában tárolt értékével fog számolni az R.

```{r tidy=FALSE}
x+2       # mintha 97+2 lenne
2*x^3+5   # 2*97^3+5
```

Minden objektumnak van neve és tartozik hozzá a memóriában egy terület, ahol a kérdéses érték tárolásra kerül. Esetünkben az objektum neve `x`, a hozzá tartozó memóriaterületen pedig a 97 értéket tárolja az R. Az objektum leegyszerűsítve tehát egy név-érték pár, ahol a nevet és a memóriában eltárolandó értéket is mi magunk választjuk meg.

Az objektumok kezeléséhez 3 művelet kapcsolódik:

* objektum létrehozása, 
* objektum értékének lekérdezése, 
* és az objektum értékének megváltoztatása. 


#### Objektumok létrehozása

Objektumot értékadással hozhatunk létre. Az értékadás tartalmaz egy értékadás operátort, melynek alakja `<-` (balra nyíl), vagyis egy kisebb jel és egy mínusz előjel egymás után írva szóköz nélkül[^2].

Az értékadás általános alakja: 

```markdown
objektumnév <- kifejezés    # értékadó utasítás
```

Ahol lehet a továbbiakban ezt a balra nyíl alakú értékadó operátort használjuk az értékadás során, és nem a szintén legális egyenlőségjelet (`=`). A balra nyíl írását az *RStudio* az `Alt+-` segítségével támogatja, így a bevitele nem okozhat nehézséget. Az egyenlőségjelet megtartjuk a függvényargumentumok elnevezésére. Az egyszerűség kedvéért a balra nyíl előtt lévő objektumnevet az értékadás bal oldalának, az utána lévő kifejezést az értékadás jobb oldalának nevezzük.

Ha olyan objektumnevet szerepeltetünk az értékadásban, amely még nem létezik, akkor az R létrehoz egy ilyen nevű új objektumot, és a hozzá tartozó memóriaterületen pedig az értékadás jobb oldalán lévő kifejezés kiértékelése után kapott értéket tárolja el.

```{r}
a <- 1+2    # objektum létrehozása
```

A fenti sor végrehajtása után a konzolban nem jelenik meg eredmény, mégis egy nagyon fontos dolog történik, létrejön az `a` nevű objektum, amelynek értéke 3 lesz mindaddig, amig ezen nem változtatunk. A munkánk során létrehozott objektumok a memória egy speciális területére, a *munkaterület*re (*workspace*) kerülnek.

Ha az értékadásban használt objektum már létezik, akkor a jobb oldali kifejezés kiértékelése után a kapott értékkel felülírja a bal oldali objektumhoz tartozó memóriaterületet. Ezzel a módszerrel tehát a korábban létrehozott objektum értékét módosíthatjuk. 

A már létező `a` objektum értékét könnyen megváltoztathatjuk.

```{r}
a <- 10/3   # objektum értékének megváltoztatása
```


#### Objektumok értékének lekérdezése

Az objektum memóriában tárolt értékét le is kérdezhetjük. A legegyszerűbb mód erre, ha az objektum nevét a parancssorba írjuk és végrehajtjuk a sort, máris megkapjuk az objektum memóriában tárolt értékét.

```{r}
a     # vajon mi az "a" objektum értéke
```

Objektumok tetszőleges kifejezésben megjelenhetnek, akár egy értékadás jobb oldalán lévő kifejezésben is. A kifejezések kiértékelésében az objektum a memóriában tárolt értékével vesz részt.

```{r tidy=FALSE}
a*3              # a kifejezés értéke konzolba kerül
a <- 4 + a * 3   # megváltozik az objektum értéke, nincs output
a                # megtudjuk az objektum értékét
```

A fenti sorokból kiolvasható, hogy immár az `a` objektum értéke 14.

#### Objektumok elnevezése {#objektumelnevezes}

Az objektumok elnevezésére eddig egyetlen betűt (karaktert) használtunk, de ez elég ritka eset a munka során. Helyes gyakorlat, ha az objektum neve utal az objektum tartalmára, céljára. Ha például testmagasságot tárolunk el egy objektumban, akkor írhatjuk a következőt:

```{r}
magassag <- 179
```

A fenti sor létrehozza a munkaterületen a `magassag` nevű objektumot 179 értékkel.

Az objektumok elnevezésére 

* betűket, 
* számjegyeket, 
* és az aláhúzás (`_`) vagy pont (`.`) szimbólumokat használhatjuk. 

Az objektum neve csak betűvel vagy ponttal kezdődhet, számjeggyel vagy aláhúzással nem. Továbbá a név nem lehet az R-ben már lefoglalt kulcsszó, mint például `if`, `function` vagy `TRUE` (a kulcsszavak listáját a `?Reserved` paranccsal ismerhetjük meg). Hagyományosan a pont karaktert használjuk az objektumnevekben a tagolásra (például `magassag.peter` Péter magasságának tárolására). Az R a magyar ékezetes karakterek használatát is megengedi az objektumnevekben, de csakúgy mint az állományok és könyvtárak elnevezésében, érdemes ezek használatát mellőzni.

Az objektumoknak érdemes "beszédes" nevet választani, még ha ennek az ára némi extra gépelés is. Tudjuk, a `Tab` billentyű segíti a gépelést az *RStudio*-ban.

Az R kis- és nagybetű érzékeny, vagyis az `x` és a `X` különböző objektumoknak számítanak. Például a következő 

```{r}
pulzus.atlag <- 72
```

parancs után a 

```{r eval=FALSE, tidy=FALSE}
Pulzus.atlag
#> Error: object 'Pulzus.atlag' not found
```

sor hibát jelez (`Error: object 'Pulzus.atlag' not found`), azaz a `Pulzus.atlag` objektumot nem találja az R. Minden olyan esetben, ha nem létező objektumra hivatkozunk, a fenti hibaüzenet jelenik meg a konzolban.

Amennyiben gondoskodunk nagy `P`-vel kezdődő objektumról is, akkor lehetőségünk van hibaüzenet nélkül mindkét objektum értékének kiíratására. 

```{r tidy=FALSE}
Pulzus.atlag <- 69           # új objektumot hozunk létre
Pulzus.atlag; pulzus.atlag   # két parancs egy sorban
```

A gyakorlatban kerüljük el az olyan helyzeteket, amikor két objektumnév csak kis- nagybetűk használatában tér el. 

A fenti példában egy további apró újdonság is szerepelt. Ha egy parancssorban több utasítást szeretnénk elhelyezni, akkor ezeket pontosvesszővel (`;`) kell elválasztanunk. A pontosvesszővel elválasztott utasításokat az R értelmező egymás után, balról jobbra haladva hajtja végre, mintha külön sorba írtuk volna őket. A lenti sor 3 kifejezést (parancsot) tartalmaz pontosvesszővel elválasztva, mindegyik eredménye külön-külön jelenik meg a konzolban, mintha 3 különböző sorba írtuk volna őket.


```{r tidy=FALSE}
1+2; 3+4; 5+6     # három kifejezés egy sorban
```


### Megjegyzések {#MegjegyzesazRben}

Nagyon sok példában láttunk már magyar nyelvű, magyarázó, értelmező szövegrészeket az R parancsok körül. Ezek az R *megjegyzések*. Megjegyzést az R-ben a kettőskereszt (`#`) karakter használatával vezetünk be. Az R értelmező a kettőskereszttől a sor végéig tartó részt figyelmen kívül hagyja. Itt helyezhetjük el a paranccsal kapcsolatos magyarázatainkat magunk vagy a kódot később olvasók számára. Teljes sorokat, vagy a sorok végét tudjuk így kivonni a végrehajtás alól. 

```{r tidy=FALSE}
# Érdekes tény, ha a 153 számjegyeit köbre emeljük, 
#   majd összeadjuk őket, pontosan 153-at kapunk
1^3+5^3+3^3       # hatványozás a ^ operátorral
1**3+5**3+3**3    # hatványozás a ** operátorral
```

Nem kizárólag magyarázó szövegek kerülhetnek megjegyzésbe, sokszor R parancsok végrehajtását akadályozzuk meg ezzel a módszerrel. Úgy kerülhetjük el egy parancs végrehajtását, hogy nem kell kitörölnünk a parancsállományból vagy az RMarkdown állományból, egyszerűen csak megjegyzésbe kell tennünk őket. Emlékezzünk vissza, hogy az \@ref(Csomagoktelepitese). fejezetben a csomagok telepítésért felelős parancsok esetében kifezetten javasoltuk a megjegyzések használatát:

```{r tidy=FALSE, eval=FALSE}
# xkcd: Randall Munroe webképregényei
# install.packages("RXKCD")
library(RXKCD)             # csomag betöltése       
searchXKCD("Star Wars")    # keresés címben vagy leírásban
getXKCD(1769)              # webképregény megjelenítése
```


Végül megemlítjük, hogy az *RStudio*-ban egyszerre több kijelölt sort tudunk megjegyzésbe tenni, vagy onnan kivenni a `Ctrl+Shift+C` segítségével.

### Összefoglalás {#az-r-nyelv-1-summary}

```{block, type='rmdsummary'}

Egyszerű kifejezéseket építhetünk numerikus konstansok (számok), operátorok és kerek zárójelek segítségével. A legfontosabb matematikai operátorok a négy alapművelet és a hatványozás. A kifejezés kiértékelése balról jobbra sorrendben történik, de ezt felülírhatja a kerek zárójelek használata és az operátorok precedenciája. Egy kifejezés értékét eltárolhatjuk a memória speciális területén, a munkamemóriában. Ehhez az értékadó operátorral (`<-`) létre kell hoznunk egy új objektumot. Az objektum egy név-érték páros. Az objektum létrehozása után az objektum neve megjelenhet egy tetszőleges kifejezés adat részében. Több parancsot a pontosvesszővel (`;`) írhatunk egy sorba. Megjegyzéseket a kettőskereszt (`#`) segítségével helyezhetünk el.

```


### Feladatok {#az-r-nyelv-1-exercise}

```{block2, type='rmdexercise'}

1. Gondoljuk át, mi lehet a következő algebrai kifejezés eredménye, majd ellenőrizzük R-ben is: $8/2(2+2)$.
1. Gondoljuk át, hogy a `.342e1` név miért nem lehet érvényes objektumnév? Próbáljuk ki a `make.names(".342e1")` parancsot, majd tanulmányozzuk a `?make.names` leírást!
1. Magyarázzuk meg a `make.names(c("", "", ""))` és a `make.names(c("", "", ""), unique = T)` parancsok közötti különbséget!
1. Gondoljuk át, hogy egy parancsállomány mely pontjain érdemes feltétlenül megjegyzéseket használni!
1. Jelentősen segíthetjük a navigációt az *RStudio* parancsállományaiban, ha bizonyos megjegyzések végére ezt írjuk: ` ----` (szóköz és négy mínusz jel). Hogyan használhatjuk ezt a lehetőséget az *RStudio*-ban, és milyen előnyei vannak?
1. Az *RStudio*-ban parancsállomány (`.R`) szerkesztése közben próbáljuk ki a `Ctrl+Alt+R` billentyűparancsot, és a hozzá kapcsolódó `Shift+Alt+J` billentyűparancsot is. Mi a jelentése az `Alt+L`, `Shift+Alt+L`, `Alt+O` és `Shift+Alt+O` billentyűparancsoknak? A most megismert funkciók hogyan válthatók ki RMarkdown (`.Rmd`) állomány szerkesztése közben?
  
```

`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-1-exercise-solution)'`

## Függvények

```{block2, type='rmdlevel1'}

Ebben a fejezetben:
  
* áttekintjük a függvényhívás lehetőségeit a nevesített argumentumokkal, az alapértelmezésekkel és az argumentumok sorrendjének megváltoztatásával,
* megismerjük a legfontosabb matematikai függvényeket,
* és pontosítjuk a kifejezés fogalmát.

```


Az aritmetikai kifejezéseinkben használható operátorok nem teszik lehetővé minden matematikai művelet elvégzését. Mit tegyünk ha a 2 négyzetgyökét szeretnénk kiszámolni? A négyzetgyökvonás operátor nem létezik az R-ben, de ebben a speciális esetben a hatványozás operátor segítségével is elérhetjük a célunkat.

```{r}
2^0.5
```

Az R azonban más lehetőséget is biztosít a négyzetgyök kiszámítására és ez az `sqrt()` függvény.

```{r}
sqrt(2)
```

A függvények valamilyen utasítássorozatot hajtanak végre és a számítás eredményét szolgáltatják. Esetünkben az `sqrt()` függvény egy szám (pozitív) négyzetgyökét számolja ki, annak a számnak a négyzetgyökét, amely a kerek zárójelek között szerepel. Tehát az R a paraméterben megadott 2 értékre meghívja az `sqrt()` függvényt, ami visszatér a 2 négyzetgyökével.

### A függvényhívás szabályai

A függvényhívás általános alakja:

```markdown
függvénynév(argNév1=arg1, argNév2=arg2, ..., argNévN=argN)
```

A függvény neve ugyanazoknak a szabályoknak engedelmeskedik, amelyeket az objektumok nevénél megtárgyaltunk (lévén a függvény is egy objektum). A függvény neve után kerek zárójelben következnek a függvény argumentumai, amelyek a függvény utasításainak a bemenő paraméterei. A függvény a bemenő paraméterek alapján az utasításainak megfelelően egy visszatérési értéket fog szolgáltatni.

Egy függvény különböző hívásainál az előforduló argumentumok száma és azok sorrendje igen változatos képet mutathat. Elöljáróban elmondhatjuk, hogy a függvények argumentumai alapértelmezett értékkel is rendelkezhetnek, így ezek az argumentumok elhagyhatók. Továbbá, a függvények argumentumai névvel is rendelkeznek, amelyeket ha a függvény hívásánál felhasználjuk, az argumentumok sorrendje tetszőleges lehet.


Először tekintsük át az R alapvető matematikai függvényeit (\@ref(tab:matfuggvenyek). táblázat). Nézzük meg részletesebben a `log()` függvényt. Ha kikérjük a súgóját a `?log` parancs begépelésével, akkor megtudhatjuk, hogy ez a legáltalánosabb logaritmus függvény, tetszőleges alap esetén hívható. Számunkra most a legfontosabb a súgónak az a sora, amely a logaritmus függvény használatát mutatja: `log(x, base=exp(1))`. 



```{r matfuggvenyek, echo=FALSE}
table.kiir <- data.frame(A=c( "abs(x)", 
                              "sign(x)", 
                              "sqrt(x)", 
                              "exp(x)", 
                              "log(x,base=exp(1))", 
                              "log10(x);log2(x)", 
                              "cos(x);sin(x);tan(x)", 
                              "round(x,digits=0)", 
                              "floor(x)", 
                              "ceiling(x)", 
                              "trunc(x)"),
                         B= c("abszolútérték függvény",
                              "előjel függvény",
                              "négyzetgyök függvény",
                              "exponenciális függvény",
                              "logaritmus függvény",
                              "10-es és 2-es alapú logaritmus",
                              "trigonometrikus függvények",
                              "kerekítés adott tizedesre",
                              "x-nél kisebb, legnagyobb egész",
                              "x-nél nagyobb, legkisebb egész",
                              "x-hez közelebbi egész x és 0 között"
                              ),
                         C=c( "abs(-1)",
                              "sign(pi)",
                              "sqrt(9+16)",
                              "exp(1)",
                              "log(exp(3));log(8,10)",
                              "log10(1000);log2(256)",
                              "cos(pi);sin(0);tan(0)",
                              "round(c(1.5,-1.5))",
                              "floor(c(1.5,-1.5))",
                              "ceiling(c(1.5,-1.5))",
                              "trunc(c(1.5,-1.5))"
                              ))


table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
  col.names = c("Függvény",
                "Leírás",
                "Példa"),
  caption = 'Az R alapvető matematikai függvényei',
  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))

```


Ebből kiolvasható, hogy a `log()` függvénynek 2 argumentuma (más néven paramétere) van. Az elsőt `x`-nek, a másodikat `base`-nek nevezik. A második paraméter alapértelmezett értékkel is rendelkezik, tehát ez a paraméter a hívásnál elhagyható, míg az `x=` argumentum megadása kötelező. A `base=` paraméter értéke könnyen kideríthető az 

```{r}
exp(1)    #  Euler-féle szám, a természetes logaritmus alapja 
```

parancsból. Ezt az irracionális számot a matematikában *e*-vel jelöljük, és Euler-féle számnak nevezzük, ez a természetes logaritmus alapja. Ha nem határozzuk meg a második paramétert, akkor a `log()` függvény ezzel a természetes alappal (`base=exp(1)`) számítja ki az `x` logaritmusát.

Ezek alapján 2 természetes alapú logaritmusát a 

```{r}
log(2)    # 2 természetes alapú logaritmusa
```


függvényhívás adja meg. Azt is megtehetjük, hogy felhasználjuk hívásnál az argumentum nevét (`x`), és egy egyenlőségjel (`=`) felhasználásával ezt a 2 elé szúrjuk be.

```{r}
log(x=2)   # 2 természetes alapú logaritmusa
```

A fenti sor természetesen ugyanúgy a 2 természetes alapú logaritmusát szolgáltatja, csak most explicit módon közöltük, hogy az aktuális paraméterben szereplő 2-es értéket az `x=` nevű formális paraméternek feleltetjük meg. Ez most felesleges gépelést jelentett és általában is elmondhatjuk, hogy matematikai függvények esetében az oly gyakori `x=` argumentumnevet szokás szerint nem írjuk ki a függvényhívás során.

Hívjuk most két argumentummal a `log()` függvényt. A 100 10-es alapú logaritmusát a

```{r}
log(100, 10)        # 100 10-es alapú logaritmusa
```

paranccsal tudhatjuk meg. A függvényhívásnál az `x=` formális argumentum a 100, a `base=` pedig a 10 értéket kapja. Természetesen ezt a hívásnál mi is rögzíthetjük a világosabb értelmezés kedvéért saját magunk számára a

```{r}
log(100, base=10)    # 100 10-es alapú logaritmusa
```

vagy akár

```{r}
log(x=100, base=10)  # 100 10-es alapú logaritmusa
```


formában is.

Arra is lehetőség van, hogy megcseréljük az aktuális paraméterek sorrendjét. A legbiztonságosabb ekkor az összes paraméter nevesítése,


```{r}
log(base=10, x=100)  # 100 10-es alapú logaritmusa
```


de két argumentum esetén így is egyértelmű a hozzárendelés:


```{r tidy=FALSE}
log(base=10, 100); log(10, x=100)  # 100 10-es alapú logaritmusa 2x
```

Ha az argumentumok nevesítése nélkül cseréljük fel az aktuális paramétereket, akkor természetesen nem a várt eredményt kapjuk, mert a 10 100-as alapú logaritmusa lesz az eredmény.

```{r}
log(10, 100)  # 10 100-as alapú logaritmusa
```


Kényelmi lehetőség az aktuális paraméterek elnevezésénél, hogy rövidítéseket is használhatunk, addig csonkolhatjuk az argumentum nevét, amíg az argumentumok egyértelműen azonosíthatók maradnak. Így a példában akár a `b=`-vel is helyettesíthetjük a `base=` argumentumnevet:


```{r}
log(b=10, 100)   # 100 10-es alapú logaritmusa
```


Mint korábban említettük, az `x=` argumentum nem rendelkezik alapértelmezett értékkel, így paraméter nélkül nem hívható a `log()` függvény. 

```{r eval=FALSE, tidy=FALSE}
log()
#> Error: argument "x" is missing, with no default
```

A fenti hibaüzenethez hasonlót láthatunk, ha egy függvényt nem megfelelő számú paraméterrel hívunk. 

Eddig a függvények aktuális paramétereiként csak numerikus konstansokat használtunk, pedig valójában tetszőleges kifejezéseket is megadhatunk. A függvény hívása előtt ezek kiértékelődnek és a hívás során ezek az értékek rendelődnek a formális paraméterekhez.

```{r tidy=FALSE}
alap <- 10; log(exp(1)); log(exp(4),base=alap); log(2*exp(2),b=alap/2)
```

A fenti példa a következő numerikus konstansokkal történő hívásoknak felel meg:

```{r tidy=FALSE}
log(2.718282); log(54.59815, base=10); log(14.77811, base=5)
```

A függvények sokféle csoportja létezik az R-ben, a most látott matematikai függvények osztálya csak egy a sok közül. A következő fejezetekben függvények más csoportjait is megismerjük.

### A kifejezés fogalma

Elérkezett az idő, hogy a kifejezés fogalmát pontosíthassuk: **egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerek zárójelekkel helyesen összefűzött sorozata is kifejezés**.

Az R nyelv parancsai, vagy más néven utasításai lényegében kifejezések. Az R nyelvben egy parancs végrehajtása lényegében egy kifejezés kiértékelését jelenti, és a legtöbb esetben a kifejezés értékének megjelenítését a konzolban.

A munka során az R értelmező az utasítások egymás utáni kiértékelését végzi. Az utasításokat újsor karakter vagy pontosvessző választhatja el. A szintaktikailag helyes utasítások kiértékelése mindig egy értéket eredményez, ez lesz az utasítás értéke. Még akkor is rendelkezik értékkel az utasításunk, ha az nem jelenik meg a parancssorban, például az értékadó utasítás értéke a jobb oldali kifejezés értéke. Ezért írhatjuk a következő parancsot:

```{r tidy=FALSE}
y <- x <- 10
x; y
```

Amennyiben egy értékadás, mint kifejezés értékét szeretnénk megjeleníteni a konzolban, akkor tegyük kerekzárójelbe a teljes sort:

```{r}
(x <- 20)
```

A kifejezés fogalmának gyakorlásához nézzünk egy példát. A másodfokú egyenlet megoldóképlete segítségével oldjuk meg az $x^{2}–5x+4=0$ egyenletet. Gépeljük be a következő sorokat:

```{r tidy=FALSE}
egyutthato.a <- 1
egyutthato.b <- -5
egyutthato.c <- 4
D <- sqrt(egyutthato.b^2-4*egyutthato.a*egyutthato.c)
(-egyutthato.b+D)/(2*egyutthato.a)   # 1. gyök
(-egyutthato.b-D)/(2*egyutthato.a)   # 2. gyök
```

A fenti hat sor mindegyike egy-egy kifejezés. Az első három sorban lévő kifejezéseknek nincs outputja a konzolban, céljuk új objektumok létrehozása, és maguk a kifejezések csupán értékadó operátort, objektumnevet és konstanst tartalmaznak. A negyedik sor kifejezése szintén output nélkül hajtódik végre, és itt is új objektum jön létre, a kifejezés több összetevőt tartalmaz: objektumneveket, függvényhívást, matematikai operátorokat és konstansokat. Az ötödik és hatodik sorban lévő kifejezések értékei a kiértékelés után megjelennek az outputban, és objektumnevekből, matematikai operátorokból, kerek zárójelekből és konstansokból épülnek fel. 

### Összefoglalás {#az-r-nyelv-2-summary}

```{block, type='rmdsummary'}

A függvényobjektumok (vagy röviden függvények) előre definiált utasítások sorozatát hajtják végre, és egy visszatérési értéket szolgáltatnak. A visszatérési érték meghatározását a függvény bemenő paraméterei, azaz az argumentumok is befolyásolják. Minden argumentumnak van neve, és rendelkezhetnek alapértelmezett értékkel is. Az R-rel való munka nem más, mint kifejezések létrehozása és végrehajtása, vagyis kiértékelése. A kifejezés fogalma: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerek zárójelekkel helyesen összefűzött sorozata is kifejezés. A kifejezések kiértékelése során az eredmény megjelenhet a konzolban, de látható output nélkül is végbemehet a kifejezés végrehajtása.  


```

### Feladatok {#az-r-nyelv-2-exercise}

```{block2, type='rmdexercise'}

1. Tekintsük át az \@ref(tab:matfuggvenyek). táblázat utolsó oszlopában szereplő R függvényeket. Próbáljuk megjósolni a függvények visszatérési értékét. Végezzünk ellenőrzést: gépeljük be, és hajtsuk végre a matematikai függvényeket! Egészítsük ki a begépelt matematikai függvényeket az argumentumok nevével, mindegyik argumentumnak adjunk nevet az \@ref(tab:matfuggvenyek). táblázat első oszlopa alapján! 
1. Az előző feladatban a matematikai függvények gépelése során milyen *RStudio* kényelmi funkciókat fedeztünk fel. Soroljunk fel legalább hármat!
1. Az aranymetszés arányait tartalmazó épületek, képzőművészeti alkotások máig nagy esztétikai értékkel bírnak. Határozzuk meg ezt az arányt a $\phi=\frac{1+\sqrt{5}}{2}$
 képlet segítségével! Egy A/4-es oldalra kb. 47 sort írhatunk 12-es betűmérettel, és kb. 35 sort 16-os betűmérettel. Egy üres lap hanyadik sorába írnánk címet 12-es és 16-os betűméret esetén? Próbáljuk ki mindezt egy szövegszerkesztőben is! 
1. A trigonometrikus függvények argumentumában radiánban kell megadni a szög értékét, és nem fokban. Ezt figyelembe véve határozzuk meg a 0, 30, 45, 60, 90 és 180 fok szinuszát, koszinuszát és tangensét!
  
```

`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-2-exercise-solution)'`

## Adatszerkezetek

```{block2, type='rmdlevel1'}

Ebben a fejezetben:
  
* áttekintjük a numerikus, karakteres és logikai konstansok írását,
* a vektor, mátrix, faktor, lista, és adattábla adatszerkezeteket,
* ezek kezelését, indexelését, tesztelését és konvertálását.

```


Kezdünk egyre mélyebre ásni az R nyelvben. Megismertük már az adatobjektum, függvény és kifejezés fogalmát. Ezek birtokában már bátran belevághatunk könyvünk kulcsfontosságú fejezetébe, az adatszerkezetek tanulmányozásába. Legyünk alaposak az itt szereplő témakörök áttekintésében, és lehetőleg oldjunk meg minden kitűzött feladatot. Később ez sokszorosan megtérül.

Minden statisztikai programcsomag adatokkal dolgozik. Az R-ben nevekkel ellátott objektumokban tároljuk ezeket az adatokat. Lényegében minden tevékenység ezen objektumok létrehozása, módosítása és lekérdezése köré csoportosítható. Ezeket a műveleteket az R-ben az operátorok és a függvények végzik. Láttuk, adatokból (objektumokból), operátorokból és függvényekből kifejezéseket építünk, és hajtunk végre -- így foglalható össze minden egyes tevékenység az R-ben. 

Ebben a fejezetben a kifejezések adat részére összpontosítunk, hiszen minden adatelemzési munka kiinduló pontja maga az adat. Eddig csak számszerű (numerikus) adatokkal találkoztunk, és azok közül is csak az egész számok leírására fókuszáltunk. Adatfeldolgozási folyamatainkban a mért adatok azonban a numerikus mellett karakteres formában is előfordulnak, valamint az R-ben egy harmadik adattípus, a logikai is fontos szerepet kap. Összefoglalva, három R alaptípus lesz fontos számunkra az adatfeldolgozás során:

* *numerikus* típus, amely lehet *double* vagy *integer*, attól függően, hogy tizedestörteket vagy egész számokat szeretnénk tárolni,
* *karakteres* típus, amelyek nem egyetlen karaktert, hanem egy karaktersorozatot vagy más néven sztringet jelentenek,
* *logikai* típus, amely az adatszerkezetek manipulációja során jut nagyon fontos szerephez.

A továbbiakban megismerjük, hogyan adhatjuk meg az R számára a fenti típusokba tartozó értékeket, illetve ezek felhasználásával, hogyan tudunk bonyolultabb adatszerkezeteket, összetett típusokat létrehozni.


### Konstansok

Mért adatokat közvetlenül az R-be konstansok segítségével írhatunk be. A konstansok olyan objektumoknak is tekinthetők, amelyeknek nincs nevük, csak értékük, és azt nem is tudjuk megváltoztatni. Ha Péter 18 éves, akkor azt a `18` leírásával közölhetjük az R-rel, és ez nem is jelenthet mást (nem lehet más az értéke), mint 18. A már említett három egyszerű típusnak megfelelően tekintsük át a numerikus, karakteres és logikai konstansokat.

#### Numerikus konstansok

A numerikus konstansok többféle alakban is megjelenhetnek az R-ben. Az *integer* szóval az egész számok tárolását végző konstansra hivatkozunk, a *double* konstansok pedig törtrészt is tartalmazhatnak, de ez nem kötelező. Ha nem érdekes, hogy a szám *integer* vagy *double*, akkor egyszerűen a numerikus (R-ben *numeric*) elnevezést használjuk.


```{r numkonstansok, echo=FALSE}
table.kiir <- data.frame(A=c("1, -1, 2, 100, 3.5, .4",
                             "1L, -1L, 2L, 100L",
                             "1.2e3, 3e+4, .6e-2, 4e1L",
                             "0xef, 0XF01, -0xEf03, 0xd1L"),
B=c("pozitív és negatív double számok",
    "pozitív és negatív integer számok az ’L’ utótaggal",
    "exponenciális alakú double és integer számok",
    "hexadecimális double és integer számok")
)

table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
  col.names = c("Numerikus konstans formája",
                "Leírás"),
  caption = 'Numerikus konstansok írása',
  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))

```


Az \@ref(tab:numkonstansok). táblázatban látható, hogy *integer* értékek írásához szükséges az `L` utótag használata, egyébként *double*-ként kezeli az R a számot, még akkor is ha nem adtunk meg törtrészt. 

Fontos szabály, hogy a tizedesvessző alakja az R-ben a pont. A nulla egész részű tizedes törtek esetében az értéktelen nullát elhagyhatjuk.


```{r tidy=FALSE}
0.04; .04; -.04 # utóbbi egy negatív szám, a nulla egészrész megadása nélkül
```

Használhatunk az R-ben exponenciális alakú és hexadecimális (16-os számrendszerű) számokat is.

```{r tidy=FALSE}
12e3; 12E+3; 12e-3; 0xa2e; 0Xa2e
```

Az exponenciális alakú számokat `e` vagy `E` karakter vágja ketté, egy bal oldali és egy jobb oldali részre. Az exponenciális alakú szám értéke: a bal oldali rész szorozva 10 annyiadik hatványával, mint amennyi a jobb oldali rész. Érdemes időt szentelni az exponenciális alakú számok értelmezésére, mert az R outputokban gyakran előfordulnak: a szám előjelét a bal oldali rész előjele dönti el, viszont a nagyságrendjét a jobb oldali szám nagyságrendje és előjele együtt határozza meg.

Az exponenciális alakú számok nagy előnye, hogy a nagyon kis, illetve nagyon nagy számok nagyságát jobban meg tudjuk ítélni, és persze az ilyen alakú számok leírásánál helyet is megtakarítunk.


```{r tidy=FALSE}
0.0000000000000000000000000016726         # proton tömege (kg)
0.00000000000000000000000000000091093822  # elektron tömege (kg)
100000000        # ennyi fele kell figyelni egy diáknak (százmillió)
5970000000000000000000000                 # A Föld tömege (kg)
```

Az R automatikusan exponenciális alakra vált túl kicsi vagy túl nagy számok konzolbeli megjelenítésénél. Ezt a viselkedést az R egyik globális opciójának beállításával tudjuk szabályozni. A globális opciókat az `options()` függvénnyel tudjuk állítani az R-ben (`?options`), amelyben most a `scipen=` paramétert kell megadnunk. Minél nagyobb pozitív értéket adunk meg, annál jobban törekszik az R a számok fix alakú megjelenítésére, negatív érték megadásánál pedig ugyanez igaz az exponenciális alakra. 

```{r tidy=FALSE}
options(scipen= 0)       # az alapértelmezés
0.0000001                # túl kicsi: exponenciális lesz
123                      # marad fix alakú 
100000000                # túl nagy: exponenciális lesz
options(scipen=-8); 0.0000001; 123; 100000000 # exponenciális lesz mind
options(scipen= 8); 0.0000001; 123; 100000000 # fix lesz mind
options(scipen= 0)       # az alapértelmezés visszaállítása
```

A 16-os számrendszerű számok írásához a `0-9` és a kis `a-f` vagy nagy `A-F` betűket használhatjuk fel. A hexadecimális számokat a `0x` vagy `0X` előtag vezeti be.

Aritmetikai műveleteinkben rendszerint double típusú számokat, 10-es számrendszerben és fix (nem exponenciális) alakban használunk. De ettől bármikor eltérhetünk: 

```{r tidy=FALSE}
12L + -3.04 + 3.4e2 + -0x1af  # számok 4 különböző formában
```

A számok megjelenését a konzolban még egy globális opció befolyásolja. A `digits` megszabja, hány értékes jegyre pontosan jelenjenek meg a számaink a konzolban. Lehetséges értékei az 1-22 tartományba esnek, alapértelmezés szerint 7 az értéke. A beállított érték csak egy ajánlás az R számára, és főképp tizedes törtek esetén okozhat meglepetést, ha túl kicsire állítjuk a `digits` értékét.

```{r tidy=FALSE}
options(digits = 1); 12.36
options(digits = 2); 12.36
options(digits = 3); 12.36
options(digits = 4); 12.36
options(digits = 7)        # alapértelmezés visszaállítása
```

Természetesen objektumokat is létrehozhatunk a numerikus értékek tárolására, ahogyan korábban már láttuk. Az objektum típusa a konstans típusával fog megegyezni:

```{r tidy=FALSE}
peter.magassaga <- 181                                  # double objektum
peter.sulya     <- 72L                                  # integer objektum
peter.bmi       <- peter.sulya /(peter.magassaga/100)^2 # double objektum
```


#### Karakteres konstansok

Az R-ben a karakteres konstans (vagy más néven sztring vagy karaktersorozat) speciális karakterekkel határolt, tetszőleges karaktereket tartalmazó sorozat. A karakteres konstans tehát nem egyetlen karaktert jelent tipikusan, hanem többet. Három módszerrel adhatunk meg karakteres konstanst:

```{r tidy=FALSE}
"Látni távol kis falucska tornyát."
'Látni távol kis falucska tornyát.'
r"(Látni távol kis falucska tornyát.)"
```

Karakteres konstansok készítésekor a tetszőleges karaktersorozatunkat dupla (`"`) vagy egyszeres (`'`) idézőjellel kell körbevennünk, de az R 4.0.0-ás verziójától az `r"(tetszőleges_karaktersorozat)"` forma is elérhetővé vált. Láthatjuk, hogy az R a dupla idézőjelet részesíti előnyben az output megjelenítése során.

Egy karakteres konstans tetszőleges karaktert (betűt, számjegyet, írásjeleket, szóközt stb.) tartalmazhat, de az első két megadási forma esetében azt a határolójelet el kell elkerülnünk, amelyet az illető karakteres konstans létrehozásánál használtuk. Látjuk, hogy az `r"(tetszőleges_karaktersorozat)"` forma adja a legnagyobb szabadságot, de a legtöbbször a dupla  (`"`) idézőjeles formával találkozunk.

A karakteres konstansok tartalmazhatnak ún. escape szekvenciákat, olyan backslash jellel (`\`, fordított perjel) kezdődő karaktersorozatokat, amelyeket speciálisan értelmez az R. A legfontosabb escape szekvenciákat és jelentésüket az \@ref(tab:escapes). táblázat tartalmazza.


```{r escapes, echo=FALSE}
table.kiir <- data.frame(A=c( "\\t",
                              "\\r",
                              "\\n",
                              "\\\"",
                              "\\\'",
                              "\\\\"
                              ),
                         B= c("tabulátor",
                              "kocsi vissza karakter",
                              "új sor karakter",
                              "dupla idézőjel",
                              "szimpla idézőjel",
                              "backslash karakter"
                              ))


table.kiir <- data.frame(A=c( "\\\\t",
                              "\\\\r",
                              "\\\\n",
                              "\\\"",
                              "\\\'",
                              "\\\\"
                              ),
                         B= c("tabulátor",
                              "kocsi vissza karakter",
                              "új sor karakter",
                              "dupla idézőjel",
                              "szimpla idézőjel",
                              "backslash karakter"
                              ))

table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
  col.names = c("Escape szekvencia",
                "Jelentése"),
  caption = 'Néhány escape szekvencia',
  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))


```


Természetesen, karakteres objektumokat is létrehozhatunk.

```{r tidy=FALSE}
nev <- 'Zsolt'; foglalkozas <- "festő"; lakohely <- r"(Érd)"
nev; foglalkozas; lakohely
```

Karakteres operátor az R-ben nincs, de számos karakterkezelő függvény segíti a sztringek kezelését (\@ref(tab:karfuggvenyek). táblázat).


```{r karfuggvenyek, echo=FALSE}
table.kiir <- data.frame(A=c( "paste();paste0(sep=\"\")",
                              "nchar(x)",
                              "substr(x,start,stop)",
                              "tolower(x)",
                              "toupper(x)",
                              "chartr(old,new,x)",
                              "cat(sep=\" \")",
                              "grep();grepl();regexpr()",
                              "sub();gsub()"
                              ),
                         B= c("sztringek összefűzése",
                              "karakterszrting hossza",
                              "sztring egy része",  
                              "kisbetűsre konvertál",
                              "nagybetűsre konvertál",
                              "karakterek cseréje",
                              "kiíratás",
                              "részsztringek keresése",
                              "részsztringek cseréje"
                              ),
                         C=c( "paste(\"a\",\"b\",sep=\"=\")",
                              "nchar(\"alma\")",
                              "substr(\"alma\", 3, 5)",
                              "tolower(\"Kiss Géza\")",
                              "toupper(\"Kiss Géza\")",
                              "chartr(\"it\",\"ál\",\"titik\")",
                              "cat(\"alma\",\"fa\\n\",sep=\"\")",
                              "grepl(pattern=\"lm\",x=\"alma\")",
                              "gsub(\"lm\",repl=\"nyj\",x=\"alma\")"))


table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
  col.names = c("Függvény",
                "Leírás",
                "Példa"),
  caption = 'Néhány karakterkezelő függvény',
  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))


```

#### Logikai konstansok

Az eddigiekben megismert numerikus és karakteres konstansok nagyon sokfélék lehetnek, de ugyanígy a numerikus és karakteres objektumokhoz nagyon sok lehetséges numerikus és karakteres érték rendelhető. A logikai adattípus ezektől lényegesen egyszerűbb típus, mivel itt összesen két érték tárolására van módunk. Ez a logikai *igaz* és a logikai *hamis* érték, amelyek az R nyelvben a `TRUE` és a `FALSE` logikai értékeket jelentik. Az R a logikai értékek írását a `T` és `F` globális változók bevezetésével segíti, ezek induló értéke a `TRUE` és a `FALSE` logikai érték.

Ezeket a logikai konstansokat értékadásban is szerepeltethetjük, így logikai objektumokat hozhatunk létre.

```{r tidy=FALSE}
fiu <- TRUE; van.kocsija <- FALSE; hazas <- T
fiu; van.kocsija; hazas
```

Logikai értékeket vagy objektumokat relációs operátorok segítségével is létrehozhatunk (\@ref(tab:reloperatorok). táblázat).

```{r reloperatorok, echo=FALSE}
table.kiir <- data.frame(A=c( "<",
                              ">",
                              "<=",
                              ">=",
                              "==",
                              "!=",
                              "%in%"
                              ),
                         B= c("kisebb",
                              "nagyobb",
                              "kisebb egyenlő",
                              "nagyobb egyenlő",
                              "egyenlő",
                              "nem egyenlő",
                              "tartalmazás"
                              ),
                         C=c( "1<2;\"alma\"<\"körte\"",
                              "3>(1+2);\"abc\">\"ab\"",
                              "1<=-.3;\"él\"<=\"elő\"",
                              "3/4>=7/9;\"aki\">=\"Ági\"",
                              "20==2e1;\"Len\"==\"len\"",
                              "exp(1)!=pi;\"Len\"!=\"len\"",
                              "c(8, 12) %in% 1:10"
                           ),
                         D=c( "TRUE TRUE",
                              "FALSE TRUE",
                              "FALSE TRUE",
                              "FALSE TRUE",
                              "TRUE FALSE",
                              "TRUE TRUE",
                              "TRUE FALSE"))


table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(D=kableExtra::cell_spec(D, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
  col.names = c("Operátor formája",
                "Művelet",
                "Példa",
                "Példa értéke"),
  caption = 'Relációs operátorok',
  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))


```

Numerikus és karakteres adatok is lehetnek a relációs operátorok bemenő adatai. Numerikus adatok esetén a számok nagysága, karakteres adatok esetén az ábécében elfoglalt hely és a sztringek hossza (lexikografikus sorrend) alapján végzi az R az összehasonlítást. A sztringek lexikografikus összehasonlítása, magyar területi beállítások esetén, a magyar ékezetes karaktereket is helyesen kezeli.

A logikai értékkel visszatérő kifejezéseket (egyszerű) logikai kifejezéseknek nevezzük. Ezekből az egyszerű logikai kifejezésekből a logikai operátorok segítségével összetett logikai kifejezéseket hozhatunk létre (\@ref(tab:logoperatorok). táblázat).

```{r logoperatorok, echo=FALSE}
table.kiir <- data.frame(A=c( "!",
                              "&",
                              "|"
                              ),
                         B= c("logikai NEM",
                              "logikai ÉS",
                              "logikai VAGY"
                              ),
                         C=c( "!(1<2); !T; !F",
                              "T & T; T & F; F & T; F & F",
                              "T | T; T | F; F | T; F | F"
                           ),
                         D=c( "FALSE FALSE TRUE", 
                              "TRUE FALSE FALSE FALSE",
                              "TRUE TRUE TRUE FALSE"))


table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(D=kableExtra::cell_spec(D, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
  col.names = c("Operátor",
                "Művelet",
                "Példa",
                "Példa értéke"),
  caption = 'Logikai operátorok',
  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))


```


#### Összefoglalás {#az-r-nyelv-3-1-summary}

```{block, type='rmdsummary'}

Az adatfeldolgozás során többnyire számokkal és szövegekkel dolgozunk. Az R a numerikus és a karakteres adatok írásának szabályait pontosan rögzíti. Numerikus konstansok írása a matematikában megszokott módon történik (például `12`, `-24`, `12e+3`, `0xabc3`), azonban fontos megjegyeznünk, hogy a tizedestörtek esetében pontot kell használnunk az egész és a törtrész elválasztására (például `12.34`, `-0.04`, `3.12e+12`). Karakteres konstansok esetében a következő formákat használhatjuk: `"tetszőleges karakterek"`, `'tetszőleges karakterek'`, és `r"(tetszőleges karakterek)"`. A logikai konstansok az adatmanipuláció során nyújtanak segítséget, két leheséges értékük a logikai igaz és hamis: a `TRUE`, `FALSE` vagy rövidebben a `T`, `F`.

```

#### Feladatok {#az-r-nyelv-3-1-exercise}

```{block2, type='rmdexercise'}

1. Mi a hasonlóság a következő három numerikus konstans között: `0xabc`, `2748`, `.2748e4`. 
1. Az R öt előre definiált konstassal rendelkezik (`?Constants`). Írassuk ki ezek értékeit, állapítsuk meg típusukat!
1. Az aranymetszés arányszámát ($\phi=\frac{1+\sqrt{5}}{2}$) írassuk a konzolba legalább 8 tizedes pontossággal!
1. Az `r"(tetszőleges karakterek)"` formájú karakteres konstans megadásnak több válozata is létezik, soroljunk fel még legalább öt lehetőséget (`?Quotes`)! Milyen előnyökkel rendelkezik ez a megadási forma az idézőjelek és a fordított perjel tekintetében? 
1. Helyezzünk el idézőjeleket karakteres konstansokban, mindhárom megadási forma mellett!
1. Próbáljuk ki az \@ref(tab:karfuggvenyek). táblázat karakterkezelő függvényeit! Gépeljük be az utolsó oszlopban lévő példákat, és vizsgáljuk meg a függvények visszatérési értékét.
1. Próbáljuk ki az \@ref(tab:reloperatorok). táblázat relációs operátorait! Gépeljük be a példákat és ellenőrizzük az eredményeket.
1. A logikai operátorok működéséről teljes képet kaphatunk az \@ref(tab:logoperatorok). táblázatból. Próbáljuk ki ezeket a parancsokat is!


```



`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-3-1-exercise-solution)'`



### Áttekintés

Az előző fejezetben láttuk, hogy az R-ben leírható értékek alapvetően 4 típusba sorolhatók. Ezek a *double*, az *integer*,  a *karakteres* és a *logikai* alaptípusok. Ezen értékek felhasználásával nagyon egyszerűen tudunk objektumokat létrehozni. Ezek az objektumok, mindjárt látjuk, az R legalapvetőbb adatszerkezetének, a *vektor*nak az egyelemű változatai. 

```{r tidy=FALSE}
obj.double     <- 12.03
obj.integer    <- 12L
obj.karakteres <- "Péter"
obj.logikai    <- TRUE
```

A fenti objektumok típusa rendre *double*, *integer*, *karakteres* és *logikai*. Ezt könnyen ellenőrizhetjük a `typeof()` vagy `class()` függvényekkel. A `typeof()` az objektum alaptípusát adja meg, a `class()` pedig inkább az R objektum-orientált lehetőségeihez kapcsolódó függvény, de a fenti objektumok esetében nagyon hasonló eredményt szolgáltat, és a későbbiek során is sokat fogjuk használni. Egyedül a *double* objektumokok esetén tér el a visszatérési értéke, `class()` ugyanis ekkor a `numeric` outputot adja.

```{r tidy=FALSE}
typeof(obj.double);     class(obj.double)
typeof(obj.integer);    class(obj.integer)
typeof(obj.karakteres); class(obj.karakteres)
typeof(obj.logikai);    class(obj.logikai)
```

Az adatelemzési problémáink megoldásához egyszerre több adatérték feldolgozására van szükséges. Mivel az R nyelvet statisztikai adatfeldolgozásra tervezték, így nem csodálkozhatunk azon, ha több értéket is el tudunk tárolni egymás utáni memóriahelyeken a fenti 4 alaptípusból (*double*, *integer*, *karakteres* és *logikai*). Ezt többféleképp megtehetjük, például egy vagy több dimenzió mentén, illetve keverhetjük a típusokat vagy ragaszkodhatunk az azonos típusba tartozó értékek egymásutánjához. Ennek megfelelően több különböző R adatszerkezettel kell számolnunk. Ebben a fejezetben az R leggyakrabban használt adatszerkezetit tekintjük át. Most felsoroljuk és jellemezzük őket:

* *vektor* - Azonos alaptípusú értékeket egymás után sorolunk fel, egy dimenzó mentén.
* *mátrix* - Azonos alaptípusú értékekből egy kétdimenziós szerkezetet hozunk létre, amelynek vannak sorai és oszlopai.
* *faktor* - Integer értékeket egymás után teszünk, egy dimenzió mentén, de megadjuk, hogy melyik szám milyen címkét jelöl.
* *lista* -  Tetszőleges típusú objektumokat egymás után sorolunk fel, egy dimenzió mentén.
* *adattábla* - Tetszőleges típusú, de azonos elemszámú objektumokat egymás után sorolunk fel. Tipikusan azonos hosszúságú vektorokat vagy faktorokat teszünk egymás mellé, és így egy kétdimenziós szerkezetet kapunk, amelynek vannak sorai és oszlopai.

Az \@ref(fig:adatszerkezetek-1) ábra összefoglalja az adatszerkezetek fenti tulajdonságait. Beszélünk numerikus (double vagy integer), karakteres és logikai vektorokról, melyek egydimenziósak és homogének, azaz azonos típusú adatokat tartalmaznak. Ugyanez igaz a mátrixokra, csak két dimenzióban, sorokkal és oszlopokkal. A faktor egy integer vektor (azaz egydimenziós és homogén), azonban külön nyilvántartást vezet arról, hogy az egyes integer értékeknek milyen címke felel meg. Az adattábla lesz a legfontosabb adatszerkezet számunkra: kétdimenziós, de oszlopai homogének, hiszen ezek vektorok (numerikus, karakteres vagy logikai) vagy faktorok lehetnek. A lista a legszabadabb adatszerkezet, egydimenziós, de elemei bármilyen adatszerkezethez tartozhatnak. Például az \@ref(fig:adatszerkezetek-1). ábrán egy 8 elemű lista jelenik meg, amelynek első eleme egy numerikus vektor, utolsó eleme pedig egy adattábla. 

```{r adatszerkezetek-1, fig.align='center', echo=FALSE, out.width='85%', fig.link='', fig.cap="Az R legfontosabb adatszerkezetei"}
knitr::include_graphics('images/adatszerkezetek_abra.png', dpi = NA)
``` 


Az \@ref(tab:adatszerkezetek). táblázatban más szempontból mutatjuk be az adatszerkezeteket: példát mutatunk adott típusú (adatszerkezetű) objektumok létrehozására, és közöljük, hogy a `typeof()` és a `class()` milyen outputot szolgáltat az így létrehozott objektumok esetében.

```{r adatszerkezetek, echo=FALSE}
table.kiir <- data.frame(A=c( "double vektor",
                              "integer vektor",
                              "karakteres vektor",
                              "logikai vektor",
                              "double mátrix",
                              "integer mátrix",
                              "karakteres mátrix",
                              "logikai mátrix",
                              "faktor",
                              "lista",
                              "adattábla"
                              ),
                         B= c("c(12, 14)",
                              "c(12L, 14L)",
                              "c('a','az','egy')",
                              "c(T, TRUE,FALSE,F)",
                              "matrix(1.3,nrow=2,ncol=3)",
                              "matrix(1L,nrow=2,ncol=3)",
                              "matrix('az',nrow=2,ncol=3)",
                              "matrix(F,nrow=2,ncol=3)",
                              "factor(c('D','D','ND'))",
                              "list(A='Pék',B=1:2)",
                              "data.frame(id=c('a','b'), pont=c(4,9))"                              ),
                         C=c( "double",
                              "integer",
                              "character",
                              "logical",
                              "double",
                              "integer",
                              "character",
                              "logical",
                              "integer",
                              "list",
                              "list"
                           ),
                         D=c( "numeric", 
                              "integer",
                              "character",
                              "logical",
                              "matrix array",
                              "matrix array",
                              "matrix array",
                              "matrix array",
                              "factor",
                              "list",
                              "data.frame"
                              ))

table.kiir %>% 
  mutate(B=kableExtra::cell_spec(B, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(D=kableExtra::cell_spec(D, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
col.names = c("Adatszerkezet",
                "Létrehozó parancs",
                "typeof(x)",
                "class(x)"),
  caption = 'Adatszerkezetek',  format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))

```


<!-- 

```{r include=FALSE}
x <- c(12L, 14L)
typeof(x)
class(x)
x <- c(12, 14)
x <- c("a", "az", "egy")
x <- c(T, TRUE, FALSE, F)

x <- matrix(1L, nrow=2, ncol = 3)
x <- matrix(1.3, nrow=2, ncol = 3)

x <- array(2L, dim=c(2,3,5))
x <- array(2, dim=c(2,3,5))
x <- array("a", dim=c(2,3,5))
x <- array(T, dim=c(2,3,5))
x <- factor(c("D", "D", "ND"), level=c("ND", "D", "ED"))

x <- as.Date("1971-05-09")
x <- as.POSIXct("2018-08-01 22:00", tz = "UTC")
x <- as.difftime(7, units = "days")
x <- list(A='Pék', B=1:2)

x <- data.frame(nev=c("a", "b"), pont=c(11, 9))
library(tibble)

x <- tibble(x=1:3, y=letters[1:3])

```

-->

A következő alfejezetekben részletesen áttekintjük a *vektor*, a *mátrix*, a *faktor*, a *lista* és az *adattábla* adatszerkezeteket, ugyanis ezek töltik be a legfontosabb szerepet az adatelemzések során. Mindegyik esetben megvizsgáljuk:

* hogyan hozhatjuk létre az adott adatszerkezetű objektumot,
* hogyan tesztelhetjük, hogy az adott típusú objektumról van-e szó,
* hogyan konvertálhatunk más adatszerkezetekből ilyen típusú objektumot,
* milyen műveletekben vehet részt,
* hogyan érhetjük el az objektum részeit, azaz hogyan indexelhetjük az objektumokat.

#### Összefoglalás {#az-r-nyelv-4-summary}

```{block, type='rmdsummary'}

A különböző típusú konstansokat objektumok létrehozására használhatjuk fel. A statisztikában egy objektumok értéke több konstans egymásutánja. A legegyszerűbb adatszerkezet az R-ben a *vektor*, amelyben tetszőlegesen sok, azonos típusú értéket helyezhetünk el egy dimenzió mentén. A *faktor* és a *lista* is egydimenziós, míg a *mátrix* és az *adattábla* kétdimenziós. A *faktor* integer vektor, amelyben a számoknak címkéket feleltetünk meg. A *lista* elemi tetszőleges típusúak lehetnek. A *mátrix* ugyanúgy homogén, minta a *vektor* és a *faktor*. Az *adattábla* felfogható azonos elemszámú vektorok/faktorok listájának.  

```

#### Feladatok {#az-r-nyelv-4-exercise}

```{block2, type='rmdexercise'}

1. Próbáljuk ki az \@ref(tab:adatszerkezetek). táblázatban szereplő példákat. Hozzuk létre a különböző típusú objektumokat és vizsgáljuk meg a `typeof()` és `class()` függvényekkel az objektumok típusát.


```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-4-exercise-solution)'`


### Vektor

Az R legalapvetőbb adatszerkezete a *vektor*. A vektort egymás melletti (vagy alatti) cellákban tárolt értékek sorozataként képzelhetjük el (\@ref(fig:adatszerkezetek-1). ábra), mely értékek mindegyike azonos típusú. Így azt mondhatjuk, hogy a vektor azonos típusú (egynemű, homogén) adatok egydimenziós együttese. A vektor fontos jellemzője, hogy homogén, tehát a vektort alkotó értékek vagy kizárólag *integer*, vagy kizárólag *double*, vagy kizárólag *karakteres*, vagy kizárólag *logikai* típusúak lehetnek.

####  Vektor létrehozása

Vektort legegyszerűbben a `c()` függvénnyel hozhatunk létre, az argumentumlistában egymás felsoroljuk a vektort alkotó értékeket. *Double* vektort hozhatunk létre például, ha a paraméterben numerikus konstansokat sorolunk fel:

```{r tidy=FALSE}
v.d <- c(2, 4, 6, 8); v.d  # numerikus (double) vektor létrehozása
```

A `v.d` objektum egy 4 elemű *double* vektor. Az első eleme a 2, a második eleme a 4, a harmadik a 6 és a negyedik egyben utolsó eleme a 8. A vektor elemei szóközökkel elválasztva jelennek meg a konzolban.

Karakteres vektort hasonlóan hozhatunk létre, a `v.k` vektor 3 elemű lesz.

```{r tidy=FALSE}
v.k <- c("erős", 'közepes', "gyenge"); v.k # karakteres vektor létrehozása
```

Egy logikai vektor csak logikai konstansokat tartalmazhat (`TRUE` vagy `FALSE`, illetve a `T` és `F` rövidebb változatot is használhatjuk):

```{r tidy=FALSE}
v.l <- c(TRUE, FALSE, T); v.l  # logikai vektor létrehozása
```

A `v.d`, `v.k` és `v.l` objektum egy-egy példa az R különböző típusú vektoraira. Az objektumok fontos jellemzője az objektum hossza, ami vektorok esetén a vektort alkotó elemek számát jelenti. Ezt a `length()` függvénnyel kérdezhetjük le.

```{r tidy=FALSE}
length(v.d); length(v.k); length(v.l)  # vektor hossza
```

A vektor hosszát létrehozása után is módosíthatjuk, szintén a `length()` függvényt használjuk, de az értékadás bal oldalán.
 
```{r}
length(v.l) <- 5  # vektor hosszának módosítása
```

A `v.l` logikai vektor most már 5 elemű lesz:

```{r}
v.l
```

Mivel nem adtuk meg a 4. és 5. elemét, így az `NA` lesz, ami a *hiányzó érték* jele az R-ben. Az `NA` minden vektornak eleme lehet, a vektor típusától függetlenül.

```{r}
v.i <- c(12L, NA, 15L)  # 3 elemű integer vektor; a 2. eleme nem ismert
```

Térjünk vissza a vektorok létrehozásához. A `c()` függvény paraméterébe természetesen konstansok helyett tetszőleges kifejezéseket is írhatunk:

```{r tidy=FALSE}
szamok <- c(1, (2+3)*4, 1/4, .5^3);        szamok
nevek  <- c("Péter", paste0('Zso', "lt")); nevek
iteletek <- c(T, 1<2, 2==3);               iteletek
```

A vektorok esetében a homogenitás központi szerepet játszik. Az R abban az esetben sem fog különböző típusú elemekből vektort létrehozni, ha ezeket egyetlen `c()` függvényhívásban szerepeltetjük. Ekkor automatikus típuskonverzió történik. Nézzük ezeknek az eseteit:

```{r tidy=FALSE}
eset.1 <- c(2,4,"6",8);    eset.1
eset.2 <- c(T, FALSE,"6"); eset.2
eset.3 <- c(T, FALSE, 3);  eset.3
```

Amennyiben karakteres konstans szerepel az elemek között, a vektor karakteres típusú lesz. Ha numerikus és logikai értéket sorolunk fel, akkor a vektor numerikus lesz, azzal a kiegészítéssel, hogy a `TRUE` logikai érték 1-re, a `FALSE` pedig 0-ra konvertálódik.

További lehetőség a `c()` függvény használata során, hogy a paraméterben vektort is szerepeltethetünk. Ekkor ezek az elemek is szerepelni fognak az eredményvektorban:

```{r tidy=FALSE}
regi.v.1 <- c(1, 2, 3)
regi.v.2 <- c(7, 8, 9)
uj.v <- c(0, regi.v.1, 4, 5, 6, regi.v.2, 10, c(11, 12)); uj.v
```

A fenti példában létrehozott `uj.v` 13 elemű numerikus vektor összerakásához felhasználtunk két 3 elemű vektort és egy kételemű vektort is.


Vektorok létrehozása során még egy érdekes lehetőségről érdemes szót ejteni. A `c()` függvényben a vektor egyes elemeit elnevezhetjük, és ezek a nevek az outputban is meg fognak jelenni. Az elemek elnevezéséhez írjunk egy nevet és egy egyenlőségjelet az argumentumként használt elem elé. Ha a név nem egyetlen szó (vagyis tartalmaz szóközt), akkor a karakterkonstansok megadásánál látott három módszer valamelyikét használhatjuk (tehát a dupla és szimpla idézőjeleket és az `r"()"` konstrukciót), vagy a backtick (`) szimbólumot. Ezzel a módszerrel például a naponta tanulással töltött időnket úgy rögzíthetjük, hogy az output "beszédesebb" lesz, több információt tartalmaz. 

```{r tidy=FALSE}
tan.ido <- c(Hétfő=35, Kedd=95); tan.ido
tan.ido <- c(Hétfő=35, "Kedd délelőtt"=50, `Kedd délután`=45); tan.ido
```

A vektorelemek nevei lekérdezhetők a `names()` függvénnyel. Amennyiben az értékadás bal oldalán szerepeltetjük, a vektor elemneveit tudjuk módosítani. 

```{r tidy=FALSE}
names(tan.ido)                         # elemnevek lekérdezése
names(tan.ido) <- c("H", "K.1", "K.2") # elemnevek módosítása
tan.ido
```


#### Szabályos vektorok létrehozása {#szabalyosvektorokalfejezet}

Ha egy vektor elemei szabályos rendben követik egymást, akkor szabályos vektorokról beszélünk. Ilyen lehet például a következő három numerikus vektor és két karakteres vektor.

```{r tidy=FALSE, eval=FALSE}
c(1, 2, 3, 4, 5); c(1, 3, 5, 7); c(1, 1, 1, 2, 2, 2)
c("férfi", "nő", "férfi", "nő"); c("f.1", "f.2", "f.3")
```

Szabályos numerikus vektorokat hozhatunk létre a kettőspont (`:`) operátorral vagy a `seq()` függvénnyel. Az így létrehozott vektorok ugyanis valamilyen számtani sorozat egymást követő elemei, vagyis az egymás mellett lévő elemek különbsége (a lépésköz) állandó.

##### A kettőspont operátor.

A legegyszerűbb vektorlétrehozási mód a kettőspont (`:`) operátor, ahol az egymást követő elemek távolsága 1 vagy -1. Általános alakja: `start:stop`.

```{r tidy=FALSE}
1:10    # a lépésköz +1, növekvő sorozat
10:1    # a lépésköz -1, csökkenő sorozat
-1.5:5  # a lépésköz +1, növekvő sorozat
10.5:3  # a lépésköz -1, csökkenő sorozat
```

Látható, hogy az így létrehozott vektorok lehetnek csökkenő vagy növekvő rendezettségűek, valamint tört értékeket is használhatunk operandusként. A sorozat nem feltétlenül a kettőspont utáni értékig tart, mindössze annyi igaz, hogy a sorozat vége a `stop` értéknél mindig kisebb egyenlő (vagy nagyobb egyenlő, csökkenő sorozat esetén).

Hosszabb numerikus vektorokat is könnyűszerrel létrehozhatunk. A `101:140` parancs hatására 40 elemet hozunk létre. Hosszabb vektorok outputjában könnyebben el tudunk igazodni a sorok elején lévő `[x]` konstrukció segítségével: minden sorban a sor első eleme a vektor `x.` eleme. A lenti outputban szereplő `[17]` például azt mutatja, hogy a sor elején lévő 117 a 40 elemű vektor 17. eleme.


```{r tidy=FALSE, eval=FALSE}
101:140  # a lépésköz +1, növekvő sorozat
#>  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116
#> [17] 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132
#> [33] 133 134 135 136 137 138 139 140
```

##### A `seq()` függvény

A `seq()` függvény nagyobb szabadságot ad a numerikus sorozatok generálására. Legegyszerűbb használata esetén a kettőspont (`:`) operátort kapjuk vissza:

```{r}
seq(1, 10) # a lépésköz +1, növekvő sorozat
```

A `seq()` függvény használatához négy argumentum nevét és jelentését kell megtanulnunk: a `from=` a sorozat első elemét határozza meg, a `to=` az utolsó elemet, a `by=` a lépésközt és a `length.out=` a létrehozandó vektor elemeinek a számát. A négy paraméterből három megadása már egyértelműen azonosítja a kívánt vektort:

```{r}
seq(from=1, to=10, by=2)           # a lépésköz +2, növekvő sorozat
seq(from=1, to=10, length.out=5)   # a lépésköz +2.25, növekvő sorozat
seq(to=10, by=-1.3, length.out=5)  # a lépésköz -1.3, csökkenő sorozat
seq(from=1, by=1.3, length.out=5)  # a lépésköz +1.3, növekvő sorozat
```

A `seq_along()` függvénnyel szintén tudunk 1-től induló, +1-es lépésközű sorozatot alkotni, amelynek utolsó értéke, a paraméterben megadott vektor elemszáma.

```{r tidy=FALSE}
x <- c("Hétfő", "Kedd", "Szerda"); y <- 11:20
seq_along(x) # numerikus vektor 1-től, +1-es lépésközzel, 3 elemű
seq_along(y) # numerikus vektor 1-től, +1-es lépésközzel, 10 elemű
```


##### A `rep()` függvény

Tetszőleges típusú vektor létrehozására használhatjuk a `rep()` függvényt, amely egy létező vektor értékeit ismétli meg. A `rep()` első paramétere az ismétlendő vektor, a `times=` pedig az ismétlések számát adja meg.

```{r tidy=FALSE}
rep(2, times=3)            # számot ismétlünk 3-szor
rep(c(2, 0, -2), times=3)  # numerikus vektort ismétlünk 3-szor
rep("nap", times=3)        # sztringet ismétlünk 3-szor
rep(c(F, T, T), times=3)   # logikai vektort ismétlünk 3-szor
```

A fenti példában mindenhol háromszor ismételtük meg az első paramétert, méghozzá úgy, hogy az R egymás után sorolta fel őket.

Egy vektor ismétlésének van egy másik esete is, amikor az elemeit sorban egyenként véve végezzük el az ismétlést (helyben ismétlés). Ekkor nem a `times=` paramétert, hanem az `each=` argumentumot kell használnunk a függvény hívásánál.

```{r}
rep(2, each=3)            # számot ismétlünk 3-szor
rep(c(2, 0, -2), each=3)  # numerikus vektort elemeit ismételjük 3-szor
rep("nap", each=3)        # sztringet ismétlünk 3-szor
rep(c(F,T,T), each=3)     # logikai vektor elemeit ismételjük 3-szor
```

Látjuk, hogy egyelemű vektorok ismétlése esetén nincs különbség a `times=` és az `each=` paraméterek használata között.

Utolsó esetként elemenként szeretnénk ismételni, de eltérő ismétlésszámmal. Ekkor a `times=` paraméterben a bemenő vektor elemszámával azonos hosszú vektort kell megadni. Ez a vektor tartalmazza az elemek ismétlés számát.

```{r}
rep(c(2, 3, 4), times=c(1, 2, 3))    # numerikus vektort elemeit ismételjük
rep(c("nap", "part"), times=c(2, 3)) # karakteres vektort elemeit ismételjük
rep(c(T, F, T), times=c(2, 3, 4))    # logikai vektort elemeit ismételjük
```

Végezetül bemutatjuk, hogy az `each=` és az egyelemű értékkel rendelkező `times=` egyszerre is alkalmazható. Ekkor először a helyben ismétlés (`each=`), majd az így kapott vektor teljes ismétlése következik (`times=`). 

```{r}
rep(1:5, each=2, times=3) # kombinált ismétlés
```


##### A `paste()` függvény

Szabályos karakteres vektor létrehozására használhatjuk a `paste()` függvényt. Egy előtaghoz (például `f`) hozzáfűzhetünk 10 különböző számot, amely így egy 10 elemű karakteres vektort eredményez. 

```{r tidy=FALSE}
paste("f", 1:10) # 10 elemű sztring vektor
```

Láthatjuk, hogy az `f` karakter és a számok közé egy szóköz került, de ezt a `sep=` argumentummal megváltoztathatjuk:

```{r tidy=FALSE}
paste("f", 1:10, sep="-") # gondolatjel az elválasztó
paste("f", 1:10, sep="")  # nincs elválasztó
```


A `collapse=` argumentum használatával, akár egyetlen karakteres értékbe is összeolvaszthatjuk a fenti elemeket. Az argumentumban az összevonásnál használt elválasztó karaktert adjuk meg.

```{r tidy=FALSE}
paste("f", 1:10, sep="-", collapse="_") # gondolatjel az elválasztó, egy sztring
```

Az eddigiek összefoglalásaként nézzünk példát különböző típusú és elemhosszú vektorok létrehozására.

```{r tidy=FALSE}
y <- 12L                        # 1 elemű integer vektor
y <- 12                         # 1 elemű double vektor
y <- "Bízz magadban!"           # 1 elemű karakteres vektor
y <- TRUE                       # 1 elemű logikai vektor
y <- c(23.8, -5)                # 2 elemű double vektor
y <- c("H", "K")                # 2 elemű karakteres vektor
y <- c(T, FALSE)                # 2 elemű logikai vektor
y <- c(1, 2, 3, 4, 5)           # 5 elemű double vektor
y <- 1:5                        # 5 elemű integer vektor
y <- seq(from=9, to=100, by=2)  # 46 elemű double vektor
y <- rep(c("H", "K"), times=10) # 20 elemű karakteres vektor
z <- seq_along(y)               # 20 elemű integer vektor
y <- paste("év", 2001:2020)     # 20 elemű karakteres vektor
```


#### A vektoraritmetika szabályai

Amint az előzőekben láttuk, az R rendszer legalapvetőbb adattárolási szerkezete a vektor. Az R egyik legnagyszerűbb tulajdonsága pedig az, ahogyan a vektorokkal műveleteket végezhetünk. Korábban már láttuk, hogyan tudunk összeadni két számot az R-ben. Próbáljunk meg összeadni két 2 elemű vektort:

```{r tidy=FALSE}
c(1, 2) + c(3, 4) # két vektor összeadása
```

A két fenti vektort a parancssorban hoztuk létre a `c()` függvénnyel. Az összeadás eredménye egy 2 elemű vektor. Az eredményvektor az `1+3` és a `2+4` műveletek alapján jött létre, vagyis az összeadás operandusaiban szereplő vektor azonos sorszámú elemeire hajtotta végre a kijelölt műveletet az R.

Két vektor összeadásánál természetesen használhatunk objektumneveket is:

```{r tidy=FALSE}
x <- c(1, 2, 3); y <- c(2, 3, 4)
x + y # két vektor összeadása
```

Itt az eredményvektor 3 elemű, és a komponensenkénti művelet végrehajtás szabályainak megfelelően az `1+2`, `2+3` és a `3+4` összeadások eredménye lesz a 3 új elem.

Az összeadás műveletet tetszőleges operátorral felcserélhetjük, használhatjuk az összes aritmetikai, relációs és logikai operátort.


```{r tidy=FALSE}
c(1,2) - c(2,3) # két vektor összeadása 
x <- c(1, 2, 3); y <- c(2, 3, 4)
x - y           # két vektor különbsége
x * y           # két vektor szorzata
x / y           # két vektor hányadosa
x ^ y           # x az y-adikon
x == y          # x egyenlő y-nal?
x < y           # x kisebb, mint y?
```

A fenti műveletek közül a hatványozás végrehajtása tűnhet kicsit szokatlannak, itt ugyanis egy 3 elemű vektort, mint alapot egy 3 elemű másik vektorra, mint kitevőre emeljük. Ha azonban a komponensenkénti végrehajtás szabályát észben tartjuk, akkor világos, hogy az eredményvektor az `1^2`, `2^3` és a `3^4` eredménye.  
A komponensenkénti végrehajtás szabálya a logikai operátorokra is érvényes.

```{r tidy=FALSE}
!c(T, T, F, F)                 # logikai NEM egy vektorra
c(T, T, F, F) & c(T, F, T, F)  # logikai ÉS két vektorral
c(T, T, F, F) | c(T, F, T, F)  # logikai VAGY két vektorral
```

A vektorok közötti műveletek legegyszerűbb esetét tekintettük át eddig, azaz azonos elemszámú vektorokat adtunk össze vagy vontunk ki egymásból. Ha az operátor két oldalán lévő vektorok elemszáma eltér, akkor az általános szabály az, hogy a rövidebbik vektort az R megismétli mindaddig, míg a hosszabbik vektor elemszámát el nem éri. Ha a rövidebbik vektort nem egész számszor megismételve kapjuk a hosszabb vektor hosszát, akkor figyelmeztetést kapunk az R-től, melyben erre a tényre felhívja a figyelmünket, de a kijelölt műveletet az R ennek ellenére végrehajtja.

```{r tidy=FALSE}
c(1, 2) + 5  # két eltérő elemszámú vektor összeadása 
```

A fenti példában egy 2 elemű és egy 1 elemű vektort adunk össze. A rövidebb vektort még egyszer megismételve már az `c(5, 5)` vektort kapjuk, így a kijelölt összeadás minden fennakadás nélkül végrehajtható. Az eredményvektor az `1+5` és a `2+5` összeadások eredménye lesz.

Most egy 2 elemű és egy 3 elemű vektort adunk össze.

```{r tidy=FALSE, eval=FALSE}
c(1, 2) + c(3, 4, 5)  # két eltérő elemszámú vektor összeadása 
#> Warning in c(1, 2) + c(3, 4, 5) :
#>   longer object length is not a multiple of shorter object length
#> [1] 4 6 6
```

A rövidebbik vektort még egyszer megismételve a `c(1, 2, 1, 2)` vektort kapjuk, de mivel nincs szükség minden elemre, ezért figyelmeztető üzenetet kapunk. Az eredményvektor az `1+3`, `2+4` és az `1+5` összeadások eredménye lesz.  
A következő példában már nincs figyelmeztetés, hiszen a rövidebb vektort egész számszor, pontosan kétszer kellett megismételni a koordinátánkénti művelet végrehajtáshoz.

```{r tidy=FALSE}
c(1, 2) + c(3, 4, 5, 6)  # két eltérő elemszámú vektor összeadása 
```

Foglaljuk össze a vektoraritmetika szabályait: 

* azonos elemszámú vektorok között az azonos pozícióban lévő vektorelemek között hajtódik végre a kijelölt művelet (vagyis koordinátánkénti végrehajtás történik), 
* különböző elemszámú vektorok esetében pedig először a rövidebbik vektor ismétléssel kiegészül a hosszabbik vektor hosszára, és ezt követi a koordinátánkénti végrehajtás.

Az operátorokon túl az \@ref(tab:matfuggvenyek). táblázatban szereplő matematikai függvények is támogatják a vektor paramétert. Ekkor nem egyetlen értékkel térnek vissza, hanem a bemenő vektor minden elemére kiszámolt függvényértékek vektorával.

```{r tidy=FALSE}
sqrt(c(4, 9, 16))              # 3 szám négyzetgyöke
log(x=c(1, 10, 100), base=10)  # 3 szám 10-es alapú logaritmusa
x <- 1.3:10; round(x)          # 9 szám egészre kerekítve 
```

#### Függvények vektorokkal

Az előző fejezetben láttuk, hogy a matematikai függvények vektor argumentumot is elfogadnak, és a vektor minden elemére kiszámolják a függvényértéket. Míg a `log(x=16, base=2)` függvényhívás a matematikában megszokott módon egyetlen bemenő értékhez (16) egyetlen kimenő éréket szolgáltat (4), addig az R lehetőségeit jobban kihasználó `log(x = c(1, 2, 4, 8, 16), base=2)` függvényhívás négy bemenő értékből (`c(1, 2, 4, 8, 16)`) négy kimenő érték `c(0, 1, 2, 3, 4)` állít elő. A függvények és a vektorok kapcsolatának azonban van egy másik aspektusa, amely szorosan kötődik a statisztikai műveletek végrehajtásához.

Az R függvények egy nagy csoportja eleve olyan vektort vár az argumentumába, amely több tíz vagy több száz elemet tartalmaz, és tipikusan egyetlen értékkel tér vissza. Ezeket a függvényeket vektor alapú függvényeknek nevezzük, és ebbe a csoportba tartoznak az R statisztikai mutatókat számoló függvényei is. A vektor alapú függvényekre az jellemző, hogy a bemenő vektor elemeivel egy előre definiált műveletsorozatot hajtanak végre, például összeadják a vektor elemeit, kiszámolják az elemek átlagát vagy szórását, és visszatérési értékként ezt az összeget, átlagot vagy szórást szolgáltatják. A legfontosabb vektor alapú függvényeket az \@ref(tab:statfuggvenyek). táblázat tartalmazza.


```{r statfuggvenyek, echo=FALSE}
table.kiir <- data.frame(A=c( "max(x)",
                              "min(x)",
                              "sum(x)",
                              "prod(x)",
                              "mean(x)",
                              "median(x)",
                              "range(x)",
                              "sd(x)",
                              "var(x)",
                              "cor(x,y)"
                              ),
                         B= c("az x vektor legnagyobb eleme",
                              "az x vektor legkisebb eleme",
                              "x elemeinek összege",
                              "x elemeinek szorzata",
                              "x számtani közepe (mintaátlag)",
                              "x mediánja",
                              "x legkisebb és legnagyobb eleme",
                              "az x minta szórása",
                              "az x minta varianciája",
                              "korreláció x és y között"
                              ),
                         C=c( "max(1:10)",
                              "min(11:20)",
                              "sum(1:5)",
                              "prod(1:5)",
                              "mean(1:10)",
                              "median(1:10)",
                              "range(1:10)",
                              "sd(1:10)",
                              "var(1:10)",
                              "cor(1:10,11:20)"
                           ),
                         D=c( "10",
                              "11",
                              "15",
                              "120",
                              "5.5",
                              "5.5",
                              "1 10",
                              "3.03",
                              "9.17",
                              "1"))

table.kiir %>% 
  mutate(A=kableExtra::cell_spec(A, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(D=kableExtra::cell_spec(D, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
col.names = c("Függvény",
                "Leírás",
                "Példa",
                "Példa értéke"),
  caption = 'Függvények vektorokkal',
               format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))


```


#### Típusok kezelése

Minden R vektor típusa a négy alaptípus egyike lehet: *double*, *integer*, *karakteres* vagy *logikai*. Korábban láttuk, hogy a `class()` és a `typeof()` függvények pontos tájékoztatást adnak a vektorok típusáról. Létezik azonban egy függvénycsalád, amellyel megvizsgálhatjuk, hogy egy tetszőleges objektum az adott típushoz tartozik-e. Ez az `is.*()` függvénycsalád, amelynek eleme az `is.double()`, `is.integer()`, `is.logical()` és`is.character()` függvény. Nézzünk egy példát használatukra.

```{r tidy=FALSE}
x.d <- c(3.5, 4.1, 9.2)  # új objektum - double vektor
is.double(x.d)           # x.d vajon double
is.integer(x.d)          # x.d vajon integer
is.character(x.d)        # x.d vajon karakteres
is.logical(x.d)          # x.d vajon logikai
```

Láttuk korábban, hogy a logikai értékek esetében, ha szükséges, automatikus típuskonverzió történik numerikus típusra (`TRUE` - 1, `FALSE` - 0). Sok esetben azonban explicit típuskonverzióra van szükség, amit az `as.*()` függvénycsaláddal hajthatunk végre. Vektorok esetében használhatjuk az `as.double()`, `as.integer()`, `as.logical()` vagy `as.character()` függvényeket. Nézzünk ezekre is néhány példát.

```{r tidy=FALSE}
as.double(c(T, F))              # logikai vektorból double 
as.integer(c("2.9", "a", "3"))  # karakteres vektorból integer
as.character(1:5)               # integer vektorból karakteres           
as.logical(0:3)                 # integer vektorból logikai
```

Karakteres értékből könnyen kaphatunk számot, például a `"2.9"` vagy `"3"` esetén, viszont az `"a"` karakter esetében `NA` érték kerül az integer vektorba, ahogyan ezt a fenti példában is láthatjuk.


#### Az `NA` hiányzó érték

Korábbi példáinkban már felbukkant a hiányzó érték, amelyet az R-ben az `NA` jelöl. Az adatelemzési munkánkat végigkísérik a hiányzó adatok. Első lépésként azt jegyezzük meg, hogy az `NA` hiányzó érték tetszőleges típusú vektorban lehet elem.  

```{r tidy=FALSE}
x <- c(2, NA, 4); x              # NA numerikus vektorban
x <- c(NA, "erős", "gyenge"); x  # NA karakteres vektorban
x <- c(T, NA, NA); x             # NA logikai vektorban
```

Egy `NA` érték jelenlétét a vektorban az `is.na()` függvénnyel tudjuk kimutatni. Az `is.na()` argumentuma tetszőleges vektor lehet, visszatérési értéke pedig a bemenő vektor elemszámával megegyező logikai vektor. A visszatérő logikai vektor csak abban a pozícióban tartalmaz `TRUE` értéket, ahol bemenő vektorban hiányzó adatot találunk.

```{r tidy=FALSE}
x <- c(1, NA, 3, 4, NA)    # két NA a numerikus vektorban
is.na(x)                   # két TRUE a logikai vektorban
```

Hiányzó értékeket is tartalmazó vektor esetén néhány vektor alapú függvény meglepő eredményt adhat. A statisztikai mutatókat számoló függvények rendre `NA`-val térnek vissza, ha a bemenő vektorban van hiányzó érték. 

```{r tidy=FALSE}
mean(c(2, NA, 3, 4, 2, 5))  # NA-t tartalmazó vektor átlaga NA
```

Ha kíváncsiak vagyunk az `NA` értéken kívüli elemek átlagára, akkor egy második paramétert is szerepeltetnünk kell a `mean()` függvényben, és minden más statisztikai mutatót számoló függvényben. Az `na.rm=` argumentum `TRUE` értéke biztosítja, hogy az átlag számítása során a hiányzó értékeket figyelmen kívül hagyjuk.


```{r tidy=FALSE}
mean(c(2, NA, 3, 4, 2, 5), na.rm=T)  # NA-t tartalmazó vektor átlaga már nem NA
```


#### Az `Inf` és a `NaN`

Az R-ben a numerikus műveletek eredménye -- a matematikai értelmezéstől sokszor eltérően -- vezethet pozitív vagy negatív végtelen eredményre. Ezeket az `Inf` és a `-Inf` szimbólumok jelölik, amelyeket különböző kifejezésekben akár mi is felhasználhatunk.

```{r}
1/0                 # ez a matematikában nem értelmes, de R-ben Inf
log(0)
exp(Inf)
mean(c(1, 2, Inf))
```

Néhány esetben a numerikus kifejezések eredménye nem értelmezhető számként, ezt az R-ben a `NaN` (`Not a Number`) jelöli. Ilyen kifejezések például:

```{r}
0/0
Inf-Inf
Inf/Inf
```

Egy kifejezés véges vagy végtelen voltát az `is.finite()` vagy `is.infinite()` függvényekkel tesztelhetjük. A `NaN` értékre az `is.nan()` függvénnyel kérdezhetünk rá. Figyeljük meg, a `NaN` értékre, mind az `is.nan()`, mind az `is.na()` függvény `TRUE` értéket ad.

```{r}
x <- c(1, NA, NaN, Inf, -Inf)
is.na(x)           # melyik elem hiányzó
is.nan(x)          # melyik elem nem szám
is.infinite(x)     # melyik elem végtelen
is.finite(x)       # melyik elem véges
```


#### Vektor indexelése

Fontos részhez érkeztünk, érdemes kicsit lassítanunk. Már nagyon sok mindent megtanultunk a vektorokról: egy vektorban egy dimenzió mentén azonos típusú értékeket sorolhatunk fel, amellyel a vektoraritmetika szabályai szerint műveleteket tudunk végezni. Például hozzunk létre egy 10 elemű vektort, növeljük meg minden egyes vektorelem értékét 1-gyel. 

```{r tidy=FALSE}
x <- 11:20         # x integer vektor létrehozása
x + 1              # kiíratjuk az 1-gyel megnövelt értékeket (x nem változik)
x                  # x értékének kiírása
```

A fenti sorok hatására a konzolban egy 10 elemű vektor elemei jelennek meg, minden elem 1-gyel nagyobb, mint az `x` adott eleme. Egyetlen összeadás (`+`) operátor segítségével valójában 10 összeadás végrehajtását írtuk elő. Vegyük észre, hogy maga az `x` vektor nem módosult, továbbra is az eredeti `11:20` elemeket tartalmazza. Egy objektum ugyanis addig őrzi az értékét, amíg értékadó operátor segítségével felül nem írjük. 

Tekintsük most a következő sorokat. 

```{r tidy=FALSE}
y <- 11:20         # y integer vektor létrehozása
y <- y + 1         # megnöveljük 1-gyel y értékeit (y megváltozik)
y                  # y értékének kiírása 
```

Az `y` vektor 10 elemű, a `11:20` értékekkel hoztuk létre. A második sorban azonban megváltoztatjuk az `y` értékét, mert újra az értékadás bal oldalán szerepel az `y` objektum. Az `y` új értéke az értékadás jobb oldalán szereplő kifejezés értéke lesz, azaz a `y+1` összeadás eredménye, ami nem más, mint a `12:21`. Az `y` értékének megjelenítésével ellenőrizhetjük, hogy valóban a `12:21` elemek kerülnek a konzolba.

A fenti példában `y` minden értékét megváltoztattuk. Az eredeti `11:20` helyett az új érték `12:21`. Az `y` vektor minden egyes eleme megváltozott, például ahol 11 volt, ott most 12 van, ahol 12 volt ott most 13. Ha szükség van az eredeti és az új `y` értékekre akkor kicsit módosítanunk kell az eddigi sorokon.

```{r tidy=FALSE}
z    <- 11:20         # z integer vektor létrehozása
z.uj <- z + 1         # z.uj double vektor létrehozása (z nem változik)
z                     # z értékének kiírása
z.uj                  # z.uj értékének kiírása
```

A `z` vektor is 10 elemű, a `11:20` a kezdőértéke, és jól látható, hogy a fenti sorok hatására ez nem is változik meg, hiszen a `z` újra már nem jelenik meg értékadás bal oldalán. Értékadás jobb oldalán viszont felbukkan, a második sorban a `z.uj` objektum létrehozásához használtuk fel `z` értékét. Az `z` és `z.uj` objektumok értékének kiírásával ellenőrizhetjük, hogy a `z` továbbra is biztonságosan tárolja a `11.20` értékeket, de a `z.uj`-ban a kívánt `12:21` módosított értékek is megtalálhatók. A további munkafázisokban így az eredeti és a módosított értékek is elérhetők lesznek, ami újdonság, mert az előző példákban ez a lehetőség nem volt elérhető. Az `x` objektumot használó példában csak az eredeti, az `y` vektoros példában csak a módosított értékeket tudnánk a későbbiekben használni.

Összefoglalva az eddigieket, két tanulságot vonhatunk le. Egyfelől, a vektorműveleteknek csak akkor lesz "maradandó" hatása, ha objektumban őrizzük a számítás eredményét, azaz értékadást használunk. Ez az objektum lehet a kiindulásként használt eredeti objektum (`y <- y + 1`), de biztonságosabb ha új objektumot hozunk létre az új értékek számára  (`z.uj <- z + 1`), mert így az eredeti értékeket a jövőben is tudjuk használni. Másfelől, ezek a példák ráirányítják a figyelmet a vektoraritmetika egy nagyszerű jellemzőjére: a vektorműveletek megadása független a vektor hosszától, nem lesz bonyolultabb egy vektorművelet, például az `x+1` összeadás ha `x` nem 10 elemű, hanem mondjuk 100 hosszú. Az összeadás művelet parancsa 100 elemű vektor esetén is csupán `x+1`, azonban a háttérben nem 10, hanem 100 összeadás történik. Akár 10, akár 100 elemű az `x`, az összes elemre az `x` segítségével hivatkozhatunk, és az `x+1` összeadás az `x` összes eleméhez hozzáad 1-et.  
De mit tegyünk, ha nincs szükségünk `x` összes elemére, vagy nem szeretném `x` összes elemét megnövelni 1-gyel, csak néhányat. Ekkor *indexelést* kell használnunk.

Az adatfeldolgozás során gyakori, hogy a vektor egyes elemeit külön-külön szeretnénk elérni, lekérdezni vagy módosítani. A vektor egy tetszőleges részét, egy vagy több elemét az *indexelés* művelettel érhetjük el, melynek eredménye szintén vektor lesz. Az index operátor jele a szögletes zárójel (`[]`) az R-ben, amit a vektor neve után kell írnunk. Vektorok indexelésének általános alakja:

```markdown
vektor[indexvektor]        # az eredmény egy vektor
```

Az indexvektor lehet numerikus, karakteres és logikai vektor is. Nézzük ezeket sorban.


##### Indexelés numerikus vektorokkal

Kezdjük egy 10 elemű `x` vektor létrehozásával.

```{r}
x <- 11:20; x
```

Megfigyelhetjük, hogy az `x` vektor 1. eleme 11, a 2. a 12, az utolsó, a 10. pedig éppen 20. Ebben a felsorolásban az elemek sorszámai (1., 2., 10.) pontosan a vektor indexeit jelentik. A vektor indexelése tehát 1-gyel kezdődik, ez az 1. elem indexe, a 2. elem indexe 2, az utolsó elemé pedig 10. Ha az index operátorba egy ilyen egyszerű sorszámot írunk, akkor a vektor adott indexű elemét érhetjük el.

```{r tidy=FALSE}
x[1]     # x vektor 1. eleme
x[2]     # x vektor 2. eleme
x[10]    # x vektor 10. eleme
```

Nem csak lekérdezhetjük, hanem az értékadó operátor segítségével módosíthatjuk is valamelyik elemet.

```{r tidy=FALSE}
x[2] <- 100       # x 2. elemének módosítása
x[3] <- 2*x[2]    # x 3. elemének módosítása
x
```

Itt először a második elemet 100-ra cseréljük, majd a harmadikat a második kétszeresére. A változást ellenőrizhetjük a konzolban. 

Ha az `x` vektort az elemszámánál nagyobb indexszel próbáljuk elérni, akkor `NA` értéket kapunk:


```{r}
x[11]     # x csak 10 elemű, a 11. nem létező elem
```

Vektorokat azonban nem csak egy elemű indexvektorokkal indexelhetünk, hanem két vagy több elemű numerikus vektorokat is használhatunk. Ebben az esetben az indexvektorban felsorolt sorszámoknak megfelelő indexű elemeket érhetjük el.

```{r tidy=FALSE}
x <- 11:20 
x[c(1, 3, 5)]               # x vektor 1., 3. és 5. eleme
x[c(3, 5, 3, 1)]            # x vektor 3., 5., 3. és 1. eleme
x[3:6]                      # x vektor 3., 4., 5. és 6. eleme
y <- c(3,7)
x[y]                        # x vektor 3. és 7. eleme
x[seq(from=2, to=10, by=2)] # x vektor páros indexű elemei  
```

A fenti példákban látható, hogy az indexelés során létrejött vektorok elemszáma az indexvektor elemszámával egyenlő. Egy indexet akár többször is felsorolhatunk, és tetszőleges sorrend megengedett. A szögletes zárójelben lévő indexvektort helyben is elkészíthetjük a `c()` és `seq()` függvénnyel (vagy bármilyen más vektorlétrehozó függvénnyel), vagy a kettőspont (`:`) operátorral, de korábban létrehozott objektumot is használhatunk indexelésre (`x[y]`).

Az indexelés során több vektorelemet egy lépésben is tudunk módosítani. Az indexelt elemek kaphatnak azonos vagy különböző értéket. Itt is a vektoraritmetika szabályai működnek.

```{r tidy=FALSE}
x <- 11:20           
x[c(1, 2, 3)] <- c(110, 120, 130) # x 1., 2. és 3. elemét módosítjuk
x[c(4, 5, 6)] <- 0                # x 4., 5. és 6. elemét módosítjuk
x[c(7, 8, 9)] <- c(170, 180)      # x 7., 8. és 9. elemét módosítjuk
x
```

A fenti példában az `x` vektor három-három elemét módosítjuk az egyes értékadások során. Az értékadó operátor (`<-`) engedelmeskedik a vektoraritmetika szabályainak, azaz az értékadás bal és jobb oldalán szereplő vektorokat tekinthetjük két olyan vektornak, amelyek között műveletet szeretnénk végrehajtani. Az első értékadásban azonos elemszámú a két vektor, a koordinátánkénti értékadás azonnal megtörténik (`x[c(1, 2, 3)] <- c(110, 120, 130)`). A másik két értékadásban különbözik a két vektor elemszáma, így először ismétléssel kiegészül a jobb oldali, rövidebbik vektor, majd ezután következhet a koordinátánkénti végrehajtás.

Egy vektor indexe mindig egész szám, de az R megengedi, hogy tört értékeket tartalmazó indexvektort szerepeltessünk az index operátorban, ekkor az egész részét veszi az indexeknek, egyszerűen csonkolja őket.

```{r tidy=FALSE}
x <- 11:20
x[2.3]       # x 2. eleme
x[2.8]       # x 2. eleme
```

Negatív értékeket tartalmazó numerikus vektorral is indexelhetünk, ekkor a negatív előjellel megadott sorszámokon kívül az összes többi elemet tudjuk elérni vagy módosítani.

```{r tidy=FALSE}
x <- 11:15
x[-3]                         # minden x elem, kivéve a 3.
x[-c(1, 5)]                   # minden x elem, kivéve az 1. és az 5.
x[-(1:3)]                     # minden x elem, kivéve az első 3
x[-2] <- 0                    # minden x elem módosul, kivéve a 2.      
x
```


##### Indexelés karaketeres vektorokkal

Amennyiben egy vektor elemei rendelkeznek névvel, akkor karakteres indexvektorokat is használhatunk az indexeléshez. Ez meglehetősen nagy könnyebbséget jelent, ugyanis nem kell ismernünk a kívánt elem pozícióját, azaz indexét, elegendő fejben tartanunk az elem nevét. Vegyük példaként a tanulók matematika versenyen elért pontszámait tartalmazó vektort.

```{r tidy=FALSE}
x <- c('Peti'=35, 'Bori'=37, 'Éva'=33)
x["Bori"]                              # x "Bori" nevű eleme
x[c("Peti", "Éva")]                    # x "Peti" és "Éva" nevű eleme
x[c("Peti", "Éva")] <- c(36, 34)       # x fenti 2 elemének módosítása
x
```

Látható, hogy a kívánt elem eléréséhez, például Bori matematika teljesítményéhez nem kell ismernünk Bori pontszámának pozícióját, elegendő a névre emlékeznünk.

##### Indexelés logikai vektorokkal

Vektorok indexeléséhez logikai vektorokat is használhatunk. Első pillanatban kényelmetlennek, sőt feleslegesnek tűnik ez a lehetőség, de a következő fejezetben, a vektorok szűrésénél, magunk is meggyőződhetünk e módszer káprázatos erejéről

A logikai indexvektor működése nagyon egyszerű. Hossza az indexelendő vektor hosszával egyenlő, és a `TRUE` logikai értékkel jelezzük, hogy az adott pozíción lévő elemet el akarjuk érni, a `FALSE` értékkel pedig azt, hogy nincs szükség arra az elemre.

```{r}
x <- 11:15
x[c(T, F, T, T, F)]    # x vektor 1., 3., és 4. eleme    
```

A fenti példában `TRUE` szerepel az 1., 3. és 4. pozícióban, így az `x` vektor 1., 3. és 4. elemeit érhetjük el.

Az indexelésre használt logikai vektor elemszáma kisebb is lehet, mint az indexelt vektor hossza, ekkor az R az indexvektor ismétlésével kapja meg a kívánt hosszt.

```{r tidy=FALSE}
x <- 11:15
x[c(T, F)]      # x vektor 1., 3. és 5. eleme
x[T]            # x vektor összes eleme
x[F]            # x vektor egyik eleme sem
```

A `c(T, F)` vektor két elemű, az indexelendő `x` viszont 5 hosszú, így az R ismétléssel előállítja a `c(T, F, T, F, T)` öt elemű vektort, és ezt használja az `x` indexeléséhez. Ha a csupa `TRUE` értékű vektorral indexelünk, akkor az `x` vektor összes elemét megkapjuk, ha pedig a csupa `FALSE` értékkel, akkor az üres vektort kapjuk. Az `integer(0)` az üres integer vektort jelöli.

A logikai vektorral indexelt vektorelemeket ugyanúgy módosíthatjuk, mint korábban a numerikus és karakteres indexvektorok esetén.

```{r tidy=FALSE}
x <- 11:15
x[c(T, F)] <- 0                    # x vektor 1., 3. és 5. elemét módosítjuk
x[c(F, T, F, T, F)] <- c(120, 140) # x vektor 2. és 4. elemét módosítjuk
x
```


##### Indexelés speciális értékekkel {#indexelesspecna}

Az indexelésnek van néhány speciális esete, amelyet érdemes ismernünk. Vektorok indexelése során az indexoperátor üresen is maradhat, ekkor a vektor összes elemét elérhetjük, vagyis az  `x` és `x[]` kifejezések ugyanazt az outputot adják. 

```{r}
x <- 11:15
x[]           # x minden eleme
x[NaN]        # egyetlen NA
x[NA]         # x elemszámának megfelelő NA   
```

A fenti példákból kiolvasható, hogy a `NaN` és `NA` indexként való használata egyetlen `NA`-t, vagy az `x` hosszának megfelelő számú hiányzó értéket szolgáltat.

Legyünk óvatosak, ha az indexvektor tartalmaz `NA` értéket, akkor az eredménybe azon a pozíción szintén `NA` fog bekerülni.

```{r tidy=FALSE}
x <- 11:15
x[c(1, NA, 2)]          # x 1. eleme, NA és x 2. eleme
x[c(1, NA, 2)] <- 100   # x 1. és 2. elemének módosítása
x
```

Kerüljük az értékadást `NA`-t tartalmazó indexvektor használata esetén. A fenti példában az értékadás ugyan nem jelez hibát, és ellenőrizhetjük, hogy valóban megtörtént az első két vektorelem módosítása. Azonban az értékadás jobb oldalán a több elemű vektor már nem engedélyezett, például az `x[c(1, NA, 2)] <- c(100, 200)` értékadás hibaüzenethez vezet. Összefoglalva, minden esetben ellenőrizzük, hogy az indexvektorunk tartalmaz-e `NA` hiányzó értéket.   


#### Vektor szűrése

Eddig a vektorok elemeit pozíciójuk alapján értük el. Akár sorszámot, elemnevet vagy megfelelő pozícióban lévő logikai igaz/hamis értéket használtunk indexelésre, végső soron az számított, hogy az adott elem hol található a vektorelemek egydimenziós sorában. Ebben a fejezetben egy teljes más kiinduló pontot használunk a vektorelemek elérésére és ez a vektor tartalma lesz, vagyis a vektorelem konkrét értéke (és nem a pozíciója). 

Bővítsük ki a matematika pontszámokat tartalmazó vektorunkat, rögzítsük hat tanuló eredményét. 

```{r tidy=FALSE}
x <- c('Peti'=35, 'Bori'=37, 'Éva'=33, 'Pál'=21, 'Gergő'=34, 'Ili'=40)
x
```

Ha arra vagyunk kíváncsiak, hogy kik értek el 36 pontnál többet a versenyen és milyen pontszámokkal, akkor rövid áttekintés után megadhatjuk a választ, sőt a pozíció alapján könnyen elvégezhetjük az alábbi indexeléseket is.

```{r tidy=FALSE}
x[c(2, 6)]               # indexelés numerikus vektorral
x[c("Bori", "Ili")]      # indexelés karakteres vektorral
x[c(F, T, F, F, F, T)]   # indexelés logikai vektorral
```

A fenti sorok az eddigiekhez képest semmilyen újdonságot nem tartalmaznak, lényegében összefoglalják a pozíció alapú indexelésről tanultakat. Felmerülhet bennünk a kérdés, ha `x` nem hat elemű, hanem 60 vagy esetleg 600, akkor mennyi esélyünk lenne az indexelt kifejezések előállítására. Nem sok.

Adódik azonban egy másik lehetőség, amely közvetlenül abból indul ki, hogy a 36 pontnál nagyobb vektorelemeket keressük. Logikai művelettel ezt a következőképp fogalmazhatjuk meg.

```{r tidy=FALSE}
x > 36        # relációs művelet, logikai vektort eredményez
```

Korábban láttuk, hogy ez a művelet a vektoraritmetikai szabályainak engedelmeskedve két lépésben értelmezhető: (1) mivel különböző elemhosszú a két vektor, `x` hat elemű, a 36 egy elemű, először a jobb oldal is hat elemű lesz (`c(36, 36, 36, 36, 36, 36)`), majd (2) koordinátánként a relációs művelet végrehajtásra kerül, azaz `x` minden eleméről döntés születik, hogy nagyobb-e, mint 36. A relációs művelet eredménye egy hat elemű logikai vektor, amely pontosan ott `TRUE`, ahol az illető `x` elem nagyobb 36-nál, minden más helyen pedig `FALSE`. Esetünkben a Bori és Ili elemeknél jelenik meg a `TRUE`, vagyis a 2. és 6. pozícióban. Vegyük észre, hogy ez pontosan az a logikai vektor, mint amit korábban hoztunk létre a pozíció alapú indexelés egyik példájaként (`x[c(F, T, F, F, F, T)]`).

A relációs művelet eredményét, mint logikai vektort, kiválóan fel tudjuk használni az indexelésben a 36 pontnál nagyobb vektorelemek eléréséhez. 

```{r tidy=FALSE}
x[x > 36]       # x vektor szűrése (36-nál nagyobb elemek leválogatása)
```

A fenti sor az első példa szűrésre. A szűrés lényegében logikai vektorral való indexelés, ahol a logikai indexvektort egy olyan logikai kifejezés állítja elő, amely hivatkozik a vektor tartalmára. A definíciót értelmezve a példára: a logikai vektor, amely alapján az indexelés történik a `c(F, T, F, F, F, T)`, a logikai kifejezés, amely ezt előállítja az `x>36`, a vektor tartalmára pedig természetesen az `x` objektumnévvel utalunk a logikai kifejezésen belül.   

A szűrés nagyszerűen kezeli a vektorhosszal kapcsolatban korábban felvetett problémánkat. Ha az `x` nem hat, hanem 60 vagy 600 elemű, akkor is az `x[x>36]` végzi a 36-nál nagyobb elemek leválogatását.

Próbáljuk ki a szűrést nagyobb elemszám esetén is. Generáljunk 60 véletlen értékeket a 0-40 értéktartományból, úgy mintha 60 tanuló matematika pontszáma állna rendelkezésre. A `sample()` függvény az `x=` argumentumában megadott értékekből, a `size=`-ban megadott darabszámnyit állít elő. A `replace=T` argumentummal gondoskodunk arról, hogy egy érték többször is szerepelhessen az eredményvektorban.

```{r tidy=FALSE}
pontszamok <- sample(x = 0:40, size = 60, replace = T) # véletlen értékek
pontszamok[1:10]               # vektor első 10 eleme
pontszamok[pontszamok > 36]    # vektor szűrése
```

A `pontszamok` vektor 60 elemű, az első 10 értékét a képernyőn láthatjuk. A 36-nál nagyobb elemek megjelenítését szűréssel végeztük. Látható, hogy a szűrés nem lett bonyolultabb a vektor hosszának növekedésével.

Más relációs operátorokat (\@ref(tab:reloperatorok). táblázat) is használhatunk a szűrésben, sőt logikai operátorok (\@ref(tab:logoperatorok). táblázat) segítségével tetszőleges természetes nyelven megfogalmazott feltételt át tudunk fordítani R logikai kifejezésbe. A logikai operátorokat tartalmazó logikai kifejezéseket *összetett logikai kifejezés*eknek nevezzük. Írassuk ki a pontszámokat 36 és 39 között, majd 3 és 6 között, és végül mindezeket együtt.

```{r tidy=FALSE}
pontszamok[pontszamok>=36 & pontszamok<=39]
pontszamok[pontszamok>=3 & pontszamok<=6]
pontszamok[(pontszamok>=36 & pontszamok<=39) | (pontszamok>=3 & pontszamok<=6)]
```

Időnként szükségünk lehet arra az információra, hogy a vektorban melyik pozícióban vannak a feltételnek eleget tevő vektorelemek. Erre a feladatra a `which()` függvényt használhatjuk. A `which()` függvény bemenő paraméterként egy logikai vektort vár, visszatérési értéke pedig a `TRUE` logikai értékek indexe lesz.

Térjünk vissza a matematika pontszámokhoz. 

```{r tidy=FALSE}
x <- c('Peti'=35, 'Bori'=37, 'Éva'=33, 'Pál'=21, 'Gergő'=34, 'Ili'=40)
which(x > 36)             # hol vannak 36-nál nagyobb elemek
which(36 <= x & x <= 39)  # hol vannak 36-39 közötti elemek
which(x == 21)            # hol van a 21-es elem
which(x != 21)            # hol van nem 21-es elem
```

Az outputokban nem látjuk a tanulók pontszámát, tehát nem a szűrés a `which()` célja, azoknak a vektorelemeknek az indexét látjuk, amelyek az egyszerű vagy összetett logikai kifejezéseknek eleget tesznek.

Végezetül tekintsük át a szűrés és az értékadás kapcsolatát. Az adatelemzés során előfordulhat, hogy bizonyos feltételnek eleget tevő elemeket módosítani szeretnénk. Például, ha egy vektorban előzetesen a hiányzó értékeket 99-cel jelöljük, akkor a későbbi hibamentes elemzéshez `NA`-ra kell módosítanunk ezeket az értékeket.

```{r tidy=FALSE}
x <- c(11, 3, 99, 4, 99)   # nyers vektor, a 99 jelentése hiányzó érték
x[x == 99] <- NA           # 99 átírása NA-ra
x
```

Az `x` így már helyes módon tartalmazza a hiányzó értékeket. Ha esetleg később kiderül ezeknek az elemeknek a tényleges értéke, akkor az `NA`-t kell helyettesítenünk új értékekkel. Vigyázzunk, az `x == NA` kifejezés helytelen a hiányzó értékek tesztelésére, erre az `is.na()` függvényt kell használnunk. 

```{r tidy=FALSE}
x[is.na(x)] <- c(5, 7)    # hiányzó értékek módosítása
x
```

Az `x` vektorban két hiányzó érték volt, így a fenti értékadás jobb oldalán két elemű vektort használunk. Ha mindkét hiányzó értéket azonos számmal szeretnénk felülírni, akkor elegendő lenne a `x[is.na(x)] <- 7` kifejezés is.

Korábban már említettük a (\@ref(indexelesspecna). alfejezetben, hogy kerüljük az értékadást `NA`-t tartalmazó indexvektor használata esetén. Azonban nem minden esetben tudunk kitérni az ilyen esetek elől. Növeljük meg a hiányzó értékeket tartalmazó `x` vektor azon elemeit 1-gyel, amelyek 36-nál kisebbek! A nyilvánvalónak látszó `x[x < 36] <- x[x < 36] + 1` parancs helytelen, hibaüzenetet ad. Az értékadás mindkét oldalán a logikai kifejezésekhez fűzzük hozzá a `& !is.na(x)` kifejezést, így tudjuk az `NA` értékeket eltávolítani az értékadás mindkét oldaláról. 

```{r tidy=FALSE}
x <- c(33, NA, 32, 38, NA, 37)
x[x < 36 & !is.na(x)] <- x[x < 36 & !is.na(x)] + 1
```

#### Vektor rendezése

Egy vektor elemeit növekvő vagy csökkenő sorrendbe rendezhetjük. Az R-ben a vektor elemeit a `sort()` vagy az `order()` függvénnyel rendezhetjük.

```{r tidy=FALSE}
x <- c(1:5, 5:3); x
sort(x)               # x elemei növekvő sorrendben
sort(x, decreasing=T) # x elemei csökkenő sorrendben, vagy: rev(sort(x))
```

A `sort()` függvény alapértelmezés szerint növekvő sorrendbe rendezi a bemeneti vektort, ha azonban a `decreasing=` paramétert `TRUE`-ra állítjuk, csökkenő rendezést kapunk. A `rev()` függvénnyel, amely a bementi vektor elemeit fordított sorrendben sorolja fel, szintén elérhetjük a csökkenő rendezettséget.

Ha a `sort()` függvénnyel átrendezett vektort a továbbiakban fel szeretnénk használni, akkor azt érdemes új objektumban tárolni (`x.2 <- sort(x)`).

A vektor rendezésének másik módja az `order()` függvényhez kapcsolódik. A visszatérési érték ekkor egy numerikus indexvektor, amellyel a bemenő vektort indexelve rendezett vektort kapunk.

```{r}
x <- c(1:5, 5:3); x
order(x)                    # indexekkel tér vissza
x[order(x)]                 # azonos a sort(x)-szel
x[order(x, decreasing=T)]   # azonos a sort(x, decreasing=T)-val
```

Az `order()` függvény esetében is használhatjuk a `decreasing=` paramétert, amellyel csökkenő sorrendbe rendezhetjük a vektorunkat.

A numerikus vektorokon túl a karakteres és logikai vektorokat is sorba rendezhetjük a `sort()` és `order()` függvényekkel.

#### Összefoglalás {#az-r-nyelv-5-summary}

```{block, type='rmdsummary'}

Gratulálunk! Maratoni alfejezetünk végigolvasásával jelentős lépést tett meg az Olvasó a magabiztos R ismeretek megszerzéséhez. A vektor minden adatelemzési munka alapja, biztos kezelése kulcsfontosságú. Tetszőleges vektor létrehozásához a `c()` függvényt használhatjuk, és az elemeket akár nevesíthetjük is. Szabályos vektort a `seq()`, `seq_along()`, `rep()` és a `paste()` függvénnyel, vagy a kettőspont (`:`) operátorral készíthetünk. Megbeszéltük a vektorok közötti műveletek végrehajtásának fő szabályát: ismétléssel hozzuk azonos hosszra a vektorokat ha szükséges, majd koordinátánként végezzük el a kívánt műveletet. A vektorokat támogatják a matematikai függvények is, minden vektorelemre meghívódik a függvény. A statisztikai függvények szintén vektort várnak, de többnyire egy értéket szolgáltatnak. A vektorok típusának tesztelése az `is.*()`, a konvertálása pedig az `as.*()` függvényekkel történik. A vektorok indexelésével (`vektor[indexvektor]`) a vektor elemeit pozíció alapján, a vektorok szűrésével (`vektor[logikai-indexvektor]`) a vektor elemeit érték alapján érhetjük el vagy módosíthatjuk. A vektorok rendezését a `sort()` és az `order()` függvénnyel is elvégezhetjük.

```

#### Feladatok {#az-r-nyelv-5-exercise}

```{block2, type='rmdexercise'}

1. Hozzuk létre a következő numerikus vektort: 12, 14, 17.
1. Hozzuk létre a következő karakteres vektort: "Vác", "Eger", "Pécs".
1. Hozzuk létre a következő logikai vektort: TRUE, FALSE, FALSE.
1. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és a különbség 1.
1. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 102, az utolsó 8 és a különbség -1.
1. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, az utolsó 102 és a különbség 2.
1. Hozzuk létre egy számtani sorozat egymást követő elemeit, ahol az első elem 8, a különbség 3 és a vektor 25 elemű.
1. Hozzuk létre azt a numerikus vektort, amely 12 elemű, és minden elemének -2 az értéke!
1. Hozzuk létre azt a karakteres vektort, amely 7 elemű, és minden elemének "Péntek" az értéke!
1. Hozzuk létre azt a logikai vektort, amely 7 elemű, és minden elemének TRUE az értéke!
1. Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket háromszor egymás után megismétli! Hány elemű az így létrejött vektor?
1. Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket háromszor helyben megismétli! Hány elemű az így létrejött vektor?
1. Hozzuk létre azt a numerikus vektort, amely a 2, 3, 5 elemeket helyben megismétli úgy, hogy a 2-őt 4-szer, a 3-at 5-ször és az 5-öt 7-szer ismétli meg! Hány elemű az így létrejött vektor?
1. Szabályos vektorok létrehozásának van egy korábban még nem említett módja: a `sequence()` függvény. Ismerjük meg a súgóból ezt a függvényt, és értelmezzük a `sequence(4)` és `sequence(c(4,5))` függvényhívásokat!
1. Vektorok létrehozásának számos módját megismertük ebben a fejezetben, de elemek megadása nélkül, vagy akár nulla hosszúsággal is létrehozhatunk vektort. A `double()`, `integer()`, `character()` és `logical()` függvények közvetlenül az adott típusnak megfelelő vektort hozzák létre. A súgó tanulmányozásával állítsunk elő 0 és 10 elemű vektor objektumokat mind a négy típus esetén.
1. Próbáljuk ki az \@ref(tab:statfuggvenyek). táblázatban szereplő példákat.
1. Hozzuk létre a `'Peti'=5, 'Bori'=NA, 'Éva'=3, 'Pál'=NA, 'Gergő'=5, 'Ili'=4` adatokat tartalmazó vektort, majd rendezzük, indexeljük az első és az utolsó elemét, válogassuk le az 5-ös értékeket, csökkentsük mindegyik értéket 1-gyel, csak az 5-öket csökkentsük 1-gyel.

```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-5-exercise-solution)'`



### Mátrix

A mátrix adatszerkezet egyetlen lényeges dologban különbözik a vektortól: a mátrix kétdimenziós, sorokba és oszlopokba szervezi az elemeket, míg a vektor egydimenziós (érdemes visszalapozni a \@ref(fig:adatszerkezetek-1). ábrához). A mátrix ugyanúgy homogén, mint a vektor, ennek megfelelően beszélünk *double*, *integer*, *karakteres* és *logikai* mátrixokról.

#### Mátrix létrehozása

Mátrix létrehozásához a `matrix()` függvényt használjuk, amely egy kiinduló vektor elemeit használja fel a mátrix feltöltéséhez. A `data=` argumentumban kell megadnunk a kiinduló vektort, majd az `nrow=` és/vagy `ncol=` argumentumokban közöljük a sorok és oszlopok számát.  

```{r tidy=FALSE}
x <- matrix(data=1:20, nrow=4)        # 4x5-ös integer mátrix
x
```

A fenti példában a 20 elemű vektort 4 sorban rendezi el a `matrix()` függvény, ennek megfelelően 5 oszlopos lesz az `x` mátrix. A `matrix()` függvényben az `ncol=` paraméter is használható. 

```{r tidy=FALSE}
x <- matrix(data=1:20, nrow=4, ncol=5)        # 4x5-ös integer mátrix
x
x <- matrix(data=1:20, nrow=4, ncol=10)       # 4x10-es integer mátrix
x
```

Az `ncol=5` szerepeltetése nem jelent változást az előző példához képest, az `x` mátrix 4 sort és 5 oszlopot fog tartalmazni, rövidebben 4 $\times$ 5-ös. A következő sorban az `ncol=10` argumentum már egy 40 elemű mátrix létrehozását kezdeményezi (4 $\times$ 10-es), így az `1:20` vektor ismétlésével állnak elő a szükséges elemek. (Figyelmeztetést kapunk, ha a szükséges mátrixelemszám eléréséhez nem egész számszor kell ismételni a kiinduló vektort, de a mátrix ebben az esetben is létre fog jönni.)

A fenti példában azt is megfigyelhetjük, hogy a 20 elemű vektorból oszlop-folytonosan jön létre a mátrix, vagyis először az első oszlop töltődik fel a vektorelemekkel, majd a második, és így tovább. Ha sor-folytonosan szeretnénk a bemenő vektor elemeiből mátrixot képezni, akkor a `byrow=` paramétert igazra kell állítanunk.

```{r}
x <- matrix(1:12, nrow=3, byrow=T)  # 3x4-es integer mátrix, sor-folytonosan
x
```

Mátrixot karakteres vagy logikai értékekből is építhetünk.

```{r tidy=FALSE}
matrix(c("az","egy"), nrow=2, ncol=3, byrow=T) # 2x3-as karakteres mátrix
matrix(c(T,F,T), nrow=2, ncol=6, byrow=T)      # 2x6-os logikai mátrix   
```

Az előző fejezetben láttuk, hogy a vektorok elemeinek nevet is adhatunk, így olvashatóbbá tehetjük rögzített adatainkat. A `matrix()` függvény `dimnames=` argumentumában az egyes sorok és oszlopok elnevezéséről, valamint a két dimenzió nevéről is gondoskodhatunk.

```{r tidy=FALSE}
x <- matrix(0, nrow = 2, ncol = 3, 
      dimnames = list('1. dim. neve'=c("sor.1", "sor.2"),
                      '2. dim. neve'=c("oszl.1", "oszl.2", "oszl.3")))
x
```

A `dimnames=` argumentum a dimenzió-, sor- és oszlopneveket listába rendezve várja. A listákról a \@ref(listadefalf). fejezetben olvashatunk. A sor- és oszlopnevek megadásánál tartsuk be az objektumok elnevezésével kapcsolatos szabályokat, azaz betűvel kezdjünk, kerüljük a szóközt és egyéb írásjeleket, tagolásra a pontot használjuk.  

Létező mátrix esetén a `rownames()` és a `colnames()` függvényekkel tudjuk a sor- és oszlopneveket lekérdezni, illetve módosítani. Az egyes dimenziónevek módosítására a `names(dimnames(x))` konstrukciót használhatjuk.

```{r tidy=FALSE}
rownames(x)                           # sornevek lekérdezése
colnames(x)                           # oszlopnevek lekérdezése
rownames(x) <- c("eset.1", "eset.2")  # sornevek módosítása
colnames(x) <- c("o.1", "o.2", "o.3") # oszlopnevek módosítása
x
names(dimnames(x)) <- c("esetek", "oszlopok") # dimenziónevek módosítása
x
```


#### Mátrix indexelése

A mátrixok indexelése nagyon hasonló a vektorok indexeléséhez. Itt is az index operátort (`[]`) kell használnunk, de a két dimenzió miatt vesszővel választjuk el a sorra és az oszlopra vonatkozó indexeket. Mátrix indexelésének általános alakja:

```markdown
# mátrix indexelése, az eredmény egy mátrix vagy egy vektor
mátrix[sor-indexvektor, oszlop-indexvektor]
```
A sor-indexvektorra és az oszlop-indexvektorra ugyanazok a szabályok érvényesek, mint vektor esetén az indexvektorra. Használhatunk numerikus, karakteres és logikai egy vagy több elemű vektort, numerikus indexeknél negatív értéket, és természetesen el is hagyhatjuk az egyes dimenziók indexvektorait. Nézzünk ezekre néhány példát.

```{r tidy=FALSE}
x <- matrix(1:10, nrow=2, ncol=5, byrow=T)
x
x[2, 3]                 # 1 elem elérése, vektor output
x[2, c(1,4)]            # 2 elem elérése, vektor output
x[, c(1,4)]             # 4 elem elérése, 2x2-es mátrix output
x[, -c(1,4)]            # 6 elem elérése, 2x3-as mátrix output
x[1, ]                  # 5 elem elérése, vektor output
x[c(2, 1), c(T, F, T)]  # 6 elem elérése, 2x3-as mátrix output
```

A mátrix indexelése során a kapott új adatszerkezetek elveszthetik a kétdimenziós jellegüket és így mátrix helyett vektor is lehet az indexelés eredménye. Ha ezt el akarjuk kerülni, használjuk a `drop=FALSE` paramétert az indexben, ekkor minden esetben mátrix lesz az eredmény.

```{r tidy=FALSE}
x[2, 3, drop=F]             # 1 elem elérése, 1x1-es mátrix output
x[2, c(1,4), drop=F]        # 2 elem elérése, 1x2-es mátrix output
x[2, , drop=F]              # 5 elem elérése, 1x5-ös mátrix output
x[, 3, drop=F]              # 2 elem elérése, 2x1-es mátrix output
```

Amennyiben a mátrixunk sor- és oszlopnevekkel is rendelkezik, akkor ezeket is felhasználhatjuk az indexelés során.

```{r tidy=FALSE}
x <- matrix(1:10, nrow=2, ncol=5, byrow=T)
rownames(x) <- c("eset1", "eset2")
colnames(x) <- paste("v", 1:5, sep=".")
x
x["eset1", c("v.2", "v.1")]           # 2 elem elérése, vektor output
x[1:2, c("v.2", "v.1")]               # 4 elem elérése, 2x2-es mátrix
x["eset2", paste("v", 1:3, sep=".")]  # 3 elem elérése, vektor
x["eset1", c(T,F), drop=F]            # 3 elem elérése, 1x3-as mátrix
```


#### Számítások a mátrix soraiban és oszlopaiban

Az előző részben említettük, ha üresen hagyjuk a mátrix sor vagy oszlop pozícióját az indexelés során, akkor a mátrix teljes oszlopára vagy sorára tudunk hivatkozni, vagyis alapesetben vektort kapunk. Az így kapott vektorokkal tetszőleges műveleteket hajthatunk végre. Hozzunk létre egy 3 $\times$ 4-es mátrixot, amely 3 tanuló átlagát tartalmazza 4 tantárgyból.

```{r tidy=FALSE}
x <- matrix(c(3.7, 5.3, 5.1, 4.2, 4.4, 3.8, 2.9, 4.2, 5.1, 4, 3, 5), 
            nrow=3, ncol=4, byrow=T, 
            dimnames = list(c("Pál", "Ili", "Éva"),
                            c("matek", "magyar", "angol", "ének")))
x
mean(x[1,])      # Pál féléves átlaga    
sd(x[,4])        # énekből a csoport átlaga 
```

Négy speciális függvénnyel az oszlopok és sorok összegét és átlagát számíthatjuk ki.

```{r tidy=FALSE}
rowSums(x)      # sorösszegek, a tanulók jegyeinek összege
rowMeans(x)     # sorátlagok, a tanulók félév végi átlaga
colSums(x)      # oszlopösszegek, a tantárgyak jegyeinek összege
colMeans(x)     # oszlopátlagok, a tantárgyak átlaga
```

Általánosabb megoldás, ha az `apply()` függvényt használjuk, amelyben a mátrix soraira vagy oszlopaira vonatkozó függvényt mi határozzuk meg, így az összegzésen és az átlagszámításon kívül más függvényeket is elérhetünk. Az `apply()` első paramétere maga a mátrix, a második helyen pedig 1 vagy 2 áll, attól függően, hogy a mátrix soraira (1) vagy oszlopaira (2) akarjuk a harmadik paraméterben szereplő függvényt alkalmazni.

```{r tidy=FALSE}
apply(x, 1, mean)    # sorátlagok, a tanulók félév végi átlaga
apply(x, 1, sd)      # soronkénti szórások
apply(x, 1, min)     # soronkénti minimumok
apply(x, 2, mean)    # oszlopátlagok, a tantárgyak átlaga
apply(x, 2, sd)      # oszloponkénti szórások
apply(x, 2, min)     # oszloponkénti minimumok
```

Hiányzó értékek esetén a fenti függvények `NA` értéket adnak eredményül, így itt is szükséges az `na.rm=T` argumentum szerepeltetése.

```{r tidy=FALSE}
x["Pál", "matek"] <- NA     # módosítjuk Pál matek jegyét hiányzóra
rowMeans(x)                 # Pálnál NA lesz   
apply(x, 1, mean)           # Pálnál NA lesz   
rowMeans(x, na.rm=T)        # így jó Pálnál is   
apply(x, 1, mean, na.rm=T)  # így jó Pálnál is
```


#### Sorok és oszlopok kezelése

Mátrixokat az `rbind()` és a `cbind()` függvényekkel is építhetünk.

```{r tidy=FALSE}
cbind(1, 1:2, 1:4)    # mátrix létrehozása oszlopvektorokból
rbind(1, 1:2, 1:4)    # mátrix létrehozása sorvektorokból
```

Vektor paraméterek esetén, a felsorolt vektorok fogják alkotni az új mátrix oszlopait (`cbind()` esetén), illetve sorait (`rbind()` esetén), a rövidebb vektor, ha van ilyen, ismétlődni fog.

Új oszloppal vagy új sorral is kiegészíthetjük a már létező mátrixunkat.

```{r tidy=FALSE}
x <- matrix(1:12, nrow=4, ncol=3); x
cbind(-3:0, x, 13:16)  # oszlopvektorok hozzáfűzése x elé és mögé
rbind(-1, x, 1)        # sorvektorok hozzáfűzése x fölé és alá      
```

Tetszőleges pozícióba beszúrhatunk egy oszlopot vagy egy sort. Ehhez első lépésben a létező `x` mátrixhoz hozzáillesztjük az új oszlopot vagy sort, majd indexeléssel átrendezzük az oszlopokat vagy sorokat. 

```{r}
cbind(x, 13:16)[, c(1,2,4,3)]   # oszlopvektor hozzáfűzése, majd oszlopok indexelése
rbind(x, -1)[c(1, 2, 3, 5, 4),] # sorvektor hozzáfűzése, majd sorok indexelése
```

Hasznos lehetőség összesítő sorok vagy oszlopok mátrixhoz fűzése és elnevezése:

```{r}
x <- matrix(1:12, nrow=4, ncol=3); x
x <- rbind(x,apply(x,2,mean))  # átlag sor hozzáfűzése
rownames(x) <- c(1:4,"átlag")  # az új sor nevének átírása
x
```

A sorok vagy oszlopok sorrendjét is megcserélhetjük a mátrixban, valamint ezek törlésére is van lehetőségünk:

```{r tidy=FALSE}
x <- matrix(1:12, nrow=4, ncol=3); x
y <- x[, c(2, 3, 1)]          # oszlopcsere
y <- x[c(3, 2, 4, 1), ]       # sorcsere
y <- x[, c(1, 3)]             # a 2. oszlop törlése
y <- x[c(1, 3), ]             # az 2. és a 4. sor törlése
```

#### Összefoglalás {#az-r-nyelv-6-summary}

```{block, type='rmdsummary'}

A mátrix homogén kétdimenziós adatszerkezet, és többnyire a `matrix()` függvénnyel hozzuk létre, de használhatjuk a `cbind()` és `rbind()` függvényeket is. Mátrix indexelése a `[,]` operátorral történik, ahol sor- és oszlopindex megadásra van lehetőségünk. A mátrix sorain vagy oszlopain külön-külön is tudunk műveleteket végezni az `apply()` függvénnyel, a sor- és oszlopneveket a `rownames()` és a `colnames()` függvénnyel kezelhetjük.

```

#### Feladatok {#az-r-nyelv-6-exercise}

```{block2, type='rmdexercise'}

1. Hozzunk létre egy csupa 1-ből álló mátrixot, amelynek 3 sora és 2 oszlopa van!
1. Hozzunk létre egy 3 $\times$ 4-es karakteres mátrixot, amely 12 különbüző keresztnevet tartalmaz!
1. Hozzunk létre egy 3 $\times$ 4-es logikai mátrixot, amelynek 1. és 3. sora `TURE` a 2. sora pedig `FALSE` értékeket tartalmaz!
1. Mátrixok indexelésére olyan speciális indexmátrix is használható, amelynek két oszlopa van, és az elérendő elemek sor- és oszlopkoordinátáit tartalmazza. Mutassunk példát erre a `mátrix[indexmátrix]` alakú mátrixindexelésre!

```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-6-exercise-solution)'`


### Faktor

A faktor adattípus nagyon hasonló a vektorhoz, ugyanis minden faktor egy speciális *integer* vektor, a faktor tehát homogén és egydimenziós adatszerkezet. Faktorokat elsősorban kategorikus változók értékeinek tárolására használjuk, ilyen például a személyek neme vagy iskolai végzettsége. A faktor egy lényeges ponton több mint egy egyszerű *integer* vektor. A faktor karbantart egy összerendelést az 1-gyel kezdődő numerikus egészek és a faktor lehetséges karakteres értékei, a címkék között (az \@ref(fig:adatszerkezetek-1). ábrán ezt egy piros kis téglalappal jelöltük). Egy faktorelem értéke csak ezekből a címkékből kerülhet ki, ami nagy fokú védelmet jelent számunkra az adatkezelés során. Ha például létrehozunk egy faktort az (1-`"férfi"`, 2-`"nő"`) összerendeléssel, akkor egy faktorelem csak a `"férfi"` vagy `"nő"` címkéket veheti fel, más értéket nem (az `NA` hiányzó érték természetesen lehet faktorelem értéke is). A munka során mindig a címkékkel találkozunk, a háttérben lévő numerikus egészek csak ritkán kapnak szerepet. 

#### Faktor létrehozása

A faktorokat jellemzően karakteres vagy numerikus vektorokból hozzuk létre a `factor()` függvénnyel. A faktor létrehozásánál mindig gondoskodjunk a faktor lehetséges értékeinek, vagyis a faktor címkéiknek megadásáról. A címkéket néha (faktor)szinteknek (levels) is nevezzük. Mivel a kategorikus változóink lehetséges értékei többnyire ismertek az adatkezelés elején, a faktorszintek felsorolása nem okozhat nehézséget. Most hozzunk létre egy faktort, amely öt személy nemét tartalmazza.

```{r tidy=FALSE}
x <- c("férfi", "férfi", "nő", "férfi", "nő")  # karakteres vektor létrehozása
x.f <- factor(x, levels=c("férfi", "nő"))      # faktor létrehozása
x.f                                            # faktor kiíratása
unclass(x.f)                                   # integer kódok a háttérben
```

Az `x.f` faktort az `x` karakteres vektorból hoztuk létre, így `x.f` ugyanúgy 5 hosszú, mint az `x`. Az `x.f` outputjában olvasható `Levels: férfi nő` rész azt közli velünk, hogy a háttérben az 1 numerikus értéknek a `"férfi"` címke, míg a 2-nek a `"nő"` címke felel meg. A belső integer kódok is feltárulnak az `unclass(x.f)` outputjában. A szám-címke összerendelést magunk szabályozhatjuk, ha a `factor()` függvény `levels=` argumentumában módosítunk a sorrenden. 

```{r tidy=FALSE}
x.f <- factor(x, levels=c("nő", "férfi"))      # faktor létrehozása
x.f
```

A fenti `x.f` faktor ugyanannak az 5 személynek a nemét tartalmazza, de az összerendelést a `levels=c("nő", "férfi")` paraméterrel (1-`"nő"`, 2-`"férfi"`)-re változtattuk. Láthatjuk, a címkék sorrendje a faktor értékeitől független, mégis fontos szerepet kap majd a táblázatok és ábrák megjelenítésénél, tehát érdemes rá odafigyelni.

A `levels=` argumentum szerepeltetése a `factor()` függvényben sok kellemetlenségtől kímélhet meg minket. Ha elhagyjuk, akkor a `factor()` függvény a karakteres vektorban aktuálisan rendelkezésre álló értékekből konstruálja meg a faktort. Nézzünk erre három esetet.

```{r tidy=FALSE}
(x.f.1 <- factor(c("férfi", "férfi", "nő", "férfi", "nő")))
(x.f.2 <- factor(c("férfi", "Férfi", "nő", "férfi", "nő")))
(x.f.3 <- factor(c("nő", "nő", "nő", "nő", "nő")))
```

Az első esetben a faktor létrehozásához használt karakteres vektor megegyezik a korábban látottakhoz, azaz helyesen tartalmazza mind a `"férfi"`, mind a `"nő"` címkéket, így az `x.f.1` faktor a címkék lexikografikus rendezése alapján az (1-`"férfi"`, 2-`"nő"`) összerendeléssel jön létre. A második esetben karakteres vektorunk elgépelés miatt egy `"Férfi"` címkét is tartalmaz, ami az `x.f.2` faktor szintjei között is meg fog jelenni. A harmadik esetben az okozza a problémát, hogy 5 azonos nemű személy került a mintába, így a `"férfi"` címke egyáltalán nem jelenik meg az `x.f.3` faktor szintjei között. Az `x.f.2` és az `x.f.3` faktorok tehát más-más okok miatt, de hibásan tartalmazzák a faktorszinteket, és ez a későbbi működést alapvetően befolyásolja. Az `x.f.2` három különböző nemet ismer, az `x.f.3` pedig mindössze egyet. A fenti hibák a `levels=` szerepeltetésével könnyen kiküszöbölhetők.

```{r tidy=FALSE}
(x.f.2 <- factor(c("férfi", "Férfi", "nő", "férfi", "nő"),
                 levels=c("férfi", "nő")))   
(x.f.3 <- factor(c("nő", "nő", "nő", "nő", "nő"),
                 levels=c("férfi", "nő")))
```

A fenti példákban látható, hogy a `"Férfi"` címke helyére hiányzó érték került, az `x.f.3` faktor pedig már `"férfi"` értéket is fel tud venni a jövőben.

Numerikus vektorokból is készíthetünk faktorokat. Például a könnyebb rögzíthetőség miatt öt személy nemét most numerikus vektorban hoztuk létre azzal a szabállyal, hogy a 0 jelentése nő, az 1 jelentése férfi. A faktor létrehozása során ekkor a `levels=` szerepe a lehetséges numerikus értékek felsorolása lesz, és a plusz paraméterként szereplő `labels=` segít a faktorszintek beszédes elnevezésében. Az elnevezés a `levels=`-ben lévő numerikus értékek sorrendjében történik, ezért nagyon fontos, hogy a `labels=` címkéi kövessék ezt a sorrendet.

```{r tidy=FALSE}
x <- c(1, 1, 0, 1, 0)     # numerikus vektor létrehozása, 0-nő, 1-férfi
(x.f.1 <- factor(x, levels=c(0, 1), 
                    labels=c("nő", "férfi")))
(x.f.2 <- factor(x, levels=c(1, 0), 
                    labels=c("férfi", "nő")))
```

A fenti példában látható, hogy a `levels=` értékeinek sorrendje vezérli az elnevezést, a 0 mindkét esetben `"nő"`, az 1 `"férfi"` címkéhez fog vezetni. Az `x.f.1` és `x.f.2` faktorok mindössze a háttérben lévő összerendelésben különböznek, első esetben az (1-`"nő"`, 2-`"férfi"`), míg második esetben az (1-`"férfi"`, 2-`"nő"`) lesz a faktorszintek sorrendje. Vegyük észre, hogy az eredeti 0 (`nő`) és 1 (`férfi`) értékek a faktorban már eltűnnek, szerepüket a címkék veszik át (`nő`, `férfi`) és az azok alapját jelentő 1-től sorszámozott integer vektorok. 

#### Rendezett faktor

A kategorikus változók két csoportját különböztetjük meg, a nominális változókat -- ilyen volt az eddig látott *nem* változó --, és az ordinális változókat. Ez utóbbira példa az iskolai végzettség, mert ennek lehetséges értékei (alap, közép és felső értékekkel) sorba rendezhetők. Ha a változó szintjei közötti rendezettséget szeretnénk az R-ben is kifejezni, akkor rendezett faktort érdemes használni. Az eddigi `factor()` függvény is alkalmas az `ordered = T` argumentum használatával, de az `ordered()` függvényt is használhatjuk rendezett faktor létrehozására. 

```{r tidy=FALSE}
# rendezett faktor létrehozása
x <- c("felső", "közép", "alap", "közép", "felső")
x.f <- ordered(x = x, levels=c("alap", "közép", "felső"))
x.f
```

Az `ordered()` függvénnyel létrehozott rendezett faktor outputjában a szintek között a rendezettséget a kisebb (`<`) jelek teszik hangsúlyossá, de a függvény használata nem tér el a korábban látott `factor()` függvénytől.


#### Szabályos faktor létrehozása

Ismétlést tartalmazó faktorokat a `gl()` függvénnyel is létrehozhatunk. Tipikusan a szintek (`n=`) számát, az ismétlések számát (`k=`) és a címkéket (`labels=`) szoktuk megadni. Rendezett faktort az `ordered = T` argumentummal készíthetünk.

```{r tidy=FALSE}
(x.f <- gl(n = 3, k = 2))
(x.f <- gl(n = 3, k = 2, labels=c("alap", "közép", "felső")))
(x.f <- gl(n = 3, k = 2, labels=c("alap", "közép", "felső"), ordered=T))
```

#### Faktor indexelése és szűrése

Faktor indexelése a `[]` operátorral történik. Indexvektorként numerikus, karakteres és logikai vektorokat is használhatunk. Faktor indexelésének általános alakja:

```markdown
faktor[indexvektor]     # az eredmény egy faktor
```

Hozzunk létre egy faktort, amely hat személy dohányzási szokását tartalmazza (D-dohányzik, ND-nem dohányzik).

```{r tidy=F}
(x.f <- factor(c("D", "D", "ND", "D", "ND", "ND"), levels = c("ND", "D")))
x.f[1]             # az x faktor 1. eleme (faktorszintek változatlanok)
x.f[1, drop=T]     # az x faktor 1. eleme (faktorszintek változtak)
x.f[1:3]           # az x faktor 1., 2. és 3. eleme
x.f[c(T, F)]       # az x faktor 1, 3. és 5. eleme
x.f[x.f == "D"]    # x szűrése (a dohányzók)
x.f[x.f != "D"]    # x szűrése (a nem dohányzók)
```

Az indexelés eredménye minden esetben egy faktor lesz, amelynek szintjei alapesetben megegyeznek az eredeti faktor szintjeivel. A `drop=T` argumentum a nem használt címkéket eltávolítja a faktorszintek közül. Logika kifejezéseket is használhatunk az indexelés során, azaz szűrést is végezhetünk. 

Indexelt faktor természetesen érékadás bal oldalán is szerepelhet. A faktor adatszerkezet megvéd minket az értékadások során, hiszen egy faktorelem csak a faktorszintekben szereplő értékek egyikét veheti fel.


```{r tidy=FALSE}
x.f                        # az x.f faktor kiírása
x.f[1] <- "ND"             # az x.f faktor 1. eleme legális értéket kap
x.f[2] <- "nem dohányzik"  # az x.f faktor 2. eleme NA lesz
x.f
```

Mivel a `"nem dohányzik"` címke nem szerepel a faktorszintek között, az `x.f` faktor 2. eleme `NA` lesz, egy figyelmeztető üzenet kíséretében.

#### Faktorok kezelése

A faktorok kényelmes használatát két további függvény segíti. Az `nlevels()` függvénnyel a faktorszintek számát ismerhetjük meg, a `levels()` függvénnyel pedig lekérdezhetők és módosíthatók a faktorszintek. Nézzünk egy példát az iskolai végzettséggel kapcsolatban. Összesen 7 személyről tudjuk, hogy alap-, közép- vagy felsőfokú végzettségű, de az egyszerűbb rögzítés miatt indulásként ezt az információt számokkal kódoltuk (1-alap, 2-közép, 3-felső).   

```{r tidy=FALSE}
# numerikus vektor létrehozása
isk.vegz   <- c(1, 1, 2, 1, 3, 3, 2)
# faktor létrehozása
isk.vegz.f <- factor(isk.vegz, levels=c("1", "2", "3")) 
isk.vegz.f                              # a faktor értéke
nlevels(isk.vegz.f)                     # a faktor szintjeinek száma
levels(isk.vegz.f)                      # a faktor szintjei
# a faktor szintjeinek módosítása
levels(isk.vegz.f) <- c("alap", "közép", "felső") 
isk.vegz.f                              # a faktor értéke
```

Az `isk.vegz.f` faktort az `"1"`, `"2"` és `"3"` címkékkel hoztuk létre, de később a `levels()` függvénnyel beszédesebb faktorszinteket hoztunk létre.

#### Összefoglalás {#az-r-nyelv-7-summary}

```{block, type='rmdsummary'}

A faktor olyan *integer* vektor, amely az 1-től sorszámozott értékeihez egy-egy karakteres címkét rendel. Ezek a címkék alkotják a faktorelemek lehetséges értékeit, amelyeket más néven faktorszinteknek is neveznek. A faktor létrehozásához a `factor()` függvényt használjuk és karakteres vektor konstansaiból vagy numerikus vektor címkeként kezelt számértékeiből jönnek létre a faktor lehetséges értékei. Rendezett faktorok szintjei között létezik egy természetes rendezettség, létrehozásukhoz az `ordered()` függvényt használjuk. Az `nlevels()` függvény a faktorszintek számát adja meg, míg a `levels()` a szintek nevének lekérdezését és módosítását szolgálja.

```

#### Feladatok {#az-r-nyelv-7-exercise}

```{block2, type='rmdexercise'}

1. Hozzuk létre azt a karakteres vektort, amely a férfi, nő karakteres konstansokat, úgy helyezi el egymás mellett, hogy a 7 darab férfi érték után 13 db nő címke következik! Hány elemű az így létrejött vektor?
1. Egy vizsgálatban az első 10 személy neme férfi, a többi 8 neme nő volt. Hozzuk létre azt a faktort, amely leírja a neme változót!
1. Egy vizsgálatban városi ("V") és falusi ("F") fiatalok vettek részt! A megkérdezettek településtípusa rendre a következő volt: F, F, V, F, V, V, V, F. Hozzuk létre azt a faktort, amely leírja a településtípus változót!
1. Egy vizsgálatban a dohányzási szokást egy kétértékű skálán mérték: 0-nem dohányzik; 1-dohányzik. A megkérdezettek dohányzási szokása a következő volt: 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0. Hozzuk létre azt a faktort, amely leírja a dohányzási szokás változót!


```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-7-exercise-solution)'`



### Lista {#listadefalf}

Az eddig megismert vektor, mátrix és faktor adatszerkezet mindegyike homogén volt, csak azonos típusú értékek tárolására használhatjuk őket. A lista típusú adatokban különböző adatszerkezetű elemeket is felsorolhatunk, de sem a típusra, sem a méretre nincs korlátozás. Egy listaelem lehet vektor, mátrix, faktor, adattábla vagy akár egy másik lista is (\@ref(fig:adatszerkezetek-1). ábra). Látható, hogy a lista az R legszabadabb adatszerkezete, egydimenziós, és fő célja a logikailag összetartozó, de szerkezetileg különböző adatok tárolása. 

#### Lista létrehozása

A `list()` függvénnyel hozhatunk létre legegyszerűbben listákat, itt vesszővel elválasztva kell megadnunk a lista elemeit.

```{r}
x <- list(1:10, c("A","B"), c=T)    # 3 elemű lista
x
```

A fenti példában `x` egy 3 elemű lista, az első eleme egy 10 elemű numerikus vektor, a második eleme egy 2 elemű karakteres vektor, a harmadik eleme pedig egy 1 elemű logikai vektor. A harmadik elemnek a `c` nevet adtuk, de bármelyik elemet elnevezhettük volna ezzel a módszerrel. Ha a lista értékét megjelenítjük a képernyőn, akkor a listaelemek egymás alatt jelennek meg. Az első két esetben a kettős szögletes zárójelben (`[[]]`) lévő sorszám azonosítja a lista elemeit, a harmadik esetben pedig a listaelem általunk megadott neve a dollárjel (`$`) után.

A listaelemek nevét a `names()` függvénnyel kérdezhetjük le és állíthatjuk be.

```{r tidy=FALSE}
names(x)                       # az x lista elemeinek neve
names(x)[c(1,2)] <- c("a","b") # az x 1. és 2. elemének elnevezése
names(x)
x
```


#### Lista indexelése

Egy lista indexelése a már megszokott `[]` indexoperátorral történik, amelyben továbbra is lehetőségünk van numerikus, karakteres és logikai indexvektor megadására is. 

```{r tidy=FALSE}
x[1]           # az x lista 1. elemét tartalmazó 1 elemű lista
x[c(2, 3)]     # az x lista 2. és 3. elemét tartalmazó 2 elemű lista
x["a"]         # az x lista 1. elemét tartalmazó 1 elemű lista
x[c(T, F, T)]  # az x lista 1. és 3. elemét tartalmazó 1 elemű lista
```

A `[]` operátorral kapott eredmény minden esetben lista, még akkor is, ha a lista egyetlen elemét érjük el. Nagyon fontos ettől megkülönböztetni a `[[]]` operátor eredményét, amely a lista valamelyik (egyetlen) elemével, annak az értékével tér vissza. Itt nincs mód több listaelem elérésére, és szokás szerint numerikus vagy karakteres értékkel indexelünk.

```{r tidy=FALSE}
x[[1]]     # az x lista 1. eleme
x[["b"]]   # az x lista 2. eleme
x[[3]]     # az x lista 3. eleme
```

A `[[]]` operátor alkalmazása helyett a rövidebb dollár (`$`) operátort is használhatjuk azoknak a listaelemeknek az elérésére, amelyeket korábban elneveztünk. A lista nevét és az elem nevét fűzzük össze a `$` operátorral.

```{r tidy=FALSE}
x$a        # az x lista 1. eleme
x$b        # az x lista 2. eleme
x$c        # az x lista 3. eleme
```

Ha a lista elemét valamelyik módszer segítségével elértük, akkor további indexelés segítségével az elem összetevőit is lekérdezhetjük vagy módosíthatjuk.

```{r tidy=FALSE}
x[["a"]][3:4]       # az x lista 1. elemének 3. és 4. eleme 
x$a[4:5] <- 0       # az x lista 1. elemének 4. és 5. eleme 0 lesz
x$c <- 1:2          # az x lista 3. elemének módosítása    
x
```

A lista indexelésére tehát a következő lehetőségek állnak rendelkezésre:

```markdown
lista[indexvektor]     # az eredmény egy lista
lista[[index]]         # az eredmény a lista egy eleme
lista$elemnév          # az eredmény a lista egy eleme  
```

#### Művelet a listaelemekkel

Egy lista minden elemével az `lapply()` vagy az `sapply()` függvény segítségével hajthatunk végre műveletet. 

```{r tidy=FALSE}
lapply(X=x, FUN=length) # az x lista minden elemének a hossza egy listába
sapply(X=x, FUN=length) # az x lista minden elemének a hossza egy vektorba
```

Az `lapply()` a bemenő lista elemszámával egyező méretű listával tér vissza, melynek értékei az második paraméterben szereplő függvény visszatérési értékei. Az `sapply()` hasonlóan jár el, de a visszatérési értéke egy vektor.

#### Összefoglalás {#az-r-nyelv-8-summary}

```{block, type='rmdsummary'}

A lista az R legszabadabb adatszerkezete, egydimenziós és inhomogén. Listát a `list()` függvénnyel hozhatunk létre, melynek argumentumában tetszőleges adatszerkezetű objektumokat felsorolhatunk, ezek alkotják a lista egyes elemeit. Lista indexelése a `[]`, `[[]]` és `$` operátorokkal is lehetséges. 

```

#### Feladatok {#az-r-nyelv-8-exercise}

```{block2, type='rmdexercise'}

1. Hozzunk létre egy háromelemű listát a TRUE, 12, és "Verseny" konstansokból!
1. Hozzunk létre egy háromelemű listát a TRUE, 12, és "Verseny" konstansokból, de gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: "befejezve", "indulok" és "leiras"!
1. Hozzunk létre egy háromelemű listát a TRUE, 12 és "Verseny" konstansokból, valamint az induló versenyzők végső pontszámaiból, amelyek rendre: 89, 78, 23, 67, 99, 69, 85, 77, 58, 72, 48, 81. Gondoskodjunk az egyes elemek elnevezéséről, amelyek legyenek rendre: "befejezve", "indulok", "leiras" és "pontszam"!


```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-8-exercise-solution)'`


### Adattábla

Az *adattábla* (*data frame*) az R legfontosabb adatszerkezete, központi szerepet játszik az adatfeldolgozásban, lényegében minden statisztikai munka kiindulópontja. Inhomogén, kétdimenziós szerkezet, sorok és oszlopok alkotják, alapvetően azonos hosszúságú vektorokból és faktorokból épül fel (\@ref(fig:adatszerkezetek-1). ábra). Az adattábla egyesíti a mátrix és a lista adatszerkezet előnyeit. Az adattábla kétdimenziós, mint a mátrix, és inhomogén, mint a lista. Ha mátrixként tekintünk az adattáblára, akkor sorokból és oszlopokból áll, ha listaként, akkor azonos hosszúságú (oszlop)vektorok/faktorok egydimenziós sorozata.

#### Adattábla létrehozása

Adattáblát legegyszerűbben a `data.frame()`\index{data.frame()} függvénnyel hozhatunk létre, amely azonos hosszú vektorokat vagy faktorokat vár az argumentumában. A `data.frame()` tehát listaszerűen konstruálja az adattáblát.

```{r tidy=FALSE}
df <- data.frame(
  nev  = c("Péter", "Éva", "Lajos"),
  pont = c(34, 32, 29)
) 
df      # adattábla kiírása
```

A fenti `df` adattáblát egy 3 elemű karakteres vektorból, és egy 3 elemű numerikus vektorból hoztuk létre. A `data.frame()` függvénynek ezt a két vektort adtuk meg, ennek megfelelően két oszlopa lesz az adattáblának. Mindkét vektor 3 elemű, így 3 sor lesz a `df`-ben. Adattáblánk így 3 $\times$ 2-es. Mindkét argumentumot elneveztük (`nev`, `pont`), ezekből oszlopnevek lesznek. Az oszlopok elnevezéséhez az objektumneveknél használt szabályokat vegyük figyelembe (\@ref(objektumelnevezes). fejezet), és ne használjunk ékezetes karaktereket és szóközt. A fenti outputból kiolvasható, hogy az adattábla sornevekkel is rendelkezik, ezek automatikusan jönnek létre 1-től kezdődő sorszámmal. 

Ha a `data.frame()` függvényben a paraméterek hossza nem azonos, akkor a rövidebb vektorok és faktorok ismétléssel kiegészülnek a leghosszabb oszlop hosszára. Az ismétlés azonban csak egész számszor lehetséges, egyébként hibaüzenetet kapunk.

```{r tidy=FALSE}
tipus <- factor(c('A','B')); x <- 6:8; y <- 1:6
df2 <- data.frame(
   tipus, 
   pont.1=x, 
   pont.2=y
)
df2
```

A példában egy 6 sorból és 3 oszlopból álló adattáblát készítettünk (`df2` 6 $\times$ 3-as). A `data.frame()` függvényben nem azonos a `tipus` faktor és a két numerikus vektor (`x`, `y`) hossza, így ismétléssel kapjuk meg a fenti eredményt. Továbbá, ha elhagyjuk az argumentum nevét, akkor az oszlopnév a megfelelő objektum neve alapján jön létre. Így kapta az első oszlop a `tipus` nevet. 

#### Adattábla felépítése

Adattábláink ritkán olyan kicsik, mint a fenti `df` vagy `df2`. Sokszor több tucat sorból és oszlopból állnak, így az adattábla áttekintésére nem az adattáblát tároló objektum értékének képernyőre írása a legszerencsésebb. Kényelmesebb, ha az *RStudio* adatbázis ablakában jelenítjük meg az adattábla tartalmát, amit a *Környezet* panel megfelelő adatbázisnevén való kattintással és vagy a `View()` paranccsal kezdeményezhetünk. Próbáljuk ki a `View(df)` és `View(df2)` függvényhívásokat. 

Hasznos információ szolgáltat az `str()`\index{str()} függvény is, amely az adattábla szerkezetéről ad felvilágosítást.

```{r tidy=FALSE}
str(df)     # a df adattábla szerkezete
```

Láthatjuk, hogy a `df` adattáblánk 3 sort (megfigyelést) és 2 oszlopot (változót) tartalmaz, valamint leolvashatjuk az egyes oszlopok típusát is. Megfigyelhetjük, hogy a `nev` oszlop karakteres, a `pont` pedig numerikus vektor.

Láttuk korábban, hogy az adattábla sorai és oszlopai névvel is rendelkeznek.

```{r tidy=FALSE}
names(df); colnames(df)  # oszlopnevek
rownames(df)             # sornevek
```

A `rownames()` a sorok nevét, a `colnames()` és a `names()` az oszlopok nevét írja ki, de segítségükkel ezeket módosíthatjuk is. A sorok és oszlopok nevének meghatározásánál ügyeljünk arra, hogy azok minden esetben legyenek egyediek. Két azonos sornév létrehozása hibaüzenethez vezet, de az azonos oszlopnevek használatát is kerüljük.

```{r tidy=FALSE}
rownames(df) <- paste0(1:3, ".szemely")   # sornevek módosítása
names(df) <- c("X","Y")                   # oszlopnevek módosítása
df
```

A `length()` függvény az oszlopok számával tér vissza. Az `nrow()` és az `ncol()` a sor és oszlopok számával tér vissza.

```{r tidy=FALSE}
length(df); ncol(df)   # oszlopok száma
nrow(df)               # sorok száma
```

#### Adattábla indexelése

Az adattáblák indexelése a mátrixok és a listáknál megtanult indexelési formákat jelentik. Az általános indexelése formák a következők:

```markdown
adattábla[sorindexvektor, oszlopindexvektor] # adattábla, vektor vagy faktor 
adattábla[oszlopindexvektor]                 # adattábla
adattábla$oszlopnév                          # vektor vagy faktor                    
```
 
A mátrixokhoz hasonlóan indexelhetjük a sorokat és az oszlopokat, hiszen az adattábla kétdimenziós. A `[]` operátorban szerepel egy vessző, amely a sor- és oszlopkoordinátákat választja el egymástól. Használhatjuk a következő hivatkozásokat:

```{r tidy=FALSE}
df2               # a df2 adattábla kiírása
df2[2, 3]         # a df2 2. sorában a 3. oszlop adata, vektor eredmény
df2[c(2, 3), 3]   # a df2 2. és 3. sorában a 3. oszlop adata, vektor
df2[c(2, 3), 1:2] # a df2 2. és 3. sorában a 1. és 2. oszlop adata, adattábla
df2[c(2, 3), ]    # a df2 2. és 3. sora, adattábla
df2[2, ]          # a df2 2. sora, adattábla
df2[, 3]          # a df2 3. oszlopa, vektor
df2[, 3, drop=F]  # a df2 3. oszlopa, adattábla
df2[, 1:2]        # a df2 1. és 2. oszlopa, adattábla
```

Numerikus indexvektorok mellett használhatunk karakteres és logikai vektorokat is indexelésre.

```{r tidy=FALSE}
df2[, c("tipus", "pont.1")]         # minden sor, 1. és 2. oszlop
df2[c(T, F), c("tipus", "pont.1")]  # páratlan sorok 1. és 2. oszlop
```

Karakteres vektorok tipikusan oszlopindexekben fordulnak elő, logikai vektorok pedig, később látjuk, az adattábla szűrésénél kapnak fontos szerepet.

Ha az adattáblára listaként tekintünk, akkor `[]` operátorban egyetlen indexvektort is szerepeltethetünk, amely az adattábla oszlopait indexeli, és minden esetben adattáblát szolgáltat, még akkor is, ha az adattábla egyetlen oszlopát érjük el.   

```{r tidy=FALSE}
df2[2]                    # a df2 2. oszlopa, adattábla
df2[1:2]                  # a df2 1. és 2. oszlopa, adattábla
df2["tipus"]              # a df2 1. oszlopa, adattábla
df2[c("tipus", "pont.2")] # a df2 1. és 3. oszlopa, adattábla
```

Az adattábla egyes oszlopai a `$` operátorral is elérhetők, amely az adattábla nevét és az oszlop nevét választja el egymástól. Az eredmény minden esetben vektor vagy faktor lesz.

```{r tidy=FALSE}
df2$tipus               # a df2 1. oszlopa, faktor
df2$pont.1              # a df2 2. oszlopa, vektor
```


Az adattábla indexelése után kapott adatszerkezetek tovább indexelhetők. Attól függően, hogy a kiinduló adattábla indexelésével kapott adatszerkezet egy- vagy kétdimenziós használhatjuk a `[]` és `$` operátorokat is.

```{r tidy=FALSE}
df2[4:1, 1:2][2]           # df2-ből adattábla, majd adattábla
df2[4:1, 1:2]$tipus        # df2-ből adattábla, majd faktor
df2$pont.2[1:3]            # df2-ből vektor, majd vektor
```

Ne felejtsük el, hogy adattábla indexelése során a lekért elemek módosítására is lehetőségünk van, és a vektoraritmetika szabályai továbbra is teljesülnek.

```{r tidy=FALSE}
df2[2, 3] <- 200              # egyetlen érték módosítása 
df2$pont.2 <- df2$pont.2 + 1  # teljes oszlop módosítása
df2                           # df2 kiírása
```

#### Adattáblák szűrése

Az adattábla indexelésénél logikai vektorokat is használhatunk sorindexvektorban, melyek az adattábla tartalmára vonatkozó relációs kifejezések is lehetnek. Ezzel a módszerrel érhetjük el, hogy az adattábla sorait valamilyen szempont szerint leválogassuk, megszűrjük.

```{r tidy=FALSE}
df2[df2$tipus == "A", ]                      # az A típusú sorok leválogatása
df3 <- df2[df2$pont.1<8 & df2$pont.2>2, 2:3] # összetett logikai kifejezés
```

Az első szűrésünk az adattábla `"A"` címkékkel rendelkező sorait válogatta le, de csak képernyőn olvashatók ezek a sorok. A második szűrés eredményét azonban megőrizzük egy új `df3` objektumban, és látható, hogy a `pont.1` és a `pont.2` numerikus vektorokra vonatkozó összetett logikai kifejezéssel végezzük.  

#### Adattáblák sorainak rendezése

Az adattábla sorainak rendezése a vektoroknál megismert `order()` függvény és a `[]` operátor kombinált alkalmazásával lehetséges. Rendezzük a `pont.1` változó alapján a `df2` sorait.

```{r tidy=FALSE}
df2[order(df2$pont.1), ] # df2 sorainak rendezése pont.1 növekvő sorrendjében
```

Az `order()` függvény `decreasing=TRUE` argumentumával csökkenő sorrendet is elérhetünk. Az `order()` függvény több oszlopot is képes fogadni, így több oszlop alapján is tudunk sorokat rendezni.

```{r tidy=FALSE}
# df2 sorainak rendezése pont.1 és pont.2 csökkenő sorrendjében
df2[order(df2$pont.1, df2$pont.2, decreasing=T), ] 
```

####Összefoglalás {#az-r-nyelv-9-summary}

```{block, type='rmdsummary'}

Az adattábla minden statisztikai munka kiindulópontja. Kétdimenziós, inhomogén szerkezet, de mivel azonos hosszú vektorok vagy faktorok listájának is tekinthető, oszlopaiban homogén adatszerkezet. Létrehozása a `data.frame()` függvénnyel lehetséges, ahol az argumentumban az oszlopokat alkotó vektorokat és faktorokat kell felsorolni. Az adattábla indexelése a mátrixoknál és a listáknál tanultak alapján lehetséges. 

```

#### Feladatok {#az-r-nyelv-9-exercise}

```{block2, type='rmdexercise'}
  
1. Hozzunk létre egy 30 $\times$ 3-as adattáblát, `csoport`, `matematika` és `magyar` oszlopnevekkel. A `csoport` változó legyen egy `5.a`, `5.b` és `5.c` címkéket tetszőleges sorrendben tartalmazó faktor, a `matematika` és a `magyar` pedig 1-5 osztályzatokat tartalmazó numerikus vektor.
1. Írassuk ki a **MASS** csomag `survey` adattáblájának 3. sorában az 5. oszlopban lévő értéket!
1. Írassuk ki a **MASS** csomag `survey` adattáblájának 3. és 6. sorában sorában az 5. oszlopban lévő értékeket! Az adattábla típus maradjon meg!
1. Írassuk ki a **MASS** csomag `survey` adattáblájának 3. és 6. sorából az összes adatértéket!
1. Írassuk ki a **MASS** csomag `survey` adattábla `Pulse` oszlopát háromféle módszerrel! 
1. Írassuk ki a **MASS** csomag `survey` adattábla `Pulse` változójának első 3 elemét háromféle módszerrel!
1. A **HSAUR3** csomag `Forbes2000` adattáblája 2000 vállalat adatát tartalmazza! Határozzuk meg a magyar cégek nevét és helyezését (`country` oszlop alapján)! Írassuk ki a képernyőre a 10 legnagyobb piaci értékkel (`marketvalue` oszlop) rendelkező cég nevét és piaci értékét! Határozzuk meg a legkisebb profittal (`profits` oszlop) rendelkező 5 cég minden adatát! Határozzuk meg a legnagyobb profittal (`profits` oszlop) rendelkező 10 amerikai vagy japán cég nevét, országát és profitját!  
  
  
```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-9-exercise-solution)'`


## További adatszerkezetek

```{block2, type='rmdlevel2'}

Ebben a fejezetben:
  
* megismerjük a *tömb*, *táblázat*, *dátum*, *idő*, *időtartam* és *tibble* adatszerkezeteket,
* valamint a a munkaterület és munkakönyvtár kezelésének függvényeit.

```

Az R legfontosabb adatszerkezetit megismertük az előző fejezetben. Az adatelemzés kiindulópontja az *adattábla*, amely a *mátrix* és a *lista* adatszerkezet előnyeit egyesíti, lényegében *vektor*ok és *faktor*ok egymásutánja. A munka során azonban találkozhatunk három vagy több dimenzióba szervezett adatokkal (*tömb* és *táblázat*), valamint szükség lehet *dátum*, *idő* és *időtartam* kezelésére is. A *Tidyverse R* megújította az adattáblát, és bevezette a saját *tibble* típusát az adatok szokásos tárolására. Definiáljuk pontosabban a fenti, új adatszerkezeteket:

* *tömb* - Azonos alaptípusú értékekből 3 vagy több dimenzió mentén készítünk adatszerkezetet.
* *táblázat* - A gyakorisági táblázatok R megfelelője, amelyben tipikusan *integer* adatokat rögzítünk, egy, két vagy több dimenzió mentén. 
* *dátum* - Egyetlen *double* érték, amelynek jelentése az `1970-01-01` óta eltelt napok száma.
* *dátum-idő* - Egyetlen *double* érték, amelynek jelentése az `1970-01-01` óta eltelt másodpercek száma.
* *időtartam* - Egyetlen *double* érték, amelynek különböző mértékegységekben mutatja két időpont közötti különbséget.
* *tibble* - Speciális adattábla, amely a `Tidyverse R` része, és megkönnyíti az adatok kezelését.   

Az \@ref(tab:adatszerkezetek). táblázatban már korábban bemutattuk az R legfontosabb adatszerkezeteit, aZ \@ref(tab:adatszerkezetek2). táblázat azokat az új adatszerkezeteket sorolja fel, amelyeket ebben a fejezetben mutatunk be. Most is közöljük, hogy a `typeof()` és a `class()` milyen outputot szolgáltat az egyes adatszerkezetek esetén.

```{r adatszerkezetek2, echo=FALSE}
table.kiir <- data.frame(A=c( "integer tömb",
                              "double tömb",
                              "karakteres tömb",
                              "logikai tömb",
                              "táblázat",
                              "dátum",
                              "dátum-idő",
                              "időtartam",
                              "tibble"
                              ),
                         B= c("array(2L,dim=c(2,3,5))",
                              "array(2,dim=c(2,3,5))",
                              "array('a',dim=c(2,3,5))",
                              "array(T,dim=c(2,3,5))",
                              "table(sample(1:10, 100, T))", 
                              "as.Date('1971-05-09')",
                              "as.POSIXct('2018-08-01 22:00','UTC')",
                              "as.difftime(7,units='days')",
                              "tibble(x=1:3,y=letters[1:3])"
                              ),
                         C=c( "integer",
                              "double",
                              "character",
                              "logical",
                              "integer",
                              "double",
                              "double",
                              "double",
                              "list"
                           ),
                         D=c( "array",
                              "array",
                              "array",
                              "array",
                              "table",
                              "Date",
                              "POSIXct POSIXt",
                              "difftime",
                              "tbl_df tbl data.frame"))

table.kiir %>% 
  mutate(B=kableExtra::cell_spec(B, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(C=kableExtra::cell_spec(C, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
  mutate(D=kableExtra::cell_spec(D, ifelse(knitr:::is_html_output(),"html", "latex"), monospace = T)) %>% 
knitr::kable(escape = F, booktabs = T, 
col.names = c("Adatszerkezet",
                "Létrehozó parancs",
                "typeof(x)",
                "class(x)"),
  caption = 'Adatszerkezetek (folytatás)',
               format = ifelse(knitr:::is_html_output(),"html", "latex")) %>% 
  kableExtra::kable_styling(full_width = F, 
                            latex_options = c("striped", "scale_down"),
                            bootstrap_options = c("striped", "hover"))
```

### Tömbök és táblázatok

A *tömb* a mátrix általánosításával nyerhető adatszerkezet. Az azonos típusú adatokat a mátrix két dimenzió mentén rendezi össze. Azonban három vagy több dimenzió mentén is elvégezhető ez az összerendezés. Így nyerjük a három vagy több dimenziós tömböket. A mátrix két dimenziós tömbnek is tekinthető (vagy a vektor egy egy dimenziós tömbnek). A *táblázat* a tömbökhöz nagyon hasonló adatszerkezet, de tipikusan számlálással nyert  *integer* értékeket rögzítünk bennük. A tömbökhöz hasonlóan lehetnek egy, két, vagy több dimenziósak.


#### Tömb létrehozása és indexelése

Az `array()` függvénnyel egyszerűen hozhatunk létre tömböt. A függvény a `data=` argumentumban megadott vektor elemeit a `dim=` argumentumban megadott dimenzió-méretek mentén rendezi össze.      

```{r tidy=FALSE}
x <- array(data=1:12, dim=c(2, 3, 2)) # az 1:12 vektorból 3 dimenziós tömb 
x                       
```
  
A háromdimenziós *integer* tömb 2 $\times$ 3 $\times$ 2-es, azaz 2 sorból, 3 oszlopból és 2 lapból áll. Természetesen *double*, *karakteres* és *logikai* tömbök is hasonló módszerrel hozhatók létre, csak a `data=` értéket kell megfelelően megválasztani.

A tömb kiíratása során az indexoperátorokban (`[]`) szereplő sorszámok segítségével igazodhatunk el az elemek között. A háromdimenziós `x` tömb dimenziói a sorok, oszlopok és a lapok. A 12 elemet két lapon a ` , , 1` és a ` , , 2` nevű lapokon, két-két sorba `[1, ]`, `[2, ]` és három-három oszlopba `[ ,1]`, `[ ,2]`, `[ ,3]` rendezve sorolja fel az R. A második lapon a 2. sor 1. eleméhez meg kell találnunk a ` , , 2` lapot, a `[2, ]` sort és az `[ ,1]` oszlopot, ami esetünkben a 8.


A tömbök indexelése a mátrixokhoz hasonló, csak a dimenziószámnak megfelelő számú indexvektort kell használhatunk. Ha `x` 3 dimenziós, akkor az `x[1,3,2]` egy lehetséges példa indexelésére, ahol az első sor harmadik oszlopában lévő elemre gondolunk, a második lapról. Emlékezhetünk, hogy kétdimenziós mátrixok esetén csak a sor és oszlop azonosító indexekre volt szükségünk (például `x[2,3]`), míg 4 vagy afeletti dimenziószámok esetén természetesen 4 vagy több, vesszővel elválasztott indexet kell megadnunk.


#### Táblázat létrehozása

Táblázatokat a `table()` függvénnyel hozhatunk létre, tipikusan kategorikus adatokból, vagyis faktor típusú objektumokból. A **MASS** csomag `survey` adattáblája több faktor oszlopot is tartalmaz, ezt használjuk a továbbiakban.

```{r tidy=FALSE}
data("survey", package = "MASS")  # a survey betöltése
str(survey)
```

Egydimenziós gyakorisági táblázat létrehozásához egyetlen faktort használunk a `table()` argumentumában. Érdemes a `useNA="ifany"` argumentumot is használni, amely a faktorban lévő hiányzó értékek számát adja meg, amennyiben van hiányzó érték a változóban.

```{r tidy=FALSE}
table(survey$Sex, useNA = "ifany")  # egydimenziós gyakorisági táblázat
```

Az output első sorában az egydimenziós táblázat (integer vektor) elemeinek a nevét olvashatjuk, melyek a `Sex` faktor lehetséges értékeit és a hiányzó értékek címkéjét jelentik. A táblázat második sorában lévő számok az egyes címkék előfordulási gyakoriságát jelentik a faktorban. Ebben a kutatásban (`?survey`) 118 nőt és 118 férfit kérdeztek meg, egyetlen személynek nem ismerjük a nemét.

Kétdimenziós gyakorisági táblázat készítéséhez két faktorra van szükség. A nem (`Sex`) mellett a kezességet (`W.Hnd`) is bevontuk a vizsgálatba:

```{r tidy=FALSE}
# kétdimenziós gyakorisági táblázat
table(survey$Sex, survey$W.Hnd, useNA = "ifany")
```

A kétdimenziós gyakorisági táblázat (integer mátrix) sornevei és oszlopnevei segítenek értelmezni a gyakorisági értékeket. A 7 például a balkezes nők számát jelenti a mintában.

Három vagy magasabb dimenziószámú táblázatokat is hasonlóan készíthetünk: egyre több faktort vonunk be a `table()` függvénybe. Háromdimenziós gyakorisági táblázatra mutatunk példát az `Exer` faktor bevonásával.

```{r tidy=FALSE}
# háromdimenziós gyakorisági táblázat
table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = "ifany")  
```


A háromdimenziós vagy afeletti táblázatok esetében az `ftable()` kétdimenziós ábrázolással segíti a gyakorisági adatok értelmezését.

```{r tidy=FALSE}
tab3 <- table(survey$Sex, survey$W.Hnd, survey$Exer)
ftable(tab3)  # háromdimenziós táblázat két dimenzióban
tab4 <- table(survey$Sex, survey$W.Hnd, survey$Exer, survey$Smoke)
ftable(tab4)  # négydimenziós táblázat két dimenzióban
```

A `table()` függvény helyett használhatjuk az `xtabs()` függvényt is, amely támogatja a kicsit kényelmesebb formula argumentumot. Az R formula olyan kifejezés, amely tartalmaz egy tilde (`~`) karaktert, és annak két oldalán rendszerint egy adattábla oszlopnevei jelennek meg. A `table()` és az `xtabs()` általános használata a következő:

```markdown
table(df$változó_1, df$változó_2, ..., df$változó_n)
xtabs(~változó_1 + változó_2 + ... + változó_n, data=df)
```

Az `xtabs()` használatára mutatunk 3 példát. Figyeljük meg, hogy a hiányzó értékek megjelenítéséhez itt az `addNA=T` argumentumot kell használnunk. Az `xtabs()` függvény speciális formulájának bal oldala üres, jobb oldalán pedig a faktor változók `+` karakterrel vannak összekapcsolva.

```{r tidy=FALSE}
xtabs(~Sex, data=survey, addNA = T)             # 1D gyakorisági táblázat
xtabs(~Sex+W.Hnd, data=survey, addNA = T)       # 2D gyakorisági táblázat
xtabs(~Sex+W.Hnd+Exer, data=survey, addNA = T)  # 3D gyakorisági táblázat
```


#### Táblázatok átalakítása

Korábban megismertük az `as.*()` kezdetű függvényeket, amelyek egyszerű típuskonverziót végeznek. A gyakorisági táblázatokat gyakran szeretnénk vektor, mátrix, tömb, vagy még gyakrabban adattábla típusban rögzíteni. Ezek az átalakítások az `as.vector()`, `as.matrix()`, `as.array()`, valamint az `as.data.frame()` függvénnyel könnyen elvégezhetők.


```{r tidy=FALSE}
tab1 <- table(survey$Sex, useNA = "ifany")       # 1D gyakorisági táblázat
tab2 <- table(survey$Sex, survey$W.Hnd, useNA = "ifany")              # 2D   
tab3 <- table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = "ifany") # 3D  
(vekt <- as.vector(tab1))     # 1D táblázatból vektor
(mat <- as.matrix(tab2))      # 2D táblázatból mátrix
(tomb <- as.array(tab3))      # 3D táblázatból 3D tömb
(df1 <- as.data.frame(tab1))  # 1D táblázatból adattábla
(df2 <- as.data.frame(tab2))  # 2D táblázatból adattábla
(df3 <- as.data.frame(tab3))  # 3D táblázatból adattábla
```


Az ellenkező irányú átalakítás is érdekes lehet, vagyis amikor egy-, két- vagy háromdimenziós tömbökből gyakorisági táblázatot képezünk (`as.table()` függvény), de főképp amikor az adattáblában létező gyakorisági adatokat táblázattá alakítjuk. Itt érdemes az `xtabs(Freq~Változó_1+Változó_2+...+Változó_n, data=df)` függvényhívást használni, ahol a tilde (`~`) előtti oszlop az adattábla gyakorisági adatait tartalmazza, a jobbra lévő változók pedig lényegében a faktor változókat nevezik meg.


```{r tidy=FALSE}
as.table(vekt) # vektorból 1D táblázat
as.table(mat)  # mátrixból 2D táblázat
as.table(tomb) # tömbből 3D táblázat  
xtabs(Freq~Var1, data=df1)           # adattáblából 1D táblázat
xtabs(Freq~Var1+Var2, data=df2)      # adattáblából 2D táblázat
xtabs(Freq~Var1+Var2+Var3, data=df3) # adattáblából 3D táblázat

```


Érdekes lehet egy harmadik eset is, amikor a gyakorisági adatok állnak rendelkezésre (táblázatos vagy adattábla formátumban) és el szeretnénk készíteni ennek a nyers adatokat tartalmazó adattábla megfelelőjét. Vegyük a legbonyolultabb eddig tárgyalt esetet, és legyen a `tab3` a kiinduló pontunk, amely egy táblázat. A táblázatot a korábban tanult módszerrel gyakoriságokat tartalmazó adattáblává alakítjuk, majd eseteket (nyers adatokat) tartalmazó adattáblává.

```{r}
tab3 <- table(survey$Sex, survey$W.Hnd, survey$Exer, useNA = "ifany")  
ftable(tab3) # 3D gyakorisági táblázat kiterítve
df3 <- as.data.frame(df3) # adattáblából 3D táblázat
df3
# az átalakítás 2 sora:
df.long <- df3[rep(row.names(df3), df3$Freq), c("Var1", "Var2", "Var3")]
rownames(df.long) <- seq_along(rownames(df.long))
head(df.long)  # az első 6 sor kiírása
```

### Dátum és idő
 
Az adatelemzés során a dátumok kezelésének két fő oka lehet, egyrészt szűrésekben használhatjuk őket, például adott dátum vagy időpont előtti, utáni vagy közötti sorok leválogatásában, másrészt statisztikai elemzések is irányulhatnak két dátum vagy időpont között eltelt időtartamra.

#### Dátum kezelése

Amennyiben le akarjuk kérdezni az aktuális dátumot, akkor a `Sys.Date()` függvényt kell használnunk.

```{r tidy=FALSE}
datum <- Sys.Date()    # aktuális dátum, dátum típusú objektum
datum                  # datum kiírása
typeof(datum)          # datum típusa
class(datum)           # datum típusa
unclass(datum)         # datum alapja
```

Láthatjuk, hogy a `datum` objektum *dátum* (*Date*) típusú annak ellenére, hogy az objektum értéke a képernyőn kettős idézőjelek között jelenik meg. A *dátum* típus alapja egy *double* szám van, amely az 1970. 01. 01. óta eltelt napok számát tartalmazza, ahogyan az `unclass(datum)` ezt számunkra meg is mutatja. Világos, hogy az a *double* érték lehet nulla vagy negatív is.

```{r tidy=FALSE}
unclass(as.Date("1980-01-01")) # a double szám pozitív
unclass(as.Date("1970-01-01")) # a double szám nulla
unclass(as.Date("1960-01-01")) # a double szám negatív
```

##### Dátum létrehozása karakteres adatból

Dátumot legtöbb esetben karakteres konstansból hozunk létre az `as.Date()` függvény segítségével. A dátumok változatos formában jelenhetnek meg, a szabványos `"2019-02-12"` ([ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)) alak mellett sok olyan forma létezik, amelyben elválasztó karakterként a perjel vagy a pont szerepel, valamint az év-hó-nap hármas sorrendje is változhat. A konkrét dátum értelmezéséhez az `as.Date()` függvény `format=` argumentumát kell helyesen beállítani. A használható kódokat a \@ref(tab:datumkodok). táblázat tartalmazza. 

Table: (\#tab:datumkodok) Formátumkódok a dátumokban


+-------------+------------------------+
|Formátum kód | Jelentés               |
+=============+========================+
| %Y          | év 4 számjeggyel       |
+-------------+------------------------+
| %y          | év 2 számjeggyel       |
+-------------+------------------------+
| %m          | hónap                  |
+-------------+------------------------+
| %b          | hónap rövidített neve  |
+-------------+------------------------+
| %B          | hónap teljes neve      |
+-------------+------------------------+
| %d          | nap                    |
+-------------+------------------------+

```{r tidy=FALSE}
as.Date("2020-04-12")   # szabványos, nem kell format= argumentum
as.Date("2020/04/12")   # szabványos, nem kell format= argumentum
as.Date("04/12/2020", format="%m/%d/%Y")          # amerikai stílus
as.Date("12.04.2020", format="%d.%m.%Y")          # brit stílus
as.Date("2020. 04. 12.", format="%Y. %m. %d.")    # magyar stílus
```

Látható, hogy a szabványos esetekben nem szükséges a `format=` argumentum használata, de a formátumkódokkal tetszőleges sztringet *dátum* típusúvá alakíthatunk. A hónapnevek megjelenése azonban nyelvfüggő, ezért itt a R verziónk helyi beállításaira is figyelni kell.

```{r tidy=FALSE}
Sys.getlocale("LC_TIME")                          # a helyi beállítás magyar?
as.Date("2020. ápr. 12.", format="%Y. %b %d.")    # rövid magyar hónapnévvel
as.Date("2020. április 12.", format="%Y. %B %d.") # magyar hónapnévvel
```

Magyar számítógépes környezetben a helyi beállítás (`?locales`) alapértelmezés szerint magyar, ennek megfelelően a magyar hónapnevekkel dolgozik az `as.Date()` függvény, így a fenti konverziók a kívánt eredményt adják. A `Sys.getlocale("LC_TIME")` paranccsal vizsgálhatjuk meg, hogy milyen környezetben dolgozunk. A `Sys.setlocale("LC_TIME", "C")` utasítás észak-amerikai beállításokra vált az R, az angol hónapnevek felismerésére így nyílik lehetőség:

```{r tidy=FALSE}
lct <- Sys.getlocale("LC_TIME")                   # helyi beállítás mentése
Sys.setlocale("LC_TIME", "C")                     # észak-amerikai beállítás 
as.Date("Apr 12, 2020", format="%b %d, %Y")       # rövid angol hónapnévvel
as.Date("12 April 2020", format="%d %B %Y")       # angol hónapnévvel
Sys.setlocale("LC_TIME", lct)  # magyar helyi beállítás visszatöltése  
```


##### Dátum létrehozása numerikus adatokból

Dátumot a szeparáltan létező numerikus év, hónap, nap információkból is létrehozhatunk. Ehhez először az `ISOdate()` függvénnyel időpontot állítunk elő, majd az `as.Date()`-tel dátumot. Ezzel a módszerrel egyszerre több dátumot is előállíthatunk.  

```{r tidy=FALSE}
as.Date(ISOdate(year = 2020, month = 4, day = 12))   # dátum előállítása
as.Date(ISOdate(year = 2020, month = 1:4, day = 12)) # dátumok előállítása
```

##### Dátum konvertálása

Ha már van egy *dátum* típusú objektumunk, akkor azt változatos módon jeleníthetjük meg a `format()` függvény segítségével, amely egyszerű karakteres adattal tér vissza.

```{r tidy=FALSE}
(datum <- as.Date("04/12/2020", format = "%m/%d/%Y"))
format(datum, format="%Y. %m. %d.") # magyar dátum
format(datum, format="%Y. %B %d.")  # magyar dátum
format(datum, format="%Y. %b %d.")  # magyar dátum
format(datum, format="%Y-%m")       # csak az év és a hónap
format(datum, format="%Y")          # csak az év
```


#### Dátum-idő kezelése

A  *dátum-idő* (*POSIXct* típus) olyan *double* érték, amelynek jelentése az `1970-01-01` óta eltelt másodpercek száma. Az aktuális dátum és idő lekérdezése `Sys.time()` függvénnyel lehetséges, és ez az általunk *dátum-idő* típusnak tekintett *POSIXct* objektummal tér vissza:


```{r}
ido <- Sys.time()     # pontos dátum-idő, POSIXct típusú objektum
ido                   # ido kírása
typeof(ido)           # ido típusa
class(ido)            # ido típusa
unclass(ido)          # ido alapja
```

A fentiek alapján úgy tűnhet, hogy a *POSIXct* objektum egész másodperceket tárol csupán, de ez nem így van. Az alapértelmezett megjelenítéseken módosítva láthatóvá válnak a tört másodpercek is: 


```{r}
op <- options(digits.secs = 6, digits = 16)
ido             # POSIXct kiírása változott digits.sec=6 miatt
unclass(ido)    # double kiírása változott digits=6 miatt
options(op)     # alapértelmezések visszaállítása
```

A *POSIXct* objektumok másik érdekessége az időzóna tárolása, amely alapértelmezés szerint a magyar környezetben futó R helyi beállításainak megfelelően közép-európai (CEST) időt jelent. A saját rendszerünk időzónája a `Sys.timezone()` függvénnyel kérdezhető le, a lehetséges időzónákat az `OlsonNames()` függvény listázza. A legtöbb esetben ezzel nem kell foglalkoznunk, nemzetközi kutatások esetében azonban fontos lehet ismerni az időzóna váltás lehetőségét. 

Egyik lehetőség, hogy eleve a kívánt időzónának megfelelő időpontokkal dolgozunk. Ekkor a `Sys.setenv()` függvénnyel beállíthatjuk a kívánt időzónát, amely a legtöbb esetben a a koordinált világidő (UTC) vagy másképp a greenwichi középidő (GMT). Tudjuk, hogy a magyarországi időzóna téli időszámításkor közép-európai idő (CET, UTC+1), nyáron közép-európai nyári idő (CEST, UTC+2).

```{r}
tz <- Sys.timezone()  # helyi időzóna mentése
Sys.setenv(TZ="UTC")  # UTC (GMT) időzóna beállítása
Sys.time()            # pontos dátum-idő lekérése UTC szerint
Sys.setenv(TZ=tz)     # alapértelmezett időzóna visszaállítása
```

A másik lehetőség, hogy már egy létező *POSIXct* objektumon végzünk időzóna konverziót, amely így az objektum óra (vagy egyéb) részét is érintheti.

```{r}
ido <- Sys.time()  # pontos dátum-idő, helyi beállításnak megfelelően
ido.utc <- as.POSIXct(format(ido, tz="UTC"), tz="UTC")  # konverzió UTC-re
ido        # helyi időzónával
ido.utc    # UTC-vel
```


##### Dátum-idő létrehozása karakteres adatból

Amennyiben karakteres formában rendelkezésre áll egy időpont, akkor mindössze az egyes komponensek jelentését kell elmagyaráznunk az `as.POSIXct()` függvény `format=` argumentumában. Szabványos idő megadása esetén (([ISO 8601](https://en.wikipedia.org/wiki/ISO_8601))) ezt el is hagyhatjuk.

```{r}
as.POSIXct("2022-06-02 22:12:23", tz = "Europe/Budapest")  # szabványos idő
as.POSIXct("2019.09.06. 16 34 17", format="%Y.%m.%d. %H %M %S", tz="UTC")
```


A dátum értelmezéséhez használt kódok köre (\@ref(tab:datumkodok). táblázat) kibővül a \@ref(tab:datumidokodok). táblázatban szereplő időre vonatkozó kódokkal, így ezeket is használhatjuk a *POSIXct* objektum létrehozása során. Teljes listát az `?strptime` súgójában olvashatunk.

+-------------+------------------------+
|Formátum kód | Jelentés               |
+=============+========================+
| %H          | óra (00-23)            |
+-------------+------------------------+
| %I          | óra (01-12)            |
+-------------+------------------------+
| %M          | perc (00-59) neve      |
+-------------+------------------------+
| %p          | AM/PM jelzése          |
+-------------+------------------------+
| %S          | másodperc (00-59)      |
+-------------+------------------------+
| %Z          | időzóna (csak output)  |
+-------------+------------------------+


##### Dátum-idő létrehozása numerikus adatokból

Dátum-időt szeparáltan létező információkból is létrehozhatunk. Ehhez az `ISOdatetime()` függvényt kell használni, ahol minden egyes komponens egyesével felsorolható:

```{r tidy=FALSE}
# POSIXct objektum a dátum-idő tárolására
ISOdatetime(year=2022, month=7, day=3, 
            hour=11, min=12, sec=3, tz = "Europe/Budapest")
```

##### Dátum-idő konvertálása

A *POSIXct* objektum *dátum* típusúvá konvertálható az `as.Date()` függvénnyel, illetve a `format()` függvény segítségével tetszőleges formájú karakteres dátumot/időt nyerhetünk ki az objektumból.

```{r tidy=FALSE}
ido <- Sys.time()  # pontos dátum-idő, helyi beállításnak megfelelően
ido                # dátum-idő objektum
as.Date(ido)       # dátum objektum
format(ido, format="%Y. %m. %d.")              # magyar dátum
format(ido, format="%Y. %B %d. %H.%M.%S")      # magyar dátum-idő
format(ido, format="%Y. %b %d. %H:%M:%S")      # magyar dátum-idő
format(ido, format="%Y. %m. %d. %H:%M:%S %Z")  # magyar dátum-idő
```

#### Műveletek és az időtartam

A többnyire szöveges formában megjelenő dátumok és dátum-idők R objektummá alakításának a legnagyobb haszna, hogy a *Date* és *POSIXct* objektumokkal számos műveletet hajthatunk végre. Lehetőségünk van például különböző dátumok összehasonlítására, kivonására, léptetésére, vagy ábrákon a tengelyeket címkézhetjük dátum objektumokkal. Két dátum (vagy dátum-idő) különbsége az időtartam, amelyet a kivonás (`-`) operátorral, vagy a `difftime()` függvénnyel is előállíthatunk. Utóbbi nagyobb szabadságot ad, mert rendelkezik egy `unit=` argumentummal az időtartam mértékegységének megadására, így értéke lehet a `"secs"`, `"mins"`, `"hours"`, `"days"` vagy `"weeks"` is.

```{r}
Sys.Date() - as.Date("2001-03-17")          # születésnap óta eltelt idő napokban
difftime(Sys.Date(), as.Date("2001-03-17")) # ua.
difftime(Sys.Date(), as.Date("2001-03-17"), unit="hours") # órákban
as.numeric(difftime(Sys.Date(), as.Date("2001-03-17"), unit="hours")) # számként
```

Ne feledjük, hogy az időtartam is egy típus az R-ben (*difftime* osztály), ahogyan a következő sorokban ez megfigyelhetjük:

```{r}
difft <- difftime(Sys.Date(), as.Date("2001-03-17"), unit="hours")
typeof(difft)   # difft típusa
class(difft)    # difft típusa
unclass(difft)  # difft alapja
```

A `difftime()` működik dátum-idővel is, és természetesen két dátum vagy időpont között a szokásos műveletek is elvégezhetők. A Google Űrlap időbélyeg oszlopából rögzítettünk két adatot és elvégeztünk néhány műveletet köztük:

```{r}
idobelyeg.1 <- as.POSIXct("2022.04.06. 11:11:33", 
                          format="%Y.%m.%d. %H:%M:%S", tz="UTC")
idobelyeg.2 <- as.POSIXct("2022.04.06. 12:06:35", 
                          format="%Y.%m.%d. %H:%M:%S", tz="UTC")
idobelyeg.1 == idobelyeg.2  # nem egyenlőek
idobelyeg.1 < idobelyeg.2   # az első időbélyeg a korábbi
# hány másodperc telt el a két válasz között
as.numeric(difftime(idobelyeg.2, idobelyeg.1, unit="sec"))
  
```



#### Összefoglalás {#az-r-nyelv-12-summary}


```{block, type='rmdsummary'}

A dátumokat *Date* a dátum-időket *POSIXct* objektumban tároljuk az R-ben, melyekkel a szokásos dátumkezelő műveletek már könnyen elvégezhetők. Időtartamot, vagyis két dátum vagy időpont közötti különbséget a `difftime()` függvénnyel határozhatunk meg. 

```

#### Feladatok {#az-r-nyelv-12-exercise}

```{block2, type='rmdexercise'}
  
1. Konvertáljuk dátummá a következő két sztringet: `"6November2020"`, `"2013-02-29"`! Utóbbi esetben mi lehet a hiba oka?
1. A `seq()` függvény `from=` és `to=` argumentuma a dátum típusú objektumokkal is működik. A `by=` argumentum értéke ilyenkor lehet numerikus (ekkor napokat jelent), de lehet `x weeks`, `x months` vagy `x years`, ahol `x` nullánál nagyobb egész lehet. Hozzunk létre egy dátum-vektort 2020 összes hétfőjének dátumával! 
1. A Halley-üstökös utoljára 1986-ban járt a Naprendszerünkben, így az előrejelzések szerint legközelebb 2061. július 26-ban tér vissza. Rögzítsük ezt dátumként, és számoljuk ki, hány napotot kell még várni az üstökös érkezésére.

```


`r if (knitr:::is_html_output()) fontawesome::fa("check-double", fill = "forestgreen")`  `r if (knitr:::is_html_output()) '[A fenti feladatok megoldása](#az-r-nyelv-12-exercise-solution)'`


                                                                                       
### Tibble

A *Tidyverse R* használata során az adatainkat *tibble* típusú objektumban tároljuk. Használatához töltsük be a **tidyverse** csomagot. 

```{r}
library(tidyverse)
x <- rep(c('A','B'), times=4); y <- rep(6:9, times=2); z <- 1:8
df <- tibble(nev=x, pont.1=y, pont.2=z)
df
```

A tibble objektumok alaptípusa lista, de az osztálytípusok között megjelennek a tibble-re specifikus osztályok is. A A `tbl_df` osztály jelenléte hozza magával azokat az új tulajdonságokat és lehetőségeket, amit a Tidyverse R központi adatszerkezetévé teszi ezt az objektumtípust.

```{r}
attributes(df)
typeof(df); class(df)
```

A tibble és a data frame típusú objektumok között az átjárhatóságot az `as_tibble()` és az `as.data.frame()` függvény biztosítja.

```{r}
as_tibble(df)
as.data.frame(df)
```

A tibble típus tesztelése az `is_tibble()` segítségével történik, de a tibble típusú objektumokra az `is.data.frame()` is igaz értékkel tér vissza: 

```{r}
is_tibble(df); is.data.frame(df)
```


Melyek a data frame és a tibble közötti különbségek? Már három eltérést akár észre is vehettünk. Az első a tibble létrehozásához kötődik. Egy tibble típusú objektum, csak azonos hosszúságú oszlopvektorokból hozható létre, így biztonságosabban konstruálható, mint az ismétlést is támogató data frame típusú objektumok. Tibble esetében csak az egy hosszú vektorok ismétlése megengedett. Tehát ez a konstrukció működik:

```{r}
tibble(a=c("a", "b", "c"), p=1)
```


A második különbség, hogy a tibble a létrehozás során nem végez automatikus típuskonverziót. Tehát a karakteres vektorokat nem alakítja át faktorokká.

```{r}
str(df)
```


A harmadik különbség az adatok megjelenítésében van. Tibble esetében csak az első 10 sor jelenik meg, és annyi oszlop, amennyi az aktuális képernyőre kifér. A több oszlop neve alul jelenik meg. Az oszlopnevek alatt az oszlop típusa is megjelenik. 


A negyedik eltérés a tibble indexeléséhez kötődik. Az `[` operátor használata során minden esetben tibble típusú objektumot kapunk, nem kaphatunk vektort, azaz nem történhet dimenzióvesztés.

```{r}
df[, 2]
df[1, ]
df[1, 2]
df[1, 2, drop=T]
```




### A munkaterület függvényei

```{r echo=FALSE}
#rm(list = ls())
```

Megbeszéltük, hogy a munka során az objektumaink a memória speciális területére, a munkaterületre (workspace) kerülnek. Ha még korábban nem is hoztunk létre objektumot, akkor a következő három parancs, három objektumot hoz létre a munkaterületen:

```{r}
fib.0 <- 0
fib.1 <- 1
fib.2 <- fib.0 + fib.1
```

A munkaterületen létrehozott objektumok neveit az `ls()` függvény listázza ki:

```{r}
# ls()
```

A munkaterületről objektumot az `rm()` paranccsal távolíthatunk el, például a

```{r}
rm(fib.0)         # fib.0 törlése
ls()
```

a `fib.0` objektumot távolította el, így az `ls()` eredményében ez nem is szerepel. Az összes munkaterület-objektum eltávolítása a

```{r}
# rm(list = ls())   # összes objektum törlése
# ls()
```

segítségével történik.


### A munkakönyvtár függvényei

Az R használata során mindig van egy kitüntetett, aktuális könyvtárunk, amelyet munkakönyvtárnak nevezünk. A munkakönyvtár célja, hogy az állományok nyitása és mentése során, ha nem használunk külön könyvtárhivatkozást, akkor ez lesz az alapértelmezett könyvtár.

A munkakönyvtár az R-ben lekérdezhető ill. beállítható a `getwd()` és a `setwd()` parancsok kiadásával. Például

```{r eval=FALSE}
getwd()
setwd("C:/Data/peldak")
```

parancsokkal először megismerjük az aktuális könyvtárat, majd megváltoztatjuk a `C:/Data/peldak` könyvtárra. Figyeljük meg, hogy az elérési útban perjelet (`/`) használtunk.

Megjegyezzük, hogy az RStudio projekt üzemmódú használata során nincs szükség a munkakönyvtár beállítására a `setwd()` paranccsal, sőt, kerüljük a használatát. A munkakönyvtárunk a munka során végig maradjon meg az alapértelmezetten beállított könyvtár, maga a projektkönyvtár.

A munkakönyvtár jelentőségét tovább növeli, hogy az R indításakor ebben a könyvtárban 2 állomány létezését figyeli:
* `.Rhistory` (a visszahívható parancsokat tartalmazó szöveges állomány) 
* `.RData` (a tárolt objektumokat tartalmazó bináris állomány).

A fenti állományok ugyanis betöltésre kerülnek az R indításakor, ha azokat az R megtalálja a munkakönyvtárban. Így ezek után, az `.Rhistory` állományból jövő parancsok között válogathatunk a parancssor használata során, illetve az `.RData` állományban tárolt objektumok azonnal elérhetőek, vagyis lesz egy induló munkaterületünk.   


### Csomagkezelő függvények

Korábban megbeszéltük, hogy a csomagok adatobjektumokat és függvényeket tartalmaznak. Az ún. egyéb csomagok (számuk kb. 17000) elsődleges célja az *Alap R* tudásának kiegészítése.  

Az R indítása után néhány csomag automatikusan betöltésre kerül a standard csomagok közül. Ezeket a csomagokat és egyéb ún. környezeteket listázhatunk ki a `search()` függvénnyel.

```{r eval=FALSE}
search()
detach("tools:rstudio")
```

```{r eval=FALSE}
## [1] ".GlobalEnv"        "package:stats"     "package:graphics" 
## [4] "package:grDevices" "package:utils"     "package:datasets" 
## [7] "package:methods"   "Autoloads"         "package:base"
```


A fenti eredményben a `package` karaktersorozattal kezdődő elemek mutatják, hogy melyek az éppen betöltött csomagok. A listában nem szereplő, de korábban telepített csomagok betöltéséhez használjuk a `library()` vagy `require()` függvényeket.


```{r eval=FALSE}
library(MASS)
require(foreign)
search()
```

```{r eval=FALSE}
##  [1] ".GlobalEnv"        "package:foreign"   "package:MASS"     
##  [4] "package:stats"     "package:graphics"  "package:grDevices"
##  [7] "package:utils"     "package:datasets"  "package:methods"  
## [10] "Autoloads"         "package:base"  
```

A fenti példában a **MASS** és a **foreign** csomag betöltését és annak hatását követhetjük nyomon a `search()` függvény outputjára. Egy csomag betöltése azt jelenti, hogy a csomagban lévő függvények és objektumok a memóriába kerültek, azokat a parancsainkban ezután szabadon felhasználhatjuk.

Egy adott csomagban (esetünkben a **foreign** csomagban) lévő függvények és objektumok a

```{r eval=FALSE}
library(help=foreign)
```

vagy a 

```{r eval=FALSE}
help(package=foreign)
```


paranccsal kérdezhetők le. Betöltött csomagok esetében használhatjuk az

```{r eval=FALSE}
ls(name="package:foreign", all.names = T)
ls(name="package:base", all.names = T)

```

parancsot is, amely a csomag adatobjektumainak és függvényeinek a nevét listázza.

Betöltött csomagot a `detach()`\index{detach()} függvénnyel távolíthatunk el a memóriából:

```{r eval=FALSE}
detach(package:foreign)
detach(package:MASS)
```


Ha a használni kívánt csomag még nincs telepítve a számítógépünkre, akkor az \@ref(Csomagok_telepítése). fejezetben ismertetett módok egyikét válasszuk, attól függően, hogy a csomag melyik tárhelyről érhető el.

A CRAN-ról elérhető csomagok közül telepítsük fel a **DescTools** és **psych** csomagokat:

```{r eval=FALSE}
install.packages("DescTools")
install.packages("psych")
```


A számítógépünkön telepített csomagokról az `installed.packages()` függvény ad tájékoztatást. Amennyiben a 

```{r eval=FALSE}
csomagok <- installed.packages()
View(csomagok)                    # RStudio-ban vagy RGui-ban
```

parancsot kiadjuk az RStudio-ban, akkor csomagjainkat kényelmesen áttekinthetjük.


Csomagok frissítésére használjuk a már korábban említett

```{r eval=FALSE}
update.packages()
```

parancsot.

### Feladatok {#az-r-nyelv-14-exercise}

```{block2, type='rmdlevel1'}

1. Írassuk ki a munkaterület objektumait!
1. Hozzunk létre egy `pulzus` nevű objektumot és újra írassuk ki a munkaterület objektumneveit!
1. Távolítsuk el a `pulzus` objektumot a munkaterületről!
1. Határozzuk meg az aktuális munkakönyvtárat!
1. Növeljük meg a betű méretét az RGui, az R Commander és az R Studio alkalmazásokban is!
1. Vizsgáljuk meg, hogy a számítógépünkön van-e telepítve a **DescTools** csomag, ha nincs telepítsük! Derítsük ki, hogy a **DescTools** csomagnak mi a célja? Soroljunk fel három függvényt és adattáblát ebből a csomagból! Távolítsuk el a memóriából a **DescTools** csomagot!
1. Telepítsük a számítógépünkre a következő csomagokat: **HSAUR2**, **psych**, **prettyR**, **descr** és **pastecs**!

```



## Haladó nyelvi elemek

### Objektumok és típusok

Az R-ben használható objektumok név-érték párok, vagyis minden objektumnak van neve és értéke. Objektumok alatt ebben a könyvben az adatobjektumokat értjük, bár már említettünk, hogy valójában a függvények is objektumoknak tekinthetők az R-ben, hiszen a függvénynek is van neve, és értéke, az utóbbi pedig utasítások sorozata. Az R-ben minden objektum, például az eddig vizsgált vektorok, attribútumokkal is rendelkezhetnek. Az attribútumok név-értek párok, amelyek speciális tulajdonságokkal ruházzák fel az objektumunkat. Például a `names` nevű attribútummal a vektor egyes elemeit nevezhetjük el. Későbbiekben látjuk a `dim`, `dimnames`, `level` és `class` attribútumok jelentőségét is.

Egy objektum összes attribútuma az `attributes()` függvénnyel kérdezhetők le. Ha a `names` attribútumra vagyunk kíváncsiak a `names()` függvényt is használhatjuk. Ha létrehozunk egy `x` numerikus vektort, akkor 

```{r tidy=FALSE}
x <- 1:5        # integer vektor
attributes(x)   # x attribútumainak kiírása 
names(x)        # x name attribútumának kiírása

x <- numeric(0)
mode(x) <- "list"
class(x)
length(x)

attr(x, "length") <- "integer"

```

Az `x` numerikus vektornak nincsenek attribútumai. A `NULL` az általános, elem nélküli vektort jelenti. A fenti outputban szereplő két `NULL` esetünkben azt jelzi, hogy nem állítottunk be semmilyen attribútumot, így `names` attribútumot sem.

```{r tidy=FALSE}
x <- c("a"=1, "b"=2, "c"=3, "d"=4, "e"=5) # integer vektor
attributes(x)                  # x attribútumainak kiírása 
names(x)                       # x name attribútumának kiírása
```

A `names` attribútum beállítható a `names()` függvénnyel is.

```{r}
names(x) <- c("elégtelen", "elégséges", "közepes", "jó", "jeles")
attributes(x)                  # x attribútumainak kiírása 
names(x)                       # x name attribútumának kiírása
```

A `names` attribútum értéke karakteres vektor lehet, amely az outputokban is megjelenik és a indexelésben is felhasználhatjuk. 

```{r}
x
x[c("közepes", "jó")]
```

Rögzítsük a (0, 1, 2) értékek előfordulási gyakoriságait a (18, 12, 20) elemeket tartalmazó vektorban. Az elemek nevei most is karakteres konstansok lesznek, az automatikus konverzióról az R gondoskodik.

```{r}
y <- c(18, 12, 20)
names(y) <- 0:2
y
names(y)
```

Az `y` vektor indexelésénél fontos, hogy megkülönböztessük a numerikus és a karakteres indexeket, az utóbbiaknál mindig idézőjelet kell használnunk.

```{r}
x[1]
x["1"]
x[c(1,3)]; x[c("0", "2")]
```

Egyetlen attribútum lekérdezésére és beállítására az `attr()` függvényt is használhatjuk. Az `attr()` függvényben meg kell adnunk az elérendő attribútum nevét is.

```{r}
attr(x, "names") <- c("A", "B", "C", "D", "E")
attr(x, "names")
attributes(x)
```

Attribútumok törlésére a `NULL` értéket használjuk.

```{r tidy=FALSE}
names(x) <- NULL             # names attribútum törlése
attr(x, "names") <- NULL     # names attribútum törlése
attributes(x) <- NULL        # az összes attribútum törlése
```

A `dim` argumentum

```{r tidy=FALSE}
x <- 1:12                      # integer vektor
x
attr(x, "dim") <- c(2,6)       # integer mátrix (2x6-os)       
attributes(x)
x
attr(x, "dim") <- c(2, 3, 2)   # integer tömb (2x3x2-es)
attributes(x)
x
```

Amennyiben 


```{r}
x <- 1:12                      # integer vektor
attr(x, "dim") <- c(2,6)       # integer mátrix (2x6-os)       
dimnames(x) <- list(nem=c("férfi", "nő"), osztaly=LETTERS[1:6])        
x
attributes(x)
```


Osztályok

A faktor ennek megfelelően tartalmaz egy `levels` attribútumot, amely a faktor különböző értékeit (szintjeit) sorolja fel. A faktorok `class` attribútumának értéke pedig `factor`.


```{r}
f <- factor(c("a", "b", "a"))
attributes(f)
levels(f)
class(f)
class(f) <- NULL
#attributes(f)<- NULL
#f
unclass(f)

```

A `class()` függvény az objektum `class` argumentumával tér vissza. Azok az objektumok, amelyek nem rendelkeznek `class` argumentummal, a `class()` visszatérési értéke 

* `"numeric"`, ha az objektum *integer* vagy *double* vektor 
* `"array"` és/vagy `"matrix"`, ha az objektum rendelkezik `dim` attributummal
* más esetben a `typeof()` visszatérési értékével.

Az `unclass()` visszatérési értéke az az objektum, amelynek a `class` attribűtumát eltávolították.


A korábban tárgyat típusok mindegyike osztály: *Date*, *difftime*, *POSIXct*, *POSIXlt*, *table*.


```{r}
x <- as.Date("2020-03-12")
attributes(x)
class(x)

x <- Sys.Date()-as.Date("2020-03-12")
x
attributes(x)
class(x)

x <- ISOdate(year = 2020, month = 12, day = 2)
x
attributes(x)
class(x)

x <- as.POSIXlt(x)
x
attributes(x)
class(x)

x <- table(sample(LETTERS[1:3], 100, replace = T))
x
attributes(x)
class(x)
```




A listaelemek nevét a `x` lis `names` attribútuma tartalmazza, segítségével a többi elemnek is adhatunk értéket:

```{r}
names(x)
names(x)[c(1,2)] <- c("a","b")
names(x)
x
```



#### Értékek kizárása

A faktor létrehozásánál gondoskodhatunk bizonyos értékek kizárásáról, olyan értékekről, amelyeket nem szeretnénk a faktorban felsorolni:


```{r}
factor(c(1:5, NA, 3:6))
```

Alapértelmezés szerint az `NA` értéket zárjuk ki a faktor szintjeiből, de ezt megváltoztathatjuk az `exclude=` paraméter használatával:

```{r}
factor(c(1:5, NA, 3:6), exclude=NULL)
factor(c(1:5, NA, 3:6), exclude=c(4, NA))
```

Ahogy látjuk a fenti példában, akár az `NA` értéket is bevonhatjuk a faktor szintjeibe, akár más értékeket is kizárhatunk az `NA`-n kívül.

Nézzük, hogyan tekint az R az adattáblára.

```{r}
#typeof(df); class(df); length(df)
#is.list(df); is.matrix(df); is.data.frame(df)
```

Az adattáblák alaptípusa `list`, osztálytípusa pedig `data.frame` a hossza pedig az alkotó (oszlop)vektorok/faktorok száma. Az adattáblára tehát tekinthetünk úgy, mint egy listára, melynek elemei az adattábla oszlopai lesznek.


**Feladat**

2**3**4
(2**3)**4
2**(3**4)



[^1]: Más programozási nyelvekben az "objektum" helyett a "változó" elnevezést használják, de a változó fogalma már foglalt a statisztikában, így szerencsésebb a memóriában tárolt adatokra objektumként hivatkozni.
[^2]: További értékadás operátorok a `->`, `<<-`, `->>` és a `=`. Ezeket nem használjuk ebben a könyvben.




